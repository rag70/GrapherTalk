////////////// FROM INDEX.HTML //////////////
/** .bob => Are some of the changes I make to the original
 *  A few changes I have to make directly 
  * For data initialization I put look fo id
    ldData and there put the data info, Sample

    <div id="data" data-load-data="{&#34;graph&#34;: null, &#34;seed&#34;: &#34;e3636b05148b4955b9a12f202a3512f1&#34;, &#34;user&#34;: null}"></div>

 */

// TODO - get console and pushstate into regular .js files
if (!window.Desmos) {
    window.Desmos = {};
}
if (!window.console) {
    window.console = {};
}

// Pull config information, and include it in Desmos.config
window.Desmos.config = { "workerURL": LibPath + "/worker.js" };

// Make sure console.log is defined
if (!window.console.log) {
    window.console.log = function() {};
}

// Make sure we don't use pushstate on file protocol
if (window.location.protocol === 'file:') {
    window.history.pushState = function() {};
}
window.history.pushState = function() {}; // .bob, don't play with the navigation bar

////////////// END INDEX.HTML SCRIPTS //////////////

/**
 * almond 0.2.5 Copyright (c) 2011-2012, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function(undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap,
            foundI, foundStarMap, starI, i, j, part,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                //Convert baseName to array, and lop off the last part,
                //so that . matches that "directory" and not name of the baseName's
                //module. For instance, baseName of "one/two/three", maps to
                //"one/two/three.js", but we want the directory, "one/two" for
                //this normalization.
                baseParts = baseParts.slice(0, baseParts.length - 1);

                name = baseParts.concat(name.split("/"));

                //start trimDots
                for (i = 0; i < name.length; i += 1) {
                    part = name[i];
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            break;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            } else if (name.indexOf('./') === 0) {
                // No baseName, so this is ID is resolved relative
                // to baseUrl, pull off the leading dot.
                name = name.substring(2);
            }
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function() {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function(name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function(value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function(name, relName) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function() {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function(name) {
            return makeRequire(name);
        },
        exports: function(name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function(name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function(name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i,
            args = [],
            usingExports;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (typeof callback === 'function') {

            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                    hasProp(waiting, depName) ||
                    hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback.apply(defined[name], args);

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                    cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function(deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function() {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function() {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function(cfg) {
        config = cfg;
        if (config.deps) {
            req(config.deps, config.callback);
        }
        return req;
    };

    define = function(name, deps, callback) {

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());

define("vendor/almond", function() {});

/*!
 * jQuery JavaScript Library v1.8.3
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: Tue Nov 13 2012 08:20:33 GMT-0500 (Eastern Standard Time)
 */
(function(window, undefined) {
    var
    // A central reference to the root jQuery(document)
        rootjQuery,

        // The deferred used on DOM ready
        readyList,

        // Use the correct document accordingly with window argument (sandbox)
        document = window.document,
        location = window.location,
        navigator = window.navigator,

        // Map over jQuery in case of overwrite
        _jQuery = window.jQuery,

        // Map over the $ in case of overwrite
        _$ = window.$,

        // Save a reference to some core methods
        core_push = Array.prototype.push,
        core_slice = Array.prototype.slice,
        core_indexOf = Array.prototype.indexOf,
        core_toString = Object.prototype.toString,
        core_hasOwn = Object.prototype.hasOwnProperty,
        core_trim = String.prototype.trim,

        // Define a local copy of jQuery
        jQuery = function(selector, context) {
            // The jQuery object is actually just the init constructor 'enhanced'
            return new jQuery.fn.init(selector, context, rootjQuery);
        },

        // Used for matching numbers
        core_pnum = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source,

        // Used for detecting and trimming whitespace
        core_rnotwhite = /\S/,
        core_rspace = /\s+/,

        // Make sure we trim BOM and NBSP (here's looking at you, Safari 5.0 and IE)
        rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

        // A simple way to check for HTML strings
        // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
        rquickExpr = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,

        // Match a standalone tag
        rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,

        // JSON RegExp
        rvalidchars = /^[\],:{}\s]*$/,
        rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,
        rvalidescape = /\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g,
        rvalidtokens = /"[^"\\\r\n]*"|true|false|null|-?(?:\d\d*\.|)\d+(?:[eE][\-+]?\d+|)/g,

        // Matches dashed string for camelizing
        rmsPrefix = /^-ms-/,
        rdashAlpha = /-([\da-z])/gi,

        // Used by jQuery.camelCase as callback to replace()
        fcamelCase = function(all, letter) {
            return (letter + "").toUpperCase();
        },

        // The ready event handler and self cleanup method
        DOMContentLoaded = function() {
            if (document.addEventListener) {
                document.removeEventListener("DOMContentLoaded", DOMContentLoaded, false);
                jQuery.ready();
            } else if (document.readyState === "complete") {
                // we're here because readyState === "complete" in oldIE
                // which is good enough for us to call the dom ready!
                document.detachEvent("onreadystatechange", DOMContentLoaded);
                jQuery.ready();
            }
        },

        // [[Class]] -> type pairs
        class2type = {};

    jQuery.fn = jQuery.prototype = {
        constructor: jQuery,
        init: function(selector, context, rootjQuery) {
            var match, elem, ret, doc;

            // Handle $(""), $(null), $(undefined), $(false)
            if (!selector) {
                return this;
            }

            // Handle $(DOMElement)
            if (selector.nodeType) {
                this.context = this[0] = selector;
                this.length = 1;
                return this;
            }

            // Handle HTML strings
            if (typeof selector === "string") {
                if (selector.charAt(0) === "<" && selector.charAt(selector.length - 1) === ">" && selector.length >= 3) {
                    // Assume that strings that start and end with <> are HTML and skip the regex check
                    match = [null, selector, null];

                } else {
                    match = rquickExpr.exec(selector);
                }

                // Match html or make sure no context is specified for #id
                if (match && (match[1] || !context)) {

                    // HANDLE: $(html) -> $(array)
                    if (match[1]) {
                        context = context instanceof jQuery ? context[0] : context;
                        doc = (context && context.nodeType ? context.ownerDocument || context : document);

                        // scripts is true for back-compat
                        selector = jQuery.parseHTML(match[1], doc, true);
                        if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                            this.attr.call(selector, context, true);
                        }

                        return jQuery.merge(this, selector);

                        // HANDLE: $(#id)
                    } else {
                        elem = document.getElementById(match[2]);

                        // Check parentNode to catch when Blackberry 4.6 returns
                        // nodes that are no longer in the document #6963
                        if (elem && elem.parentNode) {
                            // Handle the case where IE and Opera return items
                            // by name instead of ID
                            if (elem.id !== match[2]) {
                                return rootjQuery.find(selector);
                            }

                            // Otherwise, we inject the element directly into the jQuery object
                            this.length = 1;
                            this[0] = elem;
                        }

                        this.context = document;
                        this.selector = selector;
                        return this;
                    }

                    // HANDLE: $(expr, $(...))
                } else if (!context || context.jquery) {
                    return (context || rootjQuery).find(selector);

                    // HANDLE: $(expr, context)
                    // (which is just equivalent to: $(context).find(expr)
                } else {
                    return this.constructor(context).find(selector);
                }

                // HANDLE: $(function)
                // Shortcut for document ready
            } else if (jQuery.isFunction(selector)) {
                return rootjQuery.ready(selector);
            }

            if (selector.selector !== undefined) {
                this.selector = selector.selector;
                this.context = selector.context;
            }

            return jQuery.makeArray(selector, this);
        },

        // Start with an empty selector
        selector: "",

        // The current version of jQuery being used
        jquery: "1.8.3",

        // The default length of a jQuery object is 0
        length: 0,

        // The number of elements contained in the matched element set
        size: function() {
            return this.length;
        },

        toArray: function() {
            return core_slice.call(this);
        },

        // Get the Nth element in the matched element set OR
        // Get the whole matched element set as a clean array
        get: function(num) {
            return num == null ?

                // Return a 'clean' array
                this.toArray() :

                // Return just the object
                (num < 0 ? this[this.length + num] : this[num]);
        },

        // Take an array of elements and push it onto the stack
        // (returning the new matched element set)
        pushStack: function(elems, name, selector) {

            // Build a new jQuery matched element set
            var ret = jQuery.merge(this.constructor(), elems);

            // Add the old object onto the stack (as a reference)
            ret.prevObject = this;

            ret.context = this.context;

            if (name === "find") {
                ret.selector = this.selector + (this.selector ? " " : "") + selector;
            } else if (name) {
                ret.selector = this.selector + "." + name + "(" + selector + ")";
            }

            // Return the newly-formed element set
            return ret;
        },

        // Execute a callback for every element in the matched set.
        // (You can seed the arguments with an array of args, but this is
        // only used internally.)
        each: function(callback, args) {
            return jQuery.each(this, callback, args);
        },

        ready: function(fn) {
            // Add the callback
            jQuery.ready.promise().done(fn);

            return this;
        },

        eq: function(i) {
            i = +i;
            return i === -1 ?
                this.slice(i) :
                this.slice(i, i + 1);
        },

        first: function() {
            return this.eq(0);
        },

        last: function() {
            return this.eq(-1);
        },

        slice: function() {
            return this.pushStack(core_slice.apply(this, arguments),
                "slice", core_slice.call(arguments).join(","));
        },

        map: function(callback) {
            return this.pushStack(jQuery.map(this, function(elem, i) {
                return callback.call(elem, i, elem);
            }));
        },

        end: function() {
            return this.prevObject || this.constructor(null);
        },

        // For internal use only.
        // Behaves like an Array's method, not like a jQuery method.
        push: core_push,
        sort: [].sort,
        splice: [].splice
    };

    // Give the init function the jQuery prototype for later instantiation
    jQuery.fn.init.prototype = jQuery.fn;

    jQuery.extend = jQuery.fn.extend = function() {
        var options, name, src, copy, copyIsArray, clone,
            target = arguments[0] || {},
            i = 1,
            length = arguments.length,
            deep = false;

        // Handle a deep copy situation
        if (typeof target === "boolean") {
            deep = target;
            target = arguments[1] || {};
            // skip the boolean and the target
            i = 2;
        }

        // Handle case when target is a string or something (possible in deep copy)
        if (typeof target !== "object" && !jQuery.isFunction(target)) {
            target = {};
        }

        // extend jQuery itself if only one argument is passed
        if (length === i) {
            target = this;
            --i;
        }

        for (; i < length; i++) {
            // Only deal with non-null/undefined values
            if ((options = arguments[i]) != null) {
                // Extend the base object
                for (name in options) {
                    src = target[name];
                    copy = options[name];

                    // Prevent never-ending loop
                    if (target === copy) {
                        continue;
                    }

                    // Recurse if we're merging plain objects or arrays
                    if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
                        if (copyIsArray) {
                            copyIsArray = false;
                            clone = src && jQuery.isArray(src) ? src : [];

                        } else {
                            clone = src && jQuery.isPlainObject(src) ? src : {};
                        }

                        // Never move original objects, clone them
                        target[name] = jQuery.extend(deep, clone, copy);

                        // Don't bring in undefined values
                    } else if (copy !== undefined) {
                        target[name] = copy;
                    }
                }
            }
        }

        // Return the modified object
        return target;
    };

    jQuery.extend({
        noConflict: function(deep) {
            if (window.$ === jQuery) {
                window.$ = _$;
            }

            if (deep && window.jQuery === jQuery) {
                window.jQuery = _jQuery;
            }

            return jQuery;
        },

        // Is the DOM ready to be used? Set to true once it occurs.
        isReady: false,

        // A counter to track how many items to wait for before
        // the ready event fires. See #6781
        readyWait: 1,

        // Hold (or release) the ready event
        holdReady: function(hold) {
            if (hold) {
                jQuery.readyWait++;
            } else {
                jQuery.ready(true);
            }
        },

        // Handle when the DOM is ready
        ready: function(wait) {

            // Abort if there are pending holds or we're already ready
            if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
                return;
            }

            // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
            if (!document.body) {
                return setTimeout(jQuery.ready, 1);
            }

            // Remember that the DOM is ready
            jQuery.isReady = true;

            // If a normal DOM Ready event fired, decrement, and wait if need be
            if (wait !== true && --jQuery.readyWait > 0) {
                return;
            }

            // If there are functions bound, to execute
            readyList.resolveWith(document, [jQuery]);

            // Trigger any bound ready events
            if (jQuery.fn.trigger) {
                jQuery(document).trigger("ready").off("ready");
            }
        },

        // See test/unit/core.js for details concerning isFunction.
        // Since version 1.3, DOM methods and functions like alert
        // aren't supported. They return false on IE (#2968).
        isFunction: function(obj) {
            return jQuery.type(obj) === "function";
        },

        isArray: Array.isArray || function(obj) {
            return jQuery.type(obj) === "array";
        },

        isWindow: function(obj) {
            return obj != null && obj == obj.window;
        },

        isNumeric: function(obj) {
            return !isNaN(parseFloat(obj)) && isFinite(obj);
        },

        type: function(obj) {
            return obj == null ?
                String(obj) :
                class2type[core_toString.call(obj)] || "object";
        },

        isPlainObject: function(obj) {
            // Must be an Object.
            // Because of IE, we also have to check the presence of the constructor property.
            // Make sure that DOM nodes and window objects don't pass through, as well
            if (!obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow(obj)) {
                return false;
            }

            try {
                // Not own constructor property must be Object
                if (obj.constructor &&
                    !core_hasOwn.call(obj, "constructor") &&
                    !core_hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
                    return false;
                }
            } catch (e) {
                // IE8,9 Will throw exceptions on certain host objects #9897
                return false;
            }

            // Own properties are enumerated firstly, so to speed up,
            // if last one is own, then all properties are own.

            var key;
            for (key in obj) {}

            return key === undefined || core_hasOwn.call(obj, key);
        },

        isEmptyObject: function(obj) {
            var name;
            for (name in obj) {
                return false;
            }
            return true;
        },

        error: function(msg) {
            throw new Error(msg);
        },

        // data: string of html
        // context (optional): If specified, the fragment will be created in this context, defaults to document
        // scripts (optional): If true, will include scripts passed in the html string
        parseHTML: function(data, context, scripts) {
            var parsed;
            if (!data || typeof data !== "string") {
                return null;
            }
            if (typeof context === "boolean") {
                scripts = context;
                context = 0;
            }
            context = context || document;

            // Single tag
            if ((parsed = rsingleTag.exec(data))) {
                return [context.createElement(parsed[1])];
            }

            parsed = jQuery.buildFragment([data], context, scripts ? null : []);
            return jQuery.merge([],
                (parsed.cacheable ? jQuery.clone(parsed.fragment) : parsed.fragment).childNodes);
        },

        parseJSON: function(data) {
            if (!data || typeof data !== "string") {
                return null;
            }

            // Make sure leading/trailing whitespace is removed (IE can't handle it)
            data = jQuery.trim(data);

            // Attempt to parse using the native JSON parser first
            if (window.JSON && window.JSON.parse) {
                return window.JSON.parse(data);
            }

            // Make sure the incoming data is actual JSON
            // Logic borrowed from http://json.org/json2.js
            if (rvalidchars.test(data.replace(rvalidescape, "@")
                    .replace(rvalidtokens, "]")
                    .replace(rvalidbraces, ""))) {

                return (new Function("return " + data))();

            }
            jQuery.error("Invalid JSON: " + data);
        },

        // Cross-browser xml parsing
        parseXML: function(data) {
            var xml, tmp;
            if (!data || typeof data !== "string") {
                return null;
            }
            try {
                if (window.DOMParser) { // Standard
                    tmp = new DOMParser();
                    xml = tmp.parseFromString(data, "text/xml");
                } else { // IE
                    xml = new ActiveXObject("Microsoft.XMLDOM");
                    xml.async = "false";
                    xml.loadXML(data);
                }
            } catch (e) {
                xml = undefined;
            }
            if (!xml || !xml.documentElement || xml.getElementsByTagName("parsererror").length) {
                jQuery.error("Invalid XML: " + data);
            }
            return xml;
        },

        noop: function() {},

        // Evaluates a script in a global context
        // Workarounds based on findings by Jim Driscoll
        // http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
        globalEval: function(data) {
            if (data && core_rnotwhite.test(data)) {
                // We use execScript on Internet Explorer
                // We use an anonymous function so that context is window
                // rather than jQuery in Firefox
                (window.execScript || function(data) {
                    window["eval"].call(window, data);
                })(data);
            }
        },

        // Convert dashed to camelCase; used by the css and data modules
        // Microsoft forgot to hump their vendor prefix (#9572)
        camelCase: function(string) {
            return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
        },

        nodeName: function(elem, name) {
            return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
        },

        // args is for internal usage only
        each: function(obj, callback, args) {
            var name,
                i = 0,
                length = obj.length,
                isObj = length === undefined || jQuery.isFunction(obj);

            if (args) {
                if (isObj) {
                    for (name in obj) {
                        if (callback.apply(obj[name], args) === false) {
                            break;
                        }
                    }
                } else {
                    for (; i < length;) {
                        if (callback.apply(obj[i++], args) === false) {
                            break;
                        }
                    }
                }

                // A special, fast, case for the most common use of each
            } else {
                if (isObj) {
                    for (name in obj) {
                        if (callback.call(obj[name], name, obj[name]) === false) {
                            break;
                        }
                    }
                } else {
                    for (; i < length;) {
                        if (callback.call(obj[i], i, obj[i++]) === false) {
                            break;
                        }
                    }
                }
            }

            return obj;
        },

        // Use native String.trim function wherever possible
        trim: core_trim && !core_trim.call("\uFEFF\xA0") ?
            function(text) {
                return text == null ?
                    "" :
                    core_trim.call(text);
            } :

            // Otherwise use our own trimming functionality
            function(text) {
                return text == null ?
                    "" :
                    (text + "").replace(rtrim, "");
            },

        // results is for internal usage only
        makeArray: function(arr, results) {
            var type,
                ret = results || [];

            if (arr != null) {
                // The window, strings (and functions) also have 'length'
                // Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930
                type = jQuery.type(arr);

                if (arr.length == null || type === "string" || type === "function" || type === "regexp" || jQuery.isWindow(arr)) {
                    core_push.call(ret, arr);
                } else {
                    jQuery.merge(ret, arr);
                }
            }

            return ret;
        },

        inArray: function(elem, arr, i) {
            var len;

            if (arr) {
                if (core_indexOf) {
                    return core_indexOf.call(arr, elem, i);
                }

                len = arr.length;
                i = i ? i < 0 ? Math.max(0, len + i) : i : 0;

                for (; i < len; i++) {
                    // Skip accessing in sparse arrays
                    if (i in arr && arr[i] === elem) {
                        return i;
                    }
                }
            }

            return -1;
        },

        merge: function(first, second) {
            var l = second.length,
                i = first.length,
                j = 0;

            if (typeof l === "number") {
                for (; j < l; j++) {
                    first[i++] = second[j];
                }

            } else {
                while (second[j] !== undefined) {
                    first[i++] = second[j++];
                }
            }

            first.length = i;

            return first;
        },

        grep: function(elems, callback, inv) {
            var retVal,
                ret = [],
                i = 0,
                length = elems.length;
            inv = !!inv;

            // Go through the array, only saving the items
            // that pass the validator function
            for (; i < length; i++) {
                retVal = !!callback(elems[i], i);
                if (inv !== retVal) {
                    ret.push(elems[i]);
                }
            }

            return ret;
        },

        // arg is for internal usage only
        map: function(elems, callback, arg) {
            var value, key,
                ret = [],
                i = 0,
                length = elems.length,
                // jquery objects are treated as arrays
                isArray = elems instanceof jQuery || length !== undefined && typeof length === "number" && ((length > 0 && elems[0] && elems[length - 1]) || length === 0 || jQuery.isArray(elems));

            // Go through the array, translating each of the items to their
            if (isArray) {
                for (; i < length; i++) {
                    value = callback(elems[i], i, arg);

                    if (value != null) {
                        ret[ret.length] = value;
                    }
                }

                // Go through every key on the object,
            } else {
                for (key in elems) {
                    value = callback(elems[key], key, arg);

                    if (value != null) {
                        ret[ret.length] = value;
                    }
                }
            }

            // Flatten any nested arrays
            return ret.concat.apply([], ret);
        },

        // A global GUID counter for objects
        guid: 1,

        // Bind a function to a context, optionally partially applying any
        // arguments.
        proxy: function(fn, context) {
            var tmp, args, proxy;

            if (typeof context === "string") {
                tmp = fn[context];
                context = fn;
                fn = tmp;
            }

            // Quick check to determine if target is callable, in the spec
            // this throws a TypeError, but we will just return undefined.
            if (!jQuery.isFunction(fn)) {
                return undefined;
            }

            // Simulated bind
            args = core_slice.call(arguments, 2);
            proxy = function() {
                return fn.apply(context, args.concat(core_slice.call(arguments)));
            };

            // Set the guid of unique handler to the same of original handler, so it can be removed
            proxy.guid = fn.guid = fn.guid || jQuery.guid++;

            return proxy;
        },

        // Multifunctional method to get and set values of a collection
        // The value/s can optionally be executed if it's a function
        access: function(elems, fn, key, value, chainable, emptyGet, pass) {
            var exec,
                bulk = key == null,
                i = 0,
                length = elems.length;

            // Sets many values
            if (key && typeof key === "object") {
                for (i in key) {
                    jQuery.access(elems, fn, i, key[i], 1, emptyGet, value);
                }
                chainable = 1;

                // Sets one value
            } else if (value !== undefined) {
                // Optionally, function values get executed if exec is true
                exec = pass === undefined && jQuery.isFunction(value);

                if (bulk) {
                    // Bulk operations only iterate when executing function values
                    if (exec) {
                        exec = fn;
                        fn = function(elem, key, value) {
                            return exec.call(jQuery(elem), value);
                        };

                        // Otherwise they run against the entire set
                    } else {
                        fn.call(elems, value);
                        fn = null;
                    }
                }

                if (fn) {
                    for (; i < length; i++) {
                        fn(elems[i], key, exec ? value.call(elems[i], i, fn(elems[i], key)) : value, pass);
                    }
                }

                chainable = 1;
            }

            return chainable ?
                elems :

                // Gets
                bulk ?
                fn.call(elems) :
                length ? fn(elems[0], key) : emptyGet;
        },

        now: function() {
            return (new Date()).getTime();
        }
    });

    jQuery.ready.promise = function(obj) {
        if (!readyList) {

            readyList = jQuery.Deferred();

            // Catch cases where $(document).ready() is called after the browser event has already occurred.
            // we once tried to use readyState "interactive" here, but it caused issues like the one
            // discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
            if (document.readyState === "complete") {
                // Handle it asynchronously to allow scripts the opportunity to delay ready
                setTimeout(jQuery.ready, 1);

                // Standards-based browsers support DOMContentLoaded
            } else if (document.addEventListener) {
                // Use the handy event callback
                document.addEventListener("DOMContentLoaded", DOMContentLoaded, false);

                // A fallback to window.onload, that will always work
                window.addEventListener("load", jQuery.ready, false);

                // If IE event model is used
            } else {
                // Ensure firing before onload, maybe late but safe also for iframes
                document.attachEvent("onreadystatechange", DOMContentLoaded);

                // A fallback to window.onload, that will always work
                window.attachEvent("onload", jQuery.ready);

                // If IE and not a frame
                // continually check to see if the document is ready
                var top = false;

                try {
                    top = window.frameElement == null && document.documentElement;
                } catch (e) {}

                if (top && top.doScroll) {
                    (function doScrollCheck() {
                        if (!jQuery.isReady) {

                            try {
                                // Use the trick by Diego Perini
                                // http://javascript.nwbox.com/IEContentLoaded/
                                top.doScroll("left");
                            } catch (e) {
                                return setTimeout(doScrollCheck, 50);
                            }

                            // and execute any waiting functions
                            jQuery.ready();
                        }
                    })();
                }
            }
        }
        return readyList.promise(obj);
    };

    // Populate the class2type map
    jQuery.each("Boolean Number String Function Array Date RegExp Object".split(" "), function(i, name) {
        class2type["[object " + name + "]"] = name.toLowerCase();
    });

    // All jQuery objects should point back to these
    rootjQuery = jQuery(document);
    // String to Object options format cache
    var optionsCache = {};

    // Convert String-formatted options into Object-formatted ones and store in cache
    function createOptions(options) {
        var object = optionsCache[options] = {};
        jQuery.each(options.split(core_rspace), function(_, flag) {
            object[flag] = true;
        });
        return object;
    }

    /*
     * Create a callback list using the following parameters:
     *
     *  options: an optional list of space-separated options that will change how
     *          the callback list behaves or a more traditional option object
     *
     * By default a callback list will act like an event callback list and can be
     * "fired" multiple times.
     *
     * Possible options:
     *
     *  once:           will ensure the callback list can only be fired once (like a Deferred)
     *
     *  memory:         will keep track of previous values and will call any callback added
     *                  after the list has been fired right away with the latest "memorized"
     *                  values (like a Deferred)
     *
     *  unique:         will ensure a callback can only be added once (no duplicate in the list)
     *
     *  stopOnFalse:    interrupt callings when a callback returns false
     *
     */
    jQuery.Callbacks = function(options) {

        // Convert options from String-formatted to Object-formatted if needed
        // (we check in cache first)
        options = typeof options === "string" ?
            (optionsCache[options] || createOptions(options)) :
            jQuery.extend({}, options);

        var // Last fire value (for non-forgettable lists)
            memory,
            // Flag to know if list was already fired
            fired,
            // Flag to know if list is currently firing
            firing,
            // First callback to fire (used internally by add and fireWith)
            firingStart,
            // End of the loop when firing
            firingLength,
            // Index of currently firing callback (modified by remove if needed)
            firingIndex,
            // Actual callback list
            list = [],
            // Stack of fire calls for repeatable lists
            stack = !options.once && [],
            // Fire callbacks
            fire = function(data) {
                memory = options.memory && data;
                fired = true;
                firingIndex = firingStart || 0;
                firingStart = 0;
                firingLength = list.length;
                firing = true;
                for (; list && firingIndex < firingLength; firingIndex++) {
                    if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {
                        memory = false; // To prevent further calls using add
                        break;
                    }
                }
                firing = false;
                if (list) {
                    if (stack) {
                        if (stack.length) {
                            fire(stack.shift());
                        }
                    } else if (memory) {
                        list = [];
                    } else {
                        self.disable();
                    }
                }
            },
            // Actual Callbacks object
            self = {
                // Add a callback or a collection of callbacks to the list
                add: function() {
                    if (list) {
                        // First, we save the current length
                        var start = list.length;
                        (function add(args) {
                            jQuery.each(args, function(_, arg) {
                                var type = jQuery.type(arg);
                                if (type === "function") {
                                    if (!options.unique || !self.has(arg)) {
                                        list.push(arg);
                                    }
                                } else if (arg && arg.length && type !== "string") {
                                    // Inspect recursively
                                    add(arg);
                                }
                            });
                        })(arguments);
                        // Do we need to add the callbacks to the
                        // current firing batch?
                        if (firing) {
                            firingLength = list.length;
                            // With memory, if we're not firing then
                            // we should call right away
                        } else if (memory) {
                            firingStart = start;
                            fire(memory);
                        }
                    }
                    return this;
                },
                // Remove a callback from the list
                remove: function() {
                    if (list) {
                        jQuery.each(arguments, function(_, arg) {
                            var index;
                            while ((index = jQuery.inArray(arg, list, index)) > -1) {
                                list.splice(index, 1);
                                // Handle firing indexes
                                if (firing) {
                                    if (index <= firingLength) {
                                        firingLength--;
                                    }
                                    if (index <= firingIndex) {
                                        firingIndex--;
                                    }
                                }
                            }
                        });
                    }
                    return this;
                },
                // Control if a given callback is in the list
                has: function(fn) {
                    return jQuery.inArray(fn, list) > -1;
                },
                // Remove all callbacks from the list
                empty: function() {
                    list = [];
                    return this;
                },
                // Have the list do nothing anymore
                disable: function() {
                    list = stack = memory = undefined;
                    return this;
                },
                // Is it disabled?
                disabled: function() {
                    return !list;
                },
                // Lock the list in its current state
                lock: function() {
                    stack = undefined;
                    if (!memory) {
                        self.disable();
                    }
                    return this;
                },
                // Is it locked?
                locked: function() {
                    return !stack;
                },
                // Call all callbacks with the given context and arguments
                fireWith: function(context, args) {
                    args = args || [];
                    args = [context, args.slice ? args.slice() : args];
                    if (list && (!fired || stack)) {
                        if (firing) {
                            stack.push(args);
                        } else {
                            fire(args);
                        }
                    }
                    return this;
                },
                // Call all the callbacks with the given arguments
                fire: function() {
                    self.fireWith(this, arguments);
                    return this;
                },
                // To know if the callbacks have already been called at least once
                fired: function() {
                    return !!fired;
                }
            };

        return self;
    };
    jQuery.extend({

        Deferred: function(func) {
            var tuples = [
                    // action, add listener, listener list, final state
                    ["resolve", "done", jQuery.Callbacks("once memory"), "resolved"],
                    ["reject", "fail", jQuery.Callbacks("once memory"), "rejected"],
                    ["notify", "progress", jQuery.Callbacks("memory")]
                ],
                state = "pending",
                promise = {
                    state: function() {
                        return state;
                    },
                    always: function() {
                        deferred.done(arguments).fail(arguments);
                        return this;
                    },
                    then: function( /* fnDone, fnFail, fnProgress */ ) {
                        var fns = arguments;
                        return jQuery.Deferred(function(newDefer) {
                            jQuery.each(tuples, function(i, tuple) {
                                var action = tuple[0],
                                    fn = fns[i];
                                // deferred[ done | fail | progress ] for forwarding actions to newDefer
                                deferred[tuple[1]](jQuery.isFunction(fn) ?
                                    function() {
                                        var returned = fn.apply(this, arguments);
                                        if (returned && jQuery.isFunction(returned.promise)) {
                                            returned.promise()
                                                .done(newDefer.resolve)
                                                .fail(newDefer.reject)
                                                .progress(newDefer.notify);
                                        } else {
                                            newDefer[action + "With"](this === deferred ? newDefer : this, [returned]);
                                        }
                                    } :
                                    newDefer[action]
                                );
                            });
                            fns = null;
                        }).promise();
                    },
                    // Get a promise for this deferred
                    // If obj is provided, the promise aspect is added to the object
                    promise: function(obj) {
                        return obj != null ? jQuery.extend(obj, promise) : promise;
                    }
                },
                deferred = {};

            // Keep pipe for back-compat
            promise.pipe = promise.then;

            // Add list-specific methods
            jQuery.each(tuples, function(i, tuple) {
                var list = tuple[2],
                    stateString = tuple[3];

                // promise[ done | fail | progress ] = list.add
                promise[tuple[1]] = list.add;

                // Handle state
                if (stateString) {
                    list.add(function() {
                        // state = [ resolved | rejected ]
                        state = stateString;

                        // [ reject_list | resolve_list ].disable; progress_list.lock
                    }, tuples[i ^ 1][2].disable, tuples[2][2].lock);
                }

                // deferred[ resolve | reject | notify ] = list.fire
                deferred[tuple[0]] = list.fire;
                deferred[tuple[0] + "With"] = list.fireWith;
            });

            // Make the deferred a promise
            promise.promise(deferred);

            // Call given func if any
            if (func) {
                func.call(deferred, deferred);
            }

            // All done!
            return deferred;
        },

        // Deferred helper
        when: function(subordinate /* , ..., subordinateN */ ) {
            var i = 0,
                resolveValues = core_slice.call(arguments),
                length = resolveValues.length,

                // the count of uncompleted subordinates
                remaining = length !== 1 || (subordinate && jQuery.isFunction(subordinate.promise)) ? length : 0,

                // the master Deferred. If resolveValues consist of only a single Deferred, just use that.
                deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

                // Update function for both resolve and progress values
                updateFunc = function(i, contexts, values) {
                    return function(value) {
                        contexts[i] = this;
                        values[i] = arguments.length > 1 ? core_slice.call(arguments) : value;
                        if (values === progressValues) {
                            deferred.notifyWith(contexts, values);
                        } else if (!(--remaining)) {
                            deferred.resolveWith(contexts, values);
                        }
                    };
                },

                progressValues, progressContexts, resolveContexts;

            // add listeners to Deferred subordinates; treat others as resolved
            if (length > 1) {
                progressValues = new Array(length);
                progressContexts = new Array(length);
                resolveContexts = new Array(length);
                for (; i < length; i++) {
                    if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
                        resolveValues[i].promise()
                            .done(updateFunc(i, resolveContexts, resolveValues))
                            .fail(deferred.reject)
                            .progress(updateFunc(i, progressContexts, progressValues));
                    } else {
                        --remaining;
                    }
                }
            }

            // if we're not waiting on anything, resolve the master
            if (!remaining) {
                deferred.resolveWith(resolveContexts, resolveValues);
            }

            return deferred.promise();
        }
    });
    jQuery.support = (function() {

        var support,
            all,
            a,
            select,
            opt,
            input,
            fragment,
            eventName,
            i,
            isSupported,
            clickFn,
            div = document.createElement("div");

        // Setup
        div.setAttribute("className", "t");
        div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";

        // Support tests won't run in some limited or non-browser environments
        all = div.getElementsByTagName("*");
        a = div.getElementsByTagName("a")[0];
        if (!all || !a || !all.length) {
            return {};
        }

        // First batch of tests
        select = document.createElement("select");
        opt = select.appendChild(document.createElement("option"));
        input = div.getElementsByTagName("input")[0];

        a.style.cssText = "top:1px;float:left;opacity:.5";
        support = {
            // IE strips leading whitespace when .innerHTML is used
            leadingWhitespace: (div.firstChild.nodeType === 3),

            // Make sure that tbody elements aren't automatically inserted
            // IE will insert them into empty tables
            tbody: !div.getElementsByTagName("tbody").length,

            // Make sure that link elements get serialized correctly by innerHTML
            // This requires a wrapper element in IE
            htmlSerialize: !!div.getElementsByTagName("link").length,

            // Get the style information from getAttribute
            // (IE uses .cssText instead)
            style: /top/.test(a.getAttribute("style")),

            // Make sure that URLs aren't manipulated
            // (IE normalizes it by default)
            hrefNormalized: (a.getAttribute("href") === "/a"),

            // Make sure that element opacity exists
            // (IE uses filter instead)
            // Use a regex to work around a WebKit issue. See #5145
            opacity: /^0.5/.test(a.style.opacity),

            // Verify style float existence
            // (IE uses styleFloat instead of cssFloat)
            cssFloat: !!a.style.cssFloat,

            // Make sure that if no value is specified for a checkbox
            // that it defaults to "on".
            // (WebKit defaults to "" instead)
            checkOn: (input.value === "on"),

            // Make sure that a selected-by-default option has a working selected property.
            // (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
            optSelected: opt.selected,

            // Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
            getSetAttribute: div.className !== "t",

            // Tests for enctype support on a form (#6743)
            enctype: !!document.createElement("form").enctype,

            // Makes sure cloning an html5 element does not cause problems
            // Where outerHTML is undefined, this still works
            html5Clone: document.createElement("nav").cloneNode(true).outerHTML !== "<:nav></:nav>",

            // jQuery.support.boxModel DEPRECATED in 1.8 since we don't support Quirks Mode
            boxModel: (document.compatMode === "CSS1Compat"),

            // Will be defined later
            submitBubbles: true,
            changeBubbles: true,
            focusinBubbles: false,
            deleteExpando: true,
            noCloneEvent: true,
            inlineBlockNeedsLayout: false,
            shrinkWrapBlocks: false,
            reliableMarginRight: true,
            boxSizingReliable: true,
            pixelPosition: false
        };

        // Make sure checked status is properly cloned
        input.checked = true;
        support.noCloneChecked = input.cloneNode(true).checked;

        // Make sure that the options inside disabled selects aren't marked as disabled
        // (WebKit marks them as disabled)
        select.disabled = true;
        support.optDisabled = !opt.disabled;

        // Test to see if it's possible to delete an expando from an element
        // Fails in Internet Explorer
        try {
            delete div.test;
        } catch (e) {
            support.deleteExpando = false;
        }

        if (!div.addEventListener && div.attachEvent && div.fireEvent) {
            div.attachEvent("onclick", clickFn = function() {
                // Cloning a node shouldn't copy over any
                // bound event handlers (IE does this)
                support.noCloneEvent = false;
            });
            div.cloneNode(true).fireEvent("onclick");
            div.detachEvent("onclick", clickFn);
        }

        // Check if a radio maintains its value
        // after being appended to the DOM
        input = document.createElement("input");
        input.value = "t";
        input.setAttribute("type", "radio");
        support.radioValue = input.value === "t";

        input.setAttribute("checked", "checked");

        // #11217 - WebKit loses check when the name is after the checked attribute
        input.setAttribute("name", "t");

        div.appendChild(input);
        fragment = document.createDocumentFragment();
        fragment.appendChild(div.lastChild);

        // WebKit doesn't clone checked state correctly in fragments
        support.checkClone = fragment.cloneNode(true).cloneNode(true).lastChild.checked;

        // Check if a disconnected checkbox will retain its checked
        // value of true after appended to the DOM (IE6/7)
        support.appendChecked = input.checked;

        fragment.removeChild(input);
        fragment.appendChild(div);

        // Technique from Juriy Zaytsev
        // http://perfectionkills.com/detecting-event-support-without-browser-sniffing/
        // We only care about the case where non-standard event systems
        // are used, namely in IE. Short-circuiting here helps us to
        // avoid an eval call (in setAttribute) which can cause CSP
        // to go haywire. See: https://developer.mozilla.org/en/Security/CSP
        if (div.attachEvent) {
            for (i in {
                    submit: true,
                    change: true,
                    focusin: true
                }) {
                eventName = "on" + i;
                isSupported = (eventName in div);
                if (!isSupported) {
                    div.setAttribute(eventName, "return;");
                    isSupported = (typeof div[eventName] === "function");
                }
                support[i + "Bubbles"] = isSupported;
            }
        }

        // Run tests that need a body at doc ready
        jQuery(function() {
            var container, div, tds, marginDiv,
                divReset = "padding:0;margin:0;border:0;display:block;overflow:hidden;",
                body = document.getElementsByTagName("body")[0];

            if (!body) {
                // Return for frameset docs that don't have a body
                return;
            }

            container = document.createElement("div");
            container.style.cssText = "visibility:hidden;border:0;width:0;height:0;position:static;top:0;margin-top:1px";
            body.insertBefore(container, body.firstChild);

            // Construct the test element
            div = document.createElement("div");
            container.appendChild(div);

            // Check if table cells still have offsetWidth/Height when they are set
            // to display:none and there are still other visible table cells in a
            // table row; if so, offsetWidth/Height are not reliable for use when
            // determining if an element has been hidden directly using
            // display:none (it is still safe to use offsets if a parent element is
            // hidden; don safety goggles and see bug #4512 for more information).
            // (only IE 8 fails this test)
            div.innerHTML = "<table><tr><td></td><td>t</td></tr></table>";
            tds = div.getElementsByTagName("td");
            tds[0].style.cssText = "padding:0;margin:0;border:0;display:none";
            isSupported = (tds[0].offsetHeight === 0);

            tds[0].style.display = "";
            tds[1].style.display = "none";

            // Check if empty table cells still have offsetWidth/Height
            // (IE <= 8 fail this test)
            support.reliableHiddenOffsets = isSupported && (tds[0].offsetHeight === 0);

            // Check box-sizing and margin behavior
            div.innerHTML = "";
            div.style.cssText = "box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;";
            support.boxSizing = (div.offsetWidth === 4);
            support.doesNotIncludeMarginInBodyOffset = (body.offsetTop !== 1);

            // NOTE: To any future maintainer, we've window.getComputedStyle
            // because jsdom on node.js will break without it.
            if (window.getComputedStyle) {
                support.pixelPosition = (window.getComputedStyle(div, null) || {}).top !== "1%";
                support.boxSizingReliable = (window.getComputedStyle(div, null) || { width: "4px" }).width === "4px";

                // Check if div with explicit width and no margin-right incorrectly
                // gets computed margin-right based on width of container. For more
                // info see bug #3333
                // Fails in WebKit before Feb 2011 nightlies
                // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
                marginDiv = document.createElement("div");
                marginDiv.style.cssText = div.style.cssText = divReset;
                marginDiv.style.marginRight = marginDiv.style.width = "0";
                div.style.width = "1px";
                div.appendChild(marginDiv);
                support.reliableMarginRight = !parseFloat((window.getComputedStyle(marginDiv, null) || {}).marginRight);
            }

            if (typeof div.style.zoom !== "undefined") {
                // Check if natively block-level elements act like inline-block
                // elements when setting their display to 'inline' and giving
                // them layout
                // (IE < 8 does this)
                div.innerHTML = "";
                div.style.cssText = divReset + "width:1px;padding:1px;display:inline;zoom:1";
                support.inlineBlockNeedsLayout = (div.offsetWidth === 3);

                // Check if elements with layout shrink-wrap their children
                // (IE 6 does this)
                div.style.display = "block";
                div.style.overflow = "visible";
                div.innerHTML = "<div></div>";
                div.firstChild.style.width = "5px";
                support.shrinkWrapBlocks = (div.offsetWidth !== 3);

                container.style.zoom = 1;
            }

            // Null elements to avoid leaks in IE
            body.removeChild(container);
            container = div = tds = marginDiv = null;
        });

        // Null elements to avoid leaks in IE
        fragment.removeChild(div);
        all = a = select = opt = input = fragment = div = null;

        return support;
    })();
    var rbrace = /(?:\{[\s\S]*\}|\[[\s\S]*\])$/,
        rmultiDash = /([A-Z])/g;

    jQuery.extend({
        cache: {},

        deletedIds: [],

        // Remove at next major release (1.9/2.0)
        uuid: 0,

        // Unique for each copy of jQuery on the page
        // Non-digits removed to match rinlinejQuery
        expando: "jQuery" + (jQuery.fn.jquery + Math.random()).replace(/\D/g, ""),

        // The following elements throw uncatchable exceptions if you
        // attempt to add expando properties to them.
        noData: {
            "embed": true,
            // Ban all objects except for Flash (which handle expandos)
            "object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
            "applet": true
        },

        hasData: function(elem) {
            elem = elem.nodeType ? jQuery.cache[elem[jQuery.expando]] : elem[jQuery.expando];
            return !!elem && !isEmptyDataObject(elem);
        },

        data: function(elem, name, data, pvt /* Internal Use Only */ ) {
            if (!jQuery.acceptData(elem)) {
                return;
            }

            var thisCache, ret,
                internalKey = jQuery.expando,
                getByName = typeof name === "string",

                // We have to handle DOM nodes and JS objects differently because IE6-7
                // can't GC object references properly across the DOM-JS boundary
                isNode = elem.nodeType,

                // Only DOM nodes need the global jQuery cache; JS object data is
                // attached directly to the object so GC can occur automatically
                cache = isNode ? jQuery.cache : elem,

                // Only defining an ID for JS objects if its cache already exists allows
                // the code to shortcut on the same path as a DOM node with no cache
                id = isNode ? elem[internalKey] : elem[internalKey] && internalKey;

            // Avoid doing any more work than we need to when trying to get data on an
            // object that has no data at all
            if ((!id || !cache[id] || (!pvt && !cache[id].data)) && getByName && data === undefined) {
                return;
            }

            if (!id) {
                // Only DOM nodes need a new unique ID for each element since their data
                // ends up in the global cache
                if (isNode) {
                    elem[internalKey] = id = jQuery.deletedIds.pop() || jQuery.guid++;
                } else {
                    id = internalKey;
                }
            }

            if (!cache[id]) {
                cache[id] = {};

                // Avoids exposing jQuery metadata on plain JS objects when the object
                // is serialized using JSON.stringify
                if (!isNode) {
                    cache[id].toJSON = jQuery.noop;
                }
            }

            // An object can be passed to jQuery.data instead of a key/value pair; this gets
            // shallow copied over onto the existing cache
            if (typeof name === "object" || typeof name === "function") {
                if (pvt) {
                    cache[id] = jQuery.extend(cache[id], name);
                } else {
                    cache[id].data = jQuery.extend(cache[id].data, name);
                }
            }

            thisCache = cache[id];

            // jQuery data() is stored in a separate object inside the object's internal data
            // cache in order to avoid key collisions between internal data and user-defined
            // data.
            if (!pvt) {
                if (!thisCache.data) {
                    thisCache.data = {};
                }

                thisCache = thisCache.data;
            }

            if (data !== undefined) {
                thisCache[jQuery.camelCase(name)] = data;
            }

            // Check for both converted-to-camel and non-converted data property names
            // If a data property was specified
            if (getByName) {

                // First Try to find as-is property data
                ret = thisCache[name];

                // Test for null|undefined property data
                if (ret == null) {

                    // Try to find the camelCased property
                    ret = thisCache[jQuery.camelCase(name)];
                }
            } else {
                ret = thisCache;
            }

            return ret;
        },

        removeData: function(elem, name, pvt /* Internal Use Only */ ) {
            if (!jQuery.acceptData(elem)) {
                return;
            }

            var thisCache, i, l,

                isNode = elem.nodeType,

                // See jQuery.data for more information
                cache = isNode ? jQuery.cache : elem,
                id = isNode ? elem[jQuery.expando] : jQuery.expando;

            // If there is already no cache entry for this object, there is no
            // purpose in continuing
            if (!cache[id]) {
                return;
            }

            if (name) {

                thisCache = pvt ? cache[id] : cache[id].data;

                if (thisCache) {

                    // Support array or space separated string names for data keys
                    if (!jQuery.isArray(name)) {

                        // try the string as a key before any manipulation
                        if (name in thisCache) {
                            name = [name];
                        } else {

                            // split the camel cased version by spaces unless a key with the spaces exists
                            name = jQuery.camelCase(name);
                            if (name in thisCache) {
                                name = [name];
                            } else {
                                name = name.split(" ");
                            }
                        }
                    }

                    for (i = 0, l = name.length; i < l; i++) {
                        delete thisCache[name[i]];
                    }

                    // If there is no data left in the cache, we want to continue
                    // and let the cache object itself get destroyed
                    if (!(pvt ? isEmptyDataObject : jQuery.isEmptyObject)(thisCache)) {
                        return;
                    }
                }
            }

            // See jQuery.data for more information
            if (!pvt) {
                delete cache[id].data;

                // Don't destroy the parent cache unless the internal data object
                // had been the only thing left in it
                if (!isEmptyDataObject(cache[id])) {
                    return;
                }
            }

            // Destroy the cache
            if (isNode) {
                jQuery.cleanData([elem], true);

                // Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)
            } else if (jQuery.support.deleteExpando || cache != cache.window) {
                delete cache[id];

                // When all else fails, null
            } else {
                cache[id] = null;
            }
        },

        // For internal use only.
        _data: function(elem, name, data) {
            return jQuery.data(elem, name, data, true);
        },

        // A method for determining if a DOM node can handle the data expando
        acceptData: function(elem) {
            var noData = elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()];

            // nodes accept data unless otherwise specified; rejection can be conditional
            return !noData || noData !== true && elem.getAttribute("classid") === noData;
        }
    });

    jQuery.fn.extend({
        data: function(key, value) {
            var parts, part, attr, name, l,
                elem = this[0],
                i = 0,
                data = null;

            // Gets all values
            if (key === undefined) {
                if (this.length) {
                    data = jQuery.data(elem);

                    if (elem.nodeType === 1 && !jQuery._data(elem, "parsedAttrs")) {
                        attr = elem.attributes;
                        for (l = attr.length; i < l; i++) {
                            name = attr[i].name;

                            if (!name.indexOf("data-")) {
                                name = jQuery.camelCase(name.substring(5));

                                dataAttr(elem, name, data[name]);
                            }
                        }
                        jQuery._data(elem, "parsedAttrs", true);
                    }
                }

                return data;
            }

            // Sets multiple values
            if (typeof key === "object") {
                return this.each(function() {
                    jQuery.data(this, key);
                });
            }

            parts = key.split(".", 2);
            parts[1] = parts[1] ? "." + parts[1] : "";
            part = parts[1] + "!";

            return jQuery.access(this, function(value) {

                if (value === undefined) {
                    data = this.triggerHandler("getData" + part, [parts[0]]);

                    // Try to fetch any internally stored data first
                    if (data === undefined && elem) {
                        data = jQuery.data(elem, key);
                        data = dataAttr(elem, key, data);
                    }

                    return data === undefined && parts[1] ?
                        this.data(parts[0]) :
                        data;
                }

                parts[1] = value;
                this.each(function() {
                    var self = jQuery(this);

                    self.triggerHandler("setData" + part, parts);
                    jQuery.data(this, key, value);
                    self.triggerHandler("changeData" + part, parts);
                });
            }, null, value, arguments.length > 1, null, false);
        },

        removeData: function(key) {
            return this.each(function() {
                jQuery.removeData(this, key);
            });
        }
    });

    function dataAttr(elem, key, data) {
        // If nothing was found internally, try to fetch any
        // data from the HTML5 data-* attribute
        if (data === undefined && elem.nodeType === 1) {

            var name = "data-" + key.replace(rmultiDash, "-$1").toLowerCase();

            data = elem.getAttribute(name);

            if (typeof data === "string") {
                try {
                    data = data === "true" ? true :
                        data === "false" ? false :
                        data === "null" ? null :
                        // Only convert to a number if it doesn't change the string
                        +data + "" === data ? +data :
                        rbrace.test(data) ? jQuery.parseJSON(data) :
                        data;
                } catch (e) {}

                // Make sure we set the data so it isn't changed later
                jQuery.data(elem, key, data);

            } else {
                data = undefined;
            }
        }

        return data;
    }

    // checks a cache object for emptiness
    function isEmptyDataObject(obj) {
        var name;
        for (name in obj) {

            // if the public data object is empty, the private is still empty
            if (name === "data" && jQuery.isEmptyObject(obj[name])) {
                continue;
            }
            if (name !== "toJSON") {
                return false;
            }
        }

        return true;
    }
    jQuery.extend({
        queue: function(elem, type, data) {
            var queue;

            if (elem) {
                type = (type || "fx") + "queue";
                queue = jQuery._data(elem, type);

                // Speed up dequeue by getting out quickly if this is just a lookup
                if (data) {
                    if (!queue || jQuery.isArray(data)) {
                        queue = jQuery._data(elem, type, jQuery.makeArray(data));
                    } else {
                        queue.push(data);
                    }
                }
                return queue || [];
            }
        },

        dequeue: function(elem, type) {
            type = type || "fx";

            var queue = jQuery.queue(elem, type),
                startLength = queue.length,
                fn = queue.shift(),
                hooks = jQuery._queueHooks(elem, type),
                next = function() {
                    jQuery.dequeue(elem, type);
                };

            // If the fx queue is dequeued, always remove the progress sentinel
            if (fn === "inprogress") {
                fn = queue.shift();
                startLength--;
            }

            if (fn) {

                // Add a progress sentinel to prevent the fx queue from being
                // automatically dequeued
                if (type === "fx") {
                    queue.unshift("inprogress");
                }

                // clear up the last queue stop function
                delete hooks.stop;
                fn.call(elem, next, hooks);
            }

            if (!startLength && hooks) {
                hooks.empty.fire();
            }
        },

        // not intended for public consumption - generates a queueHooks object, or returns the current one
        _queueHooks: function(elem, type) {
            var key = type + "queueHooks";
            return jQuery._data(elem, key) || jQuery._data(elem, key, {
                empty: jQuery.Callbacks("once memory").add(function() {
                    jQuery.removeData(elem, type + "queue", true);
                    jQuery.removeData(elem, key, true);
                })
            });
        }
    });

    jQuery.fn.extend({
        queue: function(type, data) {
            var setter = 2;

            if (typeof type !== "string") {
                data = type;
                type = "fx";
                setter--;
            }

            if (arguments.length < setter) {
                return jQuery.queue(this[0], type);
            }

            return data === undefined ?
                this :
                this.each(function() {
                    var queue = jQuery.queue(this, type, data);

                    // ensure a hooks for this queue
                    jQuery._queueHooks(this, type);

                    if (type === "fx" && queue[0] !== "inprogress") {
                        jQuery.dequeue(this, type);
                    }
                });
        },
        dequeue: function(type) {
            return this.each(function() {
                jQuery.dequeue(this, type);
            });
        },
        // Based off of the plugin by Clint Helfers, with permission.
        // http://blindsignals.com/index.php/2009/07/jquery-delay/
        delay: function(time, type) {
            time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
            type = type || "fx";

            return this.queue(type, function(next, hooks) {
                var timeout = setTimeout(next, time);
                hooks.stop = function() {
                    clearTimeout(timeout);
                };
            });
        },
        clearQueue: function(type) {
            return this.queue(type || "fx", []);
        },
        // Get a promise resolved when queues of a certain type
        // are emptied (fx is the type by default)
        promise: function(type, obj) {
            var tmp,
                count = 1,
                defer = jQuery.Deferred(),
                elements = this,
                i = this.length,
                resolve = function() {
                    if (!(--count)) {
                        defer.resolveWith(elements, [elements]);
                    }
                };

            if (typeof type !== "string") {
                obj = type;
                type = undefined;
            }
            type = type || "fx";

            while (i--) {
                tmp = jQuery._data(elements[i], type + "queueHooks");
                if (tmp && tmp.empty) {
                    count++;
                    tmp.empty.add(resolve);
                }
            }
            resolve();
            return defer.promise(obj);
        }
    });
    var nodeHook, boolHook, fixSpecified,
        rclass = /[\t\r\n]/g,
        rreturn = /\r/g,
        rtype = /^(?:button|input)$/i,
        rfocusable = /^(?:button|input|object|select|textarea)$/i,
        rclickable = /^a(?:rea|)$/i,
        rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,
        getSetAttribute = jQuery.support.getSetAttribute;

    jQuery.fn.extend({
        attr: function(name, value) {
            return jQuery.access(this, jQuery.attr, name, value, arguments.length > 1);
        },

        removeAttr: function(name) {
            return this.each(function() {
                jQuery.removeAttr(this, name);
            });
        },

        prop: function(name, value) {
            return jQuery.access(this, jQuery.prop, name, value, arguments.length > 1);
        },

        removeProp: function(name) {
            name = jQuery.propFix[name] || name;
            return this.each(function() {
                // try/catch handles cases where IE balks (such as removing a property on window)
                try {
                    this[name] = undefined;
                    delete this[name];
                } catch (e) {}
            });
        },

        addClass: function(value) {
            var classNames, i, l, elem,
                setClass, c, cl;

            if (jQuery.isFunction(value)) {
                return this.each(function(j) {
                    jQuery(this).addClass(value.call(this, j, this.className));
                });
            }

            if (value && typeof value === "string") {
                classNames = value.split(core_rspace);

                for (i = 0, l = this.length; i < l; i++) {
                    elem = this[i];

                    if (elem.nodeType === 1) {
                        if (!elem.className && classNames.length === 1) {
                            elem.className = value;

                        } else {
                            setClass = " " + elem.className + " ";

                            for (c = 0, cl = classNames.length; c < cl; c++) {
                                if (setClass.indexOf(" " + classNames[c] + " ") < 0) {
                                    setClass += classNames[c] + " ";
                                }
                            }
                            elem.className = jQuery.trim(setClass);
                        }
                    }
                }
            }

            return this;
        },

        removeClass: function(value) {
            var removes, className, elem, c, cl, i, l;

            if (jQuery.isFunction(value)) {
                return this.each(function(j) {
                    jQuery(this).removeClass(value.call(this, j, this.className));
                });
            }
            if ((value && typeof value === "string") || value === undefined) {
                removes = (value || "").split(core_rspace);

                for (i = 0, l = this.length; i < l; i++) {
                    elem = this[i];
                    if (elem.nodeType === 1 && elem.className) {

                        className = (" " + elem.className + " ").replace(rclass, " ");

                        // loop over each item in the removal list
                        for (c = 0, cl = removes.length; c < cl; c++) {
                            // Remove until there is nothing to remove,
                            while (className.indexOf(" " + removes[c] + " ") >= 0) {
                                className = className.replace(" " + removes[c] + " ", " ");
                            }
                        }
                        elem.className = value ? jQuery.trim(className) : "";
                    }
                }
            }

            return this;
        },

        toggleClass: function(value, stateVal) {
            var type = typeof value,
                isBool = typeof stateVal === "boolean";

            if (jQuery.isFunction(value)) {
                return this.each(function(i) {
                    jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);
                });
            }

            return this.each(function() {
                if (type === "string") {
                    // toggle individual class names
                    var className,
                        i = 0,
                        self = jQuery(this),
                        state = stateVal,
                        classNames = value.split(core_rspace);

                    while ((className = classNames[i++])) {
                        // check each className given, space separated list
                        state = isBool ? state : !self.hasClass(className);
                        self[state ? "addClass" : "removeClass"](className);
                    }

                } else if (type === "undefined" || type === "boolean") {
                    if (this.className) {
                        // store className if set
                        jQuery._data(this, "__className__", this.className);
                    }

                    // toggle whole className
                    this.className = this.className || value === false ? "" : jQuery._data(this, "__className__") || "";
                }
            });
        },

        hasClass: function(selector) {
            var className = " " + selector + " ",
                i = 0,
                l = this.length;
            for (; i < l; i++) {
                if (this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf(className) >= 0) {
                    return true;
                }
            }

            return false;
        },

        val: function(value) {
            var hooks, ret, isFunction,
                elem = this[0];

            if (!arguments.length) {
                if (elem) {
                    hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];

                    if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
                        return ret;
                    }

                    ret = elem.value;

                    return typeof ret === "string" ?
                        // handle most common string cases
                        ret.replace(rreturn, "") :
                        // handle cases where value is null/undef or number
                        ret == null ? "" : ret;
                }

                return;
            }

            isFunction = jQuery.isFunction(value);

            return this.each(function(i) {
                var val,
                    self = jQuery(this);

                if (this.nodeType !== 1) {
                    return;
                }

                if (isFunction) {
                    val = value.call(this, i, self.val());
                } else {
                    val = value;
                }

                // Treat null/undefined as ""; convert numbers to string
                if (val == null) {
                    val = "";
                } else if (typeof val === "number") {
                    val += "";
                } else if (jQuery.isArray(val)) {
                    val = jQuery.map(val, function(value) {
                        return value == null ? "" : value + "";
                    });
                }

                hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];

                // If set returns undefined, fall back to normal setting
                if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
                    this.value = val;
                }
            });
        }
    });

    jQuery.extend({
        valHooks: {
            option: {
                get: function(elem) {
                    // attributes.value is undefined in Blackberry 4.7 but
                    // uses .value. See #6932
                    var val = elem.attributes.value;
                    return !val || val.specified ? elem.value : elem.text;
                }
            },
            select: {
                get: function(elem) {
                    var value, option,
                        options = elem.options,
                        index = elem.selectedIndex,
                        one = elem.type === "select-one" || index < 0,
                        values = one ? null : [],
                        max = one ? index + 1 : options.length,
                        i = index < 0 ?
                        max :
                        one ? index : 0;

                    // Loop through all the selected options
                    for (; i < max; i++) {
                        option = options[i];

                        // oldIE doesn't update selected after form reset (#2551)
                        if ((option.selected || i === index) &&
                            // Don't return options that are disabled or in a disabled optgroup
                            (jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) &&
                            (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {

                            // Get the specific value for the option
                            value = jQuery(option).val();

                            // We don't need an array for one selects
                            if (one) {
                                return value;
                            }

                            // Multi-Selects return an array
                            values.push(value);
                        }
                    }

                    return values;
                },

                set: function(elem, value) {
                    var values = jQuery.makeArray(value);

                    jQuery(elem).find("option").each(function() {
                        this.selected = jQuery.inArray(jQuery(this).val(), values) >= 0;
                    });

                    if (!values.length) {
                        elem.selectedIndex = -1;
                    }
                    return values;
                }
            }
        },

        // Unused in 1.8, left in so attrFn-stabbers won't die; remove in 1.9
        attrFn: {},

        attr: function(elem, name, value, pass) {
            var ret, hooks, notxml,
                nType = elem.nodeType;

            // don't get/set attributes on text, comment and attribute nodes
            if (!elem || nType === 3 || nType === 8 || nType === 2) {
                return;
            }

            if (pass && jQuery.isFunction(jQuery.fn[name])) {
                return jQuery(elem)[name](value);
            }

            // Fallback to prop when attributes are not supported
            if (typeof elem.getAttribute === "undefined") {
                return jQuery.prop(elem, name, value);
            }

            notxml = nType !== 1 || !jQuery.isXMLDoc(elem);

            // All attributes are lowercase
            // Grab necessary hook if one is defined
            if (notxml) {
                name = name.toLowerCase();
                hooks = jQuery.attrHooks[name] || (rboolean.test(name) ? boolHook : nodeHook);
            }

            if (value !== undefined) {

                if (value === null) {
                    jQuery.removeAttr(elem, name);
                    return;

                } else if (hooks && "set" in hooks && notxml && (ret = hooks.set(elem, value, name)) !== undefined) {
                    return ret;

                } else {
                    elem.setAttribute(name, value + "");
                    return value;
                }

            } else if (hooks && "get" in hooks && notxml && (ret = hooks.get(elem, name)) !== null) {
                return ret;

            } else {

                ret = elem.getAttribute(name);

                // Non-existent attributes return null, we normalize to undefined
                return ret === null ?
                    undefined :
                    ret;
            }
        },

        removeAttr: function(elem, value) {
            var propName, attrNames, name, isBool,
                i = 0;

            if (value && elem.nodeType === 1) {

                attrNames = value.split(core_rspace);

                for (; i < attrNames.length; i++) {
                    name = attrNames[i];

                    if (name) {
                        propName = jQuery.propFix[name] || name;
                        isBool = rboolean.test(name);

                        // See #9699 for explanation of this approach (setting first, then removal)
                        // Do not do this for boolean attributes (see #10870)
                        if (!isBool) {
                            jQuery.attr(elem, name, "");
                        }
                        elem.removeAttribute(getSetAttribute ? name : propName);

                        // Set corresponding property to false for boolean attributes
                        if (isBool && propName in elem) {
                            elem[propName] = false;
                        }
                    }
                }
            }
        },

        attrHooks: {
            type: {
                set: function(elem, value) {
                    // We can't allow the type property to be changed (since it causes problems in IE)
                    if (rtype.test(elem.nodeName) && elem.parentNode) {
                        jQuery.error("type property can't be changed");
                    } else if (!jQuery.support.radioValue && value === "radio" && jQuery.nodeName(elem, "input")) {
                        // Setting the type on a radio button after the value resets the value in IE6-9
                        // Reset value to it's default in case type is set after value
                        // This is for element creation
                        var val = elem.value;
                        elem.setAttribute("type", value);
                        if (val) {
                            elem.value = val;
                        }
                        return value;
                    }
                }
            },
            // Use the value property for back compat
            // Use the nodeHook for button elements in IE6/7 (#1954)
            value: {
                get: function(elem, name) {
                    if (nodeHook && jQuery.nodeName(elem, "button")) {
                        return nodeHook.get(elem, name);
                    }
                    return name in elem ?
                        elem.value :
                        null;
                },
                set: function(elem, value, name) {
                    if (nodeHook && jQuery.nodeName(elem, "button")) {
                        return nodeHook.set(elem, value, name);
                    }
                    // Does not return so that setAttribute is also used
                    elem.value = value;
                }
            }
        },

        propFix: {
            tabindex: "tabIndex",
            readonly: "readOnly",
            "for": "htmlFor",
            "class": "className",
            maxlength: "maxLength",
            cellspacing: "cellSpacing",
            cellpadding: "cellPadding",
            rowspan: "rowSpan",
            colspan: "colSpan",
            usemap: "useMap",
            frameborder: "frameBorder",
            contenteditable: "contentEditable"
        },

        prop: function(elem, name, value) {
            var ret, hooks, notxml,
                nType = elem.nodeType;

            // don't get/set properties on text, comment and attribute nodes
            if (!elem || nType === 3 || nType === 8 || nType === 2) {
                return;
            }

            notxml = nType !== 1 || !jQuery.isXMLDoc(elem);

            if (notxml) {
                // Fix name and attach hooks
                name = jQuery.propFix[name] || name;
                hooks = jQuery.propHooks[name];
            }

            if (value !== undefined) {
                if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
                    return ret;

                } else {
                    return (elem[name] = value);
                }

            } else {
                if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
                    return ret;

                } else {
                    return elem[name];
                }
            }
        },

        propHooks: {
            tabIndex: {
                get: function(elem) {
                    // elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
                    // http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
                    var attributeNode = elem.getAttributeNode("tabindex");

                    return attributeNode && attributeNode.specified ?
                        parseInt(attributeNode.value, 10) :
                        rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href ?
                        0 :
                        undefined;
                }
            }
        }
    });

    // Hook for boolean attributes
    boolHook = {
        get: function(elem, name) {
            // Align boolean attributes with corresponding properties
            // Fall back to attribute presence where some booleans are not supported
            var attrNode,
                property = jQuery.prop(elem, name);
            return property === true || typeof property !== "boolean" && (attrNode = elem.getAttributeNode(name)) && attrNode.nodeValue !== false ?
                name.toLowerCase() :
                undefined;
        },
        set: function(elem, value, name) {
            var propName;
            if (value === false) {
                // Remove boolean attributes when set to false
                jQuery.removeAttr(elem, name);
            } else {
                // value is true since we know at this point it's type boolean and not false
                // Set boolean attributes to the same name and set the DOM property
                propName = jQuery.propFix[name] || name;
                if (propName in elem) {
                    // Only set the IDL specifically if it already exists on the element
                    elem[propName] = true;
                }

                elem.setAttribute(name, name.toLowerCase());
            }
            return name;
        }
    };

    // IE6/7 do not support getting/setting some attributes with get/setAttribute
    if (!getSetAttribute) {

        fixSpecified = {
            name: true,
            id: true,
            coords: true
        };

        // Use this for any attribute in IE6/7
        // This fixes almost every IE6/7 issue
        nodeHook = jQuery.valHooks.button = {
            get: function(elem, name) {
                var ret;
                ret = elem.getAttributeNode(name);
                return ret && (fixSpecified[name] ? ret.value !== "" : ret.specified) ?
                    ret.value :
                    undefined;
            },
            set: function(elem, value, name) {
                // Set the existing or create a new attribute node
                var ret = elem.getAttributeNode(name);
                if (!ret) {
                    ret = document.createAttribute(name);
                    elem.setAttributeNode(ret);
                }
                return (ret.value = value + "");
            }
        };

        // Set width and height to auto instead of 0 on empty string( Bug #8150 )
        // This is for removals
        jQuery.each(["width", "height"], function(i, name) {
            jQuery.attrHooks[name] = jQuery.extend(jQuery.attrHooks[name], {
                set: function(elem, value) {
                    if (value === "") {
                        elem.setAttribute(name, "auto");
                        return value;
                    }
                }
            });
        });

        // Set contenteditable to false on removals(#10429)
        // Setting to empty string throws an error as an invalid value
        jQuery.attrHooks.contenteditable = {
            get: nodeHook.get,
            set: function(elem, value, name) {
                if (value === "") {
                    value = "false";
                }
                nodeHook.set(elem, value, name);
            }
        };
    }


    // Some attributes require a special call on IE
    if (!jQuery.support.hrefNormalized) {
        jQuery.each(["href", "src", "width", "height"], function(i, name) {
            jQuery.attrHooks[name] = jQuery.extend(jQuery.attrHooks[name], {
                get: function(elem) {
                    var ret = elem.getAttribute(name, 2);
                    return ret === null ? undefined : ret;
                }
            });
        });
    }

    if (!jQuery.support.style) {
        jQuery.attrHooks.style = {
            get: function(elem) {
                // Return undefined in the case of empty string
                // Normalize to lowercase since IE uppercases css property names
                return elem.style.cssText.toLowerCase() || undefined;
            },
            set: function(elem, value) {
                return (elem.style.cssText = value + "");
            }
        };
    }

    // Safari mis-reports the default selected property of an option
    // Accessing the parent's selectedIndex property fixes it
    if (!jQuery.support.optSelected) {
        jQuery.propHooks.selected = jQuery.extend(jQuery.propHooks.selected, {
            get: function(elem) {
                var parent = elem.parentNode;

                if (parent) {
                    parent.selectedIndex;

                    // Make sure that it also works with optgroups, see #5701
                    if (parent.parentNode) {
                        parent.parentNode.selectedIndex;
                    }
                }
                return null;
            }
        });
    }

    // IE6/7 call enctype encoding
    if (!jQuery.support.enctype) {
        jQuery.propFix.enctype = "encoding";
    }

    // Radios and checkboxes getter/setter
    if (!jQuery.support.checkOn) {
        jQuery.each(["radio", "checkbox"], function() {
            jQuery.valHooks[this] = {
                get: function(elem) {
                    // Handle the case where in Webkit "" is returned instead of "on" if a value isn't specified
                    return elem.getAttribute("value") === null ? "on" : elem.value;
                }
            };
        });
    }
    jQuery.each(["radio", "checkbox"], function() {
        jQuery.valHooks[this] = jQuery.extend(jQuery.valHooks[this], {
            set: function(elem, value) {
                if (jQuery.isArray(value)) {
                    return (elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0);
                }
            }
        });
    });
    var rformElems = /^(?:textarea|input|select)$/i,
        rtypenamespace = /^([^\.]*|)(?:\.(.+)|)$/,
        rhoverHack = /(?:^|\s)hover(\.\S+|)\b/,
        rkeyEvent = /^key/,
        rmouseEvent = /^(?:mouse|contextmenu)|click/,
        rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
        hoverHack = function(events) {
            return jQuery.event.special.hover ? events : events.replace(rhoverHack, "mouseenter$1 mouseleave$1");
        };

    /*
     * Helper functions for managing events -- not part of the public interface.
     * Props to Dean Edwards' addEvent library for many of the ideas.
     */
    jQuery.event = {

        add: function(elem, types, handler, data, selector) {

            var elemData, eventHandle, events,
                t, tns, type, namespaces, handleObj,
                handleObjIn, handlers, special;

            // Don't attach events to noData or text/comment nodes (allow plain objects tho)
            if (elem.nodeType === 3 || elem.nodeType === 8 || !types || !handler || !(elemData = jQuery._data(elem))) {
                return;
            }

            // Caller can pass in an object of custom data in lieu of the handler
            if (handler.handler) {
                handleObjIn = handler;
                handler = handleObjIn.handler;
                selector = handleObjIn.selector;
            }

            // Make sure that the handler has a unique ID, used to find/remove it later
            if (!handler.guid) {
                handler.guid = jQuery.guid++;
            }

            // Init the element's event structure and main handler, if this is the first
            events = elemData.events;
            if (!events) {
                elemData.events = events = {};
            }
            eventHandle = elemData.handle;
            if (!eventHandle) {
                elemData.handle = eventHandle = function(e) {
                    // Discard the second event of a jQuery.event.trigger() and
                    // when an event is called after a page has unloaded
                    return typeof jQuery !== "undefined" && (!e || jQuery.event.triggered !== e.type) ?
                        jQuery.event.dispatch.apply(eventHandle.elem, arguments) :
                        undefined;
                };
                // Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
                eventHandle.elem = elem;
            }

            // Handle multiple events separated by a space
            // jQuery(...).bind("mouseover mouseout", fn);
            types = jQuery.trim(hoverHack(types)).split(" ");
            for (t = 0; t < types.length; t++) {

                tns = rtypenamespace.exec(types[t]) || [];
                type = tns[1];
                namespaces = (tns[2] || "").split(".").sort();

                // If event changes its type, use the special event handlers for the changed type
                special = jQuery.event.special[type] || {};

                // If selector defined, determine special event api type, otherwise given type
                type = (selector ? special.delegateType : special.bindType) || type;

                // Update special based on newly reset type
                special = jQuery.event.special[type] || {};

                // handleObj is passed to all event handlers
                handleObj = jQuery.extend({
                    type: type,
                    origType: tns[1],
                    data: data,
                    handler: handler,
                    guid: handler.guid,
                    selector: selector,
                    needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                    namespace: namespaces.join(".")
                }, handleObjIn);

                // Init the event handler queue if we're the first
                handlers = events[type];
                if (!handlers) {
                    handlers = events[type] = [];
                    handlers.delegateCount = 0;

                    // Only use addEventListener/attachEvent if the special events handler returns false
                    if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                        // Bind the global event handler to the element
                        if (elem.addEventListener) {
                            elem.addEventListener(type, eventHandle, false);

                        } else if (elem.attachEvent) {
                            elem.attachEvent("on" + type, eventHandle);
                        }
                    }
                }

                if (special.add) {
                    special.add.call(elem, handleObj);

                    if (!handleObj.handler.guid) {
                        handleObj.handler.guid = handler.guid;
                    }
                }

                // Add to the element's handler list, delegates in front
                if (selector) {
                    handlers.splice(handlers.delegateCount++, 0, handleObj);
                } else {
                    handlers.push(handleObj);
                }

                // Keep track of which events have ever been used, for event optimization
                jQuery.event.global[type] = true;
            }

            // Nullify elem to prevent memory leaks in IE
            elem = null;
        },

        global: {},

        // Detach an event or set of events from an element
        remove: function(elem, types, handler, selector, mappedTypes) {

            var t, tns, type, origType, namespaces, origCount,
                j, events, special, eventType, handleObj,
                elemData = jQuery.hasData(elem) && jQuery._data(elem);

            if (!elemData || !(events = elemData.events)) {
                return;
            }

            // Once for each type.namespace in types; type may be omitted
            types = jQuery.trim(hoverHack(types || "")).split(" ");
            for (t = 0; t < types.length; t++) {
                tns = rtypenamespace.exec(types[t]) || [];
                type = origType = tns[1];
                namespaces = tns[2];

                // Unbind all events (on this namespace, if provided) for the element
                if (!type) {
                    for (type in events) {
                        jQuery.event.remove(elem, type + types[t], handler, selector, true);
                    }
                    continue;
                }

                special = jQuery.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                eventType = events[type] || [];
                origCount = eventType.length;
                namespaces = namespaces ? new RegExp("(^|\\.)" + namespaces.split(".").sort().join("\\.(?:.*\\.|)") + "(\\.|$)") : null;

                // Remove matching events
                for (j = 0; j < eventType.length; j++) {
                    handleObj = eventType[j];

                    if ((mappedTypes || origType === handleObj.origType) &&
                        (!handler || handler.guid === handleObj.guid) &&
                        (!namespaces || namespaces.test(handleObj.namespace)) &&
                        (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
                        eventType.splice(j--, 1);

                        if (handleObj.selector) {
                            eventType.delegateCount--;
                        }
                        if (special.remove) {
                            special.remove.call(elem, handleObj);
                        }
                    }
                }

                // Remove generic event handler if we removed something and no more handlers exist
                // (avoids potential for endless recursion during removal of special event handlers)
                if (eventType.length === 0 && origCount !== eventType.length) {
                    if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                        jQuery.removeEvent(elem, type, elemData.handle);
                    }

                    delete events[type];
                }
            }

            // Remove the expando if it's no longer used
            if (jQuery.isEmptyObject(events)) {
                delete elemData.handle;

                // removeData also checks for emptiness and clears the expando if empty
                // so use it instead of delete
                jQuery.removeData(elem, "events", true);
            }
        },

        // Events that are safe to short-circuit if no handlers are attached.
        // Native DOM events should not be added, they may have inline handlers.
        customEvent: {
            "getData": true,
            "setData": true,
            "changeData": true
        },

        trigger: function(event, data, elem, onlyHandlers) {
            // Don't do events on text and comment nodes
            if (elem && (elem.nodeType === 3 || elem.nodeType === 8)) {
                return;
            }

            // Event object or event type
            var cache, exclusive, i, cur, old, ontype, special, handle, eventPath, bubbleType,
                type = event.type || event,
                namespaces = [];

            // focus/blur morphs to focusin/out; ensure we're not firing them right now
            if (rfocusMorph.test(type + jQuery.event.triggered)) {
                return;
            }

            if (type.indexOf("!") >= 0) {
                // Exclusive events trigger only for the exact event (no namespaces)
                type = type.slice(0, -1);
                exclusive = true;
            }

            if (type.indexOf(".") >= 0) {
                // Namespaced trigger; create a regexp to match event type in handle()
                namespaces = type.split(".");
                type = namespaces.shift();
                namespaces.sort();
            }

            if ((!elem || jQuery.event.customEvent[type]) && !jQuery.event.global[type]) {
                // No jQuery handlers for this event type, and it can't have inline handlers
                return;
            }

            // Caller can pass in an Event, Object, or just an event type string
            event = typeof event === "object" ?
                // jQuery.Event object
                event[jQuery.expando] ? event :
                // Object literal
                new jQuery.Event(type, event) :
                // Just the event type (string)
                new jQuery.Event(type);

            event.type = type;
            event.isTrigger = true;
            event.exclusive = exclusive;
            event.namespace = namespaces.join(".");
            event.namespace_re = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
            ontype = type.indexOf(":") < 0 ? "on" + type : "";

            // Handle a global trigger
            if (!elem) {

                // TODO: Stop taunting the data cache; remove global events and always attach to document
                cache = jQuery.cache;
                for (i in cache) {
                    if (cache[i].events && cache[i].events[type]) {
                        jQuery.event.trigger(event, data, cache[i].handle.elem, true);
                    }
                }
                return;
            }

            // Clean up the event in case it is being reused
            event.result = undefined;
            if (!event.target) {
                event.target = elem;
            }

            // Clone any incoming data and prepend the event, creating the handler arg list
            data = data != null ? jQuery.makeArray(data) : [];
            data.unshift(event);

            // Allow special events to draw outside the lines
            special = jQuery.event.special[type] || {};
            if (special.trigger && special.trigger.apply(elem, data) === false) {
                return;
            }

            // Determine event propagation path in advance, per W3C events spec (#9951)
            // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
            eventPath = [
                [elem, special.bindType || type]
            ];
            if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {

                bubbleType = special.delegateType || type;
                cur = rfocusMorph.test(bubbleType + type) ? elem : elem.parentNode;
                for (old = elem; cur; cur = cur.parentNode) {
                    eventPath.push([cur, bubbleType]);
                    old = cur;
                }

                // Only add window if we got to document (e.g., not plain obj or detached DOM)
                if (old === (elem.ownerDocument || document)) {
                    eventPath.push([old.defaultView || old.parentWindow || window, bubbleType]);
                }
            }

            // Fire handlers on the event path
            for (i = 0; i < eventPath.length && !event.isPropagationStopped(); i++) {

                cur = eventPath[i][0];
                event.type = eventPath[i][1];

                handle = (jQuery._data(cur, "events") || {})[event.type] && jQuery._data(cur, "handle");
                if (handle) {
                    handle.apply(cur, data);
                }
                // Note that this is a bare JS function and not a jQuery handler
                handle = ontype && cur[ontype];
                if (handle && jQuery.acceptData(cur) && handle.apply && handle.apply(cur, data) === false) {
                    event.preventDefault();
                }
            }
            event.type = type;

            // If nobody prevented the default action, do it now
            if (!onlyHandlers && !event.isDefaultPrevented()) {

                if ((!special._default || special._default.apply(elem.ownerDocument, data) === false) &&
                    !(type === "click" && jQuery.nodeName(elem, "a")) && jQuery.acceptData(elem)) {

                    // Call a native DOM method on the target with the same name name as the event.
                    // Can't use an .isFunction() check here because IE6/7 fails that test.
                    // Don't do default actions on window, that's where global variables be (#6170)
                    // IE<9 dies on focus/blur to hidden element (#1486)
                    if (ontype && elem[type] && ((type !== "focus" && type !== "blur") || event.target.offsetWidth !== 0) && !jQuery.isWindow(elem)) {

                        // Don't re-trigger an onFOO event when we call its FOO() method
                        old = elem[ontype];

                        if (old) {
                            elem[ontype] = null;
                        }

                        // Prevent re-triggering of the same event, since we already bubbled it above
                        jQuery.event.triggered = type;
                        elem[type]();
                        jQuery.event.triggered = undefined;

                        if (old) {
                            elem[ontype] = old;
                        }
                    }
                }
            }

            return event.result;
        },

        dispatch: function(event) {

            // Make a writable jQuery.Event from the native event object
            event = jQuery.event.fix(event || window.event);

            var i, j, cur, ret, selMatch, matched, matches, handleObj, sel, related,
                handlers = ((jQuery._data(this, "events") || {})[event.type] || []),
                delegateCount = handlers.delegateCount,
                args = core_slice.call(arguments),
                run_all = !event.exclusive && !event.namespace,
                special = jQuery.event.special[event.type] || {},
                handlerQueue = [];

            // Use the fix-ed jQuery.Event rather than the (read-only) native event
            args[0] = event;
            event.delegateTarget = this;

            // Call the preDispatch hook for the mapped type, and let it bail if desired
            if (special.preDispatch && special.preDispatch.call(this, event) === false) {
                return;
            }

            // Determine handlers that should run if there are delegated events
            // Avoid non-left-click bubbling in Firefox (#3861)
            if (delegateCount && !(event.button && event.type === "click")) {

                for (cur = event.target; cur != this; cur = cur.parentNode || this) {

                    // Don't process clicks (ONLY) on disabled elements (#6911, #8165, #11382, #11764)
                    if (cur.disabled !== true || event.type !== "click") {
                        selMatch = {};
                        matches = [];
                        for (i = 0; i < delegateCount; i++) {
                            handleObj = handlers[i];
                            sel = handleObj.selector;

                            if (selMatch[sel] === undefined) {
                                selMatch[sel] = handleObj.needsContext ?
                                    jQuery(sel, this).index(cur) >= 0 :
                                    jQuery.find(sel, this, null, [cur]).length;
                            }
                            if (selMatch[sel]) {
                                matches.push(handleObj);
                            }
                        }
                        if (matches.length) {
                            handlerQueue.push({ elem: cur, matches: matches });
                        }
                    }
                }
            }

            // Add the remaining (directly-bound) handlers
            if (handlers.length > delegateCount) {
                handlerQueue.push({ elem: this, matches: handlers.slice(delegateCount) });
            }

            // Run delegates first; they may want to stop propagation beneath us
            for (i = 0; i < handlerQueue.length && !event.isPropagationStopped(); i++) {
                matched = handlerQueue[i];
                event.currentTarget = matched.elem;

                for (j = 0; j < matched.matches.length && !event.isImmediatePropagationStopped(); j++) {
                    handleObj = matched.matches[j];

                    // Triggered event must either 1) be non-exclusive and have no namespace, or
                    // 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
                    if (run_all || (!event.namespace && !handleObj.namespace) || event.namespace_re && event.namespace_re.test(handleObj.namespace)) {

                        event.data = handleObj.data;
                        event.handleObj = handleObj;

                        ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler)
                            .apply(matched.elem, args);

                        if (ret !== undefined) {
                            event.result = ret;
                            if (ret === false) {
                                event.preventDefault();
                                event.stopPropagation();
                            }
                        }
                    }
                }
            }

            // Call the postDispatch hook for the mapped type
            if (special.postDispatch) {
                special.postDispatch.call(this, event);
            }

            return event.result;
        },

        // Includes some event props shared by KeyEvent and MouseEvent
        // *** attrChange attrName relatedNode srcElement  are not normalized, non-W3C, deprecated, will be removed in 1.8 ***
        props: "attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

        fixHooks: {},

        keyHooks: {
            props: "char charCode key keyCode".split(" "),
            filter: function(event, original) {

                // Add which for key events
                if (event.which == null) {
                    event.which = original.charCode != null ? original.charCode : original.keyCode;
                }

                return event;
            }
        },

        mouseHooks: {
            props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
            filter: function(event, original) {
                var eventDoc, doc, body,
                    button = original.button,
                    fromElement = original.fromElement;

                // Calculate pageX/Y if missing and clientX/Y available
                if (event.pageX == null && original.clientX != null) {
                    eventDoc = event.target.ownerDocument || document;
                    doc = eventDoc.documentElement;
                    body = eventDoc.body;

                    event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
                    event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
                }

                // Add relatedTarget, if necessary
                if (!event.relatedTarget && fromElement) {
                    event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
                }

                // Add which for click: 1 === left; 2 === middle; 3 === right
                // Note: button is not normalized, so don't use it
                if (!event.which && button !== undefined) {
                    event.which = (button & 1 ? 1 : (button & 2 ? 3 : (button & 4 ? 2 : 0)));
                }

                return event;
            }
        },

        fix: function(event) {
            if (event[jQuery.expando]) {
                return event;
            }

            // Create a writable copy of the event object and normalize some properties
            var i, prop,
                originalEvent = event,
                fixHook = jQuery.event.fixHooks[event.type] || {},
                copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;

            event = jQuery.Event(originalEvent);

            for (i = copy.length; i;) {
                prop = copy[--i];
                event[prop] = originalEvent[prop];
            }

            // Fix target property, if necessary (#1925, IE 6/7/8 & Safari2)
            if (!event.target) {
                event.target = originalEvent.srcElement || document;
            }

            // Target should not be a text node (#504, Safari)
            if (event.target.nodeType === 3) {
                event.target = event.target.parentNode;
            }

            // For mouse/key events, metaKey==false if it's undefined (#3368, #11328; IE6/7/8)
            event.metaKey = !!event.metaKey;

            return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
        },

        special: {
            load: {
                // Prevent triggered image.load events from bubbling to window.load
                noBubble: true
            },

            focus: {
                delegateType: "focusin"
            },
            blur: {
                delegateType: "focusout"
            },

            beforeunload: {
                setup: function(data, namespaces, eventHandle) {
                    // We only want to do this special case on windows
                    if (jQuery.isWindow(this)) {
                        this.onbeforeunload = eventHandle;
                    }
                },

                teardown: function(namespaces, eventHandle) {
                    if (this.onbeforeunload === eventHandle) {
                        this.onbeforeunload = null;
                    }
                }
            }
        },

        simulate: function(type, elem, event, bubble) {
            // Piggyback on a donor event to simulate a different one.
            // Fake originalEvent to avoid donor's stopPropagation, but if the
            // simulated event prevents default then we do the same on the donor.
            var e = jQuery.extend(
                new jQuery.Event(),
                event, {
                    type: type,
                    isSimulated: true,
                    originalEvent: {}
                }
            );
            if (bubble) {
                jQuery.event.trigger(e, null, elem);
            } else {
                jQuery.event.dispatch.call(elem, e);
            }
            if (e.isDefaultPrevented()) {
                event.preventDefault();
            }
        }
    };

    // Some plugins are using, but it's undocumented/deprecated and will be removed.
    // The 1.7 special event interface should provide all the hooks needed now.
    jQuery.event.handle = jQuery.event.dispatch;

    jQuery.removeEvent = document.removeEventListener ?
        function(elem, type, handle) {
            if (elem.removeEventListener) {
                elem.removeEventListener(type, handle, false);
            }
        } :
        function(elem, type, handle) {
            var name = "on" + type;

            if (elem.detachEvent) {

                // #8545, #7054, preventing memory leaks for custom events in IE6-8
                // detachEvent needed property on element, by name of that event, to properly expose it to GC
                if (typeof elem[name] === "undefined") {
                    elem[name] = null;
                }

                elem.detachEvent(name, handle);
            }
        };

    jQuery.Event = function(src, props) {
        // Allow instantiation without the 'new' keyword
        if (!(this instanceof jQuery.Event)) {
            return new jQuery.Event(src, props);
        }

        // Event object
        if (src && src.type) {
            this.originalEvent = src;
            this.type = src.type;

            // Events bubbling up the document may have been marked as prevented
            // by a handler lower down the tree; reflect the correct value.
            this.isDefaultPrevented = (src.defaultPrevented || src.returnValue === false ||
                src.getPreventDefault && src.getPreventDefault()) ? returnTrue : returnFalse;

            // Event type
        } else {
            this.type = src;
        }

        // Put explicitly provided properties onto the event object
        if (props) {
            jQuery.extend(this, props);
        }

        // Create a timestamp if incoming event doesn't have one
        this.timeStamp = src && src.timeStamp || jQuery.now();

        // Mark it as fixed
        this[jQuery.expando] = true;
    };

    function returnFalse() {
        return false;
    }

    function returnTrue() {
        return true;
    }

    // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
    // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
    jQuery.Event.prototype = {
        preventDefault: function() {
            this.isDefaultPrevented = returnTrue;

            var e = this.originalEvent;
            if (!e) {
                return;
            }

            // if preventDefault exists run it on the original event
            if (e.preventDefault) {
                e.preventDefault();

                // otherwise set the returnValue property of the original event to false (IE)
            } else {
                e.returnValue = false;
            }
        },
        stopPropagation: function() {
            this.isPropagationStopped = returnTrue;

            var e = this.originalEvent;
            if (!e) {
                return;
            }
            // if stopPropagation exists run it on the original event
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            // otherwise set the cancelBubble property of the original event to true (IE)
            e.cancelBubble = true;
        },
        stopImmediatePropagation: function() {
            this.isImmediatePropagationStopped = returnTrue;
            this.stopPropagation();
        },
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse
    };

    // Create mouseenter/leave events using mouseover/out and event-time checks
    jQuery.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout"
    }, function(orig, fix) {
        jQuery.event.special[orig] = {
            delegateType: fix,
            bindType: fix,

            handle: function(event) {
                var ret,
                    target = this,
                    related = event.relatedTarget,
                    handleObj = event.handleObj,
                    selector = handleObj.selector;

                // For mousenter/leave call the handler if related is outside the target.
                // NB: No relatedTarget if the mouse left/entered the browser window
                if (!related || (related !== target && !jQuery.contains(target, related))) {
                    event.type = handleObj.origType;
                    ret = handleObj.handler.apply(this, arguments);
                    event.type = fix;
                }
                return ret;
            }
        };
    });

    // IE submit delegation
    if (!jQuery.support.submitBubbles) {

        jQuery.event.special.submit = {
            setup: function() {
                // Only need this for delegated form submit events
                if (jQuery.nodeName(this, "form")) {
                    return false;
                }

                // Lazy-add a submit handler when a descendant form may potentially be submitted
                jQuery.event.add(this, "click._submit keypress._submit", function(e) {
                    // Node name check avoids a VML-related crash in IE (#9807)
                    var elem = e.target,
                        form = jQuery.nodeName(elem, "input") || jQuery.nodeName(elem, "button") ? elem.form : undefined;
                    if (form && !jQuery._data(form, "_submit_attached")) {
                        jQuery.event.add(form, "submit._submit", function(event) {
                            event._submit_bubble = true;
                        });
                        jQuery._data(form, "_submit_attached", true);
                    }
                });
                // return undefined since we don't need an event listener
            },

            postDispatch: function(event) {
                // If form was submitted by the user, bubble the event up the tree
                if (event._submit_bubble) {
                    delete event._submit_bubble;
                    if (this.parentNode && !event.isTrigger) {
                        jQuery.event.simulate("submit", this.parentNode, event, true);
                    }
                }
            },

            teardown: function() {
                // Only need this for delegated form submit events
                if (jQuery.nodeName(this, "form")) {
                    return false;
                }

                // Remove delegated handlers; cleanData eventually reaps submit handlers attached above
                jQuery.event.remove(this, "._submit");
            }
        };
    }

    // IE change delegation and checkbox/radio fix
    if (!jQuery.support.changeBubbles) {

        jQuery.event.special.change = {

            setup: function() {

                if (rformElems.test(this.nodeName)) {
                    // IE doesn't fire change on a check/radio until blur; trigger it on click
                    // after a propertychange. Eat the blur-change in special.change.handle.
                    // This still fires onchange a second time for check/radio after blur.
                    if (this.type === "checkbox" || this.type === "radio") {
                        jQuery.event.add(this, "propertychange._change", function(event) {
                            if (event.originalEvent.propertyName === "checked") {
                                this._just_changed = true;
                            }
                        });
                        jQuery.event.add(this, "click._change", function(event) {
                            if (this._just_changed && !event.isTrigger) {
                                this._just_changed = false;
                            }
                            // Allow triggered, simulated change events (#11500)
                            jQuery.event.simulate("change", this, event, true);
                        });
                    }
                    return false;
                }
                // Delegated event; lazy-add a change handler on descendant inputs
                jQuery.event.add(this, "beforeactivate._change", function(e) {
                    var elem = e.target;

                    if (rformElems.test(elem.nodeName) && !jQuery._data(elem, "_change_attached")) {
                        jQuery.event.add(elem, "change._change", function(event) {
                            if (this.parentNode && !event.isSimulated && !event.isTrigger) {
                                jQuery.event.simulate("change", this.parentNode, event, true);
                            }
                        });
                        jQuery._data(elem, "_change_attached", true);
                    }
                });
            },

            handle: function(event) {
                var elem = event.target;

                // Swallow native change events from checkbox/radio, we already triggered them above
                if (this !== elem || event.isSimulated || event.isTrigger || (elem.type !== "radio" && elem.type !== "checkbox")) {
                    return event.handleObj.handler.apply(this, arguments);
                }
            },

            teardown: function() {
                jQuery.event.remove(this, "._change");

                return !rformElems.test(this.nodeName);
            }
        };
    }

    // Create "bubbling" focus and blur events
    if (!jQuery.support.focusinBubbles) {
        jQuery.each({ focus: "focusin", blur: "focusout" }, function(orig, fix) {

            // Attach a single capturing handler while someone wants focusin/focusout
            var attaches = 0,
                handler = function(event) {
                    jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true);
                };

            jQuery.event.special[fix] = {
                setup: function() {
                    if (attaches++ === 0) {
                        document.addEventListener(orig, handler, true);
                    }
                },
                teardown: function() {
                    if (--attaches === 0) {
                        document.removeEventListener(orig, handler, true);
                    }
                }
            };
        });
    }

    jQuery.fn.extend({

        on: function(types, selector, data, fn, /*INTERNAL*/ one) {
            var origFn, type;

            // Types can be a map of types/handlers
            if (typeof types === "object") {
                // ( types-Object, selector, data )
                if (typeof selector !== "string") { // && selector != null
                    // ( types-Object, data )
                    data = data || selector;
                    selector = undefined;
                }
                for (type in types) {
                    this.on(type, selector, data, types[type], one);
                }
                return this;
            }

            if (data == null && fn == null) {
                // ( types, fn )
                fn = selector;
                data = selector = undefined;
            } else if (fn == null) {
                if (typeof selector === "string") {
                    // ( types, selector, fn )
                    fn = data;
                    data = undefined;
                } else {
                    // ( types, data, fn )
                    fn = data;
                    data = selector;
                    selector = undefined;
                }
            }
            if (fn === false) {
                fn = returnFalse;
            } else if (!fn) {
                return this;
            }

            if (one === 1) {
                origFn = fn;
                fn = function(event) {
                    // Can use an empty set, since event contains the info
                    jQuery().off(event);
                    return origFn.apply(this, arguments);
                };
                // Use same guid so caller can remove using origFn
                fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
            }
            return this.each(function() {
                jQuery.event.add(this, types, fn, data, selector);
            });
        },
        one: function(types, selector, data, fn) {
            return this.on(types, selector, data, fn, 1);
        },
        off: function(types, selector, fn) {
            var handleObj, type;
            if (types && types.preventDefault && types.handleObj) {
                // ( event )  dispatched jQuery.Event
                handleObj = types.handleObj;
                jQuery(types.delegateTarget).off(
                    handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
                    handleObj.selector,
                    handleObj.handler
                );
                return this;
            }
            if (typeof types === "object") {
                // ( types-object [, selector] )
                for (type in types) {
                    this.off(type, selector, types[type]);
                }
                return this;
            }
            if (selector === false || typeof selector === "function") {
                // ( types [, fn] )
                fn = selector;
                selector = undefined;
            }
            if (fn === false) {
                fn = returnFalse;
            }
            return this.each(function() {
                jQuery.event.remove(this, types, fn, selector);
            });
        },

        bind: function(types, data, fn) {
            return this.on(types, null, data, fn);
        },
        unbind: function(types, fn) {
            return this.off(types, null, fn);
        },

        live: function(types, data, fn) {
            jQuery(this.context).on(types, this.selector, data, fn);
            return this;
        },
        die: function(types, fn) {
            jQuery(this.context).off(types, this.selector || "**", fn);
            return this;
        },

        delegate: function(selector, types, data, fn) {
            return this.on(types, selector, data, fn);
        },
        undelegate: function(selector, types, fn) {
            // ( namespace ) or ( selector, types [, fn] )
            return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
        },

        trigger: function(type, data) {
            return this.each(function() {
                jQuery.event.trigger(type, data, this);
            });
        },
        triggerHandler: function(type, data) {
            if (this[0]) {
                return jQuery.event.trigger(type, data, this[0], true);
            }
        },

        toggle: function(fn) {
            // Save reference to arguments for access in closure
            var args = arguments,
                guid = fn.guid || jQuery.guid++,
                i = 0,
                toggler = function(event) {
                    // Figure out which function to execute
                    var lastToggle = (jQuery._data(this, "lastToggle" + fn.guid) || 0) % i;
                    jQuery._data(this, "lastToggle" + fn.guid, lastToggle + 1);

                    // Make sure that clicks stop
                    event.preventDefault();

                    // and execute the function
                    return args[lastToggle].apply(this, arguments) || false;
                };

            // link all the functions, so any of them can unbind this click handler
            toggler.guid = guid;
            while (i < args.length) {
                args[i++].guid = guid;
            }

            return this.click(toggler);
        },

        hover: function(fnOver, fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
        }
    });

    jQuery.each(("blur focus focusin focusout load resize scroll unload click dblclick " +
        "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
        "change select submit keydown keypress keyup error contextmenu").split(" "), function(i, name) {

        // Handle event binding
        jQuery.fn[name] = function(data, fn) {
            if (fn == null) {
                fn = data;
                data = null;
            }

            return arguments.length > 0 ?
                this.on(name, null, data, fn) :
                this.trigger(name);
        };

        if (rkeyEvent.test(name)) {
            jQuery.event.fixHooks[name] = jQuery.event.keyHooks;
        }

        if (rmouseEvent.test(name)) {
            jQuery.event.fixHooks[name] = jQuery.event.mouseHooks;
        }
    });
    /*!
     * Sizzle CSS Selector Engine
     * Copyright 2012 jQuery Foundation and other contributors
     * Released under the MIT license
     * http://sizzlejs.com/
     */
    (function(window, undefined) {

        var cachedruns,
            assertGetIdNotName,
            Expr,
            getText,
            isXML,
            contains,
            compile,
            sortOrder,
            hasDuplicate,
            outermostContext,

            baseHasDuplicate = true,
            strundefined = "undefined",

            expando = ("sizcache" + Math.random()).replace(".", ""),

            Token = String,
            document = window.document,
            docElem = document.documentElement,
            dirruns = 0,
            done = 0,
            pop = [].pop,
            push = [].push,
            slice = [].slice,
            // Use a stripped-down indexOf if a native one is unavailable
            indexOf = [].indexOf || function(elem) {
                var i = 0,
                    len = this.length;
                for (; i < len; i++) {
                    if (this[i] === elem) {
                        return i;
                    }
                }
                return -1;
            },

            // Augment a function for special use by Sizzle
            markFunction = function(fn, value) {
                fn[expando] = value == null || value;
                return fn;
            },

            createCache = function() {
                var cache = {},
                    keys = [];

                return markFunction(function(key, value) {
                    // Only keep the most recent entries
                    if (keys.push(key) > Expr.cacheLength) {
                        delete cache[keys.shift()];
                    }

                    // Retrieve with (key + " ") to avoid collision with native Object.prototype properties (see Issue #157)
                    return (cache[key + " "] = value);
                }, cache);
            },

            classCache = createCache(),
            tokenCache = createCache(),
            compilerCache = createCache(),

            // Regex

            // Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
            whitespace = "[\\x20\\t\\r\\n\\f]",
            // http://www.w3.org/TR/css3-syntax/#characters
            characterEncoding = "(?:\\\\.|[-\\w]|[^\\x00-\\xa0])+",

            // Loosely modeled on CSS identifier characters
            // An unquoted value should be a CSS identifier (http://www.w3.org/TR/css3-selectors/#attribute-selectors)
            // Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
            identifier = characterEncoding.replace("w", "w#"),

            // Acceptable operators http://www.w3.org/TR/selectors/#attribute-selectors
            operators = "([*^$|!~]?=)",
            attributes = "\\[" + whitespace + "*(" + characterEncoding + ")" + whitespace +
            "*(?:" + operators + whitespace + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + identifier + ")|)|)" + whitespace + "*\\]",

            // Prefer arguments not in parens/brackets,
            //   then attribute selectors and non-pseudos (denoted by :),
            //   then anything else
            // These preferences are here to reduce the number of selectors
            //   needing tokenize in the PSEUDO preFilter
            pseudos = ":(" + characterEncoding + ")(?:\\((?:(['\"])((?:\\\\.|[^\\\\])*?)\\2|([^()[\\]]*|(?:(?:" + attributes + ")|[^:]|\\\\.)*|.*))\\)|)",

            // For matchExpr.POS and matchExpr.needsContext
            pos = ":(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace +
            "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)",

            // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
            rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),

            rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
            rcombinators = new RegExp("^" + whitespace + "*([\\x20\\t\\r\\n\\f>+~])" + whitespace + "*"),
            rpseudo = new RegExp(pseudos),

            // Easily-parseable/retrievable ID or TAG or CLASS selectors
            rquickExpr = /^(?:#([\w\-]+)|(\w+)|\.([\w\-]+))$/,

            rnot = /^:not/,
            rsibling = /[\x20\t\r\n\f]*[+~]/,
            rendsWithNot = /:not\($/,

            rheader = /h\d/i,
            rinputs = /input|select|textarea|button/i,

            rbackslash = /\\(?!\\)/g,

            matchExpr = {
                "ID": new RegExp("^#(" + characterEncoding + ")"),
                "CLASS": new RegExp("^\\.(" + characterEncoding + ")"),
                "NAME": new RegExp("^\\[name=['\"]?(" + characterEncoding + ")['\"]?\\]"),
                "TAG": new RegExp("^(" + characterEncoding.replace("w", "w*") + ")"),
                "ATTR": new RegExp("^" + attributes),
                "PSEUDO": new RegExp("^" + pseudos),
                "POS": new RegExp(pos, "i"),
                "CHILD": new RegExp("^:(only|nth|first|last)-child(?:\\(" + whitespace +
                    "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
                    "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
                // For use in libraries implementing .is()
                "needsContext": new RegExp("^" + whitespace + "*[>+~]|" + pos, "i")
            },

            // Support

            // Used for testing something on an element
            assert = function(fn) {
                var div = document.createElement("div");

                try {
                    return fn(div);
                } catch (e) {
                    return false;
                } finally {
                    // release memory in IE
                    div = null;
                }
            },

            // Check if getElementsByTagName("*") returns only elements
            assertTagNameNoComments = assert(function(div) {
                div.appendChild(document.createComment(""));
                return !div.getElementsByTagName("*").length;
            }),

            // Check if getAttribute returns normalized href attributes
            assertHrefNotNormalized = assert(function(div) {
                div.innerHTML = "<a href='#'></a>";
                return div.firstChild && typeof div.firstChild.getAttribute !== strundefined &&
                    div.firstChild.getAttribute("href") === "#";
            }),

            // Check if attributes should be retrieved by attribute nodes
            assertAttributes = assert(function(div) {
                div.innerHTML = "<select></select>";
                var type = typeof div.lastChild.getAttribute("multiple");
                // IE8 returns a string for some attributes even when not present
                return type !== "boolean" && type !== "string";
            }),

            // Check if getElementsByClassName can be trusted
            assertUsableClassName = assert(function(div) {
                // Opera can't find a second classname (in 9.6)
                div.innerHTML = "<div class='hidden e'></div><div class='hidden'></div>";
                if (!div.getElementsByClassName || !div.getElementsByClassName("e").length) {
                    return false;
                }

                // Safari 3.2 caches class attributes and doesn't catch changes
                div.lastChild.className = "e";
                return div.getElementsByClassName("e").length === 2;
            }),

            // Check if getElementById returns elements by name
            // Check if getElementsByName privileges form controls or returns elements by ID
            assertUsableName = assert(function(div) {
                // Inject content
                div.id = expando + 0;
                div.innerHTML = "<a name='" + expando + "'></a><div name='" + expando + "'></div>";
                docElem.insertBefore(div, docElem.firstChild);

                // Test
                var pass = document.getElementsByName &&
                    // buggy browsers will return fewer than the correct 2
                    document.getElementsByName(expando).length === 2 +
                    // buggy browsers will return more than the correct 0
                    document.getElementsByName(expando + 0).length;
                assertGetIdNotName = !document.getElementById(expando);

                // Cleanup
                docElem.removeChild(div);

                return pass;
            });

        // If slice is not available, provide a backup
        try {
            slice.call(docElem.childNodes, 0)[0].nodeType;
        } catch (e) {
            slice = function(i) {
                var elem,
                    results = [];
                for (;
                    (elem = this[i]); i++) {
                    results.push(elem);
                }
                return results;
            };
        }

        function Sizzle(selector, context, results, seed) {
            results = results || [];
            context = context || document;
            var match, elem, xml, m,
                nodeType = context.nodeType;

            if (!selector || typeof selector !== "string") {
                return results;
            }

            if (nodeType !== 1 && nodeType !== 9) {
                return [];
            }

            xml = isXML(context);

            if (!xml && !seed) {
                if ((match = rquickExpr.exec(selector))) {
                    // Speed-up: Sizzle("#ID")
                    if ((m = match[1])) {
                        if (nodeType === 9) {
                            elem = context.getElementById(m);
                            // Check parentNode to catch when Blackberry 4.6 returns
                            // nodes that are no longer in the document #6963
                            if (elem && elem.parentNode) {
                                // Handle the case where IE, Opera, and Webkit return items
                                // by name instead of ID
                                if (elem.id === m) {
                                    results.push(elem);
                                    return results;
                                }
                            } else {
                                return results;
                            }
                        } else {
                            // Context is not a document
                            if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) &&
                                contains(context, elem) && elem.id === m) {
                                results.push(elem);
                                return results;
                            }
                        }

                        // Speed-up: Sizzle("TAG")
                    } else if (match[2]) {
                        push.apply(results, slice.call(context.getElementsByTagName(selector), 0));
                        return results;

                        // Speed-up: Sizzle(".CLASS")
                    } else if ((m = match[3]) && assertUsableClassName && context.getElementsByClassName) {
                        push.apply(results, slice.call(context.getElementsByClassName(m), 0));
                        return results;
                    }
                }
            }

            // All others
            return select(selector.replace(rtrim, "$1"), context, results, seed, xml);
        }

        Sizzle.matches = function(expr, elements) {
            return Sizzle(expr, null, null, elements);
        };

        Sizzle.matchesSelector = function(elem, expr) {
            return Sizzle(expr, null, null, [elem]).length > 0;
        };

        // Returns a function to use in pseudos for input types
        function createInputPseudo(type) {
            return function(elem) {
                var name = elem.nodeName.toLowerCase();
                return name === "input" && elem.type === type;
            };
        }

        // Returns a function to use in pseudos for buttons
        function createButtonPseudo(type) {
            return function(elem) {
                var name = elem.nodeName.toLowerCase();
                return (name === "input" || name === "button") && elem.type === type;
            };
        }

        // Returns a function to use in pseudos for positionals
        function createPositionalPseudo(fn) {
            return markFunction(function(argument) {
                argument = +argument;
                return markFunction(function(seed, matches) {
                    var j,
                        matchIndexes = fn([], seed.length, argument),
                        i = matchIndexes.length;

                    // Match elements found at the specified indexes
                    while (i--) {
                        if (seed[(j = matchIndexes[i])]) {
                            seed[j] = !(matches[j] = seed[j]);
                        }
                    }
                });
            });
        }

        /**
         * Utility function for retrieving the text value of an array of DOM nodes
         * @param {Array|Element} elem
         */
        getText = Sizzle.getText = function(elem) {
            var node,
                ret = "",
                i = 0,
                nodeType = elem.nodeType;

            if (nodeType) {
                if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
                    // Use textContent for elements
                    // innerText usage removed for consistency of new lines (see #11153)
                    if (typeof elem.textContent === "string") {
                        return elem.textContent;
                    } else {
                        // Traverse its children
                        for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                            ret += getText(elem);
                        }
                    }
                } else if (nodeType === 3 || nodeType === 4) {
                    return elem.nodeValue;
                }
                // Do not include comment or processing instruction nodes
            } else {

                // If no nodeType, this is expected to be an array
                for (;
                    (node = elem[i]); i++) {
                    // Do not traverse comment nodes
                    ret += getText(node);
                }
            }
            return ret;
        };

        isXML = Sizzle.isXML = function(elem) {
            // documentElement is verified for cases where it doesn't yet exist
            // (such as loading iframes in IE - #4833)
            var documentElement = elem && (elem.ownerDocument || elem).documentElement;
            return documentElement ? documentElement.nodeName !== "HTML" : false;
        };

        // Element contains another
        contains = Sizzle.contains = docElem.contains ?
            function(a, b) {
                var adown = a.nodeType === 9 ? a.documentElement : a,
                    bup = b && b.parentNode;
                return a === bup || !!(bup && bup.nodeType === 1 && adown.contains && adown.contains(bup));
            } :
            docElem.compareDocumentPosition ?
            function(a, b) {
                return b && !!(a.compareDocumentPosition(b) & 16);
            } :
            function(a, b) {
                while ((b = b.parentNode)) {
                    if (b === a) {
                        return true;
                    }
                }
                return false;
            };

        Sizzle.attr = function(elem, name) {
            var val,
                xml = isXML(elem);

            if (!xml) {
                name = name.toLowerCase();
            }
            if ((val = Expr.attrHandle[name])) {
                return val(elem);
            }
            if (xml || assertAttributes) {
                return elem.getAttribute(name);
            }
            val = elem.getAttributeNode(name);
            return val ?
                typeof elem[name] === "boolean" ?
                elem[name] ? name : null :
                val.specified ? val.value : null :
                null;
        };

        Expr = Sizzle.selectors = {

            // Can be adjusted by the user
            cacheLength: 50,

            createPseudo: markFunction,

            match: matchExpr,

            // IE6/7 return a modified href
            attrHandle: assertHrefNotNormalized ? {} : {
                "href": function(elem) {
                    return elem.getAttribute("href", 2);
                },
                "type": function(elem) {
                    return elem.getAttribute("type");
                }
            },

            find: {
                "ID": assertGetIdNotName ?
                    function(id, context, xml) {
                        if (typeof context.getElementById !== strundefined && !xml) {
                            var m = context.getElementById(id);
                            // Check parentNode to catch when Blackberry 4.6 returns
                            // nodes that are no longer in the document #6963
                            return m && m.parentNode ? [m] : [];
                        }
                    } : function(id, context, xml) {
                        if (typeof context.getElementById !== strundefined && !xml) {
                            var m = context.getElementById(id);

                            return m ?
                                m.id === id || typeof m.getAttributeNode !== strundefined && m.getAttributeNode("id").value === id ? [m] :
                                undefined : [];
                        }
                    },

                "TAG": assertTagNameNoComments ?
                    function(tag, context) {
                        if (typeof context.getElementsByTagName !== strundefined) {
                            return context.getElementsByTagName(tag);
                        }
                    } : function(tag, context) {
                        var results = context.getElementsByTagName(tag);

                        // Filter out possible comments
                        if (tag === "*") {
                            var elem,
                                tmp = [],
                                i = 0;

                            for (;
                                (elem = results[i]); i++) {
                                if (elem.nodeType === 1) {
                                    tmp.push(elem);
                                }
                            }

                            return tmp;
                        }
                        return results;
                    },

                "NAME": assertUsableName && function(tag, context) {
                    if (typeof context.getElementsByName !== strundefined) {
                        return context.getElementsByName(name);
                    }
                },

                "CLASS": assertUsableClassName && function(className, context, xml) {
                    if (typeof context.getElementsByClassName !== strundefined && !xml) {
                        return context.getElementsByClassName(className);
                    }
                }
            },

            relative: {
                ">": { dir: "parentNode", first: true },
                " ": { dir: "parentNode" },
                "+": { dir: "previousSibling", first: true },
                "~": { dir: "previousSibling" }
            },

            preFilter: {
                "ATTR": function(match) {
                    match[1] = match[1].replace(rbackslash, "");

                    // Move the given value to match[3] whether quoted or unquoted
                    match[3] = (match[4] || match[5] || "").replace(rbackslash, "");

                    if (match[2] === "~=") {
                        match[3] = " " + match[3] + " ";
                    }

                    return match.slice(0, 4);
                },

                "CHILD": function(match) {
                    /* matches from matchExpr["CHILD"]
                        1 type (only|nth|...)
                        2 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
                        3 xn-component of xn+y argument ([+-]?\d*n|)
                        4 sign of xn-component
                        5 x of xn-component
                        6 sign of y-component
                        7 y of y-component
                    */
                    match[1] = match[1].toLowerCase();

                    if (match[1] === "nth") {
                        // nth-child requires argument
                        if (!match[2]) {
                            Sizzle.error(match[0]);
                        }

                        // numeric x and y parameters for Expr.filter.CHILD
                        // remember that false/true cast respectively to 0/1
                        match[3] = +(match[3] ? match[4] + (match[5] || 1) : 2 * (match[2] === "even" || match[2] === "odd"));
                        match[4] = +((match[6] + match[7]) || match[2] === "odd");

                        // other types prohibit arguments
                    } else if (match[2]) {
                        Sizzle.error(match[0]);
                    }

                    return match;
                },

                "PSEUDO": function(match) {
                    var unquoted, excess;
                    if (matchExpr["CHILD"].test(match[0])) {
                        return null;
                    }

                    if (match[3]) {
                        match[2] = match[3];
                    } else if ((unquoted = match[4])) {
                        // Only check arguments that contain a pseudo
                        if (rpseudo.test(unquoted) &&
                            // Get excess from tokenize (recursively)
                            (excess = tokenize(unquoted, true)) &&
                            // advance to the next closing parenthesis
                            (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {

                            // excess is a negative index
                            unquoted = unquoted.slice(0, excess);
                            match[0] = match[0].slice(0, excess);
                        }
                        match[2] = unquoted;
                    }

                    // Return only captures needed by the pseudo filter method (type and argument)
                    return match.slice(0, 3);
                }
            },

            filter: {
                "ID": assertGetIdNotName ?
                    function(id) {
                        id = id.replace(rbackslash, "");
                        return function(elem) {
                            return elem.getAttribute("id") === id;
                        };
                    } : function(id) {
                        id = id.replace(rbackslash, "");
                        return function(elem) {
                            var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");
                            return node && node.value === id;
                        };
                    },

                "TAG": function(nodeName) {
                    if (nodeName === "*") {
                        return function() { return true; };
                    }
                    nodeName = nodeName.replace(rbackslash, "").toLowerCase();

                    return function(elem) {
                        return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                    };
                },

                "CLASS": function(className) {
                    var pattern = classCache[expando][className + " "];

                    return pattern ||
                        (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) &&
                        classCache(className, function(elem) {
                            return pattern.test(elem.className || (typeof elem.getAttribute !== strundefined && elem.getAttribute("class")) || "");
                        });
                },

                "ATTR": function(name, operator, check) {
                    return function(elem, context) {
                        var result = Sizzle.attr(elem, name);

                        if (result == null) {
                            return operator === "!=";
                        }
                        if (!operator) {
                            return true;
                        }

                        result += "";

                        return operator === "=" ? result === check :
                            operator === "!=" ? result !== check :
                            operator === "^=" ? check && result.indexOf(check) === 0 :
                            operator === "*=" ? check && result.indexOf(check) > -1 :
                            operator === "$=" ? check && result.substr(result.length - check.length) === check :
                            operator === "~=" ? (" " + result + " ").indexOf(check) > -1 :
                            operator === "|=" ? result === check || result.substr(0, check.length + 1) === check + "-" :
                            false;
                    };
                },

                "CHILD": function(type, argument, first, last) {

                    if (type === "nth") {
                        return function(elem) {
                            var node, diff,
                                parent = elem.parentNode;

                            if (first === 1 && last === 0) {
                                return true;
                            }

                            if (parent) {
                                diff = 0;
                                for (node = parent.firstChild; node; node = node.nextSibling) {
                                    if (node.nodeType === 1) {
                                        diff++;
                                        if (elem === node) {
                                            break;
                                        }
                                    }
                                }
                            }

                            // Incorporate the offset (or cast to NaN), then check against cycle size
                            diff -= last;
                            return diff === first || (diff % first === 0 && diff / first >= 0);
                        };
                    }

                    return function(elem) {
                        var node = elem;

                        switch (type) {
                            case "only":
                            case "first":
                                while ((node = node.previousSibling)) {
                                    if (node.nodeType === 1) {
                                        return false;
                                    }
                                }

                                if (type === "first") {
                                    return true;
                                }

                                node = elem;

                                /* falls through */
                            case "last":
                                while ((node = node.nextSibling)) {
                                    if (node.nodeType === 1) {
                                        return false;
                                    }
                                }

                                return true;
                        }
                    };
                },

                "PSEUDO": function(pseudo, argument) {
                    // pseudo-class names are case-insensitive
                    // http://www.w3.org/TR/selectors/#pseudo-classes
                    // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
                    // Remember that setFilters inherits from pseudos
                    var args,
                        fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] ||
                        Sizzle.error("unsupported pseudo: " + pseudo);

                    // The user may use createPseudo to indicate that
                    // arguments are needed to create the filter function
                    // just as Sizzle does
                    if (fn[expando]) {
                        return fn(argument);
                    }

                    // But maintain support for old signatures
                    if (fn.length > 1) {
                        args = [pseudo, pseudo, "", argument];
                        return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ?
                            markFunction(function(seed, matches) {
                                var idx,
                                    matched = fn(seed, argument),
                                    i = matched.length;
                                while (i--) {
                                    idx = indexOf.call(seed, matched[i]);
                                    seed[idx] = !(matches[idx] = matched[i]);
                                }
                            }) :
                            function(elem) {
                                return fn(elem, 0, args);
                            };
                    }

                    return fn;
                }
            },

            pseudos: {
                "not": markFunction(function(selector) {
                    // Trim the selector passed to compile
                    // to avoid treating leading and trailing
                    // spaces as combinators
                    var input = [],
                        results = [],
                        matcher = compile(selector.replace(rtrim, "$1"));

                    return matcher[expando] ?
                        markFunction(function(seed, matches, context, xml) {
                            var elem,
                                unmatched = matcher(seed, null, xml, []),
                                i = seed.length;

                            // Match elements unmatched by `matcher`
                            while (i--) {
                                if ((elem = unmatched[i])) {
                                    seed[i] = !(matches[i] = elem);
                                }
                            }
                        }) :
                        function(elem, context, xml) {
                            input[0] = elem;
                            matcher(input, null, xml, results);
                            return !results.pop();
                        };
                }),

                "has": markFunction(function(selector) {
                    return function(elem) {
                        return Sizzle(selector, elem).length > 0;
                    };
                }),

                "contains": markFunction(function(text) {
                    return function(elem) {
                        return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
                    };
                }),

                "enabled": function(elem) {
                    return elem.disabled === false;
                },

                "disabled": function(elem) {
                    return elem.disabled === true;
                },

                "checked": function(elem) {
                    // In CSS3, :checked should return both checked and selected elements
                    // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                    var nodeName = elem.nodeName.toLowerCase();
                    return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
                },

                "selected": function(elem) {
                    // Accessing this property makes selected-by-default
                    // options in Safari work properly
                    if (elem.parentNode) {
                        elem.parentNode.selectedIndex;
                    }

                    return elem.selected === true;
                },

                "parent": function(elem) {
                    return !Expr.pseudos["empty"](elem);
                },

                "empty": function(elem) {
                    // http://www.w3.org/TR/selectors/#empty-pseudo
                    // :empty is only affected by element nodes and content nodes(including text(3), cdata(4)),
                    //   not comment, processing instructions, or others
                    // Thanks to Diego Perini for the nodeName shortcut
                    //   Greater than "@" means alpha characters (specifically not starting with "#" or "?")
                    var nodeType;
                    elem = elem.firstChild;
                    while (elem) {
                        if (elem.nodeName > "@" || (nodeType = elem.nodeType) === 3 || nodeType === 4) {
                            return false;
                        }
                        elem = elem.nextSibling;
                    }
                    return true;
                },

                "header": function(elem) {
                    return rheader.test(elem.nodeName);
                },

                "text": function(elem) {
                    var type, attr;
                    // IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc)
                    // use getAttribute instead to test this case
                    return elem.nodeName.toLowerCase() === "input" &&
                        (type = elem.type) === "text" &&
                        ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === type);
                },

                // Input types
                "radio": createInputPseudo("radio"),
                "checkbox": createInputPseudo("checkbox"),
                "file": createInputPseudo("file"),
                "password": createInputPseudo("password"),
                "image": createInputPseudo("image"),

                "submit": createButtonPseudo("submit"),
                "reset": createButtonPseudo("reset"),

                "button": function(elem) {
                    var name = elem.nodeName.toLowerCase();
                    return name === "input" && elem.type === "button" || name === "button";
                },

                "input": function(elem) {
                    return rinputs.test(elem.nodeName);
                },

                "focus": function(elem) {
                    var doc = elem.ownerDocument;
                    return elem === doc.activeElement && (!doc.hasFocus || doc.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                },

                "active": function(elem) {
                    return elem === elem.ownerDocument.activeElement;
                },

                // Positional types
                "first": createPositionalPseudo(function() {
                    return [0];
                }),

                "last": createPositionalPseudo(function(matchIndexes, length) {
                    return [length - 1];
                }),

                "eq": createPositionalPseudo(function(matchIndexes, length, argument) {
                    return [argument < 0 ? argument + length : argument];
                }),

                "even": createPositionalPseudo(function(matchIndexes, length) {
                    for (var i = 0; i < length; i += 2) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),

                "odd": createPositionalPseudo(function(matchIndexes, length) {
                    for (var i = 1; i < length; i += 2) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),

                "lt": createPositionalPseudo(function(matchIndexes, length, argument) {
                    for (var i = argument < 0 ? argument + length : argument; --i >= 0;) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),

                "gt": createPositionalPseudo(function(matchIndexes, length, argument) {
                    for (var i = argument < 0 ? argument + length : argument; ++i < length;) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                })
            }
        };

        function siblingCheck(a, b, ret) {
            if (a === b) {
                return ret;
            }

            var cur = a.nextSibling;

            while (cur) {
                if (cur === b) {
                    return -1;
                }

                cur = cur.nextSibling;
            }

            return 1;
        }

        sortOrder = docElem.compareDocumentPosition ?
            function(a, b) {
                if (a === b) {
                    hasDuplicate = true;
                    return 0;
                }

                return (!a.compareDocumentPosition || !b.compareDocumentPosition ?
                    a.compareDocumentPosition :
                    a.compareDocumentPosition(b) & 4
                ) ? -1 : 1;
            } :
            function(a, b) {
                // The nodes are identical, we can exit early
                if (a === b) {
                    hasDuplicate = true;
                    return 0;

                    // Fallback to using sourceIndex (in IE) if it's available on both nodes
                } else if (a.sourceIndex && b.sourceIndex) {
                    return a.sourceIndex - b.sourceIndex;
                }

                var al, bl,
                    ap = [],
                    bp = [],
                    aup = a.parentNode,
                    bup = b.parentNode,
                    cur = aup;

                // If the nodes are siblings (or identical) we can do a quick check
                if (aup === bup) {
                    return siblingCheck(a, b);

                    // If no parents were found then the nodes are disconnected
                } else if (!aup) {
                    return -1;

                } else if (!bup) {
                    return 1;
                }

                // Otherwise they're somewhere else in the tree so we need
                // to build up a full list of the parentNodes for comparison
                while (cur) {
                    ap.unshift(cur);
                    cur = cur.parentNode;
                }

                cur = bup;

                while (cur) {
                    bp.unshift(cur);
                    cur = cur.parentNode;
                }

                al = ap.length;
                bl = bp.length;

                // Start walking down the tree looking for a discrepancy
                for (var i = 0; i < al && i < bl; i++) {
                    if (ap[i] !== bp[i]) {
                        return siblingCheck(ap[i], bp[i]);
                    }
                }

                // We ended someplace up the tree so do a sibling check
                return i === al ?
                    siblingCheck(a, bp[i], -1) :
                    siblingCheck(ap[i], b, 1);
            };

        // Always assume the presence of duplicates if sort doesn't
        // pass them to our comparison function (as in Google Chrome).
        [0, 0].sort(sortOrder);
        baseHasDuplicate = !hasDuplicate;

        // Document sorting and removing duplicates
        Sizzle.uniqueSort = function(results) {
            var elem,
                duplicates = [],
                i = 1,
                j = 0;

            hasDuplicate = baseHasDuplicate;
            results.sort(sortOrder);

            if (hasDuplicate) {
                for (;
                    (elem = results[i]); i++) {
                    if (elem === results[i - 1]) {
                        j = duplicates.push(i);
                    }
                }
                while (j--) {
                    results.splice(duplicates[j], 1);
                }
            }

            return results;
        };

        Sizzle.error = function(msg) {
            throw new Error("Syntax error, unrecognized expression: " + msg);
        };

        function tokenize(selector, parseOnly) {
            var matched, match, tokens, type,
                soFar, groups, preFilters,
                cached = tokenCache[expando][selector + " "];

            if (cached) {
                return parseOnly ? 0 : cached.slice(0);
            }

            soFar = selector;
            groups = [];
            preFilters = Expr.preFilter;

            while (soFar) {

                // Comma and first run
                if (!matched || (match = rcomma.exec(soFar))) {
                    if (match) {
                        // Don't consume trailing commas as valid
                        soFar = soFar.slice(match[0].length) || soFar;
                    }
                    groups.push(tokens = []);
                }

                matched = false;

                // Combinators
                if ((match = rcombinators.exec(soFar))) {
                    tokens.push(matched = new Token(match.shift()));
                    soFar = soFar.slice(matched.length);

                    // Cast descendant combinators to space
                    matched.type = match[0].replace(rtrim, " ");
                }

                // Filters
                for (type in Expr.filter) {
                    if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] ||
                            (match = preFilters[type](match)))) {

                        tokens.push(matched = new Token(match.shift()));
                        soFar = soFar.slice(matched.length);
                        matched.type = type;
                        matched.matches = match;
                    }
                }

                if (!matched) {
                    break;
                }
            }

            // Return the length of the invalid excess
            // if we're just parsing
            // Otherwise, throw an error or return tokens
            return parseOnly ?
                soFar.length :
                soFar ?
                Sizzle.error(selector) :
                // Cache the tokens
                tokenCache(selector, groups).slice(0);
        }

        function addCombinator(matcher, combinator, base) {
            var dir = combinator.dir,
                checkNonElements = base && combinator.dir === "parentNode",
                doneName = done++;

            return combinator.first ?
                // Check against closest ancestor/preceding element
                function(elem, context, xml) {
                    while ((elem = elem[dir])) {
                        if (checkNonElements || elem.nodeType === 1) {
                            return matcher(elem, context, xml);
                        }
                    }
                } :

                // Check against all ancestor/preceding elements
                function(elem, context, xml) {
                    // We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
                    if (!xml) {
                        var cache,
                            dirkey = dirruns + " " + doneName + " ",
                            cachedkey = dirkey + cachedruns;
                        while ((elem = elem[dir])) {
                            if (checkNonElements || elem.nodeType === 1) {
                                if ((cache = elem[expando]) === cachedkey) {
                                    return elem.sizset;
                                } else if (typeof cache === "string" && cache.indexOf(dirkey) === 0) {
                                    if (elem.sizset) {
                                        return elem;
                                    }
                                } else {
                                    elem[expando] = cachedkey;
                                    if (matcher(elem, context, xml)) {
                                        elem.sizset = true;
                                        return elem;
                                    }
                                    elem.sizset = false;
                                }
                            }
                        }
                    } else {
                        while ((elem = elem[dir])) {
                            if (checkNonElements || elem.nodeType === 1) {
                                if (matcher(elem, context, xml)) {
                                    return elem;
                                }
                            }
                        }
                    }
                };
        }

        function elementMatcher(matchers) {
            return matchers.length > 1 ?
                function(elem, context, xml) {
                    var i = matchers.length;
                    while (i--) {
                        if (!matchers[i](elem, context, xml)) {
                            return false;
                        }
                    }
                    return true;
                } :
                matchers[0];
        }

        function condense(unmatched, map, filter, context, xml) {
            var elem,
                newUnmatched = [],
                i = 0,
                len = unmatched.length,
                mapped = map != null;

            for (; i < len; i++) {
                if ((elem = unmatched[i])) {
                    if (!filter || filter(elem, context, xml)) {
                        newUnmatched.push(elem);
                        if (mapped) {
                            map.push(i);
                        }
                    }
                }
            }

            return newUnmatched;
        }

        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
            if (postFilter && !postFilter[expando]) {
                postFilter = setMatcher(postFilter);
            }
            if (postFinder && !postFinder[expando]) {
                postFinder = setMatcher(postFinder, postSelector);
            }
            return markFunction(function(seed, results, context, xml) {
                var temp, i, elem,
                    preMap = [],
                    postMap = [],
                    preexisting = results.length,

                    // Get initial elements from seed or context
                    elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),

                    // Prefilter to get matcher input, preserving a map for seed-results synchronization
                    matcherIn = preFilter && (seed || !selector) ?
                    condense(elems, preMap, preFilter, context, xml) :
                    elems,

                    matcherOut = matcher ?
                    // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
                    postFinder || (seed ? preFilter : preexisting || postFilter) ?

                    // ...intermediate processing is necessary
                    [] :

                    // ...otherwise use results directly
                    results :
                    matcherIn;

                // Find primary matches
                if (matcher) {
                    matcher(matcherIn, matcherOut, context, xml);
                }

                // Apply postFilter
                if (postFilter) {
                    temp = condense(matcherOut, postMap);
                    postFilter(temp, [], context, xml);

                    // Un-match failing elements by moving them back to matcherIn
                    i = temp.length;
                    while (i--) {
                        if ((elem = temp[i])) {
                            matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
                        }
                    }
                }

                if (seed) {
                    if (postFinder || preFilter) {
                        if (postFinder) {
                            // Get the final matcherOut by condensing this intermediate into postFinder contexts
                            temp = [];
                            i = matcherOut.length;
                            while (i--) {
                                if ((elem = matcherOut[i])) {
                                    // Restore matcherIn since elem is not yet a final match
                                    temp.push((matcherIn[i] = elem));
                                }
                            }
                            postFinder(null, (matcherOut = []), temp, xml);
                        }

                        // Move matched elements from seed to results to keep them synchronized
                        i = matcherOut.length;
                        while (i--) {
                            if ((elem = matcherOut[i]) &&
                                (temp = postFinder ? indexOf.call(seed, elem) : preMap[i]) > -1) {

                                seed[temp] = !(results[temp] = elem);
                            }
                        }
                    }

                    // Add elements to results, through postFinder if defined
                } else {
                    matcherOut = condense(
                        matcherOut === results ?
                        matcherOut.splice(preexisting, matcherOut.length) :
                        matcherOut
                    );
                    if (postFinder) {
                        postFinder(null, results, matcherOut, xml);
                    } else {
                        push.apply(results, matcherOut);
                    }
                }
            });
        }

        function matcherFromTokens(tokens) {
            var checkContext, matcher, j,
                len = tokens.length,
                leadingRelative = Expr.relative[tokens[0].type],
                implicitRelative = leadingRelative || Expr.relative[" "],
                i = leadingRelative ? 1 : 0,

                // The foundational matcher ensures that elements are reachable from top-level context(s)
                matchContext = addCombinator(function(elem) {
                    return elem === checkContext;
                }, implicitRelative, true),
                matchAnyContext = addCombinator(function(elem) {
                    return indexOf.call(checkContext, elem) > -1;
                }, implicitRelative, true),
                matchers = [function(elem, context, xml) {
                    return (!leadingRelative && (xml || context !== outermostContext)) || (
                        (checkContext = context).nodeType ?
                        matchContext(elem, context, xml) :
                        matchAnyContext(elem, context, xml));
                }];

            for (; i < len; i++) {
                if ((matcher = Expr.relative[tokens[i].type])) {
                    matchers = [addCombinator(elementMatcher(matchers), matcher)];
                } else {
                    matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);

                    // Return special upon seeing a positional matcher
                    if (matcher[expando]) {
                        // Find the next relative operator (if any) for proper handling
                        j = ++i;
                        for (; j < len; j++) {
                            if (Expr.relative[tokens[j].type]) {
                                break;
                            }
                        }
                        return setMatcher(
                            i > 1 && elementMatcher(matchers),
                            i > 1 && tokens.slice(0, i - 1).join("").replace(rtrim, "$1"),
                            matcher,
                            i < j && matcherFromTokens(tokens.slice(i, j)),
                            j < len && matcherFromTokens((tokens = tokens.slice(j))),
                            j < len && tokens.join("")
                        );
                    }
                    matchers.push(matcher);
                }
            }

            return elementMatcher(matchers);
        }

        function matcherFromGroupMatchers(elementMatchers, setMatchers) {
            var bySet = setMatchers.length > 0,
                byElement = elementMatchers.length > 0,
                superMatcher = function(seed, context, xml, results, expandContext) {
                    var elem, j, matcher,
                        setMatched = [],
                        matchedCount = 0,
                        i = "0",
                        unmatched = seed && [],
                        outermost = expandContext != null,
                        contextBackup = outermostContext,
                        // We must always have either seed elements or context
                        elems = seed || byElement && Expr.find["TAG"]("*", expandContext && context.parentNode || context),
                        // Nested matchers should use non-integer dirruns
                        dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.E);

                    if (outermost) {
                        outermostContext = context !== document && context;
                        cachedruns = superMatcher.el;
                    }

                    // Add elements passing elementMatchers directly to results
                    for (;
                        (elem = elems[i]) != null; i++) {
                        if (byElement && elem) {
                            for (j = 0;
                                (matcher = elementMatchers[j]); j++) {
                                if (matcher(elem, context, xml)) {
                                    results.push(elem);
                                    break;
                                }
                            }
                            if (outermost) {
                                dirruns = dirrunsUnique;
                                cachedruns = ++superMatcher.el;
                            }
                        }

                        // Track unmatched elements for set filters
                        if (bySet) {
                            // They will have gone through all possible matchers
                            if ((elem = !matcher && elem)) {
                                matchedCount--;
                            }

                            // Lengthen the array for every element, matched or not
                            if (seed) {
                                unmatched.push(elem);
                            }
                        }
                    }

                    // Apply set filters to unmatched elements
                    matchedCount += i;
                    if (bySet && i !== matchedCount) {
                        for (j = 0;
                            (matcher = setMatchers[j]); j++) {
                            matcher(unmatched, setMatched, context, xml);
                        }

                        if (seed) {
                            // Reintegrate element matches to eliminate the need for sorting
                            if (matchedCount > 0) {
                                while (i--) {
                                    if (!(unmatched[i] || setMatched[i])) {
                                        setMatched[i] = pop.call(results);
                                    }
                                }
                            }

                            // Discard index placeholder values to get only actual matches
                            setMatched = condense(setMatched);
                        }

                        // Add matches to results
                        push.apply(results, setMatched);

                        // Seedless set matches succeeding multiple successful matchers stipulate sorting
                        if (outermost && !seed && setMatched.length > 0 &&
                            (matchedCount + setMatchers.length) > 1) {

                            Sizzle.uniqueSort(results);
                        }
                    }

                    // Override manipulation of globals by nested matchers
                    if (outermost) {
                        dirruns = dirrunsUnique;
                        outermostContext = contextBackup;
                    }

                    return unmatched;
                };

            superMatcher.el = 0;
            return bySet ?
                markFunction(superMatcher) :
                superMatcher;
        }

        compile = Sizzle.compile = function(selector, group /* Internal Use Only */ ) {
            var i,
                setMatchers = [],
                elementMatchers = [],
                cached = compilerCache[expando][selector + " "];

            if (!cached) {
                // Generate a function of recursive functions that can be used to check each element
                if (!group) {
                    group = tokenize(selector);
                }
                i = group.length;
                while (i--) {
                    cached = matcherFromTokens(group[i]);
                    if (cached[expando]) {
                        setMatchers.push(cached);
                    } else {
                        elementMatchers.push(cached);
                    }
                }

                // Cache the compiled function
                cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
            }
            return cached;
        };

        function multipleContexts(selector, contexts, results) {
            var i = 0,
                len = contexts.length;
            for (; i < len; i++) {
                Sizzle(selector, contexts[i], results);
            }
            return results;
        }

        function select(selector, context, results, seed, xml) {
            var i, tokens, token, type, find,
                match = tokenize(selector),
                j = match.length;

            if (!seed) {
                // Try to minimize operations if there is only one group
                if (match.length === 1) {

                    // Take a shortcut and set the context if the root selector is an ID
                    tokens = match[0] = match[0].slice(0);
                    if (tokens.length > 2 && (token = tokens[0]).type === "ID" &&
                        context.nodeType === 9 && !xml &&
                        Expr.relative[tokens[1].type]) {

                        context = Expr.find["ID"](token.matches[0].replace(rbackslash, ""), context, xml)[0];
                        if (!context) {
                            return results;
                        }

                        selector = selector.slice(tokens.shift().length);
                    }

                    // Fetch a seed set for right-to-left matching
                    for (i = matchExpr["POS"].test(selector) ? -1 : tokens.length - 1; i >= 0; i--) {
                        token = tokens[i];

                        // Abort if we hit a combinator
                        if (Expr.relative[(type = token.type)]) {
                            break;
                        }
                        if ((find = Expr.find[type])) {
                            // Search, expanding context for leading sibling combinators
                            if ((seed = find(
                                    token.matches[0].replace(rbackslash, ""),
                                    rsibling.test(tokens[0].type) && context.parentNode || context,
                                    xml
                                ))) {

                                // If seed is empty or no tokens remain, we can return early
                                tokens.splice(i, 1);
                                selector = seed.length && tokens.join("");
                                if (!selector) {
                                    push.apply(results, slice.call(seed, 0));
                                    return results;
                                }

                                break;
                            }
                        }
                    }
                }
            }

            // Compile and execute a filtering function
            // Provide `match` to avoid retokenization if we modified the selector above
            compile(selector, match)(
                seed,
                context,
                xml,
                results,
                rsibling.test(selector)
            );
            return results;
        }

        if (document.querySelectorAll) {
            (function() {
                var disconnectedMatch,
                    oldSelect = select,
                    rescape = /'|\\/g,
                    rattributeQuotes = /\=[\x20\t\r\n\f]*([^'"\]]*)[\x20\t\r\n\f]*\]/g,

                    // qSa(:focus) reports false when true (Chrome 21), no need to also add to buggyMatches since matches checks buggyQSA
                    // A support test would require too much code (would include document ready)
                    rbuggyQSA = [":focus"],

                    // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
                    // A support test would require too much code (would include document ready)
                    // just skip matchesSelector for :active
                    rbuggyMatches = [":active"],
                    matches = docElem.matchesSelector ||
                    docElem.mozMatchesSelector ||
                    docElem.webkitMatchesSelector ||
                    docElem.oMatchesSelector ||
                    docElem.msMatchesSelector;

                // Build QSA regex
                // Regex strategy adopted from Diego Perini
                assert(function(div) {
                    // Select is set to empty string on purpose
                    // This is to test IE's treatment of not explictly
                    // setting a boolean content attribute,
                    // since its presence should be enough
                    // http://bugs.jquery.com/ticket/12359
                    div.innerHTML = "<select><option selected=''></option></select>";

                    // IE8 - Some boolean attributes are not treated correctly
                    if (!div.querySelectorAll("[selected]").length) {
                        rbuggyQSA.push("\\[" + whitespace + "*(?:checked|disabled|ismap|multiple|readonly|selected|value)");
                    }

                    // Webkit/Opera - :checked should return selected option elements
                    // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                    // IE8 throws error here (do not put tests after this one)
                    if (!div.querySelectorAll(":checked").length) {
                        rbuggyQSA.push(":checked");
                    }
                });

                assert(function(div) {

                    // Opera 10-12/IE9 - ^= $= *= and empty values
                    // Should not select anything
                    div.innerHTML = "<p test=''></p>";
                    if (div.querySelectorAll("[test^='']").length) {
                        rbuggyQSA.push("[*^$]=" + whitespace + "*(?:\"\"|'')");
                    }

                    // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
                    // IE8 throws error here (do not put tests after this one)
                    div.innerHTML = "<input type='hidden'/>";
                    if (!div.querySelectorAll(":enabled").length) {
                        rbuggyQSA.push(":enabled", ":disabled");
                    }
                });

                // rbuggyQSA always contains :focus, so no need for a length check
                rbuggyQSA = /* rbuggyQSA.length && */ new RegExp(rbuggyQSA.join("|"));

                select = function(selector, context, results, seed, xml) {
                    // Only use querySelectorAll when not filtering,
                    // when this is not xml,
                    // and when no QSA bugs apply
                    if (!seed && !xml && !rbuggyQSA.test(selector)) {
                        var groups, i,
                            old = true,
                            nid = expando,
                            newContext = context,
                            newSelector = context.nodeType === 9 && selector;

                        // qSA works strangely on Element-rooted queries
                        // We can work around this by specifying an extra ID on the root
                        // and working up from there (Thanks to Andrew Dupont for the technique)
                        // IE 8 doesn't work on object elements
                        if (context.nodeType === 1 && context.nodeName.toLowerCase() !== "object") {
                            groups = tokenize(selector);

                            if ((old = context.getAttribute("id"))) {
                                nid = old.replace(rescape, "\\$&");
                            } else {
                                context.setAttribute("id", nid);
                            }
                            nid = "[id='" + nid + "'] ";

                            i = groups.length;
                            while (i--) {
                                groups[i] = nid + groups[i].join("");
                            }
                            newContext = rsibling.test(selector) && context.parentNode || context;
                            newSelector = groups.join(",");
                        }

                        if (newSelector) {
                            try {
                                push.apply(results, slice.call(newContext.querySelectorAll(
                                    newSelector
                                ), 0));
                                return results;
                            } catch (qsaError) {} finally {
                                if (!old) {
                                    context.removeAttribute("id");
                                }
                            }
                        }
                    }

                    return oldSelect(selector, context, results, seed, xml);
                };

                if (matches) {
                    assert(function(div) {
                        // Check to see if it's possible to do matchesSelector
                        // on a disconnected node (IE 9)
                        disconnectedMatch = matches.call(div, "div");

                        // This should fail with an exception
                        // Gecko does not error, returns false instead
                        try {
                            matches.call(div, "[test!='']:sizzle");
                            rbuggyMatches.push("!=", pseudos);
                        } catch (e) {}
                    });

                    // rbuggyMatches always contains :active and :focus, so no need for a length check
                    rbuggyMatches = /* rbuggyMatches.length && */ new RegExp(rbuggyMatches.join("|"));

                    Sizzle.matchesSelector = function(elem, expr) {
                        // Make sure that attribute selectors are quoted
                        expr = expr.replace(rattributeQuotes, "='$1']");

                        // rbuggyMatches always contains :active, so no need for an existence check
                        if (!isXML(elem) && !rbuggyMatches.test(expr) && !rbuggyQSA.test(expr)) {
                            try {
                                var ret = matches.call(elem, expr);

                                // IE 9's matchesSelector returns false on disconnected nodes
                                if (ret || disconnectedMatch ||
                                    // As well, disconnected nodes are said to be in a document
                                    // fragment in IE 9
                                    elem.document && elem.document.nodeType !== 11) {
                                    return ret;
                                }
                            } catch (e) {}
                        }

                        return Sizzle(expr, null, null, [elem]).length > 0;
                    };
                }
            })();
        }

        // Deprecated
        Expr.pseudos["nth"] = Expr.pseudos["eq"];

        // Back-compat
        function setFilters() {}
        Expr.filters = setFilters.prototype = Expr.pseudos;
        Expr.setFilters = new setFilters();

        // Override sizzle attribute retrieval
        Sizzle.attr = jQuery.attr;
        jQuery.find = Sizzle;
        jQuery.expr = Sizzle.selectors;
        jQuery.expr[":"] = jQuery.expr.pseudos;
        jQuery.unique = Sizzle.uniqueSort;
        jQuery.text = Sizzle.getText;
        jQuery.isXMLDoc = Sizzle.isXML;
        jQuery.contains = Sizzle.contains;


    })(window);
    var runtil = /Until$/,
        rparentsprev = /^(?:parents|prev(?:Until|All))/,
        isSimple = /^.[^:#\[\.,]*$/,
        rneedsContext = jQuery.expr.match.needsContext,
        // methods guaranteed to produce a unique set when starting from a unique set
        guaranteedUnique = {
            children: true,
            contents: true,
            next: true,
            prev: true
        };

    jQuery.fn.extend({
        find: function(selector) {
            var i, l, length, n, r, ret,
                self = this;

            if (typeof selector !== "string") {
                return jQuery(selector).filter(function() {
                    for (i = 0, l = self.length; i < l; i++) {
                        if (jQuery.contains(self[i], this)) {
                            return true;
                        }
                    }
                });
            }

            ret = this.pushStack("", "find", selector);

            for (i = 0, l = this.length; i < l; i++) {
                length = ret.length;
                jQuery.find(selector, this[i], ret);

                if (i > 0) {
                    // Make sure that the results are unique
                    for (n = length; n < ret.length; n++) {
                        for (r = 0; r < length; r++) {
                            if (ret[r] === ret[n]) {
                                ret.splice(n--, 1);
                                break;
                            }
                        }
                    }
                }
            }

            return ret;
        },

        has: function(target) {
            var i,
                targets = jQuery(target, this),
                len = targets.length;

            return this.filter(function() {
                for (i = 0; i < len; i++) {
                    if (jQuery.contains(this, targets[i])) {
                        return true;
                    }
                }
            });
        },

        not: function(selector) {
            return this.pushStack(winnow(this, selector, false), "not", selector);
        },

        filter: function(selector) {
            return this.pushStack(winnow(this, selector, true), "filter", selector);
        },

        is: function(selector) {
            return !!selector && (
                typeof selector === "string" ?
                // If this is a positional/relative selector, check membership in the returned set
                // so $("p:first").is("p:last") won't return true for a doc with two "p".
                rneedsContext.test(selector) ?
                jQuery(selector, this.context).index(this[0]) >= 0 :
                jQuery.filter(selector, this).length > 0 :
                this.filter(selector).length > 0);
        },

        closest: function(selectors, context) {
            var cur,
                i = 0,
                l = this.length,
                ret = [],
                pos = rneedsContext.test(selectors) || typeof selectors !== "string" ?
                jQuery(selectors, context || this.context) :
                0;

            for (; i < l; i++) {
                cur = this[i];

                while (cur && cur.ownerDocument && cur !== context && cur.nodeType !== 11) {
                    if (pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors)) {
                        ret.push(cur);
                        break;
                    }
                    cur = cur.parentNode;
                }
            }

            ret = ret.length > 1 ? jQuery.unique(ret) : ret;

            return this.pushStack(ret, "closest", selectors);
        },

        // Determine the position of an element within
        // the matched set of elements
        index: function(elem) {

            // No argument, return index in parent
            if (!elem) {
                return (this[0] && this[0].parentNode) ? this.prevAll().length : -1;
            }

            // index in selector
            if (typeof elem === "string") {
                return jQuery.inArray(this[0], jQuery(elem));
            }

            // Locate the position of the desired element
            return jQuery.inArray(
                // If it receives a jQuery object, the first element is used
                elem.jquery ? elem[0] : elem, this);
        },

        add: function(selector, context) {
            var set = typeof selector === "string" ?
                jQuery(selector, context) :
                jQuery.makeArray(selector && selector.nodeType ? [selector] : selector),
                all = jQuery.merge(this.get(), set);

            return this.pushStack(isDisconnected(set[0]) || isDisconnected(all[0]) ?
                all :
                jQuery.unique(all));
        },

        addBack: function(selector) {
            return this.add(selector == null ?
                this.prevObject : this.prevObject.filter(selector)
            );
        }
    });

    jQuery.fn.andSelf = jQuery.fn.addBack;

    // A painfully simple check to see if an element is disconnected
    // from a document (should be improved, where feasible).
    function isDisconnected(node) {
        return !node || !node.parentNode || node.parentNode.nodeType === 11;
    }

    function sibling(cur, dir) {
        do {
            cur = cur[dir];
        } while (cur && cur.nodeType !== 1);

        return cur;
    }

    jQuery.each({
        parent: function(elem) {
            var parent = elem.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null;
        },
        parents: function(elem) {
            return jQuery.dir(elem, "parentNode");
        },
        parentsUntil: function(elem, i, until) {
            return jQuery.dir(elem, "parentNode", until);
        },
        next: function(elem) {
            return sibling(elem, "nextSibling");
        },
        prev: function(elem) {
            return sibling(elem, "previousSibling");
        },
        nextAll: function(elem) {
            return jQuery.dir(elem, "nextSibling");
        },
        prevAll: function(elem) {
            return jQuery.dir(elem, "previousSibling");
        },
        nextUntil: function(elem, i, until) {
            return jQuery.dir(elem, "nextSibling", until);
        },
        prevUntil: function(elem, i, until) {
            return jQuery.dir(elem, "previousSibling", until);
        },
        siblings: function(elem) {
            return jQuery.sibling((elem.parentNode || {}).firstChild, elem);
        },
        children: function(elem) {
            return jQuery.sibling(elem.firstChild);
        },
        contents: function(elem) {
            return jQuery.nodeName(elem, "iframe") ?
                elem.contentDocument || elem.contentWindow.document :
                jQuery.merge([], elem.childNodes);
        }
    }, function(name, fn) {
        jQuery.fn[name] = function(until, selector) {
            var ret = jQuery.map(this, fn, until);

            if (!runtil.test(name)) {
                selector = until;
            }

            if (selector && typeof selector === "string") {
                ret = jQuery.filter(selector, ret);
            }

            ret = this.length > 1 && !guaranteedUnique[name] ? jQuery.unique(ret) : ret;

            if (this.length > 1 && rparentsprev.test(name)) {
                ret = ret.reverse();
            }

            return this.pushStack(ret, name, core_slice.call(arguments).join(","));
        };
    });

    jQuery.extend({
        filter: function(expr, elems, not) {
            if (not) {
                expr = ":not(" + expr + ")";
            }

            return elems.length === 1 ?
                jQuery.find.matchesSelector(elems[0], expr) ? [elems[0]] : [] :
                jQuery.find.matches(expr, elems);
        },

        dir: function(elem, dir, until) {
            var matched = [],
                cur = elem[dir];

            while (cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery(cur).is(until))) {
                if (cur.nodeType === 1) {
                    matched.push(cur);
                }
                cur = cur[dir];
            }
            return matched;
        },

        sibling: function(n, elem) {
            var r = [];

            for (; n; n = n.nextSibling) {
                if (n.nodeType === 1 && n !== elem) {
                    r.push(n);
                }
            }

            return r;
        }
    });

    // Implement the identical functionality for filter and not
    function winnow(elements, qualifier, keep) {

        // Can't pass null or undefined to indexOf in Firefox 4
        // Set to 0 to skip string check
        qualifier = qualifier || 0;

        if (jQuery.isFunction(qualifier)) {
            return jQuery.grep(elements, function(elem, i) {
                var retVal = !!qualifier.call(elem, i, elem);
                return retVal === keep;
            });

        } else if (qualifier.nodeType) {
            return jQuery.grep(elements, function(elem, i) {
                return (elem === qualifier) === keep;
            });

        } else if (typeof qualifier === "string") {
            var filtered = jQuery.grep(elements, function(elem) {
                return elem.nodeType === 1;
            });

            if (isSimple.test(qualifier)) {
                return jQuery.filter(qualifier, filtered, !keep);
            } else {
                qualifier = jQuery.filter(qualifier, filtered);
            }
        }

        return jQuery.grep(elements, function(elem, i) {
            return (jQuery.inArray(elem, qualifier) >= 0) === keep;
        });
    }

    function createSafeFragment(document) {
        var list = nodeNames.split("|"),
            safeFrag = document.createDocumentFragment();

        if (safeFrag.createElement) {
            while (list.length) {
                safeFrag.createElement(
                    list.pop()
                );
            }
        }
        return safeFrag;
    }

    var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|" +
        "header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
        rinlinejQuery = / jQuery\d+="(?:null|\d+)"/g,
        rleadingWhitespace = /^\s+/,
        rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
        rtagName = /<([\w:]+)/,
        rtbody = /<tbody/i,
        rhtml = /<|&#?\w+;/,
        rnoInnerhtml = /<(?:script|style|link)/i,
        rnocache = /<(?:script|object|embed|option|style)/i,
        rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"),
        rcheckableType = /^(?:checkbox|radio)$/,
        // checked="checked" or checked
        rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
        rscriptType = /\/(java|ecma)script/i,
        rcleanScript = /^\s*<!(?:\[CDATA\[|\-\-)|[\]\-]{2}>\s*$/g,
        wrapMap = {
            option: [1, "<select multiple='multiple'>", "</select>"],
            legend: [1, "<fieldset>", "</fieldset>"],
            thead: [1, "<table>", "</table>"],
            tr: [2, "<table><tbody>", "</tbody></table>"],
            td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
            col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"],
            area: [1, "<map>", "</map>"],
            _default: [0, "", ""]
        },
        safeFragment = createSafeFragment(document),
        fragmentDiv = safeFragment.appendChild(document.createElement("div"));

    wrapMap.optgroup = wrapMap.option;
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;

    // IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,
    // unless wrapped in a div with non-breaking characters in front of it.
    if (!jQuery.support.htmlSerialize) {
        wrapMap._default = [1, "X<div>", "</div>"];
    }

    jQuery.fn.extend({
        text: function(value) {
            return jQuery.access(this, function(value) {
                return value === undefined ?
                    jQuery.text(this) :
                    this.empty().append((this[0] && this[0].ownerDocument || document).createTextNode(value));
            }, null, value, arguments.length);
        },

        wrapAll: function(html) {
            if (jQuery.isFunction(html)) {
                return this.each(function(i) {
                    jQuery(this).wrapAll(html.call(this, i));
                });
            }

            if (this[0]) {
                // The elements to wrap the target around
                var wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);

                if (this[0].parentNode) {
                    wrap.insertBefore(this[0]);
                }

                wrap.map(function() {
                    var elem = this;

                    while (elem.firstChild && elem.firstChild.nodeType === 1) {
                        elem = elem.firstChild;
                    }

                    return elem;
                }).append(this);
            }

            return this;
        },

        wrapInner: function(html) {
            if (jQuery.isFunction(html)) {
                return this.each(function(i) {
                    jQuery(this).wrapInner(html.call(this, i));
                });
            }

            return this.each(function() {
                var self = jQuery(this),
                    contents = self.contents();

                if (contents.length) {
                    contents.wrapAll(html);

                } else {
                    self.append(html);
                }
            });
        },

        wrap: function(html) {
            var isFunction = jQuery.isFunction(html);

            return this.each(function(i) {
                jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
            });
        },

        unwrap: function() {
            return this.parent().each(function() {
                if (!jQuery.nodeName(this, "body")) {
                    jQuery(this).replaceWith(this.childNodes);
                }
            }).end();
        },

        append: function() {
            return this.domManip(arguments, true, function(elem) {
                if (this.nodeType === 1 || this.nodeType === 11) {
                    this.appendChild(elem);
                }
            });
        },

        prepend: function() {
            return this.domManip(arguments, true, function(elem) {
                if (this.nodeType === 1 || this.nodeType === 11) {
                    this.insertBefore(elem, this.firstChild);
                }
            });
        },

        before: function() {
            if (!isDisconnected(this[0])) {
                return this.domManip(arguments, false, function(elem) {
                    this.parentNode.insertBefore(elem, this);
                });
            }

            if (arguments.length) {
                var set = jQuery.clean(arguments);
                return this.pushStack(jQuery.merge(set, this), "before", this.selector);
            }
        },

        after: function() {
            if (!isDisconnected(this[0])) {
                return this.domManip(arguments, false, function(elem) {
                    this.parentNode.insertBefore(elem, this.nextSibling);
                });
            }

            if (arguments.length) {
                var set = jQuery.clean(arguments);
                return this.pushStack(jQuery.merge(this, set), "after", this.selector);
            }
        },

        // keepData is for internal use only--do not document
        remove: function(selector, keepData) {
            var elem,
                i = 0;

            for (;
                (elem = this[i]) != null; i++) {
                if (!selector || jQuery.filter(selector, [elem]).length) {
                    if (!keepData && elem.nodeType === 1) {
                        jQuery.cleanData(elem.getElementsByTagName("*"));
                        jQuery.cleanData([elem]);
                    }

                    if (elem.parentNode) {
                        elem.parentNode.removeChild(elem);
                    }
                }
            }

            return this;
        },

        empty: function() {
            var elem,
                i = 0;

            for (;
                (elem = this[i]) != null; i++) {
                // Remove element nodes and prevent memory leaks
                if (elem.nodeType === 1) {
                    jQuery.cleanData(elem.getElementsByTagName("*"));
                }

                // Remove any remaining nodes
                while (elem.firstChild) {
                    elem.removeChild(elem.firstChild);
                }
            }

            return this;
        },

        clone: function(dataAndEvents, deepDataAndEvents) {
            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

            return this.map(function() {
                return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
            });
        },

        html: function(value) {
            return jQuery.access(this, function(value) {
                var elem = this[0] || {},
                    i = 0,
                    l = this.length;

                if (value === undefined) {
                    return elem.nodeType === 1 ?
                        elem.innerHTML.replace(rinlinejQuery, "") :
                        undefined;
                }

                // See if we can take a shortcut and just use innerHTML
                if (typeof value === "string" && !rnoInnerhtml.test(value) &&
                    (jQuery.support.htmlSerialize || !rnoshimcache.test(value)) &&
                    (jQuery.support.leadingWhitespace || !rleadingWhitespace.test(value)) &&
                    !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {

                    value = value.replace(rxhtmlTag, "<$1></$2>");

                    try {
                        for (; i < l; i++) {
                            // Remove element nodes and prevent memory leaks
                            elem = this[i] || {};
                            if (elem.nodeType === 1) {
                                jQuery.cleanData(elem.getElementsByTagName("*"));
                                elem.innerHTML = value;
                            }
                        }

                        elem = 0;

                        // If using innerHTML throws an exception, use the fallback method
                    } catch (e) {}
                }

                if (elem) {
                    this.empty().append(value);
                }
            }, null, value, arguments.length);
        },

        replaceWith: function(value) {
            if (!isDisconnected(this[0])) {
                // Make sure that the elements are removed from the DOM before they are inserted
                // this can help fix replacing a parent with child elements
                if (jQuery.isFunction(value)) {
                    return this.each(function(i) {
                        var self = jQuery(this),
                            old = self.html();
                        self.replaceWith(value.call(this, i, old));
                    });
                }

                if (typeof value !== "string") {
                    value = jQuery(value).detach();
                }

                return this.each(function() {
                    var next = this.nextSibling,
                        parent = this.parentNode;

                    jQuery(this).remove();

                    if (next) {
                        jQuery(next).before(value);
                    } else {
                        jQuery(parent).append(value);
                    }
                });
            }

            return this.length ?
                this.pushStack(jQuery(jQuery.isFunction(value) ? value() : value), "replaceWith", value) :
                this;
        },

        detach: function(selector) {
            return this.remove(selector, true);
        },

        domManip: function(args, table, callback) {

            // Flatten any nested arrays
            args = [].concat.apply([], args);

            var results, first, fragment, iNoClone,
                i = 0,
                value = args[0],
                scripts = [],
                l = this.length;

            // We can't cloneNode fragments that contain checked, in WebKit
            if (!jQuery.support.checkClone && l > 1 && typeof value === "string" && rchecked.test(value)) {
                return this.each(function() {
                    jQuery(this).domManip(args, table, callback);
                });
            }

            if (jQuery.isFunction(value)) {
                return this.each(function(i) {
                    var self = jQuery(this);
                    args[0] = value.call(this, i, table ? self.html() : undefined);
                    self.domManip(args, table, callback);
                });
            }

            if (this[0]) {
                results = jQuery.buildFragment(args, this, scripts);
                fragment = results.fragment;
                first = fragment.firstChild;

                if (fragment.childNodes.length === 1) {
                    fragment = first;
                }

                if (first) {
                    table = table && jQuery.nodeName(first, "tr");

                    // Use the original fragment for the last item instead of the first because it can end up
                    // being emptied incorrectly in certain situations (#8070).
                    // Fragments from the fragment cache must always be cloned and never used in place.
                    for (iNoClone = results.cacheable || l - 1; i < l; i++) {
                        callback.call(
                            table && jQuery.nodeName(this[i], "table") ?
                            findOrAppend(this[i], "tbody") :
                            this[i],
                            i === iNoClone ?
                            fragment :
                            jQuery.clone(fragment, true, true)
                        );
                    }
                }

                // Fix #11809: Avoid leaking memory
                fragment = first = null;

                if (scripts.length) {
                    jQuery.each(scripts, function(i, elem) {
                        if (elem.src) {
                            if (jQuery.ajax) {
                                jQuery.ajax({
                                    url: elem.src,
                                    type: "GET",
                                    dataType: "script",
                                    async: false,
                                    global: false,
                                    "throws": true
                                });
                            } else {
                                jQuery.error("no ajax");
                            }
                        } else {
                            jQuery.globalEval((elem.text || elem.textContent || elem.innerHTML || "").replace(rcleanScript, ""));
                        }

                        if (elem.parentNode) {
                            elem.parentNode.removeChild(elem);
                        }
                    });
                }
            }

            return this;
        }
    });

    function findOrAppend(elem, tag) {
        return elem.getElementsByTagName(tag)[0] || elem.appendChild(elem.ownerDocument.createElement(tag));
    }

    function cloneCopyEvent(src, dest) {

        if (dest.nodeType !== 1 || !jQuery.hasData(src)) {
            return;
        }

        var type, i, l,
            oldData = jQuery._data(src),
            curData = jQuery._data(dest, oldData),
            events = oldData.events;

        if (events) {
            delete curData.handle;
            curData.events = {};

            for (type in events) {
                for (i = 0, l = events[type].length; i < l; i++) {
                    jQuery.event.add(dest, type, events[type][i]);
                }
            }
        }

        // make the cloned public data object a copy from the original
        if (curData.data) {
            curData.data = jQuery.extend({}, curData.data);
        }
    }

    function cloneFixAttributes(src, dest) {
        var nodeName;

        // We do not need to do anything for non-Elements
        if (dest.nodeType !== 1) {
            return;
        }

        // clearAttributes removes the attributes, which we don't want,
        // but also removes the attachEvent events, which we *do* want
        if (dest.clearAttributes) {
            dest.clearAttributes();
        }

        // mergeAttributes, in contrast, only merges back on the
        // original attributes, not the events
        if (dest.mergeAttributes) {
            dest.mergeAttributes(src);
        }

        nodeName = dest.nodeName.toLowerCase();

        if (nodeName === "object") {
            // IE6-10 improperly clones children of object elements using classid.
            // IE10 throws NoModificationAllowedError if parent is null, #12132.
            if (dest.parentNode) {
                dest.outerHTML = src.outerHTML;
            }

            // This path appears unavoidable for IE9. When cloning an object
            // element in IE9, the outerHTML strategy above is not sufficient.
            // If the src has innerHTML and the destination does not,
            // copy the src.innerHTML into the dest.innerHTML. #10324
            if (jQuery.support.html5Clone && (src.innerHTML && !jQuery.trim(dest.innerHTML))) {
                dest.innerHTML = src.innerHTML;
            }

        } else if (nodeName === "input" && rcheckableType.test(src.type)) {
            // IE6-8 fails to persist the checked state of a cloned checkbox
            // or radio button. Worse, IE6-7 fail to give the cloned element
            // a checked appearance if the defaultChecked value isn't also set

            dest.defaultChecked = dest.checked = src.checked;

            // IE6-7 get confused and end up setting the value of a cloned
            // checkbox/radio button to an empty string instead of "on"
            if (dest.value !== src.value) {
                dest.value = src.value;
            }

            // IE6-8 fails to return the selected option to the default selected
            // state when cloning options
        } else if (nodeName === "option") {
            dest.selected = src.defaultSelected;

            // IE6-8 fails to set the defaultValue to the correct value when
            // cloning other types of input fields
        } else if (nodeName === "input" || nodeName === "textarea") {
            dest.defaultValue = src.defaultValue;

            // IE blanks contents when cloning scripts
        } else if (nodeName === "script" && dest.text !== src.text) {
            dest.text = src.text;
        }

        // Event data gets referenced instead of copied if the expando
        // gets copied too
        dest.removeAttribute(jQuery.expando);
    }

    jQuery.buildFragment = function(args, context, scripts) {
        var fragment, cacheable, cachehit,
            first = args[0];

        // Set context from what may come in as undefined or a jQuery collection or a node
        // Updated to fix #12266 where accessing context[0] could throw an exception in IE9/10 &
        // also doubles as fix for #8950 where plain objects caused createDocumentFragment exception
        context = context || document;
        context = !context.nodeType && context[0] || context;
        context = context.ownerDocument || context;

        // Only cache "small" (1/2 KB) HTML strings that are associated with the main document
        // Cloning options loses the selected state, so don't cache them
        // IE 6 doesn't like it when you put <object> or <embed> elements in a fragment
        // Also, WebKit does not clone 'checked' attributes on cloneNode, so don't cache
        // Lastly, IE6,7,8 will not correctly reuse cached fragments that were created from unknown elems #10501
        if (args.length === 1 && typeof first === "string" && first.length < 512 && context === document &&
            first.charAt(0) === "<" && !rnocache.test(first) &&
            (jQuery.support.checkClone || !rchecked.test(first)) &&
            (jQuery.support.html5Clone || !rnoshimcache.test(first))) {

            // Mark cacheable and look for a hit
            cacheable = true;
            fragment = jQuery.fragments[first];
            cachehit = fragment !== undefined;
        }

        if (!fragment) {
            fragment = context.createDocumentFragment();
            jQuery.clean(args, context, fragment, scripts);

            // Update the cache, but only store false
            // unless this is a second parsing of the same content
            if (cacheable) {
                jQuery.fragments[first] = cachehit && fragment;
            }
        }

        return { fragment: fragment, cacheable: cacheable };
    };

    jQuery.fragments = {};

    jQuery.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function(name, original) {
        jQuery.fn[name] = function(selector) {
            var elems,
                i = 0,
                ret = [],
                insert = jQuery(selector),
                l = insert.length,
                parent = this.length === 1 && this[0].parentNode;

            if ((parent == null || parent && parent.nodeType === 11 && parent.childNodes.length === 1) && l === 1) {
                insert[original](this[0]);
                return this;
            } else {
                for (; i < l; i++) {
                    elems = (i > 0 ? this.clone(true) : this).get();
                    jQuery(insert[i])[original](elems);
                    ret = ret.concat(elems);
                }

                return this.pushStack(ret, name, insert.selector);
            }
        };
    });

    function getAll(elem) {
        if (typeof elem.getElementsByTagName !== "undefined") {
            return elem.getElementsByTagName("*");

        } else if (typeof elem.querySelectorAll !== "undefined") {
            return elem.querySelectorAll("*");

        } else {
            return [];
        }
    }

    // Used in clean, fixes the defaultChecked property
    function fixDefaultChecked(elem) {
        if (rcheckableType.test(elem.type)) {
            elem.defaultChecked = elem.checked;
        }
    }

    jQuery.extend({
        clone: function(elem, dataAndEvents, deepDataAndEvents) {
            var srcElements,
                destElements,
                i,
                clone;

            if (jQuery.support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test("<" + elem.nodeName + ">")) {
                clone = elem.cloneNode(true);

                // IE<=8 does not properly clone detached, unknown element nodes
            } else {
                fragmentDiv.innerHTML = elem.outerHTML;
                fragmentDiv.removeChild(clone = fragmentDiv.firstChild);
            }

            if ((!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &&
                (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
                // IE copies events bound via attachEvent when using cloneNode.
                // Calling detachEvent on the clone will also remove the events
                // from the original. In order to get around this, we use some
                // proprietary methods to clear the events. Thanks to MooTools
                // guys for this hotness.

                cloneFixAttributes(elem, clone);

                // Using Sizzle here is crazy slow, so we use getElementsByTagName instead
                srcElements = getAll(elem);
                destElements = getAll(clone);

                // Weird iteration because IE will replace the length property
                // with an element if you are cloning the body and one of the
                // elements on the page has a name or id of "length"
                for (i = 0; srcElements[i]; ++i) {
                    // Ensure that the destination node is not null; Fixes #9587
                    if (destElements[i]) {
                        cloneFixAttributes(srcElements[i], destElements[i]);
                    }
                }
            }

            // Copy the events from the original to the clone
            if (dataAndEvents) {
                cloneCopyEvent(elem, clone);

                if (deepDataAndEvents) {
                    srcElements = getAll(elem);
                    destElements = getAll(clone);

                    for (i = 0; srcElements[i]; ++i) {
                        cloneCopyEvent(srcElements[i], destElements[i]);
                    }
                }
            }

            srcElements = destElements = null;

            // Return the cloned set
            return clone;
        },

        clean: function(elems, context, fragment, scripts) {
            var i, j, elem, tag, wrap, depth, div, hasBody, tbody, len, handleScript, jsTags,
                safe = context === document && safeFragment,
                ret = [];

            // Ensure that context is a document
            if (!context || typeof context.createDocumentFragment === "undefined") {
                context = document;
            }

            // Use the already-created safe fragment if context permits
            for (i = 0;
                (elem = elems[i]) != null; i++) {
                if (typeof elem === "number") {
                    elem += "";
                }

                if (!elem) {
                    continue;
                }

                // Convert html string into DOM nodes
                if (typeof elem === "string") {
                    if (!rhtml.test(elem)) {
                        elem = context.createTextNode(elem);
                    } else {
                        // Ensure a safe container in which to render the html
                        safe = safe || createSafeFragment(context);
                        div = context.createElement("div");
                        safe.appendChild(div);

                        // Fix "XHTML"-style tags in all browsers
                        elem = elem.replace(rxhtmlTag, "<$1></$2>");

                        // Go to html and back, then peel off extra wrappers
                        tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
                        wrap = wrapMap[tag] || wrapMap._default;
                        depth = wrap[0];
                        div.innerHTML = wrap[1] + elem + wrap[2];

                        // Move to the right depth
                        while (depth--) {
                            div = div.lastChild;
                        }

                        // Remove IE's autoinserted <tbody> from table fragments
                        if (!jQuery.support.tbody) {

                            // String was a <table>, *may* have spurious <tbody>
                            hasBody = rtbody.test(elem);
                            tbody = tag === "table" && !hasBody ?
                                div.firstChild && div.firstChild.childNodes :

                                // String was a bare <thead> or <tfoot>
                                wrap[1] === "<table>" && !hasBody ?
                                div.childNodes : [];

                            for (j = tbody.length - 1; j >= 0; --j) {
                                if (jQuery.nodeName(tbody[j], "tbody") && !tbody[j].childNodes.length) {
                                    tbody[j].parentNode.removeChild(tbody[j]);
                                }
                            }
                        }

                        // IE completely kills leading whitespace when innerHTML is used
                        if (!jQuery.support.leadingWhitespace && rleadingWhitespace.test(elem)) {
                            div.insertBefore(context.createTextNode(rleadingWhitespace.exec(elem)[0]), div.firstChild);
                        }

                        elem = div.childNodes;

                        // Take out of fragment container (we need a fresh div each time)
                        div.parentNode.removeChild(div);
                    }
                }

                if (elem.nodeType) {
                    ret.push(elem);
                } else {
                    jQuery.merge(ret, elem);
                }
            }

            // Fix #11356: Clear elements from safeFragment
            if (div) {
                elem = div = safe = null;
            }

            // Reset defaultChecked for any radios and checkboxes
            // about to be appended to the DOM in IE 6/7 (#8060)
            if (!jQuery.support.appendChecked) {
                for (i = 0;
                    (elem = ret[i]) != null; i++) {
                    if (jQuery.nodeName(elem, "input")) {
                        fixDefaultChecked(elem);
                    } else if (typeof elem.getElementsByTagName !== "undefined") {
                        jQuery.grep(elem.getElementsByTagName("input"), fixDefaultChecked);
                    }
                }
            }

            // Append elements to a provided document fragment
            if (fragment) {
                // Special handling of each script element
                handleScript = function(elem) {
                    // Check if we consider it executable
                    if (!elem.type || rscriptType.test(elem.type)) {
                        // Detach the script and store it in the scripts array (if provided) or the fragment
                        // Return truthy to indicate that it has been handled
                        return scripts ?
                            scripts.push(elem.parentNode ? elem.parentNode.removeChild(elem) : elem) :
                            fragment.appendChild(elem);
                    }
                };

                for (i = 0;
                    (elem = ret[i]) != null; i++) {
                    // Check if we're done after handling an executable script
                    if (!(jQuery.nodeName(elem, "script") && handleScript(elem))) {
                        // Append to fragment and handle embedded scripts
                        fragment.appendChild(elem);
                        if (typeof elem.getElementsByTagName !== "undefined") {
                            // handleScript alters the DOM, so use jQuery.merge to ensure snapshot iteration
                            jsTags = jQuery.grep(jQuery.merge([], elem.getElementsByTagName("script")), handleScript);

                            // Splice the scripts into ret after their former ancestor and advance our index beyond them
                            ret.splice.apply(ret, [i + 1, 0].concat(jsTags));
                            i += jsTags.length;
                        }
                    }
                }
            }

            return ret;
        },

        cleanData: function(elems, /* internal */ acceptData) {
            var data, id, elem, type,
                i = 0,
                internalKey = jQuery.expando,
                cache = jQuery.cache,
                deleteExpando = jQuery.support.deleteExpando,
                special = jQuery.event.special;

            for (;
                (elem = elems[i]) != null; i++) {

                if (acceptData || jQuery.acceptData(elem)) {

                    id = elem[internalKey];
                    data = id && cache[id];

                    if (data) {
                        if (data.events) {
                            for (type in data.events) {
                                if (special[type]) {
                                    jQuery.event.remove(elem, type);

                                    // This is a shortcut to avoid jQuery.event.remove's overhead
                                } else {
                                    jQuery.removeEvent(elem, type, data.handle);
                                }
                            }
                        }

                        // Remove cache only if it was not already removed by jQuery.event.remove
                        if (cache[id]) {

                            delete cache[id];

                            // IE does not allow us to delete expando properties from nodes,
                            // nor does it have a removeAttribute function on Document nodes;
                            // we must handle all of these cases
                            if (deleteExpando) {
                                delete elem[internalKey];

                            } else if (elem.removeAttribute) {
                                elem.removeAttribute(internalKey);

                            } else {
                                elem[internalKey] = null;
                            }

                            jQuery.deletedIds.push(id);
                        }
                    }
                }
            }
        }
    });
    // Limit scope pollution from any deprecated API
    (function() {

        var matched, browser;

        // Use of jQuery.browser is frowned upon.
        // More details: http://api.jquery.com/jQuery.browser
        // jQuery.uaMatch maintained for back-compat
        jQuery.uaMatch = function(ua) {
            ua = ua.toLowerCase();

            var match = /(chrome)[ \/]([\w.]+)/.exec(ua) ||
                /(webkit)[ \/]([\w.]+)/.exec(ua) ||
                /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(ua) ||
                /(msie) ([\w.]+)/.exec(ua) ||
                ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua) || [];

            return {
                browser: match[1] || "",
                version: match[2] || "0"
            };
        };

        matched = jQuery.uaMatch(navigator.userAgent);
        browser = {};

        if (matched.browser) {
            browser[matched.browser] = true;
            browser.version = matched.version;
        }

        // Chrome is Webkit, but Webkit is also Safari.
        if (browser.chrome) {
            browser.webkit = true;
        } else if (browser.webkit) {
            browser.safari = true;
        }

        jQuery.browser = browser;

        jQuery.sub = function() {
            function jQuerySub(selector, context) {
                return new jQuerySub.fn.init(selector, context);
            }
            jQuery.extend(true, jQuerySub, this);
            jQuerySub.superclass = this;
            jQuerySub.fn = jQuerySub.prototype = this();
            jQuerySub.fn.constructor = jQuerySub;
            jQuerySub.sub = this.sub;
            jQuerySub.fn.init = function init(selector, context) {
                if (context && context instanceof jQuery && !(context instanceof jQuerySub)) {
                    context = jQuerySub(context);
                }

                return jQuery.fn.init.call(this, selector, context, rootjQuerySub);
            };
            jQuerySub.fn.init.prototype = jQuerySub.fn;
            var rootjQuerySub = jQuerySub(document);
            return jQuerySub;
        };

    })();
    var curCSS, iframe, iframeDoc,
        ralpha = /alpha\([^)]*\)/i,
        ropacity = /opacity=([^)]*)/,
        rposition = /^(top|right|bottom|left)$/,
        // swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
        // see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
        rdisplayswap = /^(none|table(?!-c[ea]).+)/,
        rmargin = /^margin/,
        rnumsplit = new RegExp("^(" + core_pnum + ")(.*)$", "i"),
        rnumnonpx = new RegExp("^(" + core_pnum + ")(?!px)[a-z%]+$", "i"),
        rrelNum = new RegExp("^([-+])=(" + core_pnum + ")", "i"),
        elemdisplay = { BODY: "block" },

        cssShow = { position: "absolute", visibility: "hidden", display: "block" },
        cssNormalTransform = {
            letterSpacing: 0,
            fontWeight: 400
        },

        cssExpand = ["Top", "Right", "Bottom", "Left"],
        cssPrefixes = ["Webkit", "O", "Moz", "ms"],

        eventsToggle = jQuery.fn.toggle;

    // return a css property mapped to a potentially vendor prefixed property
    function vendorPropName(style, name) {

        // shortcut for names that are not vendor prefixed
        if (name in style) {
            return name;
        }

        // check for vendor prefixed names
        var capName = name.charAt(0).toUpperCase() + name.slice(1),
            origName = name,
            i = cssPrefixes.length;

        while (i--) {
            name = cssPrefixes[i] + capName;
            if (name in style) {
                return name;
            }
        }

        return origName;
    }

    function isHidden(elem, el) {
        elem = el || elem;
        return jQuery.css(elem, "display") === "none" || !jQuery.contains(elem.ownerDocument, elem);
    }

    function showHide(elements, show) {
        var elem, display,
            values = [],
            index = 0,
            length = elements.length;

        for (; index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
                continue;
            }
            values[index] = jQuery._data(elem, "olddisplay");
            if (show) {
                // Reset the inline display of this element to learn if it is
                // being hidden by cascaded rules or not
                if (!values[index] && elem.style.display === "none") {
                    elem.style.display = "";
                }

                // Set elements which have been overridden with display: none
                // in a stylesheet to whatever the default browser style is
                // for such an element
                if (elem.style.display === "" && isHidden(elem)) {
                    values[index] = jQuery._data(elem, "olddisplay", css_defaultDisplay(elem.nodeName));
                }
            } else {
                display = curCSS(elem, "display");

                if (!values[index] && display !== "none") {
                    jQuery._data(elem, "olddisplay", display);
                }
            }
        }

        // Set the display of most of the elements in a second loop
        // to avoid the constant reflow
        for (index = 0; index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
                continue;
            }
            if (!show || elem.style.display === "none" || elem.style.display === "") {
                elem.style.display = show ? values[index] || "" : "none";
            }
        }

        return elements;
    }

    jQuery.fn.extend({
        css: function(name, value) {
            return jQuery.access(this, function(elem, name, value) {
                return value !== undefined ?
                    jQuery.style(elem, name, value) :
                    jQuery.css(elem, name);
            }, name, value, arguments.length > 1);
        },
        show: function() {
            return showHide(this, true);
        },
        hide: function() {
            return showHide(this);
        },
        toggle: function(state, fn2) {
            var bool = typeof state === "boolean";

            if (jQuery.isFunction(state) && jQuery.isFunction(fn2)) {
                return eventsToggle.apply(this, arguments);
            }

            return this.each(function() {
                if (bool ? state : isHidden(this)) {
                    jQuery(this).show();
                } else {
                    jQuery(this).hide();
                }
            });
        }
    });

    jQuery.extend({
        // Add in style property hooks for overriding the default
        // behavior of getting and setting a style property
        cssHooks: {
            opacity: {
                get: function(elem, computed) {
                    if (computed) {
                        // We should always get a number back from opacity
                        var ret = curCSS(elem, "opacity");
                        return ret === "" ? "1" : ret;

                    }
                }
            }
        },

        // Exclude the following css properties to add px
        cssNumber: {
            "fillOpacity": true,
            "fontWeight": true,
            "lineHeight": true,
            "opacity": true,
            "orphans": true,
            "widows": true,
            "zIndex": true,
            "zoom": true
        },

        // Add in properties whose names you wish to fix before
        // setting or getting the value
        cssProps: {
            // normalize float css property
            "float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"
        },

        // Get and set the style property on a DOM Node
        style: function(elem, name, value, extra) {
            // Don't set styles on text and comment nodes
            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
                return;
            }

            // Make sure that we're working with the right name
            var ret, type, hooks,
                origName = jQuery.camelCase(name),
                style = elem.style;

            name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(style, origName));

            // gets hook for the prefixed version
            // followed by the unprefixed version
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

            // Check if we're setting a value
            if (value !== undefined) {
                type = typeof value;

                // convert relative number strings (+= or -=) to relative numbers. #7345
                if (type === "string" && (ret = rrelNum.exec(value))) {
                    value = (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name));
                    // Fixes bug #9237
                    type = "number";
                }

                // Make sure that NaN and null values aren't set. See: #7116
                if (value == null || type === "number" && isNaN(value)) {
                    return;
                }

                // If a number was passed in, add 'px' to the (except for certain CSS properties)
                if (type === "number" && !jQuery.cssNumber[origName]) {
                    value += "px";
                }

                // If a hook was provided, use that value, otherwise just set the specified value
                if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
                    // Wrapped to prevent IE from throwing errors when 'invalid' values are provided
                    // Fixes bug #5509
                    try {
                        style[name] = value;
                    } catch (e) {}
                }

            } else {
                // If a hook was provided get the non-computed value from there
                if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
                    return ret;
                }

                // Otherwise just get the value from the style object
                return style[name];
            }
        },

        css: function(elem, name, numeric, extra) {
            var val, num, hooks,
                origName = jQuery.camelCase(name);

            // Make sure that we're working with the right name
            name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(elem.style, origName));

            // gets hook for the prefixed version
            // followed by the unprefixed version
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

            // If a hook was provided get the computed value from there
            if (hooks && "get" in hooks) {
                val = hooks.get(elem, true, extra);
            }

            // Otherwise, if a way to get the computed value exists, use that
            if (val === undefined) {
                val = curCSS(elem, name);
            }

            //convert "normal" to computed value
            if (val === "normal" && name in cssNormalTransform) {
                val = cssNormalTransform[name];
            }

            // Return, converting to number if forced or a qualifier was provided and val looks numeric
            if (numeric || extra !== undefined) {
                num = parseFloat(val);
                return numeric || jQuery.isNumeric(num) ? num || 0 : val;
            }
            return val;
        },

        // A method for quickly swapping in/out CSS properties to get correct calculations
        swap: function(elem, options, callback) {
            var ret, name,
                old = {};

            // Remember the old values, and insert the new ones
            for (name in options) {
                old[name] = elem.style[name];
                elem.style[name] = options[name];
            }

            ret = callback.call(elem);

            // Revert the old values
            for (name in options) {
                elem.style[name] = old[name];
            }

            return ret;
        }
    });

    // NOTE: To any future maintainer, we've window.getComputedStyle
    // because jsdom on node.js will break without it.
    if (window.getComputedStyle) {
        curCSS = function(elem, name) {
            var ret, width, minWidth, maxWidth,
                computed = window.getComputedStyle(elem, null),
                style = elem.style;

            if (computed) {

                // getPropertyValue is only needed for .css('filter') in IE9, see #12537
                ret = computed.getPropertyValue(name) || computed[name];

                if (ret === "" && !jQuery.contains(elem.ownerDocument, elem)) {
                    ret = jQuery.style(elem, name);
                }

                // A tribute to the "awesome hack by Dean Edwards"
                // Chrome < 17 and Safari 5.0 uses "computed value" instead of "used value" for margin-right
                // Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
                // this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
                if (rnumnonpx.test(ret) && rmargin.test(name)) {
                    width = style.width;
                    minWidth = style.minWidth;
                    maxWidth = style.maxWidth;

                    style.minWidth = style.maxWidth = style.width = ret;
                    ret = computed.width;

                    style.width = width;
                    style.minWidth = minWidth;
                    style.maxWidth = maxWidth;
                }
            }

            return ret;
        };
    } else if (document.documentElement.currentStyle) {
        curCSS = function(elem, name) {
            var left, rsLeft,
                ret = elem.currentStyle && elem.currentStyle[name],
                style = elem.style;

            // Avoid setting ret to empty string here
            // so we don't default to auto
            if (ret == null && style && style[name]) {
                ret = style[name];
            }

            // From the awesome hack by Dean Edwards
            // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

            // If we're not dealing with a regular pixel number
            // but a number that has a weird ending, we need to convert it to pixels
            // but not position css attributes, as those are proportional to the parent element instead
            // and we can't measure the parent instead because it might trigger a "stacking dolls" problem
            if (rnumnonpx.test(ret) && !rposition.test(name)) {

                // Remember the original values
                left = style.left;
                rsLeft = elem.runtimeStyle && elem.runtimeStyle.left;

                // Put in the new values to get a computed value out
                if (rsLeft) {
                    elem.runtimeStyle.left = elem.currentStyle.left;
                }
                style.left = name === "fontSize" ? "1em" : ret;
                ret = style.pixelLeft + "px";

                // Revert the changed values
                style.left = left;
                if (rsLeft) {
                    elem.runtimeStyle.left = rsLeft;
                }
            }

            return ret === "" ? "auto" : ret;
        };
    }

    function setPositiveNumber(elem, value, subtract) {
        var matches = rnumsplit.exec(value);
        return matches ?
            Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || "px") :
            value;
    }

    function augmentWidthOrHeight(elem, name, extra, isBorderBox) {
        var i = extra === (isBorderBox ? "border" : "content") ?
            // If we already have the right measurement, avoid augmentation
            4 :
            // Otherwise initialize for horizontal or vertical properties
            name === "width" ? 1 : 0,

            val = 0;

        for (; i < 4; i += 2) {
            // both box models exclude margin, so add it if we want it
            if (extra === "margin") {
                // we use jQuery.css instead of curCSS here
                // because of the reliableMarginRight CSS hook!
                val += jQuery.css(elem, extra + cssExpand[i], true);
            }

            // From this point on we use curCSS for maximum performance (relevant in animations)
            if (isBorderBox) {
                // border-box includes padding, so remove it if we want content
                if (extra === "content") {
                    val -= parseFloat(curCSS(elem, "padding" + cssExpand[i])) || 0;
                }

                // at this point, extra isn't border nor margin, so remove border
                if (extra !== "margin") {
                    val -= parseFloat(curCSS(elem, "border" + cssExpand[i] + "Width")) || 0;
                }
            } else {
                // at this point, extra isn't content, so add padding
                val += parseFloat(curCSS(elem, "padding" + cssExpand[i])) || 0;

                // at this point, extra isn't content nor padding, so add border
                if (extra !== "padding") {
                    val += parseFloat(curCSS(elem, "border" + cssExpand[i] + "Width")) || 0;
                }
            }
        }

        return val;
    }

    function getWidthOrHeight(elem, name, extra) {

        // Start with offset property, which is equivalent to the border-box value
        var val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
            valueIsBorderBox = true,
            isBorderBox = jQuery.support.boxSizing && jQuery.css(elem, "boxSizing") === "border-box";

        // some non-html elements return undefined for offsetWidth, so check for null/undefined
        // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
        // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
        if (val <= 0 || val == null) {
            // Fall back to computed then uncomputed css if necessary
            val = curCSS(elem, name);
            if (val < 0 || val == null) {
                val = elem.style[name];
            }

            // Computed unit is not pixels. Stop here and return.
            if (rnumnonpx.test(val)) {
                return val;
            }

            // we need the check for style in case a browser which returns unreliable values
            // for getComputedStyle silently falls back to the reliable elem.style
            valueIsBorderBox = isBorderBox && (jQuery.support.boxSizingReliable || val === elem.style[name]);

            // Normalize "", auto, and prepare for extra
            val = parseFloat(val) || 0;
        }

        // use the active box-sizing model to add/subtract irrelevant styles
        return (val +
            augmentWidthOrHeight(
                elem,
                name,
                extra || (isBorderBox ? "border" : "content"),
                valueIsBorderBox
            )
        ) + "px";
    }


    // Try to determine the default display value of an element
    function css_defaultDisplay(nodeName) {
        if (elemdisplay[nodeName]) {
            return elemdisplay[nodeName];
        }

        var elem = jQuery("<" + nodeName + ">").appendTo(document.body),
            display = elem.css("display");
        elem.remove();

        // If the simple way fails,
        // get element's real default display by attaching it to a temp iframe
        if (display === "none" || display === "") {
            // Use the already-created iframe if possible
            iframe = document.body.appendChild(
                iframe || jQuery.extend(document.createElement("iframe"), {
                    frameBorder: 0,
                    width: 0,
                    height: 0
                })
            );

            // Create a cacheable copy of the iframe document on first call.
            // IE and Opera will allow us to reuse the iframeDoc without re-writing the fake HTML
            // document to it; WebKit & Firefox won't allow reusing the iframe document.
            if (!iframeDoc || !iframe.createElement) {
                iframeDoc = (iframe.contentWindow || iframe.contentDocument).document;
                iframeDoc.write("<!doctype html><html><body>");
                iframeDoc.close();
            }

            elem = iframeDoc.body.appendChild(iframeDoc.createElement(nodeName));

            display = curCSS(elem, "display");
            document.body.removeChild(iframe);
        }

        // Store the correct default display
        elemdisplay[nodeName] = display;

        return display;
    }

    jQuery.each(["height", "width"], function(i, name) {
        jQuery.cssHooks[name] = {
            get: function(elem, computed, extra) {
                if (computed) {
                    // certain elements can have dimension info if we invisibly show them
                    // however, it must have a current display style that would benefit from this
                    if (elem.offsetWidth === 0 && rdisplayswap.test(curCSS(elem, "display"))) {
                        return jQuery.swap(elem, cssShow, function() {
                            return getWidthOrHeight(elem, name, extra);
                        });
                    } else {
                        return getWidthOrHeight(elem, name, extra);
                    }
                }
            },

            set: function(elem, value, extra) {
                return setPositiveNumber(elem, value, extra ?
                    augmentWidthOrHeight(
                        elem,
                        name,
                        extra,
                        jQuery.support.boxSizing && jQuery.css(elem, "boxSizing") === "border-box"
                    ) : 0
                );
            }
        };
    });

    if (!jQuery.support.opacity) {
        jQuery.cssHooks.opacity = {
            get: function(elem, computed) {
                // IE uses filters for opacity
                return ropacity.test((computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "") ?
                    (0.01 * parseFloat(RegExp.$1)) + "" :
                    computed ? "1" : "";
            },

            set: function(elem, value) {
                var style = elem.style,
                    currentStyle = elem.currentStyle,
                    opacity = jQuery.isNumeric(value) ? "alpha(opacity=" + value * 100 + ")" : "",
                    filter = currentStyle && currentStyle.filter || style.filter || "";

                // IE has trouble with opacity if it does not have layout
                // Force it by setting the zoom level
                style.zoom = 1;

                // if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
                if (value >= 1 && jQuery.trim(filter.replace(ralpha, "")) === "" &&
                    style.removeAttribute) {

                    // Setting style.filter to null, "" & " " still leave "filter:" in the cssText
                    // if "filter:" is present at all, clearType is disabled, we want to avoid this
                    // style.removeAttribute is IE Only, but so apparently is this code path...
                    style.removeAttribute("filter");

                    // if there there is no filter style applied in a css rule, we are done
                    if (currentStyle && !currentStyle.filter) {
                        return;
                    }
                }

                // otherwise, set new filter values
                style.filter = ralpha.test(filter) ?
                    filter.replace(ralpha, opacity) :
                    filter + " " + opacity;
            }
        };
    }

    // These hooks cannot be added until DOM ready because the support test
    // for it is not run until after DOM ready
    jQuery(function() {
        if (!jQuery.support.reliableMarginRight) {
            jQuery.cssHooks.marginRight = {
                get: function(elem, computed) {
                    // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
                    // Work around by temporarily setting element display to inline-block
                    return jQuery.swap(elem, { "display": "inline-block" }, function() {
                        if (computed) {
                            return curCSS(elem, "marginRight");
                        }
                    });
                }
            };
        }

        // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
        // getComputedStyle returns percent when specified for top/left/bottom/right
        // rather than make the css module depend on the offset module, we just check for it here
        if (!jQuery.support.pixelPosition && jQuery.fn.position) {
            jQuery.each(["top", "left"], function(i, prop) {
                jQuery.cssHooks[prop] = {
                    get: function(elem, computed) {
                        if (computed) {
                            var ret = curCSS(elem, prop);
                            // if curCSS returns percentage, fallback to offset
                            return rnumnonpx.test(ret) ? jQuery(elem).position()[prop] + "px" : ret;
                        }
                    }
                };
            });
        }

    });

    if (jQuery.expr && jQuery.expr.filters) {
        jQuery.expr.filters.hidden = function(elem) {
            return (elem.offsetWidth === 0 && elem.offsetHeight === 0) || (!jQuery.support.reliableHiddenOffsets && ((elem.style && elem.style.display) || curCSS(elem, "display")) === "none");
        };

        jQuery.expr.filters.visible = function(elem) {
            return !jQuery.expr.filters.hidden(elem);
        };
    }

    // These hooks are used by animate to expand properties
    jQuery.each({
        margin: "",
        padding: "",
        border: "Width"
    }, function(prefix, suffix) {
        jQuery.cssHooks[prefix + suffix] = {
            expand: function(value) {
                var i,

                    // assumes a single number if not a string
                    parts = typeof value === "string" ? value.split(" ") : [value],
                    expanded = {};

                for (i = 0; i < 4; i++) {
                    expanded[prefix + cssExpand[i] + suffix] =
                        parts[i] || parts[i - 2] || parts[0];
                }

                return expanded;
            }
        };

        if (!rmargin.test(prefix)) {
            jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
        }
    });
    var r20 = /%20/g,
        rbracket = /\[\]$/,
        rCRLF = /\r?\n/g,
        rinput = /^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,
        rselectTextarea = /^(?:select|textarea)/i;

    jQuery.fn.extend({
        serialize: function() {
            return jQuery.param(this.serializeArray());
        },
        serializeArray: function() {
            return this.map(function() {
                    return this.elements ? jQuery.makeArray(this.elements) : this;
                })
                .filter(function() {
                    return this.name && !this.disabled &&
                        (this.checked || rselectTextarea.test(this.nodeName) ||
                            rinput.test(this.type));
                })
                .map(function(i, elem) {
                    var val = jQuery(this).val();

                    return val == null ?
                        null :
                        jQuery.isArray(val) ?
                        jQuery.map(val, function(val, i) {
                            return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
                        }) : { name: elem.name, value: val.replace(rCRLF, "\r\n") };
                }).get();
        }
    });

    //Serialize an array of form elements or a set of
    //key/values into a query string
    jQuery.param = function(a, traditional) {
        var prefix,
            s = [],
            add = function(key, value) {
                // If value is a function, invoke it and return its value
                value = jQuery.isFunction(value) ? value() : (value == null ? "" : value);
                s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
            };

        // Set traditional to true for jQuery <= 1.3.2 behavior.
        if (traditional === undefined) {
            traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
        }

        // If an array was passed in, assume that it is an array of form elements.
        if (jQuery.isArray(a) || (a.jquery && !jQuery.isPlainObject(a))) {
            // Serialize the form elements
            jQuery.each(a, function() {
                add(this.name, this.value);
            });

        } else {
            // If traditional, encode the "old" way (the way 1.3.2 or older
            // did it), otherwise encode params recursively.
            for (prefix in a) {
                buildParams(prefix, a[prefix], traditional, add);
            }
        }

        // Return the resulting serialization
        return s.join("&").replace(r20, "+");
    };

    function buildParams(prefix, obj, traditional, add) {
        var name;

        if (jQuery.isArray(obj)) {
            // Serialize array item.
            jQuery.each(obj, function(i, v) {
                if (traditional || rbracket.test(prefix)) {
                    // Treat each array item as a scalar.
                    add(prefix, v);

                } else {
                    // If array item is non-scalar (array or object), encode its
                    // numeric index to resolve deserialization ambiguity issues.
                    // Note that rack (as of 1.0.0) can't currently deserialize
                    // nested arrays properly, and attempting to do so may cause
                    // a server error. Possible fixes are to modify rack's
                    // deserialization algorithm or to provide an option or flag
                    // to force array serialization to be shallow.
                    buildParams(prefix + "[" + (typeof v === "object" ? i : "") + "]", v, traditional, add);
                }
            });

        } else if (!traditional && jQuery.type(obj) === "object") {
            // Serialize object item.
            for (name in obj) {
                buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
            }

        } else {
            // Serialize scalar item.
            add(prefix, obj);
        }
    }
    var
    // Document location
        ajaxLocParts,
        ajaxLocation,

        rhash = /#.*$/,
        rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
        // #7653, #8125, #8152: local protocol detection
        rlocalProtocol = /^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,
        rnoContent = /^(?:GET|HEAD)$/,
        rprotocol = /^\/\//,
        rquery = /\?/,
        rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
        rts = /([?&])_=[^&]*/,
        rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,

        // Keep a copy of the old load method
        _load = jQuery.fn.load,

        /* Prefilters
         * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
         * 2) These are called:
         *    - BEFORE asking for a transport
         *    - AFTER param serialization (s.data is a string if s.processData is true)
         * 3) key is the dataType
         * 4) the catchall symbol "*" can be used
         * 5) execution will start with transport dataType and THEN continue down to "*" if needed
         */
        prefilters = {},

        /* Transports bindings
         * 1) key is the dataType
         * 2) the catchall symbol "*" can be used
         * 3) selection will start with transport dataType and THEN go to "*" if needed
         */
        transports = {},

        // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
        allTypes = ["*/"] + ["*"];

    // #8138, IE may throw an exception when accessing
    // a field from window.location if document.domain has been set
    try {
        ajaxLocation = location.href;
    } catch (e) {
        // Use the href attribute of an A element
        // since IE will modify it given document.location
        ajaxLocation = document.createElement("a");
        ajaxLocation.href = "";
        ajaxLocation = ajaxLocation.href;
    }

    // Segment location into parts
    ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];

    // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
    function addToPrefiltersOrTransports(structure) {

        // dataTypeExpression is optional and defaults to "*"
        return function(dataTypeExpression, func) {

            if (typeof dataTypeExpression !== "string") {
                func = dataTypeExpression;
                dataTypeExpression = "*";
            }

            var dataType, list, placeBefore,
                dataTypes = dataTypeExpression.toLowerCase().split(core_rspace),
                i = 0,
                length = dataTypes.length;

            if (jQuery.isFunction(func)) {
                // For each dataType in the dataTypeExpression
                for (; i < length; i++) {
                    dataType = dataTypes[i];
                    // We control if we're asked to add before
                    // any existing element
                    placeBefore = /^\+/.test(dataType);
                    if (placeBefore) {
                        dataType = dataType.substr(1) || "*";
                    }
                    list = structure[dataType] = structure[dataType] || [];
                    // then we add to the structure accordingly
                    list[placeBefore ? "unshift" : "push"](func);
                }
            }
        };
    }

    // Base inspection function for prefilters and transports
    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR,
        dataType /* internal */ , inspected /* internal */ ) {

        dataType = dataType || options.dataTypes[0];
        inspected = inspected || {};

        inspected[dataType] = true;

        var selection,
            list = structure[dataType],
            i = 0,
            length = list ? list.length : 0,
            executeOnly = (structure === prefilters);

        for (; i < length && (executeOnly || !selection); i++) {
            selection = list[i](options, originalOptions, jqXHR);
            // If we got redirected to another dataType
            // we try there if executing only and not done already
            if (typeof selection === "string") {
                if (!executeOnly || inspected[selection]) {
                    selection = undefined;
                } else {
                    options.dataTypes.unshift(selection);
                    selection = inspectPrefiltersOrTransports(
                        structure, options, originalOptions, jqXHR, selection, inspected);
                }
            }
        }
        // If we're only executing or nothing was selected
        // we try the catchall dataType if not done already
        if ((executeOnly || !selection) && !inspected["*"]) {
            selection = inspectPrefiltersOrTransports(
                structure, options, originalOptions, jqXHR, "*", inspected);
        }
        // unnecessary when only executing (prefilters)
        // but it'll be ignored by the caller in that case
        return selection;
    }

    // A special extend for ajax options
    // that takes "flat" options (not to be deep extended)
    // Fixes #9887
    function ajaxExtend(target, src) {
        var key, deep,
            flatOptions = jQuery.ajaxSettings.flatOptions || {};
        for (key in src) {
            if (src[key] !== undefined) {
                (flatOptions[key] ? target : (deep || (deep = {})))[key] = src[key];
            }
        }
        if (deep) {
            jQuery.extend(true, target, deep);
        }
    }

    jQuery.fn.load = function(url, params, callback) {
        if (typeof url !== "string" && _load) {
            return _load.apply(this, arguments);
        }

        // Don't do a request if no elements are being requested
        if (!this.length) {
            return this;
        }

        var selector, type, response,
            self = this,
            off = url.indexOf(" ");

        if (off >= 0) {
            selector = url.slice(off, url.length);
            url = url.slice(0, off);
        }

        // If it's a function
        if (jQuery.isFunction(params)) {

            // We assume that it's the callback
            callback = params;
            params = undefined;

            // Otherwise, build a param string
        } else if (params && typeof params === "object") {
            type = "POST";
        }

        // Request the remote document
        jQuery.ajax({
            url: url,

            // if "type" variable is undefined, then "GET" method will be used
            type: type,
            dataType: "html",
            data: params,
            complete: function(jqXHR, status) {
                if (callback) {
                    self.each(callback, response || [jqXHR.responseText, status, jqXHR]);
                }
            }
        }).done(function(responseText) {

            // Save response for use in complete callback
            response = arguments;

            // See if a selector was specified
            self.html(selector ?

                // Create a dummy div to hold the results
                jQuery("<div>")

                // inject the contents of the document in, removing the scripts
                // to avoid any 'Permission Denied' errors in IE
                .append(responseText.replace(rscript, ""))

                // Locate the specified elements
                .find(selector) :

                // If not, just inject the full result
                responseText);

        });

        return this;
    };

    // Attach a bunch of functions for handling common AJAX events
    jQuery.each("ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split(" "), function(i, o) {
        jQuery.fn[o] = function(f) {
            return this.on(o, f);
        };
    });

    jQuery.each(["get", "post"], function(i, method) {
        jQuery[method] = function(url, data, callback, type) {
            // shift arguments if data argument was omitted
            if (jQuery.isFunction(data)) {
                type = type || callback;
                callback = data;
                data = undefined;
            }

            return jQuery.ajax({
                type: method,
                url: url,
                data: data,
                success: callback,
                dataType: type
            });
        };
    });

    jQuery.extend({

        getScript: function(url, callback) {
            return jQuery.get(url, undefined, callback, "script");
        },

        getJSON: function(url, data, callback) {
            return jQuery.get(url, data, callback, "json");
        },

        // Creates a full fledged settings object into target
        // with both ajaxSettings and settings fields.
        // If target is omitted, writes into ajaxSettings.
        ajaxSetup: function(target, settings) {
            if (settings) {
                // Building a settings object
                ajaxExtend(target, jQuery.ajaxSettings);
            } else {
                // Extending ajaxSettings
                settings = target;
                target = jQuery.ajaxSettings;
            }
            ajaxExtend(target, settings);
            return target;
        },

        ajaxSettings: {
            url: ajaxLocation,
            isLocal: rlocalProtocol.test(ajaxLocParts[1]),
            global: true,
            type: "GET",
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            processData: true,
            async: true,
            /*
            timeout: 0,
            data: null,
            dataType: null,
            username: null,
            password: null,
            cache: null,
            throws: false,
            traditional: false,
            headers: {},
            */

            accepts: {
                xml: "application/xml, text/xml",
                html: "text/html",
                text: "text/plain",
                json: "application/json, text/javascript",
                "*": allTypes
            },

            contents: {
                xml: /xml/,
                html: /html/,
                json: /json/
            },

            responseFields: {
                xml: "responseXML",
                text: "responseText"
            },

            // List of data converters
            // 1) key format is "source_type destination_type" (a single space in-between)
            // 2) the catchall symbol "*" can be used for source_type
            converters: {

                // Convert anything to text
                "* text": window.String,

                // Text to html (true = no transformation)
                "text html": true,

                // Evaluate text as a json expression
                "text json": jQuery.parseJSON,

                // Parse text as xml
                "text xml": jQuery.parseXML
            },

            // For options that shouldn't be deep extended:
            // you can add your own custom options here if
            // and when you create one that shouldn't be
            // deep extended (see ajaxExtend)
            flatOptions: {
                context: true,
                url: true
            }
        },

        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),

        // Main method
        ajax: function(url, options) {

            // If url is an object, simulate pre-1.5 signature
            if (typeof url === "object") {
                options = url;
                url = undefined;
            }

            // Force options to be an object
            options = options || {};

            var // ifModified key
                ifModifiedKey,
                // Response headers
                responseHeadersString,
                responseHeaders,
                // transport
                transport,
                // timeout handle
                timeoutTimer,
                // Cross-domain detection vars
                parts,
                // To know if global events are to be dispatched
                fireGlobals,
                // Loop variable
                i,
                // Create the final options object
                s = jQuery.ajaxSetup({}, options),
                // Callbacks context
                callbackContext = s.context || s,
                // Context for global events
                // It's the callbackContext if one was provided in the options
                // and if it's a DOM node or a jQuery collection
                globalEventContext = callbackContext !== s &&
                (callbackContext.nodeType || callbackContext instanceof jQuery) ?
                jQuery(callbackContext) : jQuery.event,
                // Deferreds
                deferred = jQuery.Deferred(),
                completeDeferred = jQuery.Callbacks("once memory"),
                // Status-dependent callbacks
                statusCode = s.statusCode || {},
                // Headers (they are sent all at once)
                requestHeaders = {},
                requestHeadersNames = {},
                // The jqXHR state
                state = 0,
                // Default abort message
                strAbort = "canceled",
                // Fake xhr
                jqXHR = {

                    readyState: 0,

                    // Caches the header
                    setRequestHeader: function(name, value) {
                        if (!state) {
                            var lname = name.toLowerCase();
                            name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
                            requestHeaders[name] = value;
                        }
                        return this;
                    },

                    // Raw string
                    getAllResponseHeaders: function() {
                        return state === 2 ? responseHeadersString : null;
                    },

                    // Builds headers hashtable if needed
                    getResponseHeader: function(key) {
                        var match;
                        if (state === 2) {
                            if (!responseHeaders) {
                                responseHeaders = {};
                                while ((match = rheaders.exec(responseHeadersString))) {
                                    responseHeaders[match[1].toLowerCase()] = match[2];
                                }
                            }
                            match = responseHeaders[key.toLowerCase()];
                        }
                        return match === undefined ? null : match;
                    },

                    // Overrides response content-type header
                    overrideMimeType: function(type) {
                        if (!state) {
                            s.mimeType = type;
                        }
                        return this;
                    },

                    // Cancel the request
                    abort: function(statusText) {
                        statusText = statusText || strAbort;
                        if (transport) {
                            transport.abort(statusText);
                        }
                        done(0, statusText);
                        return this;
                    }
                };

            // Callback for when everything is done
            // It is defined here because jslint complains if it is declared
            // at the end of the function (which would be more logical and readable)
            function done(status, nativeStatusText, responses, headers) {
                var isSuccess, success, error, response, modified,
                    statusText = nativeStatusText;

                // Called once
                if (state === 2) {
                    return;
                }

                // State is "done" now
                state = 2;

                // Clear timeout if it exists
                if (timeoutTimer) {
                    clearTimeout(timeoutTimer);
                }

                // Dereference transport for early garbage collection
                // (no matter how long the jqXHR object will be used)
                transport = undefined;

                // Cache response headers
                responseHeadersString = headers || "";

                // Set readyState
                jqXHR.readyState = status > 0 ? 4 : 0;

                // Get response data
                if (responses) {
                    response = ajaxHandleResponses(s, jqXHR, responses);
                }

                // If successful, handle type chaining
                if (status >= 200 && status < 300 || status === 304) {

                    // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                    if (s.ifModified) {

                        modified = jqXHR.getResponseHeader("Last-Modified");
                        if (modified) {
                            jQuery.lastModified[ifModifiedKey] = modified;
                        }
                        modified = jqXHR.getResponseHeader("Etag");
                        if (modified) {
                            jQuery.etag[ifModifiedKey] = modified;
                        }
                    }

                    // If not modified
                    if (status === 304) {

                        statusText = "notmodified";
                        isSuccess = true;

                        // If we have data
                    } else {

                        isSuccess = ajaxConvert(s, response);
                        statusText = isSuccess.state;
                        success = isSuccess.data;
                        error = isSuccess.error;
                        isSuccess = !error;
                    }
                } else {
                    // We extract error from statusText
                    // then normalize statusText and status for non-aborts
                    error = statusText;
                    if (!statusText || status) {
                        statusText = "error";
                        if (status < 0) {
                            status = 0;
                        }
                    }
                }

                // Set data for the fake xhr object
                jqXHR.status = status;
                jqXHR.statusText = (nativeStatusText || statusText) + "";

                // Success/Error
                if (isSuccess) {
                    deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
                } else {
                    deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
                }

                // Status-dependent callbacks
                jqXHR.statusCode(statusCode);
                statusCode = undefined;

                if (fireGlobals) {
                    globalEventContext.trigger("ajax" + (isSuccess ? "Success" : "Error"), [jqXHR, s, isSuccess ? success : error]);
                }

                // Complete
                completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);

                if (fireGlobals) {
                    globalEventContext.trigger("ajaxComplete", [jqXHR, s]);
                    // Handle the global AJAX counter
                    if (!(--jQuery.active)) {
                        jQuery.event.trigger("ajaxStop");
                    }
                }
            }

            // Attach deferreds
            deferred.promise(jqXHR);
            jqXHR.success = jqXHR.done;
            jqXHR.error = jqXHR.fail;
            jqXHR.complete = completeDeferred.add;

            // Status-dependent callbacks
            jqXHR.statusCode = function(map) {
                if (map) {
                    var tmp;
                    if (state < 2) {
                        for (tmp in map) {
                            statusCode[tmp] = [statusCode[tmp], map[tmp]];
                        }
                    } else {
                        tmp = map[jqXHR.status];
                        jqXHR.always(tmp);
                    }
                }
                return this;
            };

            // Remove hash character (#7531: and string promotion)
            // Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
            // We also use the url parameter if available
            s.url = ((url || s.url) + "").replace(rhash, "").replace(rprotocol, ajaxLocParts[1] + "//");

            // Extract dataTypes list
            s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().split(core_rspace);

            // A cross-domain request is in order when we have a protocol:host:port mismatch
            if (s.crossDomain == null) {
                parts = rurl.exec(s.url.toLowerCase());
                s.crossDomain = !!(parts &&
                    (parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] ||
                        (parts[3] || (parts[1] === "http:" ? 80 : 443)) !=
                        (ajaxLocParts[3] || (ajaxLocParts[1] === "http:" ? 80 : 443)))
                );
            }

            // Convert data if not already a string
            if (s.data && s.processData && typeof s.data !== "string") {
                s.data = jQuery.param(s.data, s.traditional);
            }

            // Apply prefilters
            inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);

            // If request was aborted inside a prefilter, stop there
            if (state === 2) {
                return jqXHR;
            }

            // We can fire global events as of now if asked to
            fireGlobals = s.global;

            // Uppercase the type
            s.type = s.type.toUpperCase();

            // Determine if request has content
            s.hasContent = !rnoContent.test(s.type);

            // Watch for a new set of requests
            if (fireGlobals && jQuery.active++ === 0) {
                jQuery.event.trigger("ajaxStart");
            }

            // More options handling for requests with no content
            if (!s.hasContent) {

                // If data is available, append data to url
                if (s.data) {
                    s.url += (rquery.test(s.url) ? "&" : "?") + s.data;
                    // #9682: remove data so that it's not used in an eventual retry
                    delete s.data;
                }

                // Get ifModifiedKey before adding the anti-cache parameter
                ifModifiedKey = s.url;

                // Add anti-cache in url if needed
                if (s.cache === false) {

                    var ts = jQuery.now(),
                        // try replacing _= if it is there
                        ret = s.url.replace(rts, "$1_=" + ts);

                    // if nothing was replaced, add timestamp to the end
                    s.url = ret + ((ret === s.url) ? (rquery.test(s.url) ? "&" : "?") + "_=" + ts : "");
                }
            }

            // Set the correct header, if data is being sent
            if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
                jqXHR.setRequestHeader("Content-Type", s.contentType);
            }

            // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
            if (s.ifModified) {
                ifModifiedKey = ifModifiedKey || s.url;
                if (jQuery.lastModified[ifModifiedKey]) {
                    jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[ifModifiedKey]);
                }
                if (jQuery.etag[ifModifiedKey]) {
                    jqXHR.setRequestHeader("If-None-Match", jQuery.etag[ifModifiedKey]);
                }
            }

            // Set the Accepts header for the server, depending on the dataType
            jqXHR.setRequestHeader(
                "Accept",
                s.dataTypes[0] && s.accepts[s.dataTypes[0]] ?
                s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") :
                s.accepts["*"]
            );

            // Check for headers option
            for (i in s.headers) {
                jqXHR.setRequestHeader(i, s.headers[i]);
            }

            // Allow custom headers/mimetypes and early abort
            if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
                // Abort if not done already and return
                return jqXHR.abort();

            }

            // aborting is no longer a cancellation
            strAbort = "abort";

            // Install callbacks on deferreds
            for (i in { success: 1, error: 1, complete: 1 }) {
                jqXHR[i](s[i]);
            }

            // Get transport
            transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);

            // If no transport, we auto-abort
            if (!transport) {
                done(-1, "No Transport");
            } else {
                jqXHR.readyState = 1;
                // Send global event
                if (fireGlobals) {
                    globalEventContext.trigger("ajaxSend", [jqXHR, s]);
                }
                // Timeout
                if (s.async && s.timeout > 0) {
                    timeoutTimer = setTimeout(function() {
                        jqXHR.abort("timeout");
                    }, s.timeout);
                }

                try {
                    state = 1;
                    transport.send(requestHeaders, done);
                } catch (e) {
                    // Propagate exception as error if not done
                    if (state < 2) {
                        done(-1, e);
                        // Simply rethrow otherwise
                    } else {
                        throw e;
                    }
                }
            }

            return jqXHR;
        },

        // Counter for holding the number of active queries
        active: 0,

        // Last-Modified header cache for next request
        lastModified: {},
        etag: {}

    });

    /* Handles responses to an ajax request:
     * - sets all responseXXX fields accordingly
     * - finds the right dataType (mediates between content-type and expected dataType)
     * - returns the corresponding response
     */
    function ajaxHandleResponses(s, jqXHR, responses) {

        var ct, type, finalDataType, firstDataType,
            contents = s.contents,
            dataTypes = s.dataTypes,
            responseFields = s.responseFields;

        // Fill responseXXX fields
        for (type in responseFields) {
            if (type in responses) {
                jqXHR[responseFields[type]] = responses[type];
            }
        }

        // Remove auto dataType and get content-type in the process
        while (dataTypes[0] === "*") {
            dataTypes.shift();
            if (ct === undefined) {
                ct = s.mimeType || jqXHR.getResponseHeader("content-type");
            }
        }

        // Check if we're dealing with a known content-type
        if (ct) {
            for (type in contents) {
                if (contents[type] && contents[type].test(ct)) {
                    dataTypes.unshift(type);
                    break;
                }
            }
        }

        // Check to see if we have a response for the expected dataType
        if (dataTypes[0] in responses) {
            finalDataType = dataTypes[0];
        } else {
            // Try convertible dataTypes
            for (type in responses) {
                if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
                    finalDataType = type;
                    break;
                }
                if (!firstDataType) {
                    firstDataType = type;
                }
            }
            // Or just use first one
            finalDataType = finalDataType || firstDataType;
        }

        // If we found a dataType
        // We add the dataType to the list if needed
        // and return the corresponding response
        if (finalDataType) {
            if (finalDataType !== dataTypes[0]) {
                dataTypes.unshift(finalDataType);
            }
            return responses[finalDataType];
        }
    }

    // Chain conversions given the request and the original response
    function ajaxConvert(s, response) {

        var conv, conv2, current, tmp,
            // Work with a copy of dataTypes in case we need to modify it for conversion
            dataTypes = s.dataTypes.slice(),
            prev = dataTypes[0],
            converters = {},
            i = 0;

        // Apply the dataFilter if provided
        if (s.dataFilter) {
            response = s.dataFilter(response, s.dataType);
        }

        // Create converters map with lowercased keys
        if (dataTypes[1]) {
            for (conv in s.converters) {
                converters[conv.toLowerCase()] = s.converters[conv];
            }
        }

        // Convert to each sequential dataType, tolerating list modification
        for (;
            (current = dataTypes[++i]);) {

            // There's only work to do if current dataType is non-auto
            if (current !== "*") {

                // Convert response if prev dataType is non-auto and differs from current
                if (prev !== "*" && prev !== current) {

                    // Seek a direct converter
                    conv = converters[prev + " " + current] || converters["* " + current];

                    // If none found, seek a pair
                    if (!conv) {
                        for (conv2 in converters) {

                            // If conv2 outputs current
                            tmp = conv2.split(" ");
                            if (tmp[1] === current) {

                                // If prev can be converted to accepted input
                                conv = converters[prev + " " + tmp[0]] ||
                                    converters["* " + tmp[0]];
                                if (conv) {
                                    // Condense equivalence converters
                                    if (conv === true) {
                                        conv = converters[conv2];

                                        // Otherwise, insert the intermediate dataType
                                    } else if (converters[conv2] !== true) {
                                        current = tmp[0];
                                        dataTypes.splice(i--, 0, current);
                                    }

                                    break;
                                }
                            }
                        }
                    }

                    // Apply converter (if not an equivalence)
                    if (conv !== true) {

                        // Unless errors are allowed to bubble, catch and return them
                        if (conv && s["throws"]) {
                            response = conv(response);
                        } else {
                            try {
                                response = conv(response);
                            } catch (e) {
                                return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
                            }
                        }
                    }
                }

                // Update prev for next iteration
                prev = current;
            }
        }

        return { state: "success", data: response };
    }
    var oldCallbacks = [],
        rquestion = /\?/,
        rjsonp = /(=)\?(?=&|$)|\?\?/,
        nonce = jQuery.now();

    // Default jsonp settings
    jQuery.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function() {
            var callback = oldCallbacks.pop() || (jQuery.expando + "_" + (nonce++));
            this[callback] = true;
            return callback;
        }
    });

    // Detect, normalize options and install callbacks for jsonp requests
    jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {

        var callbackName, overwritten, responseContainer,
            data = s.data,
            url = s.url,
            hasCallback = s.jsonp !== false,
            replaceInUrl = hasCallback && rjsonp.test(url),
            replaceInData = hasCallback && !replaceInUrl && typeof data === "string" &&
            !(s.contentType || "").indexOf("application/x-www-form-urlencoded") &&
            rjsonp.test(data);

        // Handle iff the expected data type is "jsonp" or we have a parameter to set
        if (s.dataTypes[0] === "jsonp" || replaceInUrl || replaceInData) {

            // Get callback name, remembering preexisting value associated with it
            callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ?
                s.jsonpCallback() :
                s.jsonpCallback;
            overwritten = window[callbackName];

            // Insert callback into url or form data
            if (replaceInUrl) {
                s.url = url.replace(rjsonp, "$1" + callbackName);
            } else if (replaceInData) {
                s.data = data.replace(rjsonp, "$1" + callbackName);
            } else if (hasCallback) {
                s.url += (rquestion.test(url) ? "&" : "?") + s.jsonp + "=" + callbackName;
            }

            // Use data converter to retrieve json after script execution
            s.converters["script json"] = function() {
                if (!responseContainer) {
                    jQuery.error(callbackName + " was not called");
                }
                return responseContainer[0];
            };

            // force json dataType
            s.dataTypes[0] = "json";

            // Install callback
            window[callbackName] = function() {
                responseContainer = arguments;
            };

            // Clean-up function (fires after converters)
            jqXHR.always(function() {
                // Restore preexisting value
                window[callbackName] = overwritten;

                // Save back as free
                if (s[callbackName]) {
                    // make sure that re-using the options doesn't screw things around
                    s.jsonpCallback = originalSettings.jsonpCallback;

                    // save the callback name for future use
                    oldCallbacks.push(callbackName);
                }

                // Call if it was a function and we have a response
                if (responseContainer && jQuery.isFunction(overwritten)) {
                    overwritten(responseContainer[0]);
                }

                responseContainer = overwritten = undefined;
            });

            // Delegate to script
            return "script";
        }
    });
    // Install script dataType
    jQuery.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /javascript|ecmascript/
        },
        converters: {
            "text script": function(text) {
                jQuery.globalEval(text);
                return text;
            }
        }
    });

    // Handle cache's special case and global
    jQuery.ajaxPrefilter("script", function(s) {
        if (s.cache === undefined) {
            s.cache = false;
        }
        if (s.crossDomain) {
            s.type = "GET";
            s.global = false;
        }
    });

    // Bind script tag hack transport
    jQuery.ajaxTransport("script", function(s) {

        // This transport only deals with cross domain requests
        if (s.crossDomain) {

            var script,
                head = document.head || document.getElementsByTagName("head")[0] || document.documentElement;

            return {

                send: function(_, callback) {

                    script = document.createElement("script");

                    script.async = "async";

                    if (s.scriptCharset) {
                        script.charset = s.scriptCharset;
                    }

                    script.src = s.url;

                    // Attach handlers for all browsers
                    script.onload = script.onreadystatechange = function(_, isAbort) {

                        if (isAbort || !script.readyState || /loaded|complete/.test(script.readyState)) {

                            // Handle memory leak in IE
                            script.onload = script.onreadystatechange = null;

                            // Remove the script
                            if (head && script.parentNode) {
                                head.removeChild(script);
                            }

                            // Dereference the script
                            script = undefined;

                            // Callback if not abort
                            if (!isAbort) {
                                callback(200, "success");
                            }
                        }
                    };
                    // Use insertBefore instead of appendChild  to circumvent an IE6 bug.
                    // This arises when a base node is used (#2709 and #4378).
                    head.insertBefore(script, head.firstChild);
                },

                abort: function() {
                    if (script) {
                        script.onload(0, 1);
                    }
                }
            };
        }
    });
    var xhrCallbacks,
        // #5280: Internet Explorer will keep connections alive if we don't abort on unload
        xhrOnUnloadAbort = window.ActiveXObject ? function() {
            // Abort all pending requests
            for (var key in xhrCallbacks) {
                xhrCallbacks[key](0, 1);
            }
        } : false,
        xhrId = 0;

    // Functions to create xhrs
    function createStandardXHR() {
        try {
            return new window.XMLHttpRequest();
        } catch (e) {}
    }

    function createActiveXHR() {
        try {
            return new window.ActiveXObject("Microsoft.XMLHTTP");
        } catch (e) {}
    }

    // Create the request object
    // (This is still attached to ajaxSettings for backward compatibility)
    jQuery.ajaxSettings.xhr = window.ActiveXObject ?
        /* Microsoft failed to properly
         * implement the XMLHttpRequest in IE7 (can't request local files),
         * so we use the ActiveXObject when it is available
         * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
         * we need a fallback.
         */
        function() {
            return !this.isLocal && createStandardXHR() || createActiveXHR();
        } :
        // For all other browsers, use the standard XMLHttpRequest object
        createStandardXHR;

    // Determine support properties
    (function(xhr) {
        jQuery.extend(jQuery.support, {
            ajax: !!xhr,
            cors: !!xhr && ("withCredentials" in xhr)
        });
    })(jQuery.ajaxSettings.xhr());

    // Create transport if the browser can provide an xhr
    if (jQuery.support.ajax) {

        jQuery.ajaxTransport(function(s) {
            // Cross domain only allowed if supported through XMLHttpRequest
            if (!s.crossDomain || jQuery.support.cors) {

                var callback;

                return {
                    send: function(headers, complete) {

                        // Get a new xhr
                        var handle, i,
                            xhr = s.xhr();

                        // Open the socket
                        // Passing null username, generates a login popup on Opera (#2865)
                        if (s.username) {
                            xhr.open(s.type, s.url, s.async, s.username, s.password);
                        } else {
                            xhr.open(s.type, s.url, s.async);
                        }

                        // Apply custom fields if provided
                        if (s.xhrFields) {
                            for (i in s.xhrFields) {
                                xhr[i] = s.xhrFields[i];
                            }
                        }

                        // Override mime type if needed
                        if (s.mimeType && xhr.overrideMimeType) {
                            xhr.overrideMimeType(s.mimeType);
                        }

                        // X-Requested-With header
                        // For cross-domain requests, seeing as conditions for a preflight are
                        // akin to a jigsaw puzzle, we simply never set it to be sure.
                        // (it can always be set on a per-request basis or even using ajaxSetup)
                        // For same-domain requests, won't change header if already provided.
                        if (!s.crossDomain && !headers["X-Requested-With"]) {
                            headers["X-Requested-With"] = "XMLHttpRequest";
                        }

                        // Need an extra try/catch for cross domain requests in Firefox 3
                        try {
                            for (i in headers) {
                                xhr.setRequestHeader(i, headers[i]);
                            }
                        } catch (_) {}

                        // Do send the request
                        // This may raise an exception which is actually
                        // handled in jQuery.ajax (so no try/catch here)
                        xhr.send((s.hasContent && s.data) || null);

                        // Listener
                        callback = function(_, isAbort) {

                            var status,
                                statusText,
                                responseHeaders,
                                responses,
                                xml;

                            // Firefox throws exceptions when accessing properties
                            // of an xhr when a network error occurred
                            // http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)
                            try {

                                // Was never called and is aborted or complete
                                if (callback && (isAbort || xhr.readyState === 4)) {

                                    // Only called once
                                    callback = undefined;

                                    // Do not keep as active anymore
                                    if (handle) {
                                        xhr.onreadystatechange = jQuery.noop;
                                        if (xhrOnUnloadAbort) {
                                            delete xhrCallbacks[handle];
                                        }
                                    }

                                    // If it's an abort
                                    if (isAbort) {
                                        // Abort it manually if needed
                                        if (xhr.readyState !== 4) {
                                            xhr.abort();
                                        }
                                    } else {
                                        status = xhr.status;
                                        responseHeaders = xhr.getAllResponseHeaders();
                                        responses = {};
                                        xml = xhr.responseXML;

                                        // Construct response list
                                        if (xml && xml.documentElement /* #4958 */ ) {
                                            responses.xml = xml;
                                        }

                                        // When requesting binary data, IE6-9 will throw an exception
                                        // on any attempt to access responseText (#11426)
                                        try {
                                            responses.text = xhr.responseText;
                                        } catch (e) {}

                                        // Firefox throws an exception when accessing
                                        // statusText for faulty cross-domain requests
                                        try {
                                            statusText = xhr.statusText;
                                        } catch (e) {
                                            // We normalize with Webkit giving an empty statusText
                                            statusText = "";
                                        }

                                        // Filter status for non standard behaviors

                                        // If the request is local and we have data: assume a success
                                        // (success with no data won't get notified, that's the best we
                                        // can do given current implementations)
                                        if (!status && s.isLocal && !s.crossDomain) {
                                            status = responses.text ? 200 : 404;
                                            // IE - #1450: sometimes returns 1223 when it should be 204
                                        } else if (status === 1223) {
                                            status = 204;
                                        }
                                    }
                                }
                            } catch (firefoxAccessException) {
                                if (!isAbort) {
                                    complete(-1, firefoxAccessException);
                                }
                            }

                            // Call complete if needed
                            if (responses) {
                                complete(status, statusText, responses, responseHeaders);
                            }
                        };

                        if (!s.async) {
                            // if we're in sync mode we fire the callback
                            callback();
                        } else if (xhr.readyState === 4) {
                            // (IE6 & IE7) if it's in cache and has been
                            // retrieved directly we need to fire the callback
                            setTimeout(callback, 0);
                        } else {
                            handle = ++xhrId;
                            if (xhrOnUnloadAbort) {
                                // Create the active xhrs callbacks list if needed
                                // and attach the unload handler
                                if (!xhrCallbacks) {
                                    xhrCallbacks = {};
                                    jQuery(window).unload(xhrOnUnloadAbort);
                                }
                                // Add to list of active xhrs callbacks
                                xhrCallbacks[handle] = callback;
                            }
                            xhr.onreadystatechange = callback;
                        }
                    },

                    abort: function() {
                        if (callback) {
                            callback(0, 1);
                        }
                    }
                };
            }
        });
    }
    var fxNow, timerId,
        rfxtypes = /^(?:toggle|show|hide)$/,
        rfxnum = new RegExp("^(?:([-+])=|)(" + core_pnum + ")([a-z%]*)$", "i"),
        rrun = /queueHooks$/,
        animationPrefilters = [defaultPrefilter],
        tweeners = {
            "*": [function(prop, value) {
                var end, unit,
                    tween = this.createTween(prop, value),
                    parts = rfxnum.exec(value),
                    target = tween.cur(),
                    start = +target || 0,
                    scale = 1,
                    maxIterations = 20;

                if (parts) {
                    end = +parts[2];
                    unit = parts[3] || (jQuery.cssNumber[prop] ? "" : "px");

                    // We need to compute starting value
                    if (unit !== "px" && start) {
                        // Iteratively approximate from a nonzero starting point
                        // Prefer the current property, because this process will be trivial if it uses the same units
                        // Fallback to end or a simple constant
                        start = jQuery.css(tween.elem, prop, true) || end || 1;

                        do {
                            // If previous iteration zeroed out, double until we get *something*
                            // Use a string for doubling factor so we don't accidentally see scale as unchanged below
                            scale = scale || ".5";

                            // Adjust and apply
                            start = start / scale;
                            jQuery.style(tween.elem, prop, start + unit);

                            // Update scale, tolerating zero or NaN from tween.cur()
                            // And breaking the loop if scale is unchanged or perfect, or if we've just had enough
                        } while (scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations);
                    }

                    tween.unit = unit;
                    tween.start = start;
                    // If a +=/-= token was provided, we're doing a relative animation
                    tween.end = parts[1] ? start + (parts[1] + 1) * end : end;
                }
                return tween;
            }]
        };

    // Animations created synchronously will run synchronously
    function createFxNow() {
        setTimeout(function() {
            fxNow = undefined;
        }, 0);
        return (fxNow = jQuery.now());
    }

    function createTweens(animation, props) {
        jQuery.each(props, function(prop, value) {
            var collection = (tweeners[prop] || []).concat(tweeners["*"]),
                index = 0,
                length = collection.length;
            for (; index < length; index++) {
                if (collection[index].call(animation, prop, value)) {

                    // we're done with this property
                    return;
                }
            }
        });
    }

    function Animation(elem, properties, options) {
        var result,
            index = 0,
            tweenerIndex = 0,
            length = animationPrefilters.length,
            deferred = jQuery.Deferred().always(function() {
                // don't match elem in the :animated selector
                delete tick.elem;
            }),
            tick = function() {
                var currentTime = fxNow || createFxNow(),
                    remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
                    // archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)
                    temp = remaining / animation.duration || 0,
                    percent = 1 - temp,
                    index = 0,
                    length = animation.tweens.length;

                for (; index < length; index++) {
                    animation.tweens[index].run(percent);
                }

                deferred.notifyWith(elem, [animation, percent, remaining]);

                if (percent < 1 && length) {
                    return remaining;
                } else {
                    deferred.resolveWith(elem, [animation]);
                    return false;
                }
            },
            animation = deferred.promise({
                elem: elem,
                props: jQuery.extend({}, properties),
                opts: jQuery.extend(true, { specialEasing: {} }, options),
                originalProperties: properties,
                originalOptions: options,
                startTime: fxNow || createFxNow(),
                duration: options.duration,
                tweens: [],
                createTween: function(prop, end, easing) {
                    var tween = jQuery.Tween(elem, animation.opts, prop, end,
                        animation.opts.specialEasing[prop] || animation.opts.easing);
                    animation.tweens.push(tween);
                    return tween;
                },
                stop: function(gotoEnd) {
                    var index = 0,
                        // if we are going to the end, we want to run all the tweens
                        // otherwise we skip this part
                        length = gotoEnd ? animation.tweens.length : 0;

                    for (; index < length; index++) {
                        animation.tweens[index].run(1);
                    }

                    // resolve when we played the last frame
                    // otherwise, reject
                    if (gotoEnd) {
                        deferred.resolveWith(elem, [animation, gotoEnd]);
                    } else {
                        deferred.rejectWith(elem, [animation, gotoEnd]);
                    }
                    return this;
                }
            }),
            props = animation.props;

        propFilter(props, animation.opts.specialEasing);

        for (; index < length; index++) {
            result = animationPrefilters[index].call(animation, elem, props, animation.opts);
            if (result) {
                return result;
            }
        }

        createTweens(animation, props);

        if (jQuery.isFunction(animation.opts.start)) {
            animation.opts.start.call(elem, animation);
        }

        jQuery.fx.timer(
            jQuery.extend(tick, {
                anim: animation,
                queue: animation.opts.queue,
                elem: elem
            })
        );

        // attach callbacks from options
        return animation.progress(animation.opts.progress)
            .done(animation.opts.done, animation.opts.complete)
            .fail(animation.opts.fail)
            .always(animation.opts.always);
    }

    function propFilter(props, specialEasing) {
        var index, name, easing, value, hooks;

        // camelCase, specialEasing and expand cssHook pass
        for (index in props) {
            name = jQuery.camelCase(index);
            easing = specialEasing[name];
            value = props[index];
            if (jQuery.isArray(value)) {
                easing = value[1];
                value = props[index] = value[0];
            }

            if (index !== name) {
                props[name] = value;
                delete props[index];
            }

            hooks = jQuery.cssHooks[name];
            if (hooks && "expand" in hooks) {
                value = hooks.expand(value);
                delete props[name];

                // not quite $.extend, this wont overwrite keys already present.
                // also - reusing 'index' from above because we have the correct "name"
                for (index in value) {
                    if (!(index in props)) {
                        props[index] = value[index];
                        specialEasing[index] = easing;
                    }
                }
            } else {
                specialEasing[name] = easing;
            }
        }
    }

    jQuery.Animation = jQuery.extend(Animation, {

        tweener: function(props, callback) {
            if (jQuery.isFunction(props)) {
                callback = props;
                props = ["*"];
            } else {
                props = props.split(" ");
            }

            var prop,
                index = 0,
                length = props.length;

            for (; index < length; index++) {
                prop = props[index];
                tweeners[prop] = tweeners[prop] || [];
                tweeners[prop].unshift(callback);
            }
        },

        prefilter: function(callback, prepend) {
            if (prepend) {
                animationPrefilters.unshift(callback);
            } else {
                animationPrefilters.push(callback);
            }
        }
    });

    function defaultPrefilter(elem, props, opts) {
        var index, prop, value, length, dataShow, toggle, tween, hooks, oldfire,
            anim = this,
            style = elem.style,
            orig = {},
            handled = [],
            hidden = elem.nodeType && isHidden(elem);

        // handle queue: false promises
        if (!opts.queue) {
            hooks = jQuery._queueHooks(elem, "fx");
            if (hooks.unqueued == null) {
                hooks.unqueued = 0;
                oldfire = hooks.empty.fire;
                hooks.empty.fire = function() {
                    if (!hooks.unqueued) {
                        oldfire();
                    }
                };
            }
            hooks.unqueued++;

            anim.always(function() {
                // doing this makes sure that the complete handler will be called
                // before this completes
                anim.always(function() {
                    hooks.unqueued--;
                    if (!jQuery.queue(elem, "fx").length) {
                        hooks.empty.fire();
                    }
                });
            });
        }

        // height/width overflow pass
        if (elem.nodeType === 1 && ("height" in props || "width" in props)) {
            // Make sure that nothing sneaks out
            // Record all 3 overflow attributes because IE does not
            // change the overflow attribute when overflowX and
            // overflowY are set to the same value
            opts.overflow = [style.overflow, style.overflowX, style.overflowY];

            // Set display property to inline-block for height/width
            // animations on inline elements that are having width/height animated
            if (jQuery.css(elem, "display") === "inline" &&
                jQuery.css(elem, "float") === "none") {

                // inline-level elements accept inline-block;
                // block-level elements need to be inline with layout
                if (!jQuery.support.inlineBlockNeedsLayout || css_defaultDisplay(elem.nodeName) === "inline") {
                    style.display = "inline-block";

                } else {
                    style.zoom = 1;
                }
            }
        }

        if (opts.overflow) {
            style.overflow = "hidden";
            if (!jQuery.support.shrinkWrapBlocks) {
                anim.done(function() {
                    style.overflow = opts.overflow[0];
                    style.overflowX = opts.overflow[1];
                    style.overflowY = opts.overflow[2];
                });
            }
        }


        // show/hide pass
        for (index in props) {
            value = props[index];
            if (rfxtypes.exec(value)) {
                delete props[index];
                toggle = toggle || value === "toggle";
                if (value === (hidden ? "hide" : "show")) {
                    continue;
                }
                handled.push(index);
            }
        }

        length = handled.length;
        if (length) {
            dataShow = jQuery._data(elem, "fxshow") || jQuery._data(elem, "fxshow", {});
            if ("hidden" in dataShow) {
                hidden = dataShow.hidden;
            }

            // store state if its toggle - enables .stop().toggle() to "reverse"
            if (toggle) {
                dataShow.hidden = !hidden;
            }
            if (hidden) {
                jQuery(elem).show();
            } else {
                anim.done(function() {
                    jQuery(elem).hide();
                });
            }
            anim.done(function() {
                var prop;
                jQuery.removeData(elem, "fxshow", true);
                for (prop in orig) {
                    jQuery.style(elem, prop, orig[prop]);
                }
            });
            for (index = 0; index < length; index++) {
                prop = handled[index];
                tween = anim.createTween(prop, hidden ? dataShow[prop] : 0);
                orig[prop] = dataShow[prop] || jQuery.style(elem, prop);

                if (!(prop in dataShow)) {
                    dataShow[prop] = tween.start;
                    if (hidden) {
                        tween.end = tween.start;
                        tween.start = prop === "width" || prop === "height" ? 1 : 0;
                    }
                }
            }
        }
    }

    function Tween(elem, options, prop, end, easing) {
        return new Tween.prototype.init(elem, options, prop, end, easing);
    }
    jQuery.Tween = Tween;

    Tween.prototype = {
        constructor: Tween,
        init: function(elem, options, prop, end, easing, unit) {
            this.elem = elem;
            this.prop = prop;
            this.easing = easing || "swing";
            this.options = options;
            this.start = this.now = this.cur();
            this.end = end;
            this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
        },
        cur: function() {
            var hooks = Tween.propHooks[this.prop];

            return hooks && hooks.get ?
                hooks.get(this) :
                Tween.propHooks._default.get(this);
        },
        run: function(percent) {
            var eased,
                hooks = Tween.propHooks[this.prop];

            if (this.options.duration) {
                this.pos = eased = jQuery.easing[this.easing](
                    percent, this.options.duration * percent, 0, 1, this.options.duration
                );
            } else {
                this.pos = eased = percent;
            }
            this.now = (this.end - this.start) * eased + this.start;

            if (this.options.step) {
                this.options.step.call(this.elem, this.now, this);
            }

            if (hooks && hooks.set) {
                hooks.set(this);
            } else {
                Tween.propHooks._default.set(this);
            }
            return this;
        }
    };

    Tween.prototype.init.prototype = Tween.prototype;

    Tween.propHooks = {
        _default: {
            get: function(tween) {
                var result;

                if (tween.elem[tween.prop] != null &&
                    (!tween.elem.style || tween.elem.style[tween.prop] == null)) {
                    return tween.elem[tween.prop];
                }

                // passing any value as a 4th parameter to .css will automatically
                // attempt a parseFloat and fallback to a string if the parse fails
                // so, simple values such as "10px" are parsed to Float.
                // complex values such as "rotate(1rad)" are returned as is.
                result = jQuery.css(tween.elem, tween.prop, false, "");
                // Empty strings, null, undefined and "auto" are converted to 0.
                return !result || result === "auto" ? 0 : result;
            },
            set: function(tween) {
                // use step hook for back compat - use cssHook if its there - use .style if its
                // available and use plain properties where available
                if (jQuery.fx.step[tween.prop]) {
                    jQuery.fx.step[tween.prop](tween);
                } else if (tween.elem.style && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
                    jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
                } else {
                    tween.elem[tween.prop] = tween.now;
                }
            }
        }
    };

    // Remove in 2.0 - this supports IE8's panic based approach
    // to setting things on disconnected nodes

    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
        set: function(tween) {
            if (tween.elem.nodeType && tween.elem.parentNode) {
                tween.elem[tween.prop] = tween.now;
            }
        }
    };

    jQuery.each(["toggle", "show", "hide"], function(i, name) {
        var cssFn = jQuery.fn[name];
        jQuery.fn[name] = function(speed, easing, callback) {
            return speed == null || typeof speed === "boolean" ||
                // special check for .toggle( handler, handler, ... )
                (!i && jQuery.isFunction(speed) && jQuery.isFunction(easing)) ?
                cssFn.apply(this, arguments) :
                this.animate(genFx(name, true), speed, easing, callback);
        };
    });

    jQuery.fn.extend({
        fadeTo: function(speed, to, easing, callback) {

            // show any hidden elements after setting opacity to 0
            return this.filter(isHidden).css("opacity", 0).show()

            // animate to the value specified
            .end().animate({ opacity: to }, speed, easing, callback);
        },
        animate: function(prop, speed, easing, callback) {
            var empty = jQuery.isEmptyObject(prop),
                optall = jQuery.speed(speed, easing, callback),
                doAnimation = function() {
                    // Operate on a copy of prop so per-property easing won't be lost
                    var anim = Animation(this, jQuery.extend({}, prop), optall);

                    // Empty animations resolve immediately
                    if (empty) {
                        anim.stop(true);
                    }
                };

            return empty || optall.queue === false ?
                this.each(doAnimation) :
                this.queue(optall.queue, doAnimation);
        },
        stop: function(type, clearQueue, gotoEnd) {
            var stopQueue = function(hooks) {
                var stop = hooks.stop;
                delete hooks.stop;
                stop(gotoEnd);
            };

            if (typeof type !== "string") {
                gotoEnd = clearQueue;
                clearQueue = type;
                type = undefined;
            }
            if (clearQueue && type !== false) {
                this.queue(type || "fx", []);
            }

            return this.each(function() {
                var dequeue = true,
                    index = type != null && type + "queueHooks",
                    timers = jQuery.timers,
                    data = jQuery._data(this);

                if (index) {
                    if (data[index] && data[index].stop) {
                        stopQueue(data[index]);
                    }
                } else {
                    for (index in data) {
                        if (data[index] && data[index].stop && rrun.test(index)) {
                            stopQueue(data[index]);
                        }
                    }
                }

                for (index = timers.length; index--;) {
                    if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                        timers[index].anim.stop(gotoEnd);
                        dequeue = false;
                        timers.splice(index, 1);
                    }
                }

                // start the next in the queue if the last step wasn't forced
                // timers currently will call their complete callbacks, which will dequeue
                // but only if they were gotoEnd
                if (dequeue || !gotoEnd) {
                    jQuery.dequeue(this, type);
                }
            });
        }
    });

    // Generate parameters to create a standard animation
    function genFx(type, includeWidth) {
        var which,
            attrs = { height: type },
            i = 0;

        // if we include width, step value is 1 to do all cssExpand values,
        // if we don't include width, step value is 2 to skip over Left and Right
        includeWidth = includeWidth ? 1 : 0;
        for (; i < 4; i += 2 - includeWidth) {
            which = cssExpand[i];
            attrs["margin" + which] = attrs["padding" + which] = type;
        }

        if (includeWidth) {
            attrs.opacity = attrs.width = type;
        }

        return attrs;
    }

    // Generate shortcuts for custom animations
    jQuery.each({
        slideDown: genFx("show"),
        slideUp: genFx("hide"),
        slideToggle: genFx("toggle"),
        fadeIn: { opacity: "show" },
        fadeOut: { opacity: "hide" },
        fadeToggle: { opacity: "toggle" }
    }, function(name, props) {
        jQuery.fn[name] = function(speed, easing, callback) {
            return this.animate(props, speed, easing, callback);
        };
    });

    jQuery.speed = function(speed, easing, fn) {
        var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
            complete: fn || !fn && easing ||
                jQuery.isFunction(speed) && speed,
            duration: speed,
            easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
        };

        opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
            opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;

        // normalize opt.queue - true/undefined/null -> "fx"
        if (opt.queue == null || opt.queue === true) {
            opt.queue = "fx";
        }

        // Queueing
        opt.old = opt.complete;

        opt.complete = function() {
            if (jQuery.isFunction(opt.old)) {
                opt.old.call(this);
            }

            if (opt.queue) {
                jQuery.dequeue(this, opt.queue);
            }
        };

        return opt;
    };

    jQuery.easing = {
        linear: function(p) {
            return p;
        },
        swing: function(p) {
            return 0.5 - Math.cos(p * Math.PI) / 2;
        }
    };

    jQuery.timers = [];
    jQuery.fx = Tween.prototype.init;
    jQuery.fx.tick = function() {
        var timer,
            timers = jQuery.timers,
            i = 0;

        fxNow = jQuery.now();

        for (; i < timers.length; i++) {
            timer = timers[i];
            // Checks the timer has not already been removed
            if (!timer() && timers[i] === timer) {
                timers.splice(i--, 1);
            }
        }

        if (!timers.length) {
            jQuery.fx.stop();
        }
        fxNow = undefined;
    };

    jQuery.fx.timer = function(timer) {
        if (timer() && jQuery.timers.push(timer) && !timerId) {
            timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval);
        }
    };

    jQuery.fx.interval = 13;

    jQuery.fx.stop = function() {
        clearInterval(timerId);
        timerId = null;
    };

    jQuery.fx.speeds = {
        slow: 600,
        fast: 200,
        // Default speed
        _default: 400
    };

    // Back Compat <1.8 extension point
    jQuery.fx.step = {};

    if (jQuery.expr && jQuery.expr.filters) {
        jQuery.expr.filters.animated = function(elem) {
            return jQuery.grep(jQuery.timers, function(fn) {
                return elem === fn.elem;
            }).length;
        };
    }
    var rroot = /^(?:body|html)$/i;

    jQuery.fn.offset = function(options) {
        if (arguments.length) {
            return options === undefined ?
                this :
                this.each(function(i) {
                    jQuery.offset.setOffset(this, options, i);
                });
        }

        var docElem, body, win, clientTop, clientLeft, scrollTop, scrollLeft,
            box = { top: 0, left: 0 },
            elem = this[0],
            doc = elem && elem.ownerDocument;

        if (!doc) {
            return;
        }

        if ((body = doc.body) === elem) {
            return jQuery.offset.bodyOffset(elem);
        }

        docElem = doc.documentElement;

        // Make sure it's not a disconnected DOM node
        if (!jQuery.contains(docElem, elem)) {
            return box;
        }

        // If we don't have gBCR, just use 0,0 rather than error
        // BlackBerry 5, iOS 3 (original iPhone)
        if (typeof elem.getBoundingClientRect !== "undefined") {
            box = elem.getBoundingClientRect();
        }
        win = getWindow(doc);
        clientTop = docElem.clientTop || body.clientTop || 0;
        clientLeft = docElem.clientLeft || body.clientLeft || 0;
        scrollTop = win.pageYOffset || docElem.scrollTop;
        scrollLeft = win.pageXOffset || docElem.scrollLeft;
        return {
            top: box.top + scrollTop - clientTop,
            left: box.left + scrollLeft - clientLeft
        };
    };

    jQuery.offset = {

        bodyOffset: function(body) {
            var top = body.offsetTop,
                left = body.offsetLeft;

            if (jQuery.support.doesNotIncludeMarginInBodyOffset) {
                top += parseFloat(jQuery.css(body, "marginTop")) || 0;
                left += parseFloat(jQuery.css(body, "marginLeft")) || 0;
            }

            return { top: top, left: left };
        },

        setOffset: function(elem, options, i) {
            var position = jQuery.css(elem, "position");

            // set position first, in-case top/left are set even on static elem
            if (position === "static") {
                elem.style.position = "relative";
            }

            var curElem = jQuery(elem),
                curOffset = curElem.offset(),
                curCSSTop = jQuery.css(elem, "top"),
                curCSSLeft = jQuery.css(elem, "left"),
                calculatePosition = (position === "absolute" || position === "fixed") && jQuery.inArray("auto", [curCSSTop, curCSSLeft]) > -1,
                props = {},
                curPosition = {},
                curTop, curLeft;

            // need to be able to calculate position if either top or left is auto and position is either absolute or fixed
            if (calculatePosition) {
                curPosition = curElem.position();
                curTop = curPosition.top;
                curLeft = curPosition.left;
            } else {
                curTop = parseFloat(curCSSTop) || 0;
                curLeft = parseFloat(curCSSLeft) || 0;
            }

            if (jQuery.isFunction(options)) {
                options = options.call(elem, i, curOffset);
            }

            if (options.top != null) {
                props.top = (options.top - curOffset.top) + curTop;
            }
            if (options.left != null) {
                props.left = (options.left - curOffset.left) + curLeft;
            }

            if ("using" in options) {
                options.using.call(elem, props);
            } else {
                curElem.css(props);
            }
        }
    };


    jQuery.fn.extend({

        position: function() {
            if (!this[0]) {
                return;
            }

            var elem = this[0],

                // Get *real* offsetParent
                offsetParent = this.offsetParent(),

                // Get correct offsets
                offset = this.offset(),
                parentOffset = rroot.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset();

            // Subtract element margins
            // note: when an element has margin: auto the offsetLeft and marginLeft
            // are the same in Safari causing offset.left to incorrectly be 0
            offset.top -= parseFloat(jQuery.css(elem, "marginTop")) || 0;
            offset.left -= parseFloat(jQuery.css(elem, "marginLeft")) || 0;

            // Add offsetParent borders
            parentOffset.top += parseFloat(jQuery.css(offsetParent[0], "borderTopWidth")) || 0;
            parentOffset.left += parseFloat(jQuery.css(offsetParent[0], "borderLeftWidth")) || 0;

            // Subtract the two offsets
            return {
                top: offset.top - parentOffset.top,
                left: offset.left - parentOffset.left
            };
        },

        offsetParent: function() {
            return this.map(function() {
                var offsetParent = this.offsetParent || document.body;
                while (offsetParent && (!rroot.test(offsetParent.nodeName) && jQuery.css(offsetParent, "position") === "static")) {
                    offsetParent = offsetParent.offsetParent;
                }
                return offsetParent || document.body;
            });
        }
    });


    // Create scrollLeft and scrollTop methods
    jQuery.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function(method, prop) {
        var top = /Y/.test(prop);

        jQuery.fn[method] = function(val) {
            return jQuery.access(this, function(elem, method, val) {
                var win = getWindow(elem);

                if (val === undefined) {
                    return win ? (prop in win) ? win[prop] :
                        win.document.documentElement[method] :
                        elem[method];
                }

                if (win) {
                    win.scrollTo(!top ? val : jQuery(win).scrollLeft(),
                        top ? val : jQuery(win).scrollTop()
                    );

                } else {
                    elem[method] = val;
                }
            }, method, val, arguments.length, null);
        };
    });

    function getWindow(elem) {
        return jQuery.isWindow(elem) ?
            elem :
            elem.nodeType === 9 ?
            elem.defaultView || elem.parentWindow :
            false;
    }
    // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
    jQuery.each({ Height: "height", Width: "width" }, function(name, type) {
        jQuery.each({ padding: "inner" + name, content: type, "": "outer" + name }, function(defaultExtra, funcName) {
            // margin is only for outerHeight, outerWidth
            jQuery.fn[funcName] = function(margin, value) {
                var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
                    extra = defaultExtra || (margin === true || value === true ? "margin" : "border");

                return jQuery.access(this, function(elem, type, value) {
                    var doc;

                    if (jQuery.isWindow(elem)) {
                        // As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
                        // isn't a whole lot we can do. See pull request at this URL for discussion:
                        // https://github.com/jquery/jquery/pull/764
                        return elem.document.documentElement["client" + name];
                    }

                    // Get document width or height
                    if (elem.nodeType === 9) {
                        doc = elem.documentElement;

                        // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height], whichever is greatest
                        // unfortunately, this causes bug #3838 in IE6/8 only, but there is currently no good, small way to fix it.
                        return Math.max(
                            elem.body["scroll" + name], doc["scroll" + name],
                            elem.body["offset" + name], doc["offset" + name],
                            doc["client" + name]
                        );
                    }

                    return value === undefined ?
                        // Get width or height on the element, requesting but not forcing parseFloat
                        jQuery.css(elem, type, value, extra) :

                        // Set width or height on the element
                        jQuery.style(elem, type, value, extra);
                }, type, chainable ? margin : undefined, chainable, null);
            };
        });
    });
    // Expose jQuery to the global object
    window.jQuery = window.$ = jQuery;

    // Expose jQuery as an AMD module, but only for AMD loaders that
    // understand the issues with loading multiple versions of jQuery
    // in a page that all might call define(). The loader will indicate
    // they have special allowances for multiple jQuery versions by
    // specifying define.amd.jQuery = true. Register as a named module,
    // since jQuery can be concatenated with other files that may use define,
    // but not use a proper concatenation script that understands anonymous
    // AMD modules. A named AMD is safest and most robust way to register.
    // Lowercase jquery is used because AMD module names are derived from
    // file names, and jQuery is normally delivered in a lowercase file name.
    // Do this after creating the global so that if an AMD module wants to call
    // noConflict to hide this version of jQuery, it will work.
    if (typeof define === "function" && define.amd && define.amd.jQuery) {
        define("jquery", [], function() { return jQuery; });
    }

})(window);

define('lib/clone', ['require'], function(require) {
    var clone = function(json) {
        return JSON.parse(JSON.stringify(json));
    };
    return clone;
});

// There are a few ways we can define the configuration.
define('config', ['require', 'lib/clone'], function(require) {
    var clone = require('lib/clone');
    var config = {};

    // Parse query parameters from the url search.
    //
    // config options here have 2 purposes:
    //  * desktop-calc specific options (testing, preview, maintenance, language menu)
    //  * testing api options (nofolders, etc)
    var query = location.search;
    if (query[0] === '?') query = query.slice(1);
    var paramStrings = query.split('&'),
        params = {};

    for (var i = 0; i < paramStrings.length; i++) {
        var pair = paramStrings[i].split('=');
        params[pair[0]] = (pair.length === 2) ? pair[1] : true;
    }

    var checkOption = function(option) {
        return params.hasOwnProperty(option);
    };
    var addOption = function(option) {
        if (checkOption(option)) config[option] = true;
    };

    //starts "no", i.e. "nographpaper" => graphpaper: false
    var addInverseOption = function(option) {
        if (checkOption("no" + option)) config[option] = false;
    };

    //desktop specific options
    addOption('testing');
    addOption('maintenance');
    addOption('disablelocale');
    addOption('detectlocale');
    addOption('nativeOnscreenKeypad');
    if (params.lang) config.lang = params.lang;

    // Disable navigation warning -- Eric likes not having this in noconcat. Eli likes it in startlivecss
    if (checkOption('noconcat')) config.no_navigation_warning = true;

    //previewMode rules:
    config.previewMessage = "You're previewing regressions.";
    config.previewFeedbackUrl = "https://docs.google.com/forms/d/1-TJNpusDOTmxuI44Pt8cNTPEtuc2zh5U_izPTPM2Glg/viewform";
    var hostIsPreview = location && location.hostname === 'preview.desmos.com';
    config.previewMode = (checkOption('previewMode') || hostIsPreview);

    //API options for testing
    addOption('lockViewport');
    addOption('resizeLoop');

    //note: on desktop, this won't work when you open a blank graph because we add focus
    //and that automatically uncollapses. Need to test on a non-blank state or in ?embed
    addOption('expressionsCollapsed');
    addInverseOption('images');
    addInverseOption('folders');
    addInverseOption('menus');
    addInverseOption('zoomButtons');
    addInverseOption('keypad');
    addInverseOption('graphpaper');
    addInverseOption('expressions');
    addInverseOption('expressionsTopbar');
    addInverseOption('settingsMenu');
    addInverseOption('branding');

    return {
        get: function(prop) {
            return config[prop];
        },
        all: function() {
            return clone(config);
        }
    };
});

// Do things this way to avoid script injection, and to have the LOAD_DATA
// var available to all our other javascript written out below. Using
// jQuery, which lives in vendor (above).
define('main/load_data', ['require', 'jquery'], function(require) {
    var $ = require('jquery');
    var load_data = $('#ldData').data('load-data'); //.bob
    return load_data;
});

define('pjs', [], function() {
    var P = (function(prototype, ownProperty, undefined) {
        // helper functions that also help minification
        function isObject(o) { return typeof o === 'object'; }

        function isFunction(f) { return typeof f === 'function'; }

        // used to extend the prototypes of superclasses (which might not
        // have `.Bare`s)
        function SuperclassBare() {}

        function P(_superclass /* = Object */ , definition) {
            // handle the case where no superclass is given
            if (definition === undefined) {
                definition = _superclass;
                _superclass = Object;
            }

            // C is the class to be returned.
            //
            // It delegates to instantiating an instance of `Bare`, so that it
            // will always return a new instance regardless of the calling
            // context.
            //
            //  TODO: the Chrome inspector shows all created objects as `C`
            //        rather than `Object`.  Setting the .name property seems to
            //        have no effect.  Is there a way to override this behavior?
            function C() {
                var self = new Bare;
                if (isFunction(self.init)) self.init.apply(self, arguments);
                return self;
            }

            // C.Bare is a class with a noop constructor.  Its prototype is the
            // same as C, so that instances of C.Bare are also instances of C.
            // New objects can be allocated without initialization by calling
            // `new MyClass.Bare`.
            function Bare() {}
            C.Bare = Bare;

            // Set up the prototype of the new class.
            var _super = SuperclassBare[prototype] = _superclass[prototype];
            var proto = Bare[prototype] = C[prototype] = new SuperclassBare;

            // other variables, as a minifier optimization
            var extensions;


            // set the constructor property on the prototype, for convenience
            proto.constructor = C;

            C.mixin = function(def) {
                Bare[prototype] = C[prototype] = P(C, def)[prototype];
                return C;
            }

            return (C.open = function(def) {
                extensions = {};

                if (isFunction(def)) {
                    // call the defining function with all the arguments you need
                    // extensions captures the return value.
                    extensions = def.call(C, proto, _super, C, _superclass);
                } else if (isObject(def)) {
                    // if you passed an object instead, we'll take it
                    extensions = def;
                }

                // ...and extend it
                if (isObject(extensions)) {
                    for (var ext in extensions) {
                        if (ownProperty.call(extensions, ext)) {
                            proto[ext] = extensions[ext];
                        }
                    }
                }

                // if there's no init, we assume we're inheriting a non-pjs class, so
                // we default to applying the superclass's constructor.
                if (!isFunction(proto.init)) {
                    proto.init = _superclass;
                }

                return C;
            })(definition);
        }

        // ship it
        return P;

        // as a minifier optimization, we've closured in a few helper functions
        // and the string 'prototype' (C[p] is much shorter than C.prototype)
    })('prototype', ({}).hasOwnProperty);
    return P;
});

//     Underscore.js 1.3.3
//     (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.
//     Underscore may be freely distributed under the MIT license.
//     Portions of Underscore are inspired or borrowed from Prototype,
//     Oliver Steele's Functional, and John Resig's Micro-Templating.
//     For all details and documentation:
//     http://documentcloud.github.com/underscore

(function() {

    // Baseline setup
    // --------------

    // Establish the root object, `window` in the browser, or `global` on the server.
    var root = this;

    // Save the previous value of the `_` variable.
    var previousUnderscore = root._;

    // Establish the object that gets returned to break out of a loop iteration.
    var breaker = {};

    // Save bytes in the minified (but not gzipped) version:
    var ArrayProto = Array.prototype,
        ObjProto = Object.prototype,
        FuncProto = Function.prototype;

    // Create quick reference variables for speed access to core prototypes.
    var slice = ArrayProto.slice,
        unshift = ArrayProto.unshift,
        toString = ObjProto.toString,
        hasOwnProperty = ObjProto.hasOwnProperty;

    // All **ECMAScript 5** native function implementations that we hope to use
    // are declared here.
    var
        nativeForEach = ArrayProto.forEach,
        nativeMap = ArrayProto.map,
        nativeReduce = ArrayProto.reduce,
        nativeReduceRight = ArrayProto.reduceRight,
        nativeFilter = ArrayProto.filter,
        nativeEvery = ArrayProto.every,
        nativeSome = ArrayProto.some,
        nativeIndexOf = ArrayProto.indexOf,
        nativeLastIndexOf = ArrayProto.lastIndexOf,
        nativeIsArray = Array.isArray,
        nativeKeys = Object.keys,
        nativeBind = FuncProto.bind;

    // Create a safe reference to the Underscore object for use below.
    var _ = function(obj) { return new wrapper(obj); };

    // Export the Underscore object for **Node.js**, with
    // backwards-compatibility for the old `require()` API. If we're in
    // the browser, add `_` as a global object via a string identifier,
    // for Closure Compiler "advanced" mode.
    if (typeof exports !== 'undefined') {
        if (typeof module !== 'undefined' && module.exports) {
            exports = module.exports = _;
        }
        exports._ = _;
    } else {
        root['_'] = _;
    }

    // Current version.
    _.VERSION = '1.3.3';

    // Collection Functions
    // --------------------

    // The cornerstone, an `each` implementation, aka `forEach`.
    // Handles objects with the built-in `forEach`, arrays, and raw objects.
    // Delegates to **ECMAScript 5**'s native `forEach` if available.
    var each = _.each = _.forEach = function(obj, iterator, context) {
        if (obj == null) return;
        if (nativeForEach && obj.forEach === nativeForEach) {
            obj.forEach(iterator, context);
        } else if (obj.length === +obj.length) {
            for (var i = 0, l = obj.length; i < l; i++) {
                if (i in obj && iterator.call(context, obj[i], i, obj) === breaker) return;
            }
        } else {
            for (var key in obj) {
                if (_.has(obj, key)) {
                    if (iterator.call(context, obj[key], key, obj) === breaker) return;
                }
            }
        }
    };

    // Return the results of applying the iterator to each element.
    // Delegates to **ECMAScript 5**'s native `map` if available.
    _.map = _.collect = function(obj, iterator, context) {
        var results = [];
        if (obj == null) return results;
        if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
        each(obj, function(value, index, list) {
            results[results.length] = iterator.call(context, value, index, list);
        });
        if (obj.length === +obj.length) results.length = obj.length;
        return results;
    };

    // **Reduce** builds up a single result from a list of values, aka `inject`,
    // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
    _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
        var initial = arguments.length > 2;
        if (obj == null) obj = [];
        if (nativeReduce && obj.reduce === nativeReduce) {
            if (context) iterator = _.bind(iterator, context);
            return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
        }
        each(obj, function(value, index, list) {
            if (!initial) {
                memo = value;
                initial = true;
            } else {
                memo = iterator.call(context, memo, value, index, list);
            }
        });
        if (!initial) throw new TypeError('Reduce of empty array with no initial value');
        return memo;
    };

    // The right-associative version of reduce, also known as `foldr`.
    // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
    _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
        var initial = arguments.length > 2;
        if (obj == null) obj = [];
        if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
            if (context) iterator = _.bind(iterator, context);
            return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
        }
        var reversed = _.toArray(obj).reverse();
        if (context && !initial) iterator = _.bind(iterator, context);
        return initial ? _.reduce(reversed, iterator, memo, context) : _.reduce(reversed, iterator);
    };

    // Return the first value which passes a truth test. Aliased as `detect`.
    _.find = _.detect = function(obj, iterator, context) {
        var result;
        any(obj, function(value, index, list) {
            if (iterator.call(context, value, index, list)) {
                result = value;
                return true;
            }
        });
        return result;
    };

    // Return all the elements that pass a truth test.
    // Delegates to **ECMAScript 5**'s native `filter` if available.
    // Aliased as `select`.
    _.filter = _.select = function(obj, iterator, context) {
        var results = [];
        if (obj == null) return results;
        if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
        each(obj, function(value, index, list) {
            if (iterator.call(context, value, index, list)) results[results.length] = value;
        });
        return results;
    };

    // Return all the elements for which a truth test fails.
    _.reject = function(obj, iterator, context) {
        var results = [];
        if (obj == null) return results;
        each(obj, function(value, index, list) {
            if (!iterator.call(context, value, index, list)) results[results.length] = value;
        });
        return results;
    };

    // Determine whether all of the elements match a truth test.
    // Delegates to **ECMAScript 5**'s native `every` if available.
    // Aliased as `all`.
    _.every = _.all = function(obj, iterator, context) {
        var result = true;
        if (obj == null) return result;
        if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
        each(obj, function(value, index, list) {
            if (!(result = result && iterator.call(context, value, index, list))) return breaker;
        });
        return !!result;
    };

    // Determine if at least one element in the object matches a truth test.
    // Delegates to **ECMAScript 5**'s native `some` if available.
    // Aliased as `any`.
    var any = _.some = _.any = function(obj, iterator, context) {
        iterator || (iterator = _.identity);
        var result = false;
        if (obj == null) return result;
        if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
        each(obj, function(value, index, list) {
            if (result || (result = iterator.call(context, value, index, list))) return breaker;
        });
        return !!result;
    };

    // Determine if a given value is included in the array or object using `===`.
    // Aliased as `contains`.
    _.include = _.contains = function(obj, target) {
        var found = false;
        if (obj == null) return found;
        if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
        found = any(obj, function(value) {
            return value === target;
        });
        return found;
    };

    // Invoke a method (with arguments) on every item in a collection.
    _.invoke = function(obj, method) {
        var args = slice.call(arguments, 2);
        return _.map(obj, function(value) {
            return (_.isFunction(method) ? method || value : value[method]).apply(value, args);
        });
    };

    // Convenience version of a common use case of `map`: fetching a property.
    _.pluck = function(obj, key) {
        return _.map(obj, function(value) { return value[key]; });
    };

    // Return the maximum element or (element-based computation).
    _.max = function(obj, iterator, context) {
        if (!iterator && _.isArray(obj) && obj[0] === +obj[0]) return Math.max.apply(Math, obj);
        if (!iterator && _.isEmpty(obj)) return -Infinity;
        var result = { computed: -Infinity };
        each(obj, function(value, index, list) {
            var computed = iterator ? iterator.call(context, value, index, list) : value;
            computed >= result.computed && (result = { value: value, computed: computed });
        });
        return result.value;
    };

    // Return the minimum element (or element-based computation).
    _.min = function(obj, iterator, context) {
        if (!iterator && _.isArray(obj) && obj[0] === +obj[0]) return Math.min.apply(Math, obj);
        if (!iterator && _.isEmpty(obj)) return Infinity;
        var result = { computed: Infinity };
        each(obj, function(value, index, list) {
            var computed = iterator ? iterator.call(context, value, index, list) : value;
            computed < result.computed && (result = { value: value, computed: computed });
        });
        return result.value;
    };

    // Shuffle an array.
    _.shuffle = function(obj) {
        var shuffled = [],
            rand;
        each(obj, function(value, index, list) {
            rand = Math.floor(Math.random() * (index + 1));
            shuffled[index] = shuffled[rand];
            shuffled[rand] = value;
        });
        return shuffled;
    };

    // Sort the object's values by a criterion produced by an iterator.
    _.sortBy = function(obj, val, context) {
        var iterator = _.isFunction(val) ? val : function(obj) { return obj[val]; };
        return _.pluck(_.map(obj, function(value, index, list) {
            return {
                value: value,
                criteria: iterator.call(context, value, index, list)
            };
        }).sort(function(left, right) {
            var a = left.criteria,
                b = right.criteria;
            if (a === void 0) return 1;
            if (b === void 0) return -1;
            return a < b ? -1 : a > b ? 1 : 0;
        }), 'value');
    };

    // Groups the object's values by a criterion. Pass either a string attribute
    // to group by, or a function that returns the criterion.
    _.groupBy = function(obj, val) {
        var result = {};
        var iterator = _.isFunction(val) ? val : function(obj) { return obj[val]; };
        each(obj, function(value, index) {
            var key = iterator(value, index);
            (result[key] || (result[key] = [])).push(value);
        });
        return result;
    };

    // Use a comparator function to figure out at what index an object should
    // be inserted so as to maintain order. Uses binary search.
    _.sortedIndex = function(array, obj, iterator) {
        iterator || (iterator = _.identity);
        var low = 0,
            high = array.length;
        while (low < high) {
            var mid = (low + high) >> 1;
            iterator(array[mid]) < iterator(obj) ? low = mid + 1 : high = mid;
        }
        return low;
    };

    // Safely convert anything iterable into a real, live array.
    _.toArray = function(obj) {
        if (!obj) return [];
        if (_.isArray(obj)) return slice.call(obj);
        if (_.isArguments(obj)) return slice.call(obj);
        if (obj.toArray && _.isFunction(obj.toArray)) return obj.toArray();
        return _.values(obj);
    };

    // Return the number of elements in an object.
    _.size = function(obj) {
        return _.isArray(obj) ? obj.length : _.keys(obj).length;
    };

    // Array Functions
    // ---------------

    // Get the first element of an array. Passing **n** will return the first N
    // values in the array. Aliased as `head` and `take`. The **guard** check
    // allows it to work with `_.map`.
    _.first = _.head = _.take = function(array, n, guard) {
        return (n != null) && !guard ? slice.call(array, 0, n) : array[0];
    };

    // Returns everything but the last entry of the array. Especcialy useful on
    // the arguments object. Passing **n** will return all the values in
    // the array, excluding the last N. The **guard** check allows it to work with
    // `_.map`.
    _.initial = function(array, n, guard) {
        return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
    };

    // Get the last element of an array. Passing **n** will return the last N
    // values in the array. The **guard** check allows it to work with `_.map`.
    _.last = function(array, n, guard) {
        if ((n != null) && !guard) {
            return slice.call(array, Math.max(array.length - n, 0));
        } else {
            return array[array.length - 1];
        }
    };

    // Returns everything but the first entry of the array. Aliased as `tail`.
    // Especially useful on the arguments object. Passing an **index** will return
    // the rest of the values in the array from that index onward. The **guard**
    // check allows it to work with `_.map`.
    _.rest = _.tail = function(array, index, guard) {
        return slice.call(array, (index == null) || guard ? 1 : index);
    };

    // Trim out all falsy values from an array.
    _.compact = function(array) {
        return _.filter(array, function(value) { return !!value; });
    };

    // Return a completely flattened version of an array.
    _.flatten = function(array, shallow) {
        return _.reduce(array, function(memo, value) {
            if (_.isArray(value)) return memo.concat(shallow ? value : _.flatten(value));
            memo[memo.length] = value;
            return memo;
        }, []);
    };

    // Return a version of the array that does not contain the specified value(s).
    _.without = function(array) {
        return _.difference(array, slice.call(arguments, 1));
    };

    // Produce a duplicate-free version of the array. If the array has already
    // been sorted, you have the option of using a faster algorithm.
    // Aliased as `unique`.
    _.uniq = _.unique = function(array, isSorted, iterator) {
        var initial = iterator ? _.map(array, iterator) : array;
        var results = [];
        // The `isSorted` flag is irrelevant if the array only contains two elements.
        if (array.length < 3) isSorted = true;
        _.reduce(initial, function(memo, value, index) {
            if (isSorted ? _.last(memo) !== value || !memo.length : !_.include(memo, value)) {
                memo.push(value);
                results.push(array[index]);
            }
            return memo;
        }, []);
        return results;
    };

    // Produce an array that contains the union: each distinct element from all of
    // the passed-in arrays.
    _.union = function() {
        return _.uniq(_.flatten(arguments, true));
    };

    // Produce an array that contains every item shared between all the
    // passed-in arrays. (Aliased as "intersect" for back-compat.)
    _.intersection = _.intersect = function(array) {
        var rest = slice.call(arguments, 1);
        return _.filter(_.uniq(array), function(item) {
            return _.every(rest, function(other) {
                return _.indexOf(other, item) >= 0;
            });
        });
    };

    // Take the difference between one array and a number of other arrays.
    // Only the elements present in just the first array will remain.
    _.difference = function(array) {
        var rest = _.flatten(slice.call(arguments, 1), true);
        return _.filter(array, function(value) { return !_.include(rest, value); });
    };

    // Zip together multiple lists into a single array -- elements that share
    // an index go together.
    _.zip = function() {
        var args = slice.call(arguments);
        var length = _.max(_.pluck(args, 'length'));
        var results = new Array(length);
        for (var i = 0; i < length; i++) results[i] = _.pluck(args, "" + i);
        return results;
    };

    // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
    // we need this function. Return the position of the first occurrence of an
    // item in an array, or -1 if the item is not included in the array.
    // Delegates to **ECMAScript 5**'s native `indexOf` if available.
    // If the array is large and already in sort order, pass `true`
    // for **isSorted** to use binary search.
    _.indexOf = function(array, item, isSorted) {
        if (array == null) return -1;
        var i, l;
        if (isSorted) {
            i = _.sortedIndex(array, item);
            return array[i] === item ? i : -1;
        }
        if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item);
        for (i = 0, l = array.length; i < l; i++)
            if (i in array && array[i] === item) return i;
        return -1;
    };

    // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
    _.lastIndexOf = function(array, item) {
        if (array == null) return -1;
        if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) return array.lastIndexOf(item);
        var i = array.length;
        while (i--)
            if (i in array && array[i] === item) return i;
        return -1;
    };

    // Generate an integer Array containing an arithmetic progression. A port of
    // the native Python `range()` function. See
    // [the Python documentation](http://docs.python.org/library/functions.html#range).
    _.range = function(start, stop, step) {
        if (arguments.length <= 1) {
            stop = start || 0;
            start = 0;
        }
        step = arguments[2] || 1;

        var len = Math.max(Math.ceil((stop - start) / step), 0);
        var idx = 0;
        var range = new Array(len);

        while (idx < len) {
            range[idx++] = start;
            start += step;
        }

        return range;
    };

    // Function (ahem) Functions
    // ------------------

    // Reusable constructor function for prototype setting.
    var ctor = function() {};

    // Create a function bound to a given object (assigning `this`, and arguments,
    // optionally). Binding with arguments is also known as `curry`.
    // Delegates to **ECMAScript 5**'s native `Function.bind` if available.
    // We check for `func.bind` first, to fail fast when `func` is undefined.
    _.bind = function bind(func, context) {
        var bound, args;
        if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
        if (!_.isFunction(func)) throw new TypeError;
        args = slice.call(arguments, 2);
        return bound = function() {
            if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
            ctor.prototype = func.prototype;
            var self = new ctor;
            var result = func.apply(self, args.concat(slice.call(arguments)));
            if (Object(result) === result) return result;
            return self;
        };
    };

    // Bind all of an object's methods to that object. Useful for ensuring that
    // all callbacks defined on an object belong to it.
    _.bindAll = function(obj) {
        var funcs = slice.call(arguments, 1);
        if (funcs.length == 0) funcs = _.functions(obj);
        each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
        return obj;
    };

    // Memoize an expensive function by storing its results.
    _.memoize = function(func, hasher) {
        var memo = {};
        hasher || (hasher = _.identity);
        return function() {
            var key = hasher.apply(this, arguments);
            return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
        };
    };

    // Delays a function for the given number of milliseconds, and then calls
    // it with the arguments supplied.
    _.delay = function(func, wait) {
        var args = slice.call(arguments, 2);
        return setTimeout(function() { return func.apply(null, args); }, wait);
    };

    // Defers a function, scheduling it to run after the current call stack has
    // cleared.
    _.defer = function(func) {
        return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
    };

    // Returns a function, that, when invoked, will only be triggered at most once
    // during a given window of time.
    _.throttle = function(func, wait) {
        var context, args, timeout, throttling, more, result;
        var whenDone = _.debounce(function() { more = throttling = false; }, wait);
        return function() {
            context = this;
            args = arguments;
            var later = function() {
                timeout = null;
                if (more) func.apply(context, args);
                whenDone();
            };
            if (!timeout) timeout = setTimeout(later, wait);
            if (throttling) {
                more = true;
            } else {
                result = func.apply(context, args);
            }
            whenDone();
            throttling = true;
            return result;
        };
    };

    // Returns a function, that, as long as it continues to be invoked, will not
    // be triggered. The function will be called after it stops being called for
    // N milliseconds. If `immediate` is passed, trigger the function on the
    // leading edge, instead of the trailing.
    _.debounce = function(func, wait, immediate) {
        var timeout;
        return function() {
            var context = this,
                args = arguments;
            var later = function() {
                timeout = null;
                if (!immediate) func.apply(context, args);
            };
            if (immediate && !timeout) func.apply(context, args);
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    };

    // Returns a function that will be executed at most one time, no matter how
    // often you call it. Useful for lazy initialization.
    _.once = function(func) {
        var ran = false,
            memo;
        return function() {
            if (ran) return memo;
            ran = true;
            return memo = func.apply(this, arguments);
        };
    };

    // Returns the first function passed as an argument to the second,
    // allowing you to adjust arguments, run code before and after, and
    // conditionally execute the original function.
    _.wrap = function(func, wrapper) {
        return function() {
            var args = [func].concat(slice.call(arguments, 0));
            return wrapper.apply(this, args);
        };
    };

    // Returns a function that is the composition of a list of functions, each
    // consuming the return value of the function that follows.
    _.compose = function() {
        var funcs = arguments;
        return function() {
            var args = arguments;
            for (var i = funcs.length - 1; i >= 0; i--) {
                args = [funcs[i].apply(this, args)];
            }
            return args[0];
        };
    };

    // Returns a function that will only be executed after being called N times.
    _.after = function(times, func) {
        if (times <= 0) return func();
        return function() {
            if (--times < 1) { return func.apply(this, arguments); }
        };
    };

    // Object Functions
    // ----------------

    // Retrieve the names of an object's properties.
    // Delegates to **ECMAScript 5**'s native `Object.keys`
    _.keys = nativeKeys || function(obj) {
        if (obj !== Object(obj)) throw new TypeError('Invalid object');
        var keys = [];
        for (var key in obj)
            if (_.has(obj, key)) keys[keys.length] = key;
        return keys;
    };

    // Retrieve the values of an object's properties.
    _.values = function(obj) {
        return _.map(obj, _.identity);
    };

    // Return a sorted list of the function names available on the object.
    // Aliased as `methods`
    _.functions = _.methods = function(obj) {
        var names = [];
        for (var key in obj) {
            if (_.isFunction(obj[key])) names.push(key);
        }
        return names.sort();
    };

    // Extend a given object with all the properties in passed-in object(s).
    _.extend = function(obj) {
        each(slice.call(arguments, 1), function(source) {
            for (var prop in source) {
                obj[prop] = source[prop];
            }
        });
        return obj;
    };

    // Return a copy of the object only containing the whitelisted properties.
    _.pick = function(obj) {
        var result = {};
        each(_.flatten(slice.call(arguments, 1)), function(key) {
            if (key in obj) result[key] = obj[key];
        });
        return result;
    };

    // Fill in a given object with default properties.
    _.defaults = function(obj) {
        each(slice.call(arguments, 1), function(source) {
            for (var prop in source) {
                if (obj[prop] == null) obj[prop] = source[prop];
            }
        });
        return obj;
    };

    // Create a (shallow-cloned) duplicate of an object.
    _.clone = function(obj) {
        if (!_.isObject(obj)) return obj;
        return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
    };

    // Invokes interceptor with the obj, and then returns obj.
    // The primary purpose of this method is to "tap into" a method chain, in
    // order to perform operations on intermediate results within the chain.
    _.tap = function(obj, interceptor) {
        interceptor(obj);
        return obj;
    };

    // Internal recursive comparison function.
    function eq(a, b, stack) {
        // Identical objects are equal. `0 === -0`, but they aren't identical.
        // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.
        if (a === b) return a !== 0 || 1 / a == 1 / b;
        // A strict comparison is necessary because `null == undefined`.
        if (a == null || b == null) return a === b;
        // Unwrap any wrapped objects.
        if (a._chain) a = a._wrapped;
        if (b._chain) b = b._wrapped;
        // Invoke a custom `isEqual` method if one is provided.
        if (a.isEqual && _.isFunction(a.isEqual)) return a.isEqual(b);
        if (b.isEqual && _.isFunction(b.isEqual)) return b.isEqual(a);
        // Compare `[[Class]]` names.
        var className = toString.call(a);
        if (className != toString.call(b)) return false;
        switch (className) {
            // Strings, numbers, dates, and booleans are compared by value.
            case '[object String]':
                // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
                // equivalent to `new String("5")`.
                return a == String(b);
            case '[object Number]':
                // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
                // other numeric values.
                return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
            case '[object Date]':
            case '[object Boolean]':
                // Coerce dates and booleans to numeric primitive values. Dates are compared by their
                // millisecond representations. Note that invalid dates with millisecond representations
                // of `NaN` are not equivalent.
                return +a == +b;
                // RegExps are compared by their source patterns and flags.
            case '[object RegExp]':
                return a.source == b.source &&
                    a.global == b.global &&
                    a.multiline == b.multiline &&
                    a.ignoreCase == b.ignoreCase;
        }
        if (typeof a != 'object' || typeof b != 'object') return false;
        // Assume equality for cyclic structures. The algorithm for detecting cyclic
        // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
        var length = stack.length;
        while (length--) {
            // Linear search. Performance is inversely proportional to the number of
            // unique nested structures.
            if (stack[length] == a) return true;
        }
        // Add the first object to the stack of traversed objects.
        stack.push(a);
        var size = 0,
            result = true;
        // Recursively compare objects and arrays.
        if (className == '[object Array]') {
            // Compare array lengths to determine if a deep comparison is necessary.
            size = a.length;
            result = size == b.length;
            if (result) {
                // Deep compare the contents, ignoring non-numeric properties.
                while (size--) {
                    // Ensure commutative equality for sparse arrays.
                    if (!(result = size in a == size in b && eq(a[size], b[size], stack))) break;
                }
            }
        } else {
            // Objects with different constructors are not equivalent.
            if ('constructor' in a != 'constructor' in b || a.constructor != b.constructor) return false;
            // Deep compare objects.
            for (var key in a) {
                if (_.has(a, key)) {
                    // Count the expected number of properties.
                    size++;
                    // Deep compare each member.
                    if (!(result = _.has(b, key) && eq(a[key], b[key], stack))) break;
                }
            }
            // Ensure that both objects contain the same number of properties.
            if (result) {
                for (key in b) {
                    if (_.has(b, key) && !(size--)) break;
                }
                result = !size;
            }
        }
        // Remove the first object from the stack of traversed objects.
        stack.pop();
        return result;
    }

    // Perform a deep comparison to check if two objects are equal.
    _.isEqual = function(a, b) {
        return eq(a, b, []);
    };

    // Is a given array, string, or object empty?
    // An "empty" object has no enumerable own-properties.
    _.isEmpty = function(obj) {
        if (obj == null) return true;
        if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
        for (var key in obj)
            if (_.has(obj, key)) return false;
        return true;
    };

    // Is a given value a DOM element?
    _.isElement = function(obj) {
        return !!(obj && obj.nodeType == 1);
    };

    // Is a given value an array?
    // Delegates to ECMA5's native Array.isArray
    _.isArray = nativeIsArray || function(obj) {
        return toString.call(obj) == '[object Array]';
    };

    // Is a given variable an object?
    _.isObject = function(obj) {
        return obj === Object(obj);
    };

    // Is a given variable an arguments object?
    _.isArguments = function(obj) {
        return toString.call(obj) == '[object Arguments]';
    };
    if (!_.isArguments(arguments)) {
        _.isArguments = function(obj) {
            return !!(obj && _.has(obj, 'callee'));
        };
    }

    // Is a given value a function?
    _.isFunction = function(obj) {
        return toString.call(obj) == '[object Function]';
    };

    // Is a given value a string?
    _.isString = function(obj) {
        return toString.call(obj) == '[object String]';
    };

    // Is a given value a number?
    _.isNumber = function(obj) {
        return toString.call(obj) == '[object Number]';
    };

    // Is a given object a finite number?
    _.isFinite = function(obj) {
        return _.isNumber(obj) && isFinite(obj);
    };

    // Is the given value `NaN`?
    _.isNaN = function(obj) {
        // `NaN` is the only value for which `===` is not reflexive.
        return obj !== obj;
    };

    // Is a given value a boolean?
    _.isBoolean = function(obj) {
        return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
    };

    // Is a given value a date?
    _.isDate = function(obj) {
        return toString.call(obj) == '[object Date]';
    };

    // Is the given value a regular expression?
    _.isRegExp = function(obj) {
        return toString.call(obj) == '[object RegExp]';
    };

    // Is a given value equal to null?
    _.isNull = function(obj) {
        return obj === null;
    };

    // Is a given variable undefined?
    _.isUndefined = function(obj) {
        return obj === void 0;
    };

    // Has own property?
    _.has = function(obj, key) {
        return hasOwnProperty.call(obj, key);
    };

    // Utility Functions
    // -----------------

    // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
    // previous owner. Returns a reference to the Underscore object.
    _.noConflict = function() {
        root._ = previousUnderscore;
        return this;
    };

    // Keep the identity function around for default iterators.
    _.identity = function(value) {
        return value;
    };

    // Run a function **n** times.
    _.times = function(n, iterator, context) {
        for (var i = 0; i < n; i++) iterator.call(context, i);
    };

    // Escape a string for HTML interpolation.
    _.escape = function(string) {
        return ('' + string).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#x27;').replace(/\//g, '&#x2F;');
    };

    // If the value of the named property is a function then invoke it;
    // otherwise, return it.
    _.result = function(object, property) {
        if (object == null) return null;
        var value = object[property];
        return _.isFunction(value) ? value.call(object) : value;
    };

    // Add your own custom functions to the Underscore object, ensuring that
    // they're correctly added to the OOP wrapper as well.
    _.mixin = function(obj) {
        each(_.functions(obj), function(name) {
            addToWrapper(name, _[name] = obj[name]);
        });
    };

    // Generate a unique integer id (unique within the entire client session).
    // Useful for temporary DOM ids.
    var idCounter = 0;
    _.uniqueId = function(prefix) {
        var id = idCounter++;
        return prefix ? prefix + id : id;
    };

    // By default, Underscore uses ERB-style template delimiters, change the
    // following template settings to use alternative delimiters.
    _.templateSettings = {
        evaluate: /<%([\s\S]+?)%>/g,
        interpolate: /<%=([\s\S]+?)%>/g,
        escape: /<%-([\s\S]+?)%>/g
    };

    // When customizing `templateSettings`, if you don't want to define an
    // interpolation, evaluation or escaping regex, we need one that is
    // guaranteed not to match.
    var noMatch = /.^/;

    // Certain characters need to be escaped so that they can be put into a
    // string literal.
    var escapes = {
        '\\': '\\',
        "'": "'",
        'r': '\r',
        'n': '\n',
        't': '\t',
        'u2028': '\u2028',
        'u2029': '\u2029'
    };

    for (var p in escapes) escapes[escapes[p]] = p;
    var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;
    var unescaper = /\\(\\|'|r|n|t|u2028|u2029)/g;

    // Within an interpolation, evaluation, or escaping, remove HTML escaping
    // that had been previously added.
    var unescape = function(code) {
        return code.replace(unescaper, function(match, escape) {
            return escapes[escape];
        });
    };

    // JavaScript micro-templating, similar to John Resig's implementation.
    // Underscore templating handles arbitrary delimiters, preserves whitespace,
    // and correctly escapes quotes within interpolated code.
    _.template = function(text, data, settings) {
        settings = _.defaults(settings || {}, _.templateSettings);

        // Compile the template source, taking care to escape characters that
        // cannot be included in a string literal and then unescape them in code
        // blocks.
        var source = "__p+='" + text
            .replace(escaper, function(match) {
                return '\\' + escapes[match];
            })
            .replace(settings.escape || noMatch, function(match, code) {
                return "'+\n_.escape(" + unescape(code) + ")+\n'";
            })
            .replace(settings.interpolate || noMatch, function(match, code) {
                return "'+\n(" + unescape(code) + ")+\n'";
            })
            .replace(settings.evaluate || noMatch, function(match, code) {
                return "';\n" + unescape(code) + "\n;__p+='";
            }) + "';\n";

        // If a variable is not specified, place data values in local scope.
        if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

        source = "var __p='';" +
            "var print=function(){__p+=Array.prototype.join.call(arguments, '')};\n" +
            source + "return __p;\n";

        var render = new Function(settings.variable || 'obj', '_', source);
        if (data) return render(data, _);
        var template = function(data) {
            return render.call(this, data, _);
        };

        // Provide the compiled function source as a convenience for build time
        // precompilation.
        template.source = 'function(' + (settings.variable || 'obj') + '){\n' +
            source + '}';

        return template;
    };

    // Add a "chain" function, which will delegate to the wrapper.
    _.chain = function(obj) {
        return _(obj).chain();
    };

    // The OOP Wrapper
    // ---------------

    // If Underscore is called as a function, it returns a wrapped object that
    // can be used OO-style. This wrapper holds altered versions of all the
    // underscore functions. Wrapped objects may be chained.
    var wrapper = function(obj) { this._wrapped = obj; };

    // Expose `wrapper.prototype` as `_.prototype`
    _.prototype = wrapper.prototype;

    // Helper function to continue chaining intermediate results.
    var result = function(obj, chain) {
        return chain ? _(obj).chain() : obj;
    };

    // A method to easily add functions to the OOP wrapper.
    var addToWrapper = function(name, func) {
        wrapper.prototype[name] = function() {
            var args = slice.call(arguments);
            unshift.call(args, this._wrapped);
            return result(func.apply(_, args), this._chain);
        };
    };

    // Add all of the Underscore functions to the wrapper object.
    _.mixin(_);

    // Add all mutator Array functions to the wrapper.
    each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
        var method = ArrayProto[name];
        wrapper.prototype[name] = function() {
            var wrapped = this._wrapped;
            method.apply(wrapped, arguments);
            var length = wrapped.length;
            if ((name == 'shift' || name == 'splice') && length === 0) delete wrapped[0];
            return result(wrapped, this._chain);
        };
    });

    // Add all accessor Array functions to the wrapper.
    each(['concat', 'join', 'slice'], function(name) {
        var method = ArrayProto[name];
        wrapper.prototype[name] = function() {
            return result(method.apply(this._wrapped, arguments), this._chain);
        };
    });

    // Start chaining a wrapped Underscore object.
    wrapper.prototype.chain = function() {
        this._chain = true;
        return this;
    };

    // Extracts the result from a wrapped and chained object.
    wrapper.prototype.value = function() {
        return this._wrapped;
    };

}).call(this);
define("underscore", (function(global) {
    return function() {
        var ret, fn;
        return ret || global._;
    };
}(this)));

//Copied from MDN reference
//https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind

;
(function() {
    if (!Function.prototype.bind) {
        Function.prototype.bind = function(oThis) {
            if (typeof this !== "function") {
                // closest thing possible to the ECMAScript 5 internal IsCallable function
                throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
            }

            var aArgs = Array.prototype.slice.call(arguments, 1),
                fToBind = this,
                fNOP = function() {},
                fBound = function() {
                    return fToBind.apply(this instanceof fNOP && oThis ? this : oThis,
                        aArgs.concat(Array.prototype.slice.call(arguments)));
                };

            fNOP.prototype = this.prototype;
            fBound.prototype = new fNOP();

            return fBound;
        };
    }
})();

define("function.bind", function() {});

define('underscore_model', ['require', 'underscore', 'pjs', 'function.bind'], function(require) {
    var _ = require('underscore');
    var P = require('pjs');
    require('function.bind');

    var UnderscoreModel = P(function(model) {

        // each model gets a guid that is unique even across different
        // versions of this file running within the same window
        var guid_count = 0;
        var guid_prefix = 'guid_' + Math.round(Math.random() * 1000000) + "_" + (new Date().getTime()) + "_";

        model.init = function() {
            this.__observers = {};
            this.__eventObservers = {};
            this.__oldProperties = {};
            this.__propertyComparators = {};
            this.guid = guid_prefix + (++guid_count);
        };

        model.unobserveAll = function() {
            this.__observers = {};
            this.__eventObservers = {};
        };

        model.getProperty = function(property) {
            return this[property];
        };

        model.getOldProperty = function(property) {
            return this.__oldProperties[property];
        };

        model.setProperty = function(property, newValue) {
            var oldValue = this[property];
            var comparator = this.__propertyComparators[property];
            if (comparator) {
                if (comparator(oldValue, newValue)) {
                    return;
                }
            } else if (_.isEqual(oldValue, newValue)) {
                return;
            }

            this.__oldProperties[property] = oldValue;
            this[property] = newValue;
            this.notifyPropertyChange(property);
        };

        model.setProperties = function(obj) {
            for (var k in obj) {
                if (obj.hasOwnProperty(k)) this.setProperty(k, obj[k]);
            }
        };

        model.setPropertyComparator = function(property, comparator) {
            this.__propertyComparators[property] = comparator;
        };

        // for properties
        model.notifyPropertyChange = function(property) {
            this.__callObservers(this.__observers, property, this);
        };
        model.observe = function(property_string, callback) {
            this.__addObservers(this.__observers, property_string, callback);
        };
        model.unobserve = function(property_string) {
            this.__removeObservers(this.__observers, property_string);
        };
        model.observeAndSync = function(property_string, callback) {
            this.observe(property_string, callback);
            var props = property_string.split(" ");
            for (var i = 0; i < props.length; i++) {
                var prop_parts = props[i].split(".");
                var prop = prop_parts[0];
                if (this.hasOwnProperty(prop)) {
                    //Observer will fire for each observed property that exists
                    //With the same args that an observed change would cause
                    callback(prop, this);
                }
            }
        };

        // for events
        model.triggerEvent = function(event, param) {
            this.__callObservers(this.__eventObservers, event, param);
        };
        model.observeEvent = function(event_string, callback) {
            this.__addObservers(this.__eventObservers, event_string, callback);
        };
        model.unobserveEvent = function(event_string) {
            this.__removeObservers(this.__eventObservers, event_string);
        };

        // generic implementation of trigger, add, remove observers
        model.__callObservers = function(list, prop, arg) {
            var observers = list[prop];
            if (observers) {
                for (var i = 0; i < observers.length; i++) {
                    observers[i].callback(prop, arg);
                }
            }
        };
        model.__removeObservers = function(list, prop_string) {
            var props = prop_string.split(" ");
            for (var i = 0; i < props.length; i++) {
                var prop_parts = props[i].split(".");
                var prop = prop_parts[0];
                var namespace = prop_parts[1];

                // only keep the ones with a different namespace
                if (prop && namespace) {
                    var original = list[prop];
                    var filtered = [];
                    if (!original) continue;
                    for (var j = 0; j < original.length; j++) {
                        var observer = original[j];
                        if (observer.namespace !== namespace) {
                            filtered.push(observer);
                        }
                    }
                    list[prop] = filtered;

                    // get rid of all of observers for this property since no namespace given
                } else if (prop) {
                    delete list[prop];

                    // we aren't given a property, only a namespace. run through each
                    // property that has observers and call .unobserve(property.namespace)
                } else if (namespace) {
                    for (prop in list) {
                        if (list.hasOwnProperty(prop)) {
                            this.__removeObservers(list, prop + "." + namespace);
                        }
                    }
                }
            }
        };
        model.__addObservers = function(list, prop_string, callback) {
            var props = prop_string.split(" ");
            for (var i = 0; i < props.length; i++) {
                var prop_parts = props[i].split(".");
                var prop = prop_parts[0];
                if (!prop) throw 'Must supply a property to observe';

                var namespace = prop_parts[1];
                var observer = {
                    namespace: namespace,
                    callback: callback
                };

                var observers = list[prop];
                if (!observers) {
                    list[prop] = [observer];
                } else {
                    observers.push(observer);
                }
            }
        };

    });

    return UnderscoreModel;
});

define('main/url_prefix', ['require'], function(require) {
    var URL_PREFIX = '/';
    // if we're on the file:// protocol we don't want to look at pathname. It'll
    // be a really ugly path listing all the directories we need to go through to
    // get to the index.html file. Just pretend like we're on a live server.
    return URL_PREFIX;
});


//from http://www.w3schools.com/js/js_cookies.asp
define('main/cookie', [], function() {
    function getCookie(c_name) {

        var encoded_c_name = encodeURIComponent(c_name);
        var i, x, y, ARRcookies = document.cookie.split(";");
        for (i = 0; i < ARRcookies.length; i++) {
            x = ARRcookies[i].substr(0, ARRcookies[i].indexOf("="));
            y = ARRcookies[i].substr(ARRcookies[i].indexOf("=") + 1);
            x = x.replace(/^\s+|\s+$/g, "");
            if (x == encoded_c_name) {
                return decodeURIComponent(y);
            }
        }
    }

    function setCookie(c_name, value, duration) {
        //set a javascript cookie
        var expires = new Date();
        expires.setDate(expires.getDate() + (duration || 30));
        document.cookie = (
            encodeURIComponent(c_name) +
            "=" + encodeURIComponent(value) +
            "; expires=" + expires.toUTCString() +
            "; path=/"
        );
    }

    return {
        getCookie: getCookie,
        setCookie: setCookie
    };
});

define('i18n', ['require', 'config', 'main/cookie', 'underscore'], function(require) {
    var Config = require('config');
    var Cookie = require('main/cookie');
    var _ = require('underscore');
    var default_lang = '';
    var language_dict = {};

    //this is a list of enabled languages -- i.e. ones that show up in the language dropdown
    //languages not on this list can still be accessed through the query parameter, but not
    //through the cookie or the browser preferences
    var enabled_languages = {
        'en': {
            displayName: 'English (US)',
            userGuideURL: 'https://desmos.s3.amazonaws.com/Desmos_User_Guide.pdf'
        },
        'es-ES': {
            displayName: 'EspaÃ±ol (EspaÃ±a)',
            userGuideURL: 'https://desmos.s3.amazonaws.com/Desmos_User_Guide_ES-ES.pdf',
            useAsRoot: true
        },
        'ru': {
            displayName: 'Ð ÑƒÑÑÐºÐ¸Ð¹',
            userGuideURL: 'https://desmos.s3.amazonaws.com/Desmos_User_Guide_RU.pdf'
        },
        'de': {
            displayName: 'Deutsch',
            userGuideURL: 'https://desmos.s3.amazonaws.com/Desmos_User_Guide_DE.pdf'
        },
        'pt-BR': {
            displayName: 'PortuguÃªs (Brasil)',
            userGuideURL: 'https://desmos.s3.amazonaws.com/Desmos_User_Guide.pdf'
        },
        'pt-PT': {
            displayName: 'PortuguÃªs (Portugal)',
            userGuideURL: 'https://desmos.s3.amazonaws.com/Desmos_User_Guide.pdf'
        },
        'fr': {
            displayName: 'FranÃ§ais',
            userGuideURL: 'https://desmos.s3.amazonaws.com/Desmos_User_Guide_FR.pdf'
        },
        'it': {
            displayName: 'Italiano',
            userGuideURL: 'https://desmos.s3.amazonaws.com/Desmos_User_Guide_IT.pdf'
        },
        'nl': {
            displayName: 'Nederlands',
            userGuideURL: 'https://desmos.s3.amazonaws.com/Desmos_User_Guide.pdf'
        },
        'no': {
            displayName: 'Norsk',
            userGuideURL: 'https://desmos.s3.amazonaws.com/Desmos_User_Guide.pdf'
        },
        'sv-SE': {
            displayName: 'Svenska',
            userGuideURL: 'https://desmos.s3.amazonaws.com/Desmos_User_Guide.pdf'
        },
        'cs': {
            displayName: 'ÄŒeÅ¡tina',
            userGuideURL: 'https://desmos.s3.amazonaws.com/Desmos_User_Guide.pdf'
        },
        'tr': {
            displayName: 'TÃ¼rkÃ§e',
            userGuideURL: 'https://desmos.s3.amazonaws.com/Desmos_User_Guide_TR.pdf'
        },
        'sl': {
            displayName: 'SlovenÅ¡Äina',
            userGuideURL: 'https://desmos.s3.amazonaws.com/Desmos_User_Guide_SL.pdf'
        },
        'lt': {
            displayName: 'LietuviÅ³',
            userGuideURL: 'https://desmos.s3.amazonaws.com/Desmos_User_Guide.pdf'
        },
        'pl': {
            displayName: 'Polski',
            userGuideURL: 'https://desmos.s3.amazonaws.com/Desmos_User_Guide_PL.pdf'
        },
        'ro': {
            displayName: 'RomÃ¢nÄƒ',
            userGuideURL: 'https://desmos.s3.amazonaws.com/Desmos_User_Guide.pdf'
        },
        'id': {
            displayName: 'Bahasa Indonesia',
            userGuideURL: 'https://desmos.s3.amazonaws.com/Desmos_User_Guide.pdf'
        },
        'vi': {
            displayName: 'Tiáº¿ng Viá»‡t',
            userGuideURL: 'https://desmos.s3.amazonaws.com/Desmos_User_Guide_VI.pdf'
        },
        'el': {
            displayName: 'Î•Î»Î»Î·Î½Î¹ÎºÎ¬',
            userGuideURL: 'https://desmos.s3.amazonaws.com/Desmos_User_Guide_EL.pdf'
        },
        'sr-CS': {
            displayName: 'SRPSKI',
            userGuideURL: 'https://desmos.s3.amazonaws.com/Desmos_User_Guide.pdf'
        },
        'bg': {
            displayName: 'Ð‘ÑŠÐ»Ð³Ð°Ñ€ÑÐºÐ¸',
            userGuideURL: 'https://desmos.s3.amazonaws.com/Desmos_User_Guide_BG.pdf'
        },
        'mk': {
            displayName: 'ÐœÐ°ÐºÐµÐ´Ð¾Ð½ÑÐºÐ¸',
            userGuideURL: 'https://desmos.s3.amazonaws.com/Desmos_User_Guide.pdf'
        },
        'th': {
            displayName: 'à¸ à¸²à¸©à¸²à¹„à¸—à¸¢',
            userGuideURL: 'https://desmos.s3.amazonaws.com/Desmos_User_Guide.pdf'
        },
        'zh-CN': {
            displayName: 'ç®€ä½“ä¸­æ–‡',
            useAsRoot: true,
            userGuideURL: 'https://desmos.s3.amazonaws.com/Desmos_User_Guide_ZH-CN.pdf'
        },
        'zh-TW': {
            displayName: 'ç¹é«”ä¸­æ–‡',
            userGuideURL: 'https://desmos.s3.amazonaws.com/Desmos_User_Guide_ZH-TW.pdf'
        },
        'ko': {
            displayName: 'í•œêµ­ì–´',
            userGuideURL: 'https://desmos.s3.amazonaws.com/Desmos_User_Guide.pdf'
        },
        'ja': {
            displayName: 'æ—¥æœ¬èªž',
            userGuideURL: 'https://desmos.s3.amazonaws.com/Desmos_User_Guide.pdf'
        }
    };

    function init(lang, dict) {
        default_lang = lang || '';
        language_dict = dict || {};
    }

    function translateString(message, variables) {
        var translation = language_dict[default_lang] && language_dict[default_lang][message] || message || '';

        for (var variable in variables) {
            if (variables.hasOwnProperty(variable)) {
                translation = translation.split('__' + variable + '__').join(variables[variable]);
            }
        }

        return translation;
    }

    //this function looks through users preferences to determine what language to show
    //order is:
    //  Config (i.e. query parameter): this doesn't require the lanague to be enabled
    //  Cookie: this *does* require that the language is enabled
    //  Browser settings: does require enabled
    //  Truncated version of browser setting: does require enabled
    //
    //If none of those works, we fall back to 'en' (which is actually ignored by our i18n_dict)
    function detectLanguage() {
        if (Config.get('lang')) {
            return Config.get('lang');
        }

        var preferences = [Cookie.getCookie('lang')];

        //auto detect locales
        if (!Config.get('disablelocale')) {
            var browserLocale;
            if (navigator.userLanguage) {
                browserLocale = navigator.userLanguage;
            } else {
                browserLocale = navigator.language;
            }

            var baseLocale = browserLocale.split('-')[0];
            //first choice: exact dialect
            preferences.push(browserLocale);
            //second choice: root level locale
            preferences.push(baseLocale);
            //third choice: dialect that shares the root and has useAsRoot: true
            _.each(enabled_languages, function(lang, code) {
                if (
                    code.split('-')[0] === baseLocale &&
                    lang.useAsRoot
                ) preferences.push(code);
            });
        }

        for (var i = 0; i < preferences.length; i++) {
            var lang = preferences[i];
            if (enabled_languages.hasOwnProperty(lang)) return lang;
        }
        return 'en';
    }

    function currentLanguage() {
        return default_lang;
    }

    //when we want to send translatable strings out from the worker, we JSON.stringify
    //{msg: message, vars: variables}.
    //unpack that all here.
    var unpack = function(str) {
        //numbers are JSON.parse-able, so catch this situation and return early.
        //can arise when this is called recursively from an unpack
        if (typeof(str) === 'number') return str;

        var returnVal;
        try {
            var data = JSON.parse(str);
            //elements of data.vars could also be i18n strings. recursively unpack.
            for (var key in data.vars) {
                data.vars[key] = unpack(data.vars[key]);
            }
            returnVal = translateString(data.msg, data.vars);
        } catch (ex) {
            //we sometimes just send back non-json-encoded strings (i.e. if we don't need to interpolate)
            returnVal = translateString(str);
        }
        return returnVal;
    };

    return {
        init: init,
        t: translateString,
        detectLanguage: detectLanguage,
        currentLanguage: currentLanguage,
        enabled_languages: enabled_languages,
        unpack: unpack
    };
});

define('main/graph', ['require', 'pjs', 'underscore_model', 'main/url_prefix', 'i18n'], function(require) {
    var P = require('pjs');
    var UnderscoreModel = require('underscore_model');
    var URL_PREFIX = require('main/url_prefix');
    var i18n = require('i18n');

    var Graph = P(UnderscoreModel, function(proto, _super) {

        var properties = [
            'title', 'thumbURL', 'hash', 'parentHash', 'graphData', 'access', 'created'
        ];

        proto.init = function(obj) {
            _super.init.call(this);
            var self = this;
            this.observe('title', function() {
                self.displayTitle = self.title || '[' + i18n.t('Untitled Graph') + ']';
            });
            this.observe('created', this.updateDisplayDate.bind(this));
            this.observe('hash', function() {
                self.setProperty(
                    'path',
                    URL_PREFIX + (self.hash ? '/' + self.hash : '')
                );
            });

            if (obj) {
                properties.forEach(function(p) {
                    if (obj.hasOwnProperty(p)) self.setProperty(p, obj[p]);
                });
            }
            if (!this.access) this.setProperty('access', 'all');
            if (!this.path) this.setProperty('path', URL_PREFIX);
            this.now = new Date();
        };

        proto.copy = function() {
            return Graph(this);
        };

        function computeDisplayDate(created) {
            var now = Date.now();
            var seconds = (now - created) / 1000;
            var minutes = seconds / 60;
            var hours = minutes / 60;
            var days = hours / 24;
            var weeks = days / 7;
            var monthNames = [
                i18n.t('Jan'),
                i18n.t('Feb'),
                i18n.t('Mar'),
                i18n.t('Apr'),
                i18n.t('May'),
                i18n.t('Jun'),
                i18n.t('Jul'),
                i18n.t('Aug'),
                i18n.t('Sep'),
                i18n.t('Oct'),
                i18n.t('Nov'),
                i18n.t('Dec')
            ];

            if (weeks >= 5) {
                return i18n.t('on __month__ __day__, __year__', {
                    month: monthNames[created.getMonth()],
                    day: created.getDate(),
                    year: created.getFullYear()
                });
            }
            if (weeks >= 2) return i18n.t('__number__ weeks ago', { number: String(Math.floor(weeks)) });
            if (days >= 7) return i18n.t('last week');
            if (days >= 2) return i18n.t('__number__ days ago', { number: String(Math.floor(days)) });
            if (hours >= 24) return i18n.t('yesterday');
            if (hours >= 2) return i18n.t('__number__ hours ago', { number: String(Math.floor(hours)) });
            if (minutes >= 60) return i18n.t('one hour ago');
            if (minutes >= 2) return i18n.t('__number__ minutes ago', { number: String(Math.floor(minutes)) });
            if (seconds >= 60) return i18n.t('one minute ago');
            return i18n.t('just now');
        }

        proto.updateDisplayDate = function() {
            this.displayDate = computeDisplayDate(this.created);
        };

        proto.plainObject = function() {
            var out = {};
            var self = this;
            properties.forEach(function(p) {
                out[p] = self[p];
            });
            return out;
        };
    });

    Graph.fromAjax = function(obj) {
        return Graph({
            title: obj.title,
            thumbURL: obj.thumbUrl,
            graphData: JSON.stringify(obj.state),
            hash: obj.hash,
            parentHash: obj.parent_hash,
            access: obj.access,
            created: new Date(obj.created)
        });
    };

    Graph.updateFromSync = function(obj, resp) {
        obj.setProperty('title', resp.title);
        obj.setProperty('hash', resp.hash);
        obj.setProperty('parentHash', resp.parent_hash);
        obj.setProperty('graphData', obj.graphData);
        obj.setProperty('thumbURL', resp.thumbUrl);
        obj.setProperty('created', new Date(resp.created));
    };

    return Graph;
});

define('main/calculator_backend', ['require', 'jquery', 'main/graph'], function(require) {
    var $ = require('jquery');
    var Graph = require('main/graph');

    var calculatorBackend = {
        apiPath: function(path) {
            return ['/api/v1/calculator', path].join('/');
        },

        // Helper for saveGraph and shareGraph that lets them make different
        // decision about whether to add the graph to the list of the user's graphs.
        _saveGraph: function(graph, my_graphs) {
            //detect if we should push to drive
            var push_to_drive = ($('input[name="push_to_drive"]').attr("checked") ? "push_to_drive" : undefined);
            var access = ($('input[name="access"]').attr("checked") ? "all" : "link");
            var formData = {
                parent_hash: graph.parentHash,
                thumb_data: graph.thumbURL,
                calc_state: graph.graphData,
                graph_hash: graph.hash,
                version: 'h3',
                access: access,
                my_graphs: my_graphs,
                // Use all these undefineds so that the data doesn't go to the server
                // if it is blank or null.
                title: graph.title || undefined,
                push_to_drive: push_to_drive
            };

            return $.post(this.apiPath('save'), formData).pipe(function(resp) {
                Graph.updateFromSync(graph, resp);
                return graph;
            });
        },

        saveGraph: function(graph) {
            return this._saveGraph(graph, true);
        },

        shareGraph: function(graph) {
            return this._saveGraph(graph, false);
        },

        emailGraph: function(data) {
            return $.post(this.apiPath('email_graph'), data);
        },

        emailFeedback: function(data) {
            return $.post(this.apiPath('email_feedback'), data);
        },

        allowFeature: function(data) {
            return $.post(this.apiPath('allow_feature'), data);
        },

        getGraphs: function() {
            return $.getJSON(this.apiPath('my_graphs'));
        },

        removeGraph: function(graph) {
            return $.post(this.apiPath('my_graphs/remove'), {
                hash: graph.hash
            });
        },
    };

    return calculatorBackend;
});

define('main/parse_json_errors', ['require', 'jquery'], function(require) {
    var $ = require('jquery');
    var parseJSONErrors = function(jqXHR) {
        try {
            return $.parseJSON(jqXHR.responseText).errors;
        } catch (err) {
            return [{ message: 'Internal Server Error.' }];
        }
    };
    return parseJSONErrors;
});
// RandomHashFactory takes a seed, and constructs an object with a .next()
// method that returns random 10 character alphanumeric strings. The seed is
// designed to be a hex string representing a 128 bit random UUID, but is
// allowed to be any non-empty string.
//
// Usage:
// > randomHashFactory = new Desmos.RandomHashFactory('570a95d1f9a6455ab4b9c76bbd2509b6')
// > randomHashFactory.next()
// 'medjqzoa4t'
// > randomHashFactory.next()
// 'phgn5qzrm0'
//
// Implementation Notes:
// Behind the scenes, uses an ARC4 implementation by David Bau.
// http://davidbau.com/archives/2010/01/30/random_seeds_coded_hints_and_quintillions.html
// http://davidbau.com/encode/seedrandom.js

define('lib/random_hash', ['require', 'exports', 'module'], function(require, exports) {
    /* jshint bitwise: false */

    // ARC4 wraps BauARC4 (taken from seedrandom.js) to make an object that
    // takes a string seed instead of a key as a constructor, and returns an
    // array of integers between 0 and 255 instead of a large integer.
    //
    // The seed is designed to be the hex representation of a 128 bit random
    // UUID, but is allowed to be any string.
    //
    // Usage:
    // var arc4 = new ARC4('this is a seed')
    // arc4.g(4) // returns an array of 4 integers between 0 and 256
    function ARC4(seed) {
        this.bauArc4 = new BauARC4(toKey(seed));
    }

    ARC4.prototype.g = function(count) {
        var digits = Array(count);
        for (var i = 0; i < count; i++) {
            digits[i] = this.bauArc4.g(1);
        }
        return digits;
    };

    // Helpers used by ARC4
    var width = 256;

    function lowbits(n) { return n & (width - 1); }

    //
    // tokey()
    // Converts a string seed into a key that is an array of integers
    function toKey(seed) {
        var stringSeed = seed + ''; // Ensure the seed is a string
        var key = [];
        var smear = 0;
        var j;
        for (j = 0; j < stringSeed.length; j++) {
            key[lowbits(j)] =
                lowbits((smear ^= key[lowbits(j)] * 19) + stringSeed.charCodeAt(j));
        }
        return key;
    }

    // BauARC4, cribbed from http://davidbau.com/encode/seedrandom.js
    //
    // An ARC4 implementation.  The constructor takes a key in the form of
    // an array of at most (width) integers that should be 0 <= x < (width).
    //
    // The g(count) method returns a pseudorandom integer that concatenates
    // the next (count) outputs from ARC4.  Its return value is a number x
    // that is in the range 0 <= x < (width ^ count).
    //
    /** @constructor */
    function BauARC4(key) {
        var t, u, me = this,
            keylen = key.length;
        var i = 0,
            j = me.i = me.j = me.m = 0;
        me.S = [];
        me.c = [];

        // The empty key [] is treated as [0].
        if (!keylen) { key = [keylen++]; }

        // Set up S using the standard key scheduling algorithm.
        while (i < width) { me.S[i] = i++; }
        for (i = 0; i < width; i++) {
            t = me.S[i];
            j = lowbits(j + t + key[i % keylen]);
            u = me.S[j];
            me.S[i] = u;
            me.S[j] = t;
        }

        // The "g" method returns the next (count) outputs as one number.
        me.g = function getnext(count) {
            var s = me.S;
            var i = lowbits(me.i + 1);
            var t = s[i];
            var j = lowbits(me.j + t);
            var u = s[j];
            s[i] = u;
            s[j] = t;
            var r = s[lowbits(t + u)];
            while (--count) {
                i = lowbits(i + 1);
                t = s[i];
                j = lowbits(j + t);
                u = s[j];
                s[i] = u;
                s[j] = t;
                r = r * width + s[lowbits(t + u)];
            }
            me.i = i;
            me.j = j;
            return r;
        };
        // For robust unpredictability discard an initial batch of values.
        // See http://www.rsa.com/rsalabs/node.asp?id=2009
        me.g(width);
    }

    // We're using a somewhat odd distribution of random hashes, but this
    // follows existing server side behavior. Draw characters from downcased
    // alphanumeric set. Weights each alphabetical character twice as heavily as
    // each digit.
    var upperLowerDigits =
        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    var codex = upperLowerDigits.toLowerCase();
    // Hardcoded because the below algorithm relies on this number not changing.
    var codexLength = 62;

    var nchars = 10;
    var RandomHashFactory = function(seed) {
        if (!seed) throw 'You must supply a seed to RandomHashFactory. It should have at least 128 bits of entropy.';

        var arc4 = new ARC4(seed);

        this.next = function() {
            var chars = Array(nchars);
            var n = 0;
            var trialIndex;

            // Rejection sampling. Want uniform samples between 0 and 61, the
            // valid indices into our codex. arc4 returns integers between 0 and
            // 255, so we shift two bits off them to get integers between 0 and 63,
            // and then reject the samples larger than 61.
            while (n < nchars) {
                trialIndex = arc4.g(1)[0] >> 2;
                if (trialIndex < codexLength) {
                    chars[n] = codex[trialIndex];
                    n++;
                }
            }
            return chars.join("");
        };

        // Return a new random 128-bit hex value
        this.nextSeed = function() {
            var nbytes = 16;
            var bytes = arc4.g(nbytes);
            var hexCodes = Array(nbytes);
            for (var i = 0; i < nbytes; i++) {
                hexCodes[i] = bytes[i].toString(16);
                // Pad each byte representation to 2 hex characters
                if (hexCodes[i].length === 1) {
                    hexCodes[i] = "0" + hexCodes[i];
                }
            }
            return hexCodes.join("");
        };
    };

    var factory;

    exports.next = function() {
        if (!factory) throw "Random Hash Factory not initialized";
        return factory.next();
    };

    exports.nextSeed = function() {
        if (!factory) throw "Random Hash Factory not initialized";
        return factory.nextSeed();
    };

    exports.init = function(seed) {
        factory = new RandomHashFactory(seed);
    };

    return exports;
});

define('main/graphs_controller', ['require', 'underscore', 'pjs', 'main/graph', 'main/calculator_backend', 'main/parse_json_errors', 'underscore_model', 'i18n', 'lib/random_hash'], function(require) {
    var _ = require('underscore');
    var P = require('pjs');
    var Graph = require('main/graph');
    var calculatorBackend = require('main/calculator_backend');
    var parseJSONErrors = require('main/parse_json_errors');
    var UnderscoreModel = require('underscore_model');
    var i18n = require('i18n');
    var randomHash = require('lib/random_hash');

    var GraphsController = P(UnderscoreModel, function(proto, _super) {

        proto.init = function(Calc, randomSeed) {
            _super.init.call(this);

            this.observe('currentGraph', this.onCurrentGraphChange.bind(this));

            this.Calc = Calc;
            this.content = [];
            this.undoRedo = Calc._calc.undoRedo;

            this.startSavingCallbacks = [];
            this.saveSuccessCallbacks = [];
            this.saveErrorCallbacks = [];
            this.driveAccessErrorCallbacks = [];
            this.startUpdatingGraphsCallbacks = [];
            this.updateGraphsSuccessCallbacks = [];
            this.updateGraphsErrorCallbacks = [];
            this.graphAddedCallbacks = [];
            this.clearCallbacks = [];
            this.graphRemovedCallbacks = [];
            this.randomHash = randomHash;
            this.seedRandom(randomSeed);
        };

        proto.seedRandom = function(seed) {
            if (!seed) {
                alert(i18n.t(
                    "Something went wrong, please report this to desmos.com support. (Error __error_num__)", { error_num: '77361' }
                ));
                return;
            }

            var d = new Date();
            var augmentedSeed = '' + seed + d.getTime() + d.getMilliseconds();
            this.randomHash.init(augmentedSeed);
        };

        proto.remove = function(graph) {
            var index = this.getIndexFromGraph(graph);
            this.content.splice(index, 1);
            this.triggerRemove(index);
            calculatorBackend.removeGraph(graph);
        };

        proto.clear = function() {
            this.content = [];
            this.triggerClear();
        };

        proto.triggerStartSaving = function() {
            _.each(this.startSavingCallbacks, function(cb) { cb() });
        };

        proto.triggerSaveSuccess = function() {
            _.each(this.saveSuccessCallbacks, function(cb) { cb() });
        };

        proto.triggerSaveError = function() {
            _.each(this.saveErrorCallbacks, function(cb) { cb() });
        };

        proto.triggerDriveAccessError = function() {
            _.each(this.driveAccessErrorCallbacks, function(cb) { cb() });
        };

        proto.triggerStartUpdatingGraphs = function() {
            _.each(this.startUpdatingGraphsCallbacks, function(cb) { cb() });
        };

        proto.triggerUpdateGraphsSuccess = function() {
            _.each(this.updateGraphsSuccessCallbacks, function(cb) { cb() });
        };

        proto.triggerupdateGraphsError = function() {
            _.each(this.updateGraphsErrorCallbacks, function(cb) { cb() });
        };

        proto.triggerAdd = function(index) {
            _.each(this.graphAddedCallbacks, function(cb) { cb(index); });
        };

        proto.triggerClear = function() {
            _.each(this.clearCallbacks, function(cb) { cb(); });
        };

        proto.triggerRemove = function(index) {
            _.each(this.graphRemovedCallbacks, function(cb) { cb(index); });
        };

        // Update state and screenshot
        proto.updateGraphData = function(graph) {
            var state = JSON.stringify(this.Calc.getState());
            graph.setProperty('graphData', state);
            graph.setProperty('parentHash', graph.hash);
            graph.setProperty('hash', this.randomHash.next());

            var thumbURL = this.Calc.screenshot({ width: 200, height: 200 });
            graph.setProperty('thumbURL', thumbURL);
        };

        proto.saveAs = function(graph) {
            this.save(graph, true);
        };

        //do_not_overwrite flag -- only exposed to proto.saveAs
        proto.save = function(graph, do_not_overwrite) {

            var oldGraph = this.currentGraph;
            var self = this;

            self.triggerStartSaving();

            // about to modify the graph, so we make sure we modify the copy, not the original
            graph = graph.copy();
            self.updateGraphData(graph);

            calculatorBackend.saveGraph(graph).done(function(graph) {

                // Don't call loadGraph here because we don't want to trigger a
                // setState on save.

                // copy graph so that what goes into my_graphs list isn't the exact
                // same object as what's stored in currentGraph.
                self.setProperty('currentGraph', graph.copy());
                self.content.unshift(graph);
                self.triggerAdd(0);
                self.triggerSaveSuccess();

                if (!do_not_overwrite && oldGraph) {
                    self.remove(oldGraph);
                }

                //_kmq.push(['record', 'saved graph']);
            }).fail(function(jqXHR) {
                var error = parseJSONErrors(jqXHR)[0];
                if (error.key === 'drive_access_error') self.triggerDriveAccessError();
                self.triggerSaveError();
                //_kmq.push(['record', 'failed to save graph']);
            });
        };

        //is this the stablest way to do this?
        proto.getIndexFromGraph = function(graph) {
            for (var index = 0; index < this.content.length; index++) {
                if (graph.hash === this.content[index].hash) return index;
            }
            return -1;
        };

        proto.updateGraphs = function() {
            var self = this;
            self.triggerStartUpdatingGraphs();
            calculatorBackend.getGraphs().done(function(msg) {
                var graphs;
                if (msg.myGraphs) graphs = msg.myGraphs.map(Graph.fromAjax);
                self.content = graphs;
                self.triggerUpdateGraphsSuccess();
            }).fail(function() {
                self.triggerupdateGraphsError();
            });
        };

        proto.loadGraph = function(graph) {
            var self = this;

            // combine the setState undo/redo along with the currentGraph undo/redo into
            // a single atomic undo/redo transaction.
            this.undoRedo.oneTransaction(function() {

                // set the sate. this itself is going to add to undo/redo stream to
                self.Calc.setState(graph.graphData);

                // set the currentGraph. This will add to undo/redo as well.
                self.setProperty('currentGraph', graph);
            });
        };

        proto.clearGraph = function() {
            this.loadGraph(Graph());
            this.Calc._calc.addFocus();
        };

        proto.onCurrentGraphChange = function() {
            var currentGraph = this.currentGraph;
            var oldCurrentGraph = this.getOldProperty('currentGraph');

            // only undo currentGraph if there is an oldCurrentGraph. Basically, this makes it so
            // that we skip the first time we set a Graph(), whether the first Graph()
            if (oldCurrentGraph) {
                var self = this;

                // make copies of these from the start in case they ever get modified in the future
                var undoGraph = oldCurrentGraph.copy();
                var redoGraph = currentGraph.copy();

                // this makes it so undo/redo changes title and hash
                this.undoRedo.addTransaction({
                    type: this.undoRedo.RESPONSE_TO_CHANGE,
                    redo: function() {
                        self.setProperty('currentGraph', redoGraph.copy());
                    },
                    undo: function() {
                        self.setProperty('currentGraph', undoGraph.copy());
                    }
                });
            }

            document.title = currentGraph.title || i18n.t('Grapher');

            if (!(window.history && history.pushState)) return;

            var path = currentGraph.path;
            if (!path) return;
            if (window.location.search) path += window.location.search;
            if (path !== window.location.href) {
                history.pushState(
                    currentGraph.plainObject(),
                    currentGraph.title,
                    path
                );
            }
        };
    });

    return GraphsController;
});

// From http://stackoverflow.com/questions/7742781/why-javascript-only-works-after-opening-developer-tools-in-ie-once
// Avoid `console` errors in browsers that lack a console.
define('console', ['require'], function(require) {
    var noop = function() {};
    var methods = [
        'assert', 'clear', 'count', 'debug', 'dir', 'dirxml', 'error',
        'exception', 'group', 'groupCollapsed', 'groupEnd', 'info', 'log',
        'markTimeline', 'profile', 'profileEnd', 'table', 'time', 'timeEnd',
        'timeStamp', 'trace', 'warn'
    ];
    var console = {};

    var addMethod = function(method) {
        if ((typeof window !== 'undefined') && window.console && window.console[method]) {
            console[method] = function() { window.console[method].apply(window.console, arguments) };
        } else {
            console[method] = noop;
        }
    };

    methods.forEach(addMethod);
    return console;
});

define('underscore_view', ['require', 'jquery', 'underscore', './underscore_model', 'pjs', 'i18n'], function(require) {
    var $ = require('jquery');
    var _ = require('underscore');
    var UnderscoreModel = require('./underscore_model');
    var P = require('pjs');
    var i18n = require('i18n');

    var insertionQueue = [];

    var UnderscoreView = P(UnderscoreModel, function(view, _super, _class) {

        // Class method for generating more efficient templates in the case
        // that the template takes no parameters
        _class.staticTemplate = function(str) {
            var node = $(str)[0];
            return function() { return node.cloneNode(true); };
        };

        view.$ = function(selector) {
            var $node = $(this.__domNode);
            if (!selector) {
                return $node;
            } else {
                return $node.filter(selector).add($node.find(selector));
            }
        };

        // methods to adding view to dom. these call .didInsertElement()
        // automatically
        var makeInsertFn = function(methodName) {
            return function(selector) {
                var isTopmostInsert = (insertionQueue.length === 0);
                insertionQueue.push(this);
                if (!this.__domNode) _render.call(this);

                $(selector)[methodName](this.$());
                if (isTopmostInsert) {
                    while (insertionQueue.length) {
                        insertionQueue.pop().didInsertElement();
                    }
                }
                return this.$();
            };
        };

        view.appendTo = makeInsertFn('append');
        view.replace = makeInsertFn('replaceWith');
        view.prependTo = makeInsertFn('prepend');
        view.insertAfter = makeInsertFn('after');
        view.insertBefore = makeInsertFn('before');

        view.remove = function() {
            this.$().remove();
            this.destruct();
        };

        // should be overriden and used to cleanup any resources this view has
        // aquired. Most often, that means remove any observers set and any child
        // views created.
        view.destruct = function() {};

        // Called when the view has been rendered, but before its DOM node has been
        // inserted into the document. This is a good time to attach child views and
        // event listeners.
        view.didCreateElement = function() {};

        // for this to be called, must insert this.$() into dom using one of the
        // methods above. If not, you must call .didInsertElement() yourself.
        view.didInsertElement = function() {};

        // this is the information that will be made available to the underscore template
        view.getTemplateParams = function() { return {}; };

        // tap into these if you want deep control of how a complete rerender happens.
        // one thing these are useful for are saving/restoring temporary data within
        // the view that will get wiped out when the html is regenerated.
        view.beforeRerender = function() {};
        view.afterRerender = function() {};

        // will render only if something has changed
        view.rerender = function() {
            var oldDomNode = this.__domNode;
            var newParams = this.getTemplateParams();
            if (_.isEqual(newParams, this.__lastRenderParams)) return;

            this.beforeRerender();

            _render.call(this);

            if (oldDomNode && $.contains(document, oldDomNode)) {
                this.replace(oldDomNode);
            }

            this.afterRerender();
        };

        view.setDomNode = function(node) {
            this.__domNode = node[0] ? node[0] : node;
            this.didInsertElement();
        };

        // private
        var _render = function() {
            var params = this.getTemplateParams();
            var helpers = {
                t: function(key, args) { return i18n.t(key, args); }
            };
            var combined = _.extend({}, params, helpers);
            var html = this.template(combined);
            var $node = $(html);
            this.__domNode = $node[0];
            this.__lastRenderParams = params;
            this.didCreateElement();
        };

    });
    return UnderscoreView;
});

define('keys', ['require'], function(require) {

    var Keys = function() {

        // based on http://www.w3.org/TR/2012/WD-DOM-Level-3-Events-20120614/#fixed-virtual-key-codes
        var table = {
            8: this.BACKSPACE = 'Backspace',
            9: this.TAB = 'Tab',
            13: this.ENTER = 'Enter',
            16: this.SHIFT = 'Shift',
            17: this.CONTROL = 'Control',
            18: this.ALT = 'Alt',
            20: this.CAPSLOCK = 'CapsLock',
            27: this.ESCAPE = 'Esc',
            32: this.SPACEBAR = 'Space',
            33: this.PAGEUP = 'PageUp',
            34: this.PAGEDOWN = 'PageDown',
            35: this.END = 'End',
            36: this.HOME = 'Home',
            37: this.LEFT = 'Left',
            38: this.UP = 'Up',
            39: this.RIGHT = 'Right',
            40: this.DOWN = 'Down',
            46: this.DELETE = 'Del'
        };

        this.lookup = function(evt) {
            return table[evt.which];
        };
    };

    return new Keys();
});
define('conditional_blur', ['require', 'jquery'], function(require) {
    var $ = require('jquery');

    return function() {
        if (document.activeElement === document.body) return;
        $(document.activeElement).blur();
    };
});
// Shim HTML5 placeholder element.
//
// https://github.com/parndt/jquery-html5-placeholder-shim

(function($) {
    // @todo Document this.
    $.extend($, {
        placeholder: {
            browser_supported: function() {
                return this._supported !== undefined ?
                    this._supported :
                    (this._supported = !!('placeholder' in $('<input type="text">')[0]));
            },
            shim: function(opts) {
                var config = {
                    color: '#888',
                    cls: 'placeholder',
                    selector: 'input[placeholder], textarea[placeholder]'
                };
                $.extend(config, opts);
                if (!this.browser_supported()) {
                    $(config.selector)._placeholder_shim(config);
                }
            }
        }
    });

    $.extend($.fn, {
        _placeholder_shim: function(config) {
            function calcPositionCss(target) {
                var op = $(target).offsetParent().offset();
                var ot = $(target).offset();

                return {
                    top: ot.top - op.top,
                    left: ot.left - op.left,
                    width: $(target).width()
                };
            }
            return this.each(function() {
                var $this = $(this);

                if ($this.data('placeholder')) {
                    var $ol = $this.data('placeholder');
                    $ol.css(calcPositionCss($this));
                    return true;
                }

                var possible_line_height = {};
                if (!$this.is('textarea') && $this.css('height') != 'auto') {
                    possible_line_height = { lineHeight: $this.css('height'), whiteSpace: 'nowrap' };
                }

                var ol = $('<label />')
                    .text($this.attr('placeholder'))
                    .addClass(config.cls)
                    .css($.extend({
                        position: 'absolute',
                        display: 'inline',
                        float: 'none',
                        overflow: 'hidden',
                        textAlign: 'left',
                        color: config.color,
                        cursor: 'text',
                        paddingTop: $this.css('padding-top'),
                        paddingLeft: $this.css('padding-left'),
                        paddingRight: $this.css('padding-right'),
                        paddingBottom: $this.css('padding-bottom'),
                        fontSize: $this.css('font-size'),
                        fontFamily: $this.css('font-family'),
                        fontStyle: $this.css('font-style'),
                        fontWeight: $this.css('font-weight'),
                        textTransform: $this.css('text-transform'),
                        backgroundColor: 'transparent',
                        zIndex: 99
                    }, possible_line_height))
                    .css(calcPositionCss(this))
                    .attr('for', this.id)
                    .data('target', $this)
                    .click(function() {
                        $(this).data('target').focus();
                    })
                    .insertBefore(this);
                $this
                    .data('placeholder', ol)
                    .focus(function() {
                        ol.hide();
                    }).blur(function() {
                        ol[$this.val().length ? 'hide' : 'show']();
                    }).triggerHandler('blur');
                $(window)
                    .resize(function() {
                        var $target = ol.data('target');
                        ol.css(calcPositionCss($target));
                    });
            });
        }
    });
})(jQuery);
define("vendor/jquery.html5-placeholder-shim", function() {});

/**
 * @license RequireJS text 2.0.7 Copyright (c) 2010-2012, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/requirejs/text for details
 */
/*jslint regexp: true */
/*global require, XMLHttpRequest, ActiveXObject,
  define, window, process, Packages,
  java, location, Components, FileUtils */

define('text', ['module'], function(module) {


    var text, fs, Cc, Ci,
        progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'],
        xmlRegExp = /^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im,
        bodyRegExp = /<body[^>]*>\s*([\s\S]+)\s*<\/body>/im,
        hasLocation = typeof location !== 'undefined' && location.href,
        defaultProtocol = hasLocation && location.protocol && location.protocol.replace(/\:/, ''),
        defaultHostName = hasLocation && location.hostname,
        defaultPort = hasLocation && (location.port || undefined),
        buildMap = {},
        masterConfig = (module.config && module.config()) || {};

    text = {
        version: '2.0.7',

        strip: function(content) {
            //Strips <?xml ...?> declarations so that external SVG and XML
            //documents can be added to a document without worry. Also, if the string
            //is an HTML document, only the part inside the body tag is returned.
            if (content) {
                content = content.replace(xmlRegExp, "");
                var matches = content.match(bodyRegExp);
                if (matches) {
                    content = matches[1];
                }
            } else {
                content = "";
            }
            return content;
        },

        jsEscape: function(content) {
            return content.replace(/(['\\])/g, '\\$1')
                .replace(/[\f]/g, "\\f")
                .replace(/[\b]/g, "\\b")
                .replace(/[\n]/g, "\\n")
                .replace(/[\t]/g, "\\t")
                .replace(/[\r]/g, "\\r")
                .replace(/[\u2028]/g, "\\u2028")
                .replace(/[\u2029]/g, "\\u2029");
        },

        createXhr: masterConfig.createXhr || function() {
            //Would love to dump the ActiveX crap in here. Need IE 6 to die first.
            var xhr, i, progId;
            if (typeof XMLHttpRequest !== "undefined") {
                return new XMLHttpRequest();
            } else if (typeof ActiveXObject !== "undefined") {
                for (i = 0; i < 3; i += 1) {
                    progId = progIds[i];
                    try {
                        xhr = new ActiveXObject(progId);
                    } catch (e) {}

                    if (xhr) {
                        progIds = [progId]; // so faster next time
                        break;
                    }
                }
            }

            return xhr;
        },

        /**
         * Parses a resource name into its component parts. Resource names
         * look like: module/name.ext!strip, where the !strip part is
         * optional.
         * @param {String} name the resource name
         * @returns {Object} with properties "moduleName", "ext" and "strip"
         * where strip is a boolean.
         */
        parseName: function(name) {
            var modName, ext, temp,
                strip = false,
                index = name.indexOf("."),
                isRelative = name.indexOf('./') === 0 ||
                name.indexOf('../') === 0;

            if (index !== -1 && (!isRelative || index > 1)) {
                modName = name.substring(0, index);
                ext = name.substring(index + 1, name.length);
            } else {
                modName = name;
            }

            temp = ext || modName;
            index = temp.indexOf("!");
            if (index !== -1) {
                //Pull off the strip arg.
                strip = temp.substring(index + 1) === "strip";
                temp = temp.substring(0, index);
                if (ext) {
                    ext = temp;
                } else {
                    modName = temp;
                }
            }

            return {
                moduleName: modName,
                ext: ext,
                strip: strip
            };
        },

        xdRegExp: /^((\w+)\:)?\/\/([^\/\\]+)/,

        /**
         * Is an URL on another domain. Only works for browser use, returns
         * false in non-browser environments. Only used to know if an
         * optimized .js version of a text resource should be loaded
         * instead.
         * @param {String} url
         * @returns Boolean
         */
        useXhr: function(url, protocol, hostname, port) {
            var uProtocol, uHostName, uPort,
                match = text.xdRegExp.exec(url);
            if (!match) {
                return true;
            }
            uProtocol = match[2];
            uHostName = match[3];

            uHostName = uHostName.split(':');
            uPort = uHostName[1];
            uHostName = uHostName[0];

            return (!uProtocol || uProtocol === protocol) &&
                (!uHostName || uHostName.toLowerCase() === hostname.toLowerCase()) &&
                ((!uPort && !uHostName) || uPort === port);
        },

        finishLoad: function(name, strip, content, onLoad) {
            content = strip ? text.strip(content) : content;
            if (masterConfig.isBuild) {
                buildMap[name] = content;
            }
            onLoad(content);
        },

        load: function(name, req, onLoad, config) {
            //Name has format: some.module.filext!strip
            //The strip part is optional.
            //if strip is present, then that means only get the string contents
            //inside a body tag in an HTML string. For XML/SVG content it means
            //removing the <?xml ...?> declarations so the content can be inserted
            //into the current doc without problems.

            // Do not bother with the work if a build and text will
            // not be inlined.
            if (config.isBuild && !config.inlineText) {
                onLoad();
                return;
            }

            masterConfig.isBuild = config.isBuild;

            var parsed = text.parseName(name),
                nonStripName = parsed.moduleName +
                (parsed.ext ? '.' + parsed.ext : ''),
                url = req.toUrl(nonStripName),
                useXhr = (masterConfig.useXhr) ||
                text.useXhr;

            //Load the text. Use XHR if possible and in a browser.
            if (!hasLocation || useXhr(url, defaultProtocol, defaultHostName, defaultPort)) {
                text.get(url, function(content) {
                    text.finishLoad(name, parsed.strip, content, onLoad);
                }, function(err) {
                    if (onLoad.error) {
                        onLoad.error(err);
                    }
                });
            } else {
                //Need to fetch the resource across domains. Assume
                //the resource has been optimized into a JS module. Fetch
                //by the module name + extension, but do not include the
                //!strip part to avoid file system issues.
                req([nonStripName], function(content) {
                    text.finishLoad(parsed.moduleName + '.' + parsed.ext,
                        parsed.strip, content, onLoad);
                });
            }
        },

        write: function(pluginName, moduleName, write, config) {
            if (buildMap.hasOwnProperty(moduleName)) {
                var content = text.jsEscape(buildMap[moduleName]);
                write.asModule(pluginName + "!" + moduleName,
                    "define(function () { return '" +
                    content +
                    "';});\n");
            }
        },

        writeFile: function(pluginName, moduleName, req, write, config) {
            var parsed = text.parseName(moduleName),
                extPart = parsed.ext ? '.' + parsed.ext : '',
                nonStripName = parsed.moduleName + extPart,
                //Use a '.js' file name so that it indicates it is a
                //script that can be loaded across domains.
                fileName = req.toUrl(parsed.moduleName + extPart) + '.js';

            //Leverage own load() method to load plugin value, but only
            //write out values that do not have the strip argument,
            //to avoid any potential issues with ! in file names.
            text.load(nonStripName, req, function(value) {
                //Use own write() method to construct full module value.
                //But need to create shell that translates writeFile's
                //write() to the right interface.
                var textWrite = function(contents) {
                    return write(fileName, contents);
                };
                textWrite.asModule = function(moduleName, contents) {
                    return write.asModule(moduleName, fileName, contents);
                };

                text.write(pluginName, nonStripName, textWrite, config);
            }, config);
        }
    };

    if (masterConfig.env === 'node' || (!masterConfig.env &&
            typeof process !== "undefined" &&
            process.versions &&
            !!process.versions.node)) {
        //Using special require.nodeRequire, something added by r.js.
        fs = require.nodeRequire('fs');

        text.get = function(url, callback, errback) {
            try {
                var file = fs.readFileSync(url, 'utf8');
                //Remove BOM (Byte Mark Order) from utf8 files if it is there.
                if (file.indexOf('\uFEFF') === 0) {
                    file = file.substring(1);
                }
                callback(file);
            } catch (e) {
                errback(e);
            }
        };
    } else if (masterConfig.env === 'xhr' || (!masterConfig.env &&
            text.createXhr())) {
        text.get = function(url, callback, errback, headers) {
            var xhr = text.createXhr(),
                header;
            xhr.open('GET', url, true);

            //Allow plugins direct access to xhr headers
            if (headers) {
                for (header in headers) {
                    if (headers.hasOwnProperty(header)) {
                        xhr.setRequestHeader(header.toLowerCase(), headers[header]);
                    }
                }
            }

            //Allow overrides specified in config
            if (masterConfig.onXhr) {
                masterConfig.onXhr(xhr, url);
            }

            xhr.onreadystatechange = function(evt) {
                var status, err;
                //Do not explicitly handle errors, those should be
                //visible via console output in the browser.
                if (xhr.readyState === 4) {
                    status = xhr.status;
                    if (status > 399 && status < 600) {
                        //An http 4xx or 5xx error. Signal an error.
                        err = new Error(url + ' HTTP status: ' + status);
                        err.xhr = xhr;
                        errback(err);
                    } else {
                        callback(xhr.responseText);
                    }

                    if (masterConfig.onXhrComplete) {
                        masterConfig.onXhrComplete(xhr, url);
                    }
                }
            };
            xhr.send(null);
        };
    } else if (masterConfig.env === 'rhino' || (!masterConfig.env &&
            typeof Packages !== 'undefined' && typeof java !== 'undefined')) {
        //Why Java, why is this so awkward?
        text.get = function(url, callback) {
            var stringBuffer, line,
                encoding = "utf-8",
                file = new java.io.File(url),
                lineSeparator = java.lang.System.getProperty("line.separator"),
                input = new java.io.BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(file), encoding)),
                content = '';
            try {
                stringBuffer = new java.lang.StringBuffer();
                line = input.readLine();

                // Byte Order Mark (BOM) - The Unicode Standard, version 3.0, page 324
                // http://www.unicode.org/faq/utf_bom.html

                // Note that when we use utf-8, the BOM should appear as "EF BB BF", but it doesn't due to this bug in the JDK:
                // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4508058
                if (line && line.length() && line.charAt(0) === 0xfeff) {
                    // Eat the BOM, since we've already found the encoding on this file,
                    // and we plan to concatenating this buffer with others; the BOM should
                    // only appear at the top of a file.
                    line = line.substring(1);
                }

                if (line !== null) {
                    stringBuffer.append(line);
                }

                while ((line = input.readLine()) !== null) {
                    stringBuffer.append(lineSeparator);
                    stringBuffer.append(line);
                }
                //Make sure we return a JavaScript string and not a Java string.
                content = String(stringBuffer.toString()); //String
            } finally {
                input.close();
            }
            callback(content);
        };
    } else if (masterConfig.env === 'xpconnect' || (!masterConfig.env &&
            typeof Components !== 'undefined' && Components.classes &&
            Components.interfaces)) {
        //Avert your gaze!
        Cc = Components.classes,
            Ci = Components.interfaces;
        Components.utils['import']('resource://gre/modules/FileUtils.jsm');

        text.get = function(url, callback) {
            var inStream, convertStream,
                readData = {},
                fileObj = new FileUtils.File(url);

            //XPCOM, you so crazy
            try {
                inStream = Cc['@mozilla.org/network/file-input-stream;1']
                    .createInstance(Ci.nsIFileInputStream);
                inStream.init(fileObj, 1, 0, false);

                convertStream = Cc['@mozilla.org/intl/converter-input-stream;1']
                    .createInstance(Ci.nsIConverterInputStream);
                convertStream.init(inStream, "utf-8", inStream.available(),
                    Ci.nsIConverterInputStream.DEFAULT_REPLACEMENT_CHARACTER);

                convertStream.readString(inStream.available(), readData);
                convertStream.close();
                inStream.close();
                callback(readData.value);
            } catch (e) {
                throw new Error((fileObj && fileObj.path || '') + ': ' + e);
            }
        };
    }
    return text;
});

/* global console */
define('template', ['underscore', 'text'], function(_, text) {
    var buildMap = {};

    return {
        load: function(name, req, onLoad, config) {
            var text_name = "template_src/" + name + ".underscore";
            text.get(req.toUrl(text_name), function(template_source) {
                var template = _.template(template_source);
                if (config.isBuild) {
                    buildMap[name] = template.source;
                }
                onLoad(template);
            });
        },

        write: function(pluginName, moduleName, write) {
            if (moduleName in buildMap) {
                var template = (buildMap[moduleName]);
                write(
                    "define('" +
                    pluginName + '!' + moduleName + "', " +
                    "['underscore'], " +
                    "function(_) {return " + template + ";}" +
                    ");"
                );
            } else {
                console.log("ERROR - failed to find template " + moduleName + " in buildMap");
            }
        }
    };
});

define('template!unsupported_browser', ['underscore'], function(_) {
    return function(obj) {
        var __p = '';
        var print = function() { __p += Array.prototype.join.call(arguments, '') };
        with(obj || {}) {
            __p += '<div id="unsupported-browser" class="modal_section">\n  <div style=\'color:black; font-size:150%;\'>' +
                (t('Unsupported Browser')) +
                '</div>\n  <div style=\'padding:20px 0px; color:#666\'>\n      ' +
                (t('Desmos works best on your version of Android if you use the Chrome Browser.')) +
                '\n      <br><br>\n      <a href=\'https://play.google.com/store/apps/details?id=com.android.chrome\'>\n        ' +
                (t('Click here to download Google Chrome.')) +
                '<br><br>\n      </a>\n\n          <div style="text-align: center; margin-top: 25px; margin-bottom:-16px">\n              <a class=\'dcg-btn dcg-action-hide dcg-do-not-blur\'>' +
                (t('Hide this warning.')) +
                '</a>\n          </div>\n  </div>\n</div>\n';
        }
        return __p;
    };
});
define('template!login_dialog', ['underscore'], function(_) {
    return function(obj) {
        var __p = '';
        var print = function() { __p += Array.prototype.join.call(arguments, '') };
        with(obj || {}) {
            __p += '<div id="login-dialog" class="modal_section">\n  <h1>\n    ' +
                (t('Sign In')) +
                '\n  </h1>\n  \n  <div class=\'bg-line\'>\n    <span>' +
                (t('Sign In with Google')) +
                '</span>\n  </div>\n    <div class=\'google-login-btn\'>\n      <span class=\'dcg-btn dcg-btn-large dcg-action-googlelogin\'><img src=\'/img/google_32.png\' width=\'24px\' height=\'24px\' /> ' +
                (t('Sign In with Your Google Account')) +
                '</span>\n    </div>\n    \n  <div class=\'bg-line\'>\n    <span>' +
                (t('Sign In with Desmos')) +
                '</span>\n  </div>\n  \n  ';
            _.each(errors, function(error) {;
                __p += '\n  <div class="errors">\n      <span>' +
                    (error.message) +
                    '</span>\n  </div>\n  ';
            });
            __p += '\n  \n  <form class="desmos-login dcg-action-submit">\n    <div class="form_content_interior">\n      <label for="email">\n        <span>' +
                (t('Email:')) +
                '</span>\n        <input type="email"\n          name="email"\n          class="input"\n          autofocus="autofocus"\n          required="required"\n          id="top_email"\n        />\n      </label>\n  \n      <label>\n        <span>' +
                (t('Password:')) +
                '</span>\n        <input type="password"\n          name="password"\n          class="input"\n          required="required"\n          id="top_password"\n        />\n      </label>\n  \n      <span style="float: left; margin-top: 10px; margin-bottom: 10px">\n        <a class="dcg-action-recoverpassword">' +
                (t('Forgot your password?')) +
                '</a>\n        <div style=\'height:10px\'></div>\n        <a class="dcg-action-createaccount">' +
                (t("Don't have an account?")) +
                '</a>\n      </span>\n  \n      <div style="float:right; margin-right: 30px">\n        ';
            if (spinning) {;
                __p += '\n          <div class="progress_indicator progress"></div>\n        ';
            } else {;
                __p += '\n          <button type="submit" class="dcg-btn dcg-btn-green">' +
                    (t('Sign In')) +
                    '</button> \n        ';
            };
            __p += '\n      </div>\n  \n    </div>\n  </form>\n</div>\n';
        }
        return __p;
    };
});
define('template!create_account_dialog', ['underscore'], function(_) {
    return function(obj) {
        var __p = '';
        var print = function() { __p += Array.prototype.join.call(arguments, '') };
        with(obj || {}) {
            __p += '<div id="create-account-dialog" class="modal_section ';
            if (saveNext) {;
                __p += ' save-first';
            };
            __p += '">\n  <h1>\n    ';
            if (saveNext) {;
                __p += '\n      ' +
                    (t('Create an account to save your work!')) +
                    '\n    ';
            } else {;
                __p += '\n      ' +
                    (t('Create Account')) +
                    '\n    ';
            };
            __p += '\n  </h1>\n  ';
            if (saveNext) {;
                __p += '\n    <h4 style="margin-bottom: 30px">' +
                    (t('Already have an account?')) +
                    ' <span class="dcg-action-login-then-save">' +
                    (t('Sign in')) +
                    '</span></h4>\n  ';
            };
            __p += '\n  <div class=\'bg-line\'>\n    <span>' +
                (t('Link to Google')) +
                '</span>\n  </div>\n    <div class=\'google-login-btn\'>\n      <span class=\'dcg-btn dcg-btn-large dcg-action-googlelogin\'>\n        <img src=\'/img/google_32.png\' width=\'24px\' height=\'24px\' />\n        ' +
                (t("Link to your Google Account")) +
                '\n      </span>\n    </div>\n    <div class=\'bg-line\'><span>\n      ' +
                (t("Use your Email Address")) +
                '\n    </span></div>\n  \n  ';
            _.each(errors, function(error) {;
                __p += '\n  <div class="errors">\n      <span>' +
                    (error.message) +
                    '</span>\n  </div>\n  ';
            });
            __p += '\n  \n  <form class="dcg-action-submit">\n    <label>\n      <span>' +
                (t('Name:')) +
                '</span>\n      <input type="text"\n        name="name"\n        class="input"\n        required="required"\n        autofocus="autofocus"\n      />\n    </label>\n  \n    <div class="dcg-description">\n      ' +
                (t("This is the name we'll use if we feature one of your graphs.")) +
                '\n    </div>\n  \n    <label>\n      <span>' +
                (t('Email:')) +
                '</span>\n      <input type="email"\n        name="email"\n        class="input"\n        required="required"\n      />\n    </label>\n  \n    <div class="dcg-description">\n      ' +
                (t("We'll never share or sell your email address.")) +
                '\n    </div>\n  \n    <label>\n      <span>' +
                (t('Password:')) +
                '</span>\n      <input type="password"\n        class="input"\n        name="password"\n        required="required"\n      />\n    </label>\n  \n    <span style="float: left; margin-top: 10px; margin-bottom: 10px">\n      <a class="dcg-action-login">' +
                (t('Already have an account?')) +
                '</a>\n    </span>\n  \n    ';
            if (spinning) {;
                __p += '\n      <div class="progress_indicator progress"></div>\n    ';
            } else {;
                __p += '\n      <button type="submit" class="dcg-btn dcg-btn-green" style="float:right; margin-right: 30px">' +
                    (t('Create Account')) +
                    '</button>\n    ';
            };
            __p += '\n      \n  </form>\n  <div class=\'notice\' style="margin-top: 30px">\n    ' +
                (t("By clicking \"__btn__,\" you acknowledge that you've read and accept our __terms_of_use_link__.", {
                    terms_of_use_link: "<a href='/terms' target='_blank'>" + t("Terms of Use") + "</a>",
                    btn: t("Create Account")
                })) +
                '\n  </div>\n';
        }
        return __p;
    };
});
define('template!edit_account_dialog', ['underscore'], function(_) {
    return function(obj) {
        var __p = '';
        var print = function() { __p += Array.prototype.join.call(arguments, '') };
        with(obj || {}) {
            __p += '<div id="edit-account-dialog" class="modal_section">\n  \n  ';
            _.each(errors, function(error) {;
                __p += '\n    <div class="errors">\n      <span>' +
                    (error.message) +
                    '</span>\n    </div>\n  ';
            });
            __p += '\n  \n  <form class="dcg-action-submit">\n    ';
            if (user) {;
                __p += '\n      <h1>' +
                    (t('Edit Account')) +
                    '</h1>\n      <label>\n        <span>' +
                    (t('Name:')) +
                    '</span>\n        <input type="text"\n          name="name"\n          class="input"\n          id="edit_name"\n          autofocus="autofocus"\n          required="required"\n          value="' +
                    (user.name) +
                    '"\n        />\n      </label>\n      <div class="dcg-description">\n        ' +
                    (t("This is the name we'll use if we feature one of your graphs.")) +
                    '\n      </div>\n  \n      ';
                if (!user.isEdmodoUser && !user.isDriveUser) {;
                    __p += '\n        <h1>' +
                        (t('Update Password')) +
                        '</h1>\n        <div id="update-password-fields">\n          <label>\n            <span>' +
                        (t('Current Password:')) +
                        '</span>\n            <input type="password"\n              name="old_pass"\n              class="input"\n            />\n          </label>\n  \n          <label>\n            <span>' +
                        (t('New Password:')) +
                        '</span>\n            <input type="password"\n              name="new_pass"\n              class="input"\n            />\n          </label>\n  \n          <label>\n            <span>' +
                        (t('Repeat Password:')) +
                        '</span>\n            <input type="password"\n              name="repeat_new_pass"\n              class="input"\n            />\n          </label>\n        </div>\n      ';
                };
                __p += '\n      <br />\n      \n      ';
                if (spinning) {;
                    __p += '\n        <div class="progress_indicator progress"></div>\n      ';
                } else {;
                    __p += '\n        <button type="submit" class=\'dcg-btn dcg-btn-green\' id=\'save_graph_btn\' style="float:right; margin-right: 45px">\n          ' +
                        (t('Update Account')) +
                        '\n        </button>\n      ';
                };
                __p += '\n    ';
            };
            __p += '\n  </form>\n</div>';
        }
        return __p;
    };
});
define('template!save_dialog', ['underscore'], function(_) {
    return function(obj) {
        var __p = '';
        var print = function() { __p += Array.prototype.join.call(arguments, '') };
        with(obj || {}) {
            __p += '<div id="save-dialog" class="modal_section">\n    <h1>\n      ' +
                (t('Save This Graph!')) +
                '\n    </h1>\n\n    <label class=\'input-label\'>\n      <div class=\'graph-title-title\'>' +
                (t('Title:')) +
                ' &nbsp; </div>\n      <input class="title-input"\n             name="title"\n             placeholder="[' +
                (t('Untitled Graph')) +
                ']"\n             value="' +
                (title) +
                '"\n      >\n    </label>\n\n    ';
            if (user.isDriveUser) {;
                __p += '\n    <div>\n      <label class="send-to-drive">\n        <input type="checkbox" name="push_to_drive" />\n        ' +
                    (t('Send a Copy to Google Drive')) +
                    '\n      </label>\n    </div>\n    ';
            };
            __p += '\n    <br><br>\n\n    <div>\n    ';
            if (title) {;
                __p += '\n\n      <button type="submit" class="dcg-btn dcg-btn-green pull-right dcg-action-save-as">' +
                    (t('Save a New Copy')) +
                    '</button>\n      <button type="submit" class="dcg-btn dcg-btn-gray pull-right dcg-action-save">' +
                    (t('Rename Graph')) +
                    '</button>\n\n\n    ';
            } else {;
                __p += '\n\n    <button type="submit" class="dcg-btn dcg-btn-green pull-right dcg-action-save-as">' +
                    (t('Save Graph')) +
                    '</button>\n\n    ';
            };
            __p += '\n    </div>\n</div>';
        }
        return __p;
    };
});
define('template!recover_password_dialog', ['underscore'], function(_) {
    return function(obj) {
        var __p = '';
        var print = function() { __p += Array.prototype.join.call(arguments, '') };
        with(obj || {}) {
            __p += '<div id="recover-password-dialog" class="modal_section">\n  <h1>' +
                (t('Recover Password')) +
                '</h1>\n  \n  ';
            _.each(errors, function(error) {;
                __p += '\n  <div class="errors">\n      <span>' +
                    (error.message) +
                    '</span>\n  </div>\n  ';
            });
            __p += '\n  \n  ';
            if (sentMessage) {;
                __p += '\n    <p>' +
                    (t("Message sent. Please check your email for a password recovery link.") + " (<a href='#' class='dcg-action-tryagain'>" + t("Didn't work? Try again!") + '</a>)') +
                    '</p>\n  ';
            } else {;
                __p += '\n  \n    <form class="dcg-action-submit">\n      <p>' +
                    (t('Please enter your email address. We will send a password recovery link to you.')) +
                    '</p>\n  \n      <label>\n        <span>' +
                    (t('Email:')) +
                    '</span>\n        <input type="email"\n        name="email"\n        class="input"\n        id="recover_email"\n        required="required"\n        autofocus="autofocus"\n        />\n      </label>\n\n      <br />\n\n      ';
                if (spinning) {;
                    __p += '\n        <div class="progress_indicator progress"></div>\n      ';
                } else {;
                    __p += '\n        <button type="submit" class="dcg-btn dcg-btn-green" style="float: right; margin-right: 30px">' +
                        (t('Recover Password')) +
                        '</button>\n      ';
                };
                __p += '\n\n    </form>\n    <br />\n  ';
            };
            __p += '\n  <p class="dcg-remembered-password">' +
                (t('Remembered your password?')) +
                ' <a class="dcg-action-login">' +
                (t('Sign In')) +
                '</a></p>\n</div>';
        }
        return __p;
    };
});
define('main/modals_controller', ['require', 'console', 'jquery', 'pjs', 'underscore_view', 'main/parse_json_errors', 'keys', 'i18n', 'conditional_blur', 'vendor/jquery.html5-placeholder-shim', 'template!unsupported_browser', 'template!login_dialog', 'template!create_account_dialog', 'template!edit_account_dialog', 'template!save_dialog', 'template!recover_password_dialog'], function(require) {
    var console = require('console');
    var $ = require('jquery');
    var P = require('pjs');
    var UnderscoreView = require('underscore_view');
    var parseJSONErrors = require('main/parse_json_errors');
    var Keys = require('keys');
    var i18n = require('i18n');
    var conditionalBlur = require('conditional_blur');

    require('vendor/jquery.html5-placeholder-shim');

    var templates = {};
    templates.unsupported_browser = require('template!unsupported_browser');
    templates.login_dialog = require('template!login_dialog');
    templates.create_account_dialog = require('template!create_account_dialog');
    templates.edit_account_dialog = require('template!edit_account_dialog');
    templates.save_dialog = require('template!save_dialog');
    templates.recover_password_dialog = require('template!recover_password_dialog');

    var popupDriveLogin = function() {
        var popup_window = window.open(
            '/drive_api/calculator/login',
            'drive_window',
            'width=650, height=530'
        );
        if (!popup_window) {
            alert(i18n.t('Login window blocked. Please allow popups from desmos.com to sign in with Google.'));
        }
    };

    var ModalsController = P(function(c) {

        c.init = function(graphsController) {
            this.modals = {
                unsupportedBrowserDialog: UnsupportedBrowserDialog(
                    graphsController,
                    this
                )
            };
        };

        c.ready = function() {
            this.modalElement = $('#state-modals');
            this.modalBackground = $('#modal_background');
            this.modalElement
                .find('.close-modal')
                .add(this.modalBackground)
                .on('tap', this.hide.bind(this));
        };

        c.hide = function(el) {
            try {
                //only blur if we're disappearing the focused element
                //one relevant example: feels weird to have the active mathquill blur
                //when we dismiss the "unsupported browser" modal.
                //
                //I think this is here just so that we don't end up in a weird
                //state on iPad where a focused textbox in a modal becomes hidden, but retains focus
                if ($(document.activeElement).closest(this.modalElement).length > 0) conditionalBlur();
            } catch (e) {}

            $("input[type='password']").attr("value", "");
            //this gets called right at the beginning (complete login) before modalBackground exists
            if (this.modalBackground) {
                this.modalBackground.hide();
                this.modalElement.hide();
            }
            $(el).off('keydown');
        };

        c.show = function(el) {
            $(el).siblings('.modal_section').hide();
            $(el).show();
            this.modalBackground.show();
            this.modalElement.show();
            $(el).on('keydown', this.handleKeydown.bind(this));
        };
        c.handleKeydown = function(evt) {
            if (Keys.lookup(evt) === Keys.ESCAPE) {
                this.hide($(evt.currentTarget));
            }
        };
        c.$ = function() {
            return this.modalElement;
        };

    });

    var ModalDialogView = P(UnderscoreView, function(view, _super) {

        view.init = function(graphsController, modalsController) {
            _super.init.call(this);
            this.errors = [];
            this.spinning = false;
            this.saved_inputs = {};
            this.initialized = false;
            this.graphsController = graphsController;
            this.modalsController = modalsController;
        };

        view.getTemplateParams = function() {
            return {
                errors: this.errors,
                spinning: this.spinning
            };
        };

        view.show = function() {
            if (!this.initialized) {
                this.appendTo(this.modalsController.$());
                this.initialized = true;
            }
            this.errors = [];
            this.rerender();
            this.modalsController.show(this.$());
            // Focus first visible input
            this.$('input:visible, textarea:visible').first().focus();
            // Update position of placeholder shims.
            if ($.placeholder) $.placeholder.shim();
        };

        view.beforeRerender = function() {
            // save what the display value was for the .modal_section
            this.__$display = this.$().css('display');

            // save input values
            var self = this;
            this.$('input,textarea').each(function() {
                var name = $(this).attr('name');
                var value = $(this).val();

                self.saved_inputs[name] = value;
            });
        };

        view.afterRerender = function() {
            // must restore this if we want the modal to display. They are display:none
            // by default and that's how it'll get rerendered.
            this.$().css('display', this.__$display);

            // restore input values
            for (var name in this.saved_inputs) {
                this.$('[name="' + name + '"]').val(this.saved_inputs[name]);
            }
        };

        view.hide = function() {
            this.modalsController.hide();
        };

        view.processJSONErrors = function(jqXHR) {
            this.errors = parseJSONErrors(jqXHR);
        };

        view.startProcessingForm = function() {
            this.spinning = true;
            this.errors = [];
            this.rerender();
        };

        view.stopProcessingForm = function() {
            this.spinning = false;
            this.rerender();
        };

        view.successAnimation = function() {
            //reaches into header
            $('.dcg-edit-acct-success').show();
            setTimeout(function() {
                $('.dcg-edit-acct-success').fadeOut('fast');
            }, 800);
        };
    });

    /*
     * here are the actual modal states
     */
    var UnsupportedBrowserDialog = P(ModalDialogView, function(view) {
        view.template = templates.unsupported_browser;
        view.didCreateElement = function() {
            this.$('.dcg-action-hide').on('tap', this.hide.bind(this));
        };
    });

    return ModalsController;
});

/*global console*/
define('loadcss', ['text'], function(text) {
    var buildMap = {};

    function inject_css_file(href) {
        var head = document.getElementsByTagName('head')[0];
        var link = document.createElement('link');
        link.href = href;
        link.rel = 'stylesheet';
        link.type = 'text/css';
        head.appendChild(link);
    }

    return {
        load: function(name, req, onLoad, config) {
            var filename = req.toUrl(name) + ".css";

            // it's a build, so we grab the source directly
            if (config.isBuild) {
                text.get(filename, function(css_source) {
                    buildMap[name] = css_source;
                    onLoad();
                });
            }

            // not a build, so add a <link> element to load the css file
            else {
                inject_css_file(filename);
                onLoad();
            }
        },

        onLayerEnd: function(write, data) {
            var complete_css = '';
            for (var moduleName in buildMap) {
                complete_css += buildMap[moduleName];
            }

            // save a css file in the same folder as the .js that will be saved. Could possibly
            // integrate this better with optimize.js in order to have more control over where the css
            // file goes. For now, it's fine within the generated/js/ dir.
            var fs = require.nodeRequire('fs');
            var css_file = data.path.replace(/\.js/g, '.required.css');
            fs.writeFileSync(css_file, complete_css, 'utf8');
        },

        write: function(pluginName, moduleName, write) {
            if (moduleName in buildMap) {
                write("define('" + pluginName + '!' + moduleName + "', function(){});");
            } else {
                console.log("ERROR - failed to find css " + moduleName + " in buildMap");
            }
        }
    };
});

define('loadcss!css/header_desktop', function() {});
define('browser', ['require', 'jquery'], function(require) {
    var $ = require('jquery');

    var Browser = {
        IS_IE8: navigator.userAgent.match(/MSIE 8.0/i) !== null,
        IS_IE9: navigator.userAgent.match(/MSIE 9.0/i) !== null,
        IS_IE: navigator.userAgent.match(/MSIE/i) !== null,
        IS_IPAD: navigator.userAgent.match(/iPad/i) !== null,
        IS_MOBILE: navigator.userAgent.match(/Mobile|Android/i) !== null,
        IS_ANDROID: navigator.userAgent.match(/Android/i) !== null,
        IS_CHROME: navigator.userAgent.match(/Chrome/i) !== null,
        IS_KINDLE: navigator.userAgent.match(/Kindle/i) !== null || navigator.userAgent.match(/Silk/i) !== null,
        IS_IN_IFRAME: window.parent !== window
    };
    Browser.IS_TABLET = (Browser.IS_IPAD || Browser.IS_ANDROID || Browser.IS_KINDLE);

    Browser.IOS_VERSION = (function() {
        //http://stackoverflow.com/questions/8348139/detect-ios-version-less-than-5-with-javascript
        var v = (navigator.appVersion).match(/OS (\d+)_(\d+)_?(\d+)?/);
        if (v) {
            return [parseInt(v[1], 10), parseInt(v[2], 10), parseInt(v[3] || 0, 10)];
        }
        return null;
    })();

    // Returns translate3d if supported, translate otherwise
    // from http://stackoverflow.com/questions/5661671/detecting-transform-translate3d-support
    //
    // Needs document.body to be defined before it can run (so that we can put
    // an element into it). In supported browsers, the value will be set to
    // true on $(document).ready();
    Browser.SUPPORTS_TRANSLATE3D = false;

    $(document).ready(function() {

        var el = document.createElement('p');
        var has3d;
        var computedStyle;
        var transforms = {
            'webkitTransform': '-webkit-transform',
            'OTransform': '-o-transform',
            'msTransform': '-ms-transform',
            'MozTransform': '-moz-transform',
            'transform': 'transform'
        };
        // Add it to the body to get the computed style.
        document.body.insertBefore(el, null);
        for (var t in transforms) {
            if (el.style[t] !== undefined) {
                el.style[t] = "translate3d(1px,1px,1px)";
                computedStyle = window.getComputedStyle(el);
                if (!computedStyle) return;
                has3d = computedStyle.getPropertyValue(transforms[t]);
            }
        }
        document.body.removeChild(el);
        Browser.SUPPORTS_TRANSLATE3D = (
            has3d !== undefined &&
            has3d.length > 0 &&
            has3d !== "none"
        );
    });

    //return a generated rule for an x-y translation. use translate3d where supported
    Browser.translateRule = function(x, y) {
        if (Browser.SUPPORTS_TRANSLATE3D) {
            return "translate3d(" + x + (x ? "px" : "") + "," + y + (y ? "px" : "") + ",0)";
        }
        return "translate(" + x + (x ? "px" : "") + "," + y + (y ? "px" : "") + ")";
    };

    Browser.SUPPORTS_CANVAS = (function() {
        var elem = document.createElement('canvas');
        var supports_canvas = !!(elem.getContext && elem.getContext('2d'));
        return supports_canvas;
    })();

    return Browser;
});

define('loadcss!tipsycss', function() {});
// tipsy, facebook style tooltips for jquery
// version 1.0.0a
// (c) 2008-2010 jason frame [jason@onehackoranother.com]
// released under the MIT license
//
// Modified by Mike Haverstock to work with touchtracking.js to decide when
// to show tooltips and when not to. Problem is that this library doesn't
// allow you to manually hide/show tooltips that are set with the 'live'
// option. That's because the 'live' option postpones tipsy instantiation for
// a specific node until an event bubbles up for that node. So, when you call
// .tipsy('show') for a live node, it sees that there is no .data('tipsy') set
// for the node and ignores the request. The solution is to not listen for
// mouseenter and mouseleave. Instead of those, you listen for 'tipsyshow' and
// 'tipsyhide'. Then, you manually hide/show tooltips by triggering 'tipsyshow'
// and 'tipsyhide' on that node. Then, the live code works perfectly fine. Now
// the only way to trigger tipsy is by manually triggering those events.
define('tipsy', ['require', 'loadcss!tipsycss', 'jquery'], function(require) {
    //note: the path to tipsycss needs to be configured in your requirejs config
    //for example: `'tipsycss': '../vendor_manual/albany/tipsy'`

    require('loadcss!tipsycss');
    var $ = require('jquery');

    var openSticky = null;
    var ignoreStickyOpen = false;

    $(document).on('tap', '.tipsy-sticky', function(evnt) {

        // don't do anything. let the code that hides stickies close it.
        if (ignoreStickyOpen) {
            ignoreStickyOpen = false;
            return;
        }

        var opener = evnt.currentTarget;
        var $target = $(opener);

        // if the target doesn't have a tooltip, check if a child does
        if (!$target.attr('tooltip')) {
            $target = $target.find('[tooltip]').filter(':not([tooltip=""])');
        }

        // there should be exactly 1 tooltip to show
        if ($target.length !== 1) return;

        // ensure that the target is not display:none and no parent is display:none
        if ($target.css('display') === 'none') return;
        if ($target.parents().filter(function() { return $(this).css('display') === 'none' }).length) return;

        var options = $.extend({}, $.fn.tipsy.defaults);
        options.title = 'tooltip';
        options.gravity = 'nw';

        openSticky = new Tipsy($target[0], options);
        openSticky.show();
        openSticky.opener = opener;
    });

    $(document).on('tapstart keydown', function(evnt) {
        if (openSticky) {
            openSticky.hide();

            var opener = openSticky.opener;
            if (evnt.type === 'tapstart' && $(evnt.target).closest(opener).length) {
                $(document).one('tapend', function(evnt2) {
                    if ($(evnt2.target).closest(opener).length) {
                        ignoreStickyOpen = true;
                    }
                });
            }

            openSticky = null;
        }
    });

    function maybeCall(thing, ctx) {
        return (typeof thing == 'function') ? (thing.call(ctx)) : thing;
    }

    function Tipsy(element, options) {
        this.$element = $(element);
        this.options = options;
        this.fixTitle();
    }

    Tipsy.prototype = {
        show: function() {
            var title = this.getTitle();
            if (title && !isTipsyDisabled()) {
                var $tip = this.tip();
                var $arrow = $tip.find('.tipsy-arrow');

                $tip.find('.tipsy-inner')[this.options.html ? 'html' : 'text'](title);
                $tip[0].className = 'tipsy'; // reset classname in case of dynamic gravity
                $tip.remove().css({ top: 0, left: 0, visibility: 'hidden', display: 'block' }).prependTo(document.body);

                var pos = $.extend({}, this.$element.offset(), {
                    width: this.$element[0].offsetWidth,
                    height: this.$element[0].offsetHeight
                });

                var tp, actualWidth = $tip[0].offsetWidth,
                    actualHeight = $tip[0].offsetHeight,
                    gravity = maybeCall(this.options.gravity, this.$element[0]);

                switch (gravity.charAt(0)) {
                    case 'n':
                        tp = { top: pos.top + pos.height + this.options.offset, left: pos.left + pos.width / 2 - actualWidth / 2 };
                        break;
                    case 's':
                        tp = { top: pos.top - actualHeight - this.options.offset, left: pos.left + pos.width / 2 - actualWidth / 2 };
                        break;
                    case 'e':
                        tp = { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth - this.options.offset };
                        break;
                    case 'w':
                        tp = { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width + this.options.offset };
                        break;
                }

                if (gravity.length == 2) {
                    if (gravity.charAt(1) == 'w') {
                        tp.left = pos.left + pos.width / 2 - 15;
                    } else {
                        tp.left = pos.left + pos.width / 2 - actualWidth + 15;
                    }
                }
                var arrowMarginLeft = 0;

                if (tp.left < 0) {
                    arrowMarginLeft = tp.left;
                    tp.left = 0;
                } else if (tp.left + actualWidth > window.innerWidth) {
                    arrowMarginLeft = tp.left + actualWidth - window.innerWidth;
                    tp.left = window.innerWidth - actualWidth;
                }

                //we want to center it, so add -5px margin because the tipsy arrow is 10px wide
                if (gravity === 'n' || gravity === 's') {
                    arrowMarginLeft -= 5;
                }
                $arrow.css('marginLeft', arrowMarginLeft);

                $tip.css(tp).addClass('tipsy-' + gravity);

                $arrow[0].className = 'tipsy-arrow tipsy-arrow-' + gravity.charAt(0);
                if (this.options.className) {
                    $tip.addClass(maybeCall(this.options.className, this.$element[0]));
                }

                if (this.options.fadeIn) {
                    $tip.stop().css({ opacity: 0, display: 'block', visibility: 'visible' })
                        .animate({ opacity: this.options.opacity }, this.options.fadeIn);
                } else {
                    $tip.css({ visibility: 'visible', opacity: this.options.opacity });
                }

                if (this.options.sticky) {
                    $tip.addClass('tipsy-sticky');
                }

                var self = this;
                var validateLoop = function() {
                    self.validate();
                    self.validateTimeout = setTimeout(validateLoop, 100);
                };
                validateLoop();
            }
        },

        hide: function() {
            clearTimeout(this.validateTimeout);

            if (this.options.fadeOut) {
                this.tip().stop().fadeOut(this.options.fadeOut, function() { $(this).remove(); });
            } else {
                this.tip().remove();
            }
        },

        fixTitle: function() {
            var $e = this.$element;
            if ($e.attr('title') || typeof($e.attr('original-title')) != 'string') {
                $e.attr('original-title', $e.attr('title') || '').removeAttr('title');
            }
        },

        getTitle: function() {
            var title, $e = this.$element,
                o = this.options;
            this.fixTitle();
            o = this.options;
            if (typeof o.title == 'string') {
                title = $e.attr(o.title == 'title' ? 'original-title' : o.title);
            } else if (typeof o.title == 'function') {
                title = o.title.call($e[0]);
            }

            if (title) title = ('' + title).replace(/(^\s*|\s*$)/, "");
            return title || o.fallback;
        },

        tip: function() {
            if (!this.$tip) {
                this.$tip = $('<div class="tipsy"><div class="tipsy-arrow"></div><div class="tipsy-inner"></div></div>');
            }
            return this.$tip;
        },

        validate: function() {
            var hasTitle = !!this.getTitle();
            var inDom = false;

            if (hasTitle) {
                try {
                    var node = this.$element[0];

                    while (node) {
                        if (node === document) {
                            inDom = true;
                            break;
                        } else {
                            node = node.parentNode;
                        }
                    }
                } catch (e) {}
            }

            if (!inDom) {
                this.hide();
            }
        }
    };

    $.fn.tipsy = function(options) {

        if (options === true) {
            return this.data('tipsy');
        } else if (typeof options == 'string') {
            var tipsy = this.data('tipsy');
            if (tipsy) tipsy[options]();
            return this;
        }

        options = $.extend({}, $.fn.tipsy.defaults, options);

        options.fadeIn = options.fadeIn || options.fade;
        options.fadeOut = options.fadeOut || options.fade;

        function get(ele) {
            var tipsy = $.data(ele, 'tipsy');
            if (!tipsy) {
                tipsy = new Tipsy(ele, $.fn.tipsy.elementOptions(ele, options));
                $.data(ele, 'tipsy', tipsy);
            }
            return tipsy;
        }

        function enter(evnt) {
            // the tipsyshow event bubbles up the dom, so we only want to
            // listen to the event if the target is the same as the element
            // that is responding to the event. If this wasn't here then when
            // you move your mouse from a tipsy-enabled parent to a child, the
            // tipsyshow event would be fired from the child, bubble through
            // the parent, and get caught higher up. That would cause the
            // already opened tooltip to close and fade in again. With this
            // code, we ignore the tipsyshow event because the target is the
            // the child that isn't tipsy-enabled.
            if (evnt.type === 'tipsyshow' && evnt.target !== this) return;

            // this element has a sticky open already
            if (openSticky === this) return;

            var tipsy = get(this);
            tipsy.hoverState = 'in';

            if (options.delayIn === 0) {
                tipsy.show();
            } else {
                tipsy.fixTitle();
                setTimeout(function() { if (tipsy.hoverState == 'in') tipsy.show(); }, options.delayIn);
            }
        }

        function leave(evnt) {
            // we do this for the same reason we do it for the tipsyshow event.
            // look at the comment a few lines above for more information.
            if (evnt.type === 'tipsyhide' && evnt.target !== this) return;

            var tipsy = get(this);

            // if this is a sticky tooltip, don't close it on tapStart. If we
            // closed it now, it would flicker back on when we mouse up and
            // make it permanent. We'd like it to stay on the whole time.
            if (evnt.type === 'tapstart' && tipsy.options.sticky) return;

            tipsy.hoverState = 'out';
            if (options.delayOut === 0) {
                tipsy.hide();
            } else {
                setTimeout(function() { if (tipsy.hoverState == 'out') tipsy.hide(); }, options.delayOut);
            }
        }

        if (!options.live) this.each(function() { get(this); });

        if (options.trigger != 'manual') {
            var eventIn = options.trigger == 'hover' ? 'tipsyshow' : 'focus';
            var eventOut = options.trigger == 'hover' ? 'tipsyhide tapstart tapend tapcancel' : 'blur';

            if (options.live && options.delegate) {
                this.on(eventIn, options.delegate, enter).on(eventOut, options.delegate, leave);
            } else {
                var binder = options.live ? 'on' : 'bind';
                this[binder](eventIn, enter)[binder](eventOut, leave);
            }
        }

        return this;
    };

    $.fn.tipsy.defaults = {
        className: null,
        delayIn: 0,
        delayOut: 0,
        fade: false,
        fadeIn: false,
        fadeOut: false,
        fallback: '',
        gravity: 'n',
        html: false,
        live: true,
        offset: 0,
        opacity: 1,
        title: 'title',
        trigger: 'hover'
    };

    // Overwrite this method to provide options on a per-element basis.
    // (remember - do not modify 'options' in place!)
    $.fn.tipsy.elementOptions = function(ele, options) {
        options = $.extend({}, options);

        var gravity = $(ele).attr('tipsy-gravity');
        if (gravity) {
            options.gravity = gravity;
        }

        var offset = parseInt($(ele).attr('tipsy-offset'), 10);
        if (!isNaN(offset)) {
            options.offset = offset;
        }

        return options;
    };

    $.fn.tipsy.autoNS = function() {
        return $(this).offset().top > ($(document).scrollTop() + $(window).height() / 2) ? 's' : 'n';
    };

    $.fn.tipsy.autoWE = function() {
        return $(this).offset().left > ($(document).scrollLeft() + $(window).width() / 2) ? 'e' : 'w';
    };

    /**
     * yields a closure of the supplied parameters, producing a function that takes
     * no arguments and is suitable for use as an autogravity function like so:
     *
     * @param margin (int) - distance from the viewable region edge that an
     *        element should be before setting its tooltip's gravity to be away
     *        from that edge.
     * @param prefer (string, e.g. 'n', 'sw', 'w') - the direction to prefer
     *        if there are no viewable region edges effecting the tooltip's
     *        gravity. It will try to vary from this minimally, for example,
     *        if 'sw' is preferred and an element is near the right viewable
     *        region edge, but not the top edge, it will set the gravity for
     *        that element's tooltip to be 'se', preserving the southern
     *        component.
     */
    $.fn.tipsy.autoBounds = function(margin, prefer) {
        return function() {
            var dir = { ns: prefer[0], ew: (prefer.length > 1 ? prefer[1] : false) },
                boundTop = $(document).scrollTop() + margin,
                boundLeft = $(document).scrollLeft() + margin,
                $this = $(this);

            if ($this.offset().top < boundTop) dir.ns = 'n';
            if ($this.offset().left < boundLeft) dir.ew = 'w';
            if ($(window).width() + $(document).scrollLeft() - $this.offset().left < margin) dir.ew = 'e';
            if ($(window).height() + $(document).scrollTop() - $this.offset().top < margin) dir.ns = 's';

            return dir.ns + (dir.ew ? dir.ew : '');
        };
    };

    // automatically instantiate tipsy for .tipsy-sticky classes
    $(document).tipsy({
        title: 'tooltip',
        wait: 0,
        live: true,
        delegate: '.tipsy-sticky',
        gravity: 'nw',
        sticky: true,
        fade: false
    });

    var disableLocks = 0;

    function isTipsyDisabled() {
        return disableLocks !== 0;
    }

    function removeDisableLock() {
        disableLocks--;
    }

    function addDisableLock() {
        disableLocks++;
    }

    return {
        isDisabled: isTipsyDisabled,
        removeDisableLock: removeDisableLock,
        addDisableLock: addDisableLock
    };
});

define('loadcss!css/share_options', function() {});
define('main/popover_view', ['require', 'jquery', 'pjs', 'underscore_view', 'conditional_blur'], function(require) {
    var $ = require('jquery');
    var P = require('pjs');
    var UnderscoreView = require('underscore_view');
    var conditionalBlur = require('conditional_blur');

    var allPopovers = [];

    function handleIsVisibleChange(changedPopover) {
        // hide all other popovers when this one becomes visible
        if (changedPopover.isVisible) {
            allPopovers.forEach(function(popover) {
                if (popover !== changedPopover) {
                    popover.closePopover();
                }
            });

            $(document).on('tapstart.popover-' + changedPopover.popoverNumber, function(evt) {
                changedPopover.setProperty('isVisible', !changedPopover.eventShouldClosePopover(evt));
            });
        } else {
            $(document).off('tapstart.popover-' + changedPopover.popoverNumber);
        }
    }

    var PopoverView = P(UnderscoreView, function(view, _super) {

        view.init = function() {
            _super.init.call(this);
            this.isVisible = false;

            allPopovers.push(this);

            this.popoverNumber = allPopovers.length;

            this.observe('isVisible', function() {
                handleIsVisibleChange(this);
                this.renderIsVisible();
            }.bind(this));
        };

        //jquery selector for where the arrow head should point
        view.setPointTo = function(el) {
            this.pointTo = el;
        };

        view.alignArrow = function() {
            if (!this.isVisible) return;
            var cont = this.$();
            if (!this.pointTo.length || !cont.length) return;

            var offset = this.pointTo.offset().left + 0.5 * this.pointTo.width() - cont.offset().left;

            this.$('.dcg-arrow').css('left', offset);
        };

        view.setupOpenButton = function(openButton, on) {
            this.openButton = openButton;
            this.openButton.on(on, this.onBtnPressed.bind(this));
        };

        view.didInsertElement = function() {
            this.renderIsVisible();
        };

        view.renderIsVisible = function() {
            this.$().toggle(this.isVisible);
            if (this.openButton) this.openButton.toggleClass('dcg-active', this.isVisible);
            if (this.pointTo) this.alignArrow();
        };

        // don't do anything if we're inside the popover or if we're inside the openButton
        view.eventShouldClosePopover = function(evt) {
            return !this.eventIsWithinPopover(evt);
        };

        view.eventIsWithinPopover = function(evt) {
            var $target = $(evt.target);
            return $target.closest(this.$()).length || $target.closest(this.openButton).length;
        };

        view.onBtnPressed = function(evt) {
            //for touch devices
            conditionalBlur();

            var $target = $(evt.target);

            // this is a popover whose built inside of the button. act like we didn't
            // press the button
            if ($target.closest('.dcg-popover').length) {
                return;
            }

            // pressed the open/close button
            if ($target.closest(this.openButton).length) {
                this.togglePopover();
                return;
            }
        };

        view.togglePopover = function() {
            this.setProperty('isVisible', !this.isVisible);
        };

        view.closePopover = function() {
            this.setProperty('isVisible', false);
        };
    });

    return PopoverView;
});

define('template!share_options', ['underscore'], function(_) {
    return function(obj) {
        var __p = '';
        var print = function() { __p += Array.prototype.join.call(arguments, '') };
        with(obj || {}) {
            __p += '<div class="dcg-share-container dcg-popover dcg-bottom dcg-constrained-height-popover">\n    <div class="dcg-popover-interior">\n\n    <!-- have a graph hash -->\n\n    <div class=\'dcg-popover-title\'>\n      ' +
                (t('Share your graph with the world!')) +
                '\n    </div>\n    <div class="dcg-popover-content">\n\n      <div class=\'dcg-loading\'>\n          <img src="/img/spinner_dark.gif" width="16px" height="16px" />\n          ' +
                (t('loading...')) +
                '\n      </div>\n\n      <div class=\'dcg-loaded\'>\n        <br>\n        &nbsp; ' +
                (t('Share this link:')) +
                '\n        <input class="dcg-permalink select-all dcg-variable-permalink"></input>\n\n        <form class="dcg-action-screenshoturl" target=\'_blank\' method=\'post\'>\n          <div class="dcg-btn-group dcg-options-btns">\n            <span class="dcg-btn dcg-action-togglesection" section="email">' +
                (t('Email')) +
                '</span>\n            <span class="dcg-btn dcg-action-togglesection" section="embed">' +
                (t('Embed')) +
                '</span>\n            <input type=\'hidden\' name=\'img\' class=\'dcg-imgData\'>\n            <button type=\'submit\' class="dcg-btn image-btn" section="image">' +
                (t('Image')) +
                '</button>\n          </div>\n        </form>\n\n        <div class="dcg-email-div share-div">\n          <div class="template-emailerrors"></div>\n          <form class="dcg-action-emailgraph">\n            <label>' +
                (t('Send to:')) +
                '\n            <input type="email" multiple="multiple" name="recipients" required="required" class="first-input" />\n            </label>\n\n            <label>' +
                (t('Your Name:')) +
                '\n            <input type="text" name="name" required="required" class="dcg-variable-username" />\n            </label>\n\n            <label>' +
                (t('Message: <i>(optional)</i>')) +
                '\n            <textarea name="message" rows="3" class=\'dcg-share-message\'></textarea>\n            </label>\n\n            <input type="hidden" name="hash" class="dcg-variable-graphhash" />\n            <button type="submit" class="dcg-btn dcg-btn-green" name="submit">' +
                (t('Send')) +
                '</button>\n\n            <span class=\'email-status-notifications\'>\n              <span class="template-ifprocessing">\n                <img src="/img/spinner_dark.gif" width="16px" height="16px" />\n                ' +
                (t('sending...')) +
                '\n              </span>\n            </span>\n          </form>\n        </div>\n        <div class=\'dcg-email-sent\'>\n          ' +
                (t('message sent')) +
                '\n        </div>\n\n        <div class="dcg-embed-div share-div">\n          <label>\n            ' +
                (t('HTML Embed Code')) +
                '\n            <a href="http://support.desmos.com/entries/22449752-embedding-graphs-with-html" target="_blank">' +
                (t("what's this?")) +
                '</a>\n            <textarea rows="4" class="select-all first-input dcg-variable-htmlembedcode"></textarea>\n          </label>\n  \n          <label>\n            ' +
                (t('BBCode')) +
                '\n            <a href="http://support.desmos.com/entries/22449762-embedding-graphs-in-forums-with-bbcode" target="_blank">' +
                (t("what's this?")) +
                '</a>\n\n            <input rows="4" class="select-all dcg-variable-htmlembedcodebb" />\n\n          </label>\n        </div>\n\n        <div class="template-iffeatureable">\n          <div class=\'alert dcg-allow-feature\'>\n            <a type="button" class="close dcg-action-cancelfeature">&times;</a>\n              <div class=\'content\'>\n                <div class=\'dcg-title\'>\n                  <b>' +
                (t('Nice Graph!')) +
                '</b> <br> ' +
                (t('Want us to consider featuring it?')) +
                '\n                </div>\n                \n                <div class=\'dcg-btn-group\'>\n                  <span class="dcg-allowFeature dcg-btn dcg-action-togglefeature">' +
                (t('yeah!')) +
                '</span>\n                  <span class="dcg-disallowFeature dcg-btn dcg-action-togglefeature"> ' +
                (t('no, thanks')) +
                '</span>\n                </div>\n                \n              </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  \n    <div class="dcg-arrow"></div>\n</div>\n';
        }
        return __p;
    };
});
define('main/share_options', ['require', 'loadcss!css/share_options', 'jquery', 'underscore', 'pjs', 'main/popover_view', 'main/calculator_backend', 'main/parse_json_errors', 'template!share_options'], function(require) {
    require('loadcss!css/share_options');

    var $ = require('jquery');
    var _ = require('underscore');
    var P = require('pjs');
    var PopoverView = require('main/popover_view');
    var calculatorBackend = require('main/calculator_backend');
    var parseJSONErrors = require('main/parse_json_errors');
    var template = require('template!share_options');

    /*
     * view for the settings bar
     */

    var ShareView = P(PopoverView, function(view, _super) {
        view.template = template;
        view.pointToSelector = '.dcg-action-share i';

        view.init = function(graphsController, Calc) {
            _super.init.call(this);
            this.graphsController = graphsController;
            this.Calc = Calc;
            this.sharePromise = $.Deferred().reject().promise();
            this.setProperty('isFeatureable', false);
        };

        view.renderIsVisible = function() {

            _super.renderIsVisible.call(this);
            var isVisible = this.isVisible;
            this.$().toggle(isVisible);

            if (this.isVisible) {
                this.onBecameVisible();
            } else {
                this.onBecameHidden();
            }
        };

        view.eventShouldClosePopover = function(evt) {
            var $target = $(evt.target);

            if (this.eventIsWithinPopover(evt)) {
                return false;
            }

            return !$target.closest("#state-modals").length &&
                $target.attr("id") != "modal_background";
        };

        view.didCreateElement = function() {
            _super.didCreateElement.call(this);

            this.$().on('tapstart', ".select-all", function() {
                $(this).on('tapend', function() {
                    $(this).select();
                });
            });

            this.$().on('tapmove tapend', ".select-all", function() {
                $(this).off('tapend');
            });

            // event listeners
            this.$('.dcg-action-togglesection').on('tap', this.toggleSection.bind(this));
            this.$('.dcg-action-emailgraph').on('submit', this.emailGraph.bind(this));
            this.$('.dcg-action-cancelfeature').on('tap', this.cancelFeature.bind(this));
            this.$('.dcg-action-togglefeature').on('tapstart', this.toggleFeature.bind(this));

            var self = this;

            this.observeAndSync('isFeatureable', this.renderIsFeatureable.bind(this));
            this.observe('userAllowsFeature', this.renderUserAllowsFeature.bind(this));
            this.computeIsFeatureable();

            this.renderUser();
            this.renderGraph();
            this.renderIsProcessing();
            this.renderEmailErrors();
            this.renderOpenSection();
            this.setProperty('userAllowsFeature', true);
        };

        view.onBecameVisible = function() {
            var self = this;
            var graph = this.graphsController.currentGraph.copy();
            this.graphsController.updateGraphData(graph);
            this.sharePromise = calculatorBackend.shareGraph(graph).done(
                function(graph) {
                    self.setGraph(graph);
                    self.$('.dcg-loading').hide();
                    self.$('.dcg-loaded').show();
                    self.$('.dcg-imgData').attr(
                        "value",
                        self.Calc.screenshot()
                    );
                }
            );
        };

        view.onBecameHidden = function() {
            this.$('.dcg-loaded').hide();
            this.$('.dcg-loading').show();
            var graph = this.graph;
            if (this.isFeatureable && this.userAllowsFeature) {
                this.sharePromise.done(function() {
                    calculatorBackend.allowFeature({ hash: graph.hash });
                });
            }
            this.minimizeSections();
            this.setIsProcessing(false);
            this.setEmailErrors(undefined);
        };

        view.getIsProcessing = function() {
            return this.isProcessing;
        };

        view.setIsProcessing = function(isProcessing) {
            if (isProcessing === this.isProcessing) return;
            this.isProcessing = isProcessing;
            this.renderIsProcessing();
        };

        view.renderIsProcessing = function() {
            this.$('.template-ifprocessing').toggle(this.getIsProcessing());
        };

        view.getEmailErrors = function() {
            return this.emailErrors;
        };

        view.setEmailErrors = function(emailErrors) {
            if (_.isEqual(emailErrors, this.emailErrors)) return;
            this.emailErrors = emailErrors;
            this.renderEmailErrors();
        };

        view.renderEmailErrors = function() {
            var errors = this.$('.template-emailerrors');
            errors.children().remove();
            _.each(this.emailErrors, function(error) {
                errors.append('<div class="dcg-errors">' + error.message + '</div>');
            });
        };

        view.computeIsFeatureable = function() {
            var graph = this.graphsController.currentGraph;

            //we don't want Clever users to be able to accidentally mark graphs as public
            //since we get their name through the API and until we have explicit permission we
            //don't want to use that kind of user-identifiable information.
            var isFeatureable = (graph && graph.title);
            this.setProperty('isFeatureable', isFeatureable);
        };

        view.renderIsFeatureable = function() {
            this.$('.template-iffeatureable').toggle(!!this.isFeatureable);
        };

        view.renderUserAllowsFeature = function() {
            this.$('.dcg-allowFeature').toggleClass(
                "dcg-active", !!this.userAllowsFeature
            );
            this.$('.dcg-disallowFeature').toggleClass(
                "dcg-active", !this.userAllowsFeature
            );
        };

        view.setGraph = function(graph) {
            if (this.graph && _.isEqual(graph, this.graph)) return;
            this.graph = graph;
            this.renderGraph();
            this.computeIsFeatureable();
        };

        view.renderGraph = function() {
            var graph = this.graph;
            if (!graph) graph = {};
            if (!graph.hash) graph.hash = '';
            if (!graph.path) graph.path = '';

            this.$('.dcg-action-screenshoturl').attr('action', this.getScreenshotUrl(graph));
            this.$('.dcg-variable-facebook').attr('href', this.getFacebookURL(graph));
            this.$('.dcg-variable-twitter').attr('href', this.getTwitterURL(graph));
            this.$('.dcg-variable-google').attr('href', this.getGooglePlusURL(graph));
            this.$('.dcg-permalink').val(graph.path);
            this.$('.dcg-variable-graphhash').val(graph.hash);
            this.$('.dcg-variable-htmlembedcode').val(this.getHtmlEmbedCode(graph));
            this.$('.dcg-variable-htmlembedcodebb').val(this.getHtmlEmbedCodeBB(graph));
        };

        view.setUser = function(user) {
            if (_.isEqual(user, this.user)) return;
            this.user = user;

            this.renderUser();
            this.computeIsFeatureable();
        };

        view.renderUser = function() {
            var user = this.user;

            this.$('.dcg-variable-username').val(user ? user.name : '');
        };

        view.minimizeSections = function() {
            this.setOpenSection(null);
            $('.share-div').hide();
        };

        view.getOpenSection = function() {
            return this.openSection;
        };

        view.setOpenSection = function(section) {
            if (section === this.openSection) return;
            this.openSection = section;

            this.renderOpenSection();
        };

        view.renderOpenSection = function() {
            var section = this.getOpenSection();
            this.$('[section=email]').toggleClass('dcg-active', section === 'email');
            this.$('[section=embed]').toggleClass('dcg-active', section === 'embed');
            this.$('[section=image]').toggleClass('dcg-active', section === 'image');
        };

        view.toggleSection = function(e) {
            var section = $(e.target).attr("section");
            var isOpen = this.getOpenSection() === section;
            this.minimizeSections();

            if (!isOpen) {
                this.$('.dcg-allow-feature').hide();
                this.$('.dcg-' + section + '-div').show();
                this.$('.dcg-' + section + '-div .first-input').focus().select();

                if (section === 'email') {
                    this.$('.dcg-share-message').attr('value', '');
                    this.$('.dcg-email-div .first-input').attr('value', '');
                }

            } else {
                this.$('.dcg-allow-feature').show();
                section = null;
            }

            this.setOpenSection(section);
        };

        view.toggleFeature = function() {
            this.setProperty('userAllowsFeature', !this.userAllowsFeature);
        };

        view.cancelFeature = function() {
            this.setProperty('userAllowsFeature', false);
            this.$('.template-iffeatureable').slideUp('fast');
        };

        view.getFacebookURL = function(graph) {
            return 'https://www.facebook.com/sharer/sharer.php?u=' + encodeURIComponent(graph.path);
        };

        view.getTwitterURL = function(graph) {
            var message, path;
            if (graph.hash) {
                message = 'Look what I made with the Desmos Graphing Calculator: ';
                path = graph.path;
            } else {
                message = 'Check out the Desmos Graphing Calculator: beautiful, free math!';
                path = 'https://www.desmos.com';
            }
            return (
                'https://twitter.com/intent/tweet?' +
                'url=' + encodeURIComponent(path) +
                '&text=' + encodeURIComponent(message) +
                '&via=desmos'
            );
        };

        view.getGooglePlusURL = function(graph) {
            return 'https://plus.google.com/share?url=' + encodeURIComponent(graph.path);
        };

        view.getHtmlEmbedCode = function(graph) {
            return (
                '<a title="View with the Desmos Graphing Calculator" href="' + graph.path + '">' +
                '  <img src="' + graph.thumbURL + '" width="200px" height="200px"' +
                '     style="border:1px solid #ccc; border-radius:5px"' +
                '  />' +
                '</a>'
            );
        };

        view.getHtmlEmbedCodeBB = function(graph) {
            return '[GRAPH]' + graph.hash + '[/GRAPH]';
        };

        view.emailGraph = function(evt) {
            //don't submit the form
            evt.preventDefault();
            //don't repeat send
            if (this.getIsProcessing()) return;

            this.setIsProcessing(true);
            var self = this;
            var formData = $(evt.target).serialize();
            calculatorBackend.emailGraph(formData).done(function(msg) {
                self.setEmailErrors(undefined);
                self.$('.dcg-email-div').hide();
                self.$('.dcg-email-sent').show();
                setTimeout(function() {
                    self.$('.dcg-email-sent').slideUp(400);
                    self.minimizeSections();
                }, 1000);
            }).fail(function(jqXHR) {
                self.setEmailErrors(parseJSONErrors(jqXHR));
            }).always(function() {
                self.setIsProcessing(false);
            });
        };

        view.getScreenshotUrl = function(graph) {
            return "/screenshot/" + graph.hash;
        };

    });

    return ShareView;
});

define('loadcss!css/help', function() {});
define('template!help_desktop', ['underscore'], function(_) {
    return function(obj) {
        var __p = '';
        var print = function() { __p += Array.prototype.join.call(arguments, '') };
        with(obj || {}) {
            __p += '<div class="dcg-help-container dcg-popover dcg-bottom dcg-constrained-height-popover">\n  <div class="dcg-popover-interior">\n\n\n    <div class=\'dcg-popover-title\'>' +
                (t('Tours')) +
                '</div>\n    <div class=\'dcg-popover-content dcg-tours-content\'>\n      <!-- tours get inserted here -->\n    </div>\n\n    <div class=\'dcg-popover-title\'>' +
                (t('Resources')) +
                '</div>\n    <div class=\'dcg-popover-content dcg-resources-content\'>\n      <div>\n        <a href=\'' +
                (userGuideURL) +
                '\' target=\'_blank\'>\n          <i class=\'dcg-icon-book\'></i>\n          <span>' +
                (t('Desmos User Guide')) +
                '</span>\n        </a>\n      </div>\n\n      <div>\n        <a href=\'http://support.desmos.com/categories/20081717-using-the-desmos-graphing-calculator\' target=\'_blank\'>\n          <i class=\'dcg-icon-comments\'></i>\n          <span>' +
                (t('Knowledge Base')) +
                '</span>\n        </a>\n      </div>\n    </div>\n\n    <div class=\'dcg-popover-title dcg-interior-title\'>' +
                (t('Feedback')) +
                '</div>\n    <div class=\'dcg-popover-content\'>\n      <div class=\'dcg-resources-content dcg-feedback-content\'>\n\n\n      <span class="dcg-feedback-twitter">\n        <a href="https://twitter.com/intent/tweet?text=Hey%2C%20%40desmos:%20I\'ve%20got%20a%20question!&via=desmos" target=\'_blank\'>\n          <i class=\'dcg-icon-twitter\'></i>\n          <span>' +
                (t('Tweet @desmos')) +
                '</span>\n        </a>\n       </span>\n       <span class="dcg-feedback-facebook">\n        <a href="https://www.facebook.com/desmosinc" target=\'_blank\'>\n          <i class=\'dcg-icon-facebook\'></i>\n          <span>' +
                (t('Tell us on Facebook')) +
                '</span>\n        </a>\n      </span>\n\n\n      </div>\n\n      ';
            if (previewMode) {;
                __p += '\n\n        <div class=\'dcg-previewMode\'>\n          ' +
                    (previewMessage) +
                    '<br>\n          <a class=\'dcg-btn-green dcg-btn\' href=\'' +
                    (previewFeedbackUrl) +
                    '\' target=\'_blank\'>\n            ' +
                    (t("Share your thoughts!")) +
                    '\n          </a>\n        </div>\n\n      ';
            };
            __p += '\n\n      ';
            if (!maintenance && !previewMode) {;
                __p += '\n        <div class="dcg-suggestions">\n          <div class="template-errors"></div>\n          <div class="dcg-feedback-email-sent">\n            ' +
                    (t("Thanks for the feedback &ndash; you'll hear from us soon!")) +
                    '\n          </div>\n\n          <form class="dcg-action-submit">\n\n            <textarea placeholder="' +
                    (t('type your question or suggestion...')) +
                    '" name="message"></textarea>\n            <div class="dcg-suggestions-expansion">\n              <div class="template-unlessuser">\n                <div class=\'dcg-feedback-email-label\'>\n                  ' +
                    (t('Please provide an email so that we can write back.')) +
                    '\n                  <i>(' +
                    (t('optional')) +
                    ')</i></div>\n                <input name="anonymous-email" class="dcg-anonymous-email" placeholder="your.name@test.com" type="email" />\n              </div>\n              <span class="dcg-feedback-btns">\n                <a class="dcg-btn dcg-action-closesuggestion">\n                  ' +
                    (t('Cancel')) +
                    '\n                </a>\n                <button class="dcg-btn dcg-btn-green" name="submit" type="submit">\n                  ' +
                    (t('Send Feedback')) +
                    '\n                </button>\n                </span>\n\n              <div class="template-processing" style="display:none">\n                <img src="/img/spinner_dark.gif" width="16px" height="16px" /> ' +
                    (t('sending...')) +
                    '\n              </div>\n            </div>\n          </form>\n        </div>\n      ';
            };
            __p += '\n    </div>\n  </div>\n  <div class=\'dcg-arrow\'></div>\n</div>\n';
        }
        return __p;
    };
});

define('main/help_desktop', ['require', 'loadcss!css/help', 'jquery', 'underscore', 'pjs', 'main/popover_view', 'main/parse_json_errors', 'main/calculator_backend', 'template!help_desktop', 'i18n', 'config', 'vendor/jquery.html5-placeholder-shim'], function(require) {
    require('loadcss!css/help');

    var $ = require('jquery');
    var _ = require('underscore');
    var P = require('pjs');
    var PopoverView = require('main/popover_view');
    var parseJSONErrors = require('main/parse_json_errors');
    var calculatorBackend = require('main/calculator_backend');
    var template = require('template!help_desktop');
    var i18n = require('i18n');
    var Config = require('config');
    require('vendor/jquery.html5-placeholder-shim');

    /*
     * view for the help popover
     */

    var HelpView = P(PopoverView, function(view, _super) {
        view.template = template;
        view.pointToSelector = '.dcg-action-help i';

        view.init = function(
            graphsController,
            Calc,
            modals
        ) {
            _super.init.call(this);
            this.graphsController = graphsController;
            this.Calc = Calc;
            this.modals = modals;
        };

        view.renderIsVisible = function() {
            _super.renderIsVisible.call(this);
            if (this.isVisible) {
                if ($.placeholder) $.placeholder.shim();

                // becomes hidden
            } else {
                this.setErrors([]);
            }
        };

        view.getTemplateParams = function() {
            var userGuideURL = (i18n.enabled_languages[i18n.detectLanguage()] ?
                i18n.enabled_languages[i18n.detectLanguage()].userGuideURL :
                i18n.enabled_languages.en.userGuideURL
            );
            return {
                maintenance: Config.get('maintenance'),
                previewMode: Config.get('previewMode'),
                previewFeedbackUrl: Config.get('previewFeedbackUrl'),
                previewMessage: Config.get('previewMessage'),
                userGuideURL: userGuideURL
            };
        };

        view.eventShouldClosePopover = function(evt) {
            var $target = $(evt.target);
            if (this.eventIsWithinPopover(evt)) {
                return false;
            }

            return !$target.closest("#state-modals").length &&
                $target.attr("id") != "modal_background";
        };

        view.setErrors = function(errors) {
            if (_.isEqual(errors, this.errors)) return;
            this.errors = errors;

            var div = this.$('.template-errors');
            div.children().remove();
            for (var i = 0; i < errors.length; i++) {
                div.append('<div class="dcg-errors">' + errors[i].message + '</div>');
            }
        };

        view.setProcessing = function(processing) {
            if (processing === this.processing) return;
            this.processing = processing;

            this.$('.template-processing').toggle(processing);
        };

        view.setLoggedIn = function(loggedIn) {
            if (loggedIn === this.loggedIn) return;
            this.loggedIn = loggedIn;

            this.$('.template-unlessuser').toggle(!loggedIn);
        };

        view.didCreateElement = function() {
            _super.didCreateElement.call(this);
            var self = this;
            this.$('.dcg-suggestions textarea').on("focus", function() {
                $(this).animate({ "height": "80px" }, {
                    duration: 200,
                    complete: function() {
                        if ($.placeholder) $.placeholder.shim();
                    }
                });
                self.$('.dcg-suggestions-expansion').show();
            });

            this.$('.dcg-action-submit').on('submit', this.sendFeedback.bind(this));
            this.$('.dcg-action-closesuggestion').on('tap', this.closeSuggestion.bind(this));

            var closeModal = function() { this.setProperty('isVisible', false); };

            this.setErrors([]);
            this.setProcessing(false);
            this.setLoggedIn(false);
        };

        view.closeSuggestion = function() {
            this.$('.dcg-suggestions textarea').animate({ "height": "33px" }, 200).attr("value", "");
            this.$('.dcg-suggestions-expansion').fadeOut(200);
            this.setProcessing(false);
            this.setErrors([]);
        };

        //whether the feedback email is being sent
        view.sendFeedback = function(evt) {
            //don't submit the form
            evt.preventDefault();
            //don't repeat send
            if (this.processing) return;

            var message = $.trim(this.$('textarea[name="message"]').attr("value"));
            if (!message) {
                this.setErrors([{
                    message: i18n.t('Please enter your feedback.')
                }]);
                this.$('.dcg-suggestions').focus();
                return;
            }

            var feedbackData = {
                message: message,
                state: JSON.stringify(this.Calc.getState()),
                userAgent: navigator.userAgent,
                'anonymous-email': this.$('input[name="anonymous-email"]').attr("value")
            };

            // send feedback off
            var self = this;
            this.setProcessing(true);
            calculatorBackend.emailFeedback(feedbackData).done(function(msg) {
                self.$('.dcg-feedback-email-sent').show();
                self.setErrors([]);
                self.closeSuggestion();
                setTimeout(function() {
                    self.$('.dcg-feedback-email-sent').slideUp();
                }, 2000);
            }).fail(function(jqXHR) {
                self.setErrors(parseJSONErrors(jqXHR));
            }).always(function(msg) {
                self.setProcessing(false);
            });
        };

        view.openFeedback = function() {
            this.setProperty('isVisible', true);
            this.$('.dcg-suggestions textarea').focus();
        };
    });

    return HelpView;
});

define('loadcss!css/language', function() {});
define('template!language', ['underscore'], function(_) {
    return function(obj) {
        var __p = '';
        var print = function() { __p += Array.prototype.join.call(arguments, '') };
        with(obj || {}) {
            __p += '<div class="dcg-language-container dcg-popover dcg-bottom dcg-constrained-height-popover">\n\n  <div class=\'dcg-popover-interior\'>\n    <div class=\'dcg-popover-title\'>\n      ' +
                (t('Language')) +
                '\n    </div>\n    <div class=\'dcg-popover-content\'>\n      <table>\n        <tr>\n      ';
            var i = 0;
            _.each(enabled_languages, function(language, locale) {;
                __p += '\n       <td>\n        <div lang=\'' +
                    (locale) +
                    '\' class=\'dcg-language-option' +
                    ((locale === selected_language ? ' dcg-selected' : '')) +
                    '\'>\n            ' +
                    (language.displayName) +
                    '\n\n        </div>\n        </td>\n        ' +
                    (((++i) % 2 === 0 ? '</tr><tr>' : '')) +
                    '\n\n      ';
            });
            __p += '\n        </tr>\n      </table>\n\n      <div class=\'dcg-translate-invite\'>\n        Don\'t see your language?\n        <a\n          target=\'_blank\'\n          href=\'http://support.desmos.com/entries/28346817-Help-us-translate-Desmos-\'\n        >\n          Help us translate\n        </a>\n      </div>\n    </div>\n  </div>\n  <div class=\'dcg-arrow\'></div>\n</div>';
        }
        return __p;
    };
});
define('main/preserved_state', ['require'], function(require) {
    var pushState = function(stateInfo) {
        sessionStorage.preservedState = JSON.stringify(stateInfo);
    };

    var popState = function() {
        var state_str = sessionStorage.preservedState;
        sessionStorage.preservedState = '';
        if (!state_str) return;

        return JSON.parse(state_str);
    };

    var hasState = function() {
        return !!sessionStorage.preservedState;
    };

    return {
        pushState: pushState,
        popState: popState,
        hasState: hasState
    };
});
define('main/language', ['require', 'loadcss!css/language', 'jquery', 'pjs', 'underscore', 'main/popover_view', 'template!language', 'i18n', 'main/cookie', 'main/preserved_state'], function(require) {
    require('loadcss!css/language');
    var $ = require('jquery');
    var P = require('pjs');
    var _ = require('underscore');

    var PopoverView = require('main/popover_view');
    var template = require('template!language');
    var i18n = require('i18n');
    var Cookie = require('main/cookie');
    //for page reloads when, for example, you switch language
    var preservedState = require('main/preserved_state');

    var LanguageView = P(PopoverView, function(view, _super) {
        view.template = template;
        view.pointToSelector = '.dcg-action-language i';

        view.init = function(Calc) {
            _super.init.call(this);
            this.Calc = Calc;
        };

        view.getTemplateParams = function() {
            return {
                enabled_languages: i18n.enabled_languages,
                selected_language: i18n.detectLanguage()
            };
        };

        view.didCreateElement = function() {
            _super.didCreateElement.call(this);

            this.$('.dcg-language-option').on('tap', this.selectLanguage.bind(this));
        };

        view.selectLanguage = function(evt) {
            var $el = $(evt.target);
            if ($el.hasClass('dcg-selected')) return;

            this.closePopover();

            var unsavedState = this.Calc.getState();
            var savedState = this.Calc.graphChangeMonitor.getSavedState();

            var isStateEmpty = _.filter(unsavedState.expressions.list, function(expr) {
                return (!expr.hasOwnProperty('latex') || expr.latex);
            }).length === 0;

            //TODO - with the extra information we have here I feel like
            //we can do better than this.
            //don't preserve an empty state
            if (!isStateEmpty) {
                preservedState.pushState({
                    unsavedState: unsavedState,
                    savedState: savedState
                });
            }

            Cookie.setCookie('lang', $el.attr('lang'));
            location.reload();
        };
    });

    return LanguageView;
});

define('template!account_dropdown', ['underscore'], function(_) {
    return function(obj) {
        var __p = '';
        var print = function() { __p += Array.prototype.join.call(arguments, '') };
        with(obj || {}) {
            __p += '<div class="dcg-logout-options dcg-popover dcg-bottom">\n  <div class="dcg-popover-interior">\n    <div class="dcg-popover-content">\n      <div class=\'user-info\'>\n        <span class=\'account-name\'>' +
                (name) +
                '</span>\n        <span class=\'account-email\'>' +
                (email) +
                '</span>\n        <a class="dcg-action-editaccount">' +
                (t('Edit Account')) +
                '</a>\n      </div>\n      <a class="dcg-action-feedback">' +
                (t('Send Feedback')) +
                '</a>\n      <a class="dcg-action-logout">' +
                (t('Sign Out')) +
                '</a> \n    </div>\n  </div>\n  <div class=\'dcg-arrow\'></div>\n</div>';
        }
        return __p;
    };
});
define('main/account_dropdown', ['require', 'loadcss!css/help', 'jquery', 'pjs', 'main/popover_view', 'template!account_dropdown'], function(require) {
    require('loadcss!css/help');

    var $ = require('jquery');
    var P = require('pjs');
    var PopoverView = require('main/popover_view');
    var template = require('template!account_dropdown');

    /*
     * view for the account menu
     */

    var AccountView = P(PopoverView, function(view, _super) {
        view.template = template;
        view.pointToSelector = '.dcg-account-link .email i';

        view.init = function(helpView, modals) {
            _super.init.call(this);

            this.helpView = helpView;
            this.modals = modals;
        };

        view.getTemplateParams = function() {
            return {
                name: null,
                email: null
            };
        };

        view.editAccount = function() {
            this.modals.editAccountDialog.show();
            this.closePopover();
        };

        view.logout = function() {
            this.closePopover();
        };

        view.feedback = function() {
            this.closePopover();
            this.helpView.openFeedback();
        };

        view.eventShouldClosePopover = function(evt) {
            var $target = $(evt.target);

            if (this.eventIsWithinPopover(evt)) {
                return false;
            }

            return !$target.closest("#state-modals").length &&
                $target.attr("id") != "modal_background";
        };

        view.didCreateElement = function() {
            _super.didCreateElement.call(this);

            this.$('.dcg-action-logout').on('tap', this.logout.bind(this));
            this.$('.dcg-action-feedback').on('tap', this.feedback.bind(this));
            this.$('.dcg-action-editaccount').on('tap', this.editAccount.bind(this));
        };

    });

    return AccountView;
});

define('text!data/resources_examples.json', [], function() { return '[{\n  "section": "Lines",\n  "examples": [\n    {\n      "title": "Slope Intercept Form",\n      "graphHash": "59qdbtnlzy",\n      "state": {"graph": {"squareAxes": true, "showLabels": true, "showGrid": true, "showAxes": true, "labelXMode": "", "degreeMode": false, "labelYMode": "", "viewport": {"xmin": -10, "ymin": -5.537, "ymax": 5.537, "xmax": 10}}, "expressions": {"list": [{"color": "#C0504D", "latex": "y=mx+b", "domain": {"max": 10, "min": 0}, "id": 1, "hidden":false}, {"latex": "m=1", "domain": {"max": 10, "min": 0}, "color": "#F79646", "sliderMin": -10, "hidden":false, "sliderMax": 10, "id": 3}, {"latex": "b=1", "domain": {"max": 10, "min": 0}, "color": "#8064A2", "sliderMin": -10, "hidden":false, "sliderMax": 10, "id": 2}]}}\n    },\n    {\n      "title": "Point Slope Form",\n      "graphHash": "vphpgabluz",\n      "state": {"graph": {"squareAxes": true, "showLabels": true, "showGrid": true, "showAxes": true, "labelXMode": "", "degreeMode": false, "labelYMode": "", "viewport": {"xmin": -10, "ymin": -5.537, "ymax": 5.537, "xmax": 10}}, "expressions": {"list": [{"color": "#C0504D", "latex": "y-y_1=m\\\\left(x-x_1\\\\right)", "domain": {"max": 10, "min": 0}, "id": 1, "hidden":false}, {"color": "#8064A2", "latex": "\\\\left(x_1,y_1\\\\right)", "domain": {"max": 10, "min": 0}, "id": 8, "hidden":false}, {"latex": "x_1=1", "domain": {"max": 10, "min": 0}, "color": "#4F81BD", "sliderMin": -10, "hidden":false, "sliderMax": 10, "id": 5}, {"latex": "y_1=1", "domain": {"max": 10, "min": 0}, "color": "#C0504D", "sliderMin": -10, "hidden":false, "sliderMax": 10, "id": 7}, {"latex": "m=1", "domain": {"max": 10, "min": 0}, "color": "#9BBB59", "sliderMin": -10, "hidden":false, "sliderMax": 10, "id": 6}]}}\n    },\n    {\n      "title": "Two Point Form",\n      "graphHash": "slkjzmm3ly",\n      "state": {"graph":{"viewport":{"xmin":-7.023,"ymin":-4.187,"xmax":7.024,"ymax":4.186},"showLabels":true,"degreeMode":false,"showGrid":true,"showAxes":true,"squareAxes":true,"labelXMode":"","labelYMode":""},"expressions":{"list":[{"id":1,"latex":"y-y_1=m\\\\left(x-x_1\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#C0504D"},{"id":12,"latex":"m=\\\\frac{y_2-y_1}{x_2-x_1}","domain":{"min":0,"max":10},"hidden":false,"color":"#9BBB59"},{"id":5,"latex":"x_1=-1","domain":{"min":0,"max":10},"hidden":false,"color":"#4F81BD","sliderMin":-10,"sliderMax":10},{"id":7,"latex":"y_1=1","domain":{"min":0,"max":10},"hidden":false,"color":"#C0504D","sliderMin":-10,"sliderMax":10},{"id":8,"latex":"\\\\left(x_1,y_1\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#4F81BD"},{"id":9,"latex":"x_2=3","domain":{"min":0,"max":10},"hidden":false,"color":"#F79646","sliderMin":-10,"sliderMax":10},{"id":10,"latex":"y_2=2","domain":{"min":0,"max":10},"hidden":false,"color":"#000000","sliderMin":-10,"sliderMax":10},{"id":11,"latex":"\\\\left(x_2,y_2\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#4F81BD"}]}}\n    },\n    {\n      "title": "Intercept Form",\n      "graphHash": "cmz3dawdji",\n      "state": {"graph":{"viewport":{"xmin":-10,"ymin":-5.961,"xmax":10,"ymax":5.961},"showLabels":true,"degreeMode":false,"showGrid":true,"showAxes":true,"squareAxes":true,"labelXMode":"","labelYMode":""},"expressions":{"list":[{"id":1,"latex":"\\\\frac{y}{a}+\\\\frac{x}{b}=1","domain":{"min":0,"max":10},"hidden":false,"color":"#C0504D"},{"id":14,"latex":"a=2","domain":{"min":0,"max":10},"hidden":false,"color":"#8064A2","sliderMin":-10,"sliderMax":10},{"id":13,"latex":"b=1","domain":{"min":0,"max":10},"hidden":false,"color":"#C0504D","sliderMin":-10,"sliderMax":10},{"id":15,"latex":"\\\\left(0,a\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#8064A2"},{"id":16,"latex":"\\\\left(b,0\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#8064A2"}]}}\n    },\n    {\n      "title": "General Form",\n      "graphHash": "4acfppghta",\n      "state": {"graph": {"squareAxes": true, "showLabels": true, "showGrid": true, "showAxes": true, "labelXMode": "", "degreeMode": false, "labelYMode": "", "viewport": {"xmin": -10, "ymin": -5.537, "ymax": 5.537, "xmax": 10}}, "expressions": {"list": [{"color": "#C0504D", "latex": "ax+by=c", "domain": {"max": 10, "min": 0}, "id": 1, "hidden":false}, {"latex": "a=1", "domain": {"max": 10, "min": 0}, "color": "#F79646", "sliderMin": -10, "hidden":false, "sliderMax": 10, "id": 2}, {"latex": "b=1", "domain": {"max": 10, "min": 0}, "color": "#8064A2", "sliderMin": -10, "hidden":false, "sliderMax": 10, "id": 3}, {"latex": "c=1", "domain": {"max": 10, "min": 0}, "color": "#000000", "sliderMin": -10, "hidden":false, "sliderMax": 10, "id": 4}]}}\n    },\n    {\n      "title": "Visualizing Slope",\n      "graphHash": "h4kwopbouh",\n      "state": {"graph":{"viewport":{"xmin":-3,"ymin":-10,"xmax":3,"ymax":10},"showLabels":true,"degreeMode":false,"showGrid":true,"polarMode":false,"showAxes":true,"squareAxes":true,"labelXMode":"","labelYMode":""},"expressions":{"list":[{"id":1,"latex":"\\\\left(1,m\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#000"},{"id":509,"latex":"m=1.82","domain":{"min":0,"max":10},"hidden":true,"color":"#C0504D","sliderMin":-10,"sliderMax":10},{"id":487,"latex":"\\\\floor\\\\left(x\\\\right)\\\\cdot m\\\\le y\\\\le mx","domain":{"min":0,"max":10},"hidden":false,"color":"#4F81BD"},{"id":508,"latex":"mx\\\\le y\\\\le\\\\floor\\\\left(x\\\\right)\\\\cdot m","domain":{"min":0,"max":10},"hidden":false,"color":"#C0504D"}]}}\n    }\n  ]\n},\n{\n  "section": "Parabolas",\n  "examples": [\n    {\n      "title": "Standard Form",\n      "graphHash": "3ltwect0mc",\n      "state": {"graph": {"squareAxes": true, "showLabels": true, "showGrid": true, "showAxes": true, "labelXMode": "", "degreeMode": false, "labelYMode": "", "viewport": {"xmin": -10, "ymin": -5.537, "ymax": 5.537, "xmax": 10}}, "expressions": {"list": [{"color": "#C0504D", "latex": "y=ax^2+bx+c", "domain": {"max": 10, "min": 0}, "id": 1, "hidden":false}, {"latex": "a=1", "domain": {"max": 10, "min": 0}, "color": "#C0504D", "sliderMin": -10, "hidden":false, "sliderMax": 10, "id": 19}, {"latex": "b=0", "domain": {"max": 10, "min": 0}, "color": "#9BBB59", "sliderMin": -10, "hidden":false, "sliderMax": 10, "id": 18}, {"latex": "c=1", "domain": {"max": 10, "min": 0}, "color": "#4F81BD", "sliderMin": -10, "hidden":false, "sliderMax": 10, "id": 17}]}}\n    },\n    {\n      "title": "Vertex Form",\n      "graphHash": "mey71rif1d",\n      "state": {"graph": {"squareAxes": true, "showLabels": true, "showGrid": true, "showAxes": true, "labelXMode": "", "degreeMode": false, "labelYMode": "", "viewport": {"xmin": -10, "ymin": -5.537, "ymax": 5.537, "xmax": 10}}, "expressions": {"list": [{"color": "#C0504D", "latex": "y=a\\\\left(x-h\\\\right)^2+k", "domain": {"max": 10, "min": 0}, "id": 1, "hidden":false}, {"latex": "a=1", "domain": {"max": 10, "min": 0}, "color": "#C0504D", "sliderMin": -10, "hidden":false, "sliderMax": 10, "id": 25}, {"latex": "h=1", "domain": {"max": 10, "min": 0}, "color": "#9BBB59", "sliderMin": -10, "hidden":false, "sliderMax": 10, "id": 24}, {"latex": "k=0", "domain": {"max": 10, "min": 0}, "color": "#4F81BD", "sliderMin": -10, "hidden":false, "sliderMax": 10, "id": 23}, {"color": "#8064A2", "latex": "\\\\left(h,\\\\space k\\\\right)", "domain": {"max": 10, "min": 0}, "id": 26, "hidden":false}]}}\n    },\n    {\n      "title": "Factored Form",\n      "graphHash": "qgxlpjyebd",\n      "state": {"graph":{"viewport":{"xmin":-10,"ymin":-5.942,"xmax":10,"ymax":5.98},"showLabels":true,"degreeMode":false,"showGrid":true,"showAxes":true,"squareAxes":true,"labelXMode":"","labelYMode":""},"expressions":{"list":[{"id":1,"latex":"y=a\\\\left(x-x_1\\\\right)\\\\left(x-x_2\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#C0504D"},{"id":22,"latex":"a=1","domain":{"min":0,"max":10},"hidden":false,"color":"#000000","sliderMin":-10,"sliderMax":10},{"id":21,"latex":"x_1=-2","domain":{"min":0,"max":10},"hidden":false,"color":"#F79646","sliderMin":-10,"sliderMax":10},{"id":20,"latex":"x_2=1","domain":{"min":0,"max":10},"hidden":false,"color":"#8064A2","sliderMin":-10,"sliderMax":10},{"id":23,"latex":"\\\\left(x_1,0\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#F79646"},{"id":24,"latex":"\\\\left(x_2,0\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#F79646"}]}}\n    },\n    {\n      "title": "Standard Form with Tangent",\n      "graphHash": "bqr4ko6wi9",\n      "state": {"graph":{"viewport":{"xmin":-10,"ymin":-5.961,"xmax":10,"ymax":5.961},"showLabels":true,"degreeMode":false,"showGrid":true,"showAxes":true,"squareAxes":true,"labelXMode":"","labelYMode":""},"expressions":{"list":[{"id":1,"latex":"y\\\\ge ax^2+bx+c","domain":{"min":0,"max":10},"hidden":false,"color":"#C0504D"},{"id":19,"latex":"a=1","domain":{"min":0,"max":10},"hidden":false,"color":"#C0504D","sliderMin":-10,"sliderMax":10},{"id":18,"latex":"b=1","domain":{"min":0,"max":10},"hidden":false,"color":"#9BBB59","sliderMin":-10,"sliderMax":10},{"id":17,"latex":"c=1","domain":{"min":0,"max":10},"hidden":false,"color":"#4F81BD","sliderMin":-10,"sliderMax":10},{"id":21,"latex":"y\\\\space=\\\\space bx+c","domain":{"min":0,"max":10},"hidden":false,"color":"#4F81BD"}]}}\n    }\n  ]\n},\n{\n  "section": "Trigonometry",\n  "examples": [\n    {\n      "title": "Period and Amplitude",\n      "graphHash": "pjtapprsyt",\n      "state": {"graph": {"squareAxes": true, "showLabels": true, "showGrid": true, "showAxes": true, "labelXMode": "", "degreeMode": false, "labelYMode": "", "viewport": {"xmin": -10.056, "ymin": -7.352, "ymax": 7.352, "xmax": 9.944}}, "expressions": {"list": [{"text": "Sinusoid with amplitude \\"a\\" and period \\"b\\"", "id": 10}, {"color": "#C0504D", "latex": "a\\\\space\\\\cos\\\\left(\\\\frac{2\\\\pi x}{b}\\\\right)", "domain": {"max": 10, "min": 0}, "id": 1, "hidden":false}, {"latex": "a=2.58", "domain": {"max": 10, "min": 0}, "color": "#F79646", "sliderMin": -10, "hidden":false, "sliderMax": 10, "id": 3}, {"latex": "b=4.65", "domain": {"max": 10, "min": 0}, "color": "#8064A2", "sliderMin": -10, "hidden":false, "sliderMax": 10, "id": 2}, {"color": "#8064A2", "latex": "\\\\left(b,\\\\space at\\\\right)", "domain": {"max": 1, "min": 0}, "id": 4, "hidden":false}, {"color": "#4F81BD", "latex": "\\\\left(bt,\\\\space a\\\\right)", "domain": {"max": 1, "min": 0}, "id": 5, "hidden":false}]}}\n    },\n    {\n      "title": "Phase",\n      "graphHash": "rfo6v7r5vg",\n      "state": {"graph":{"viewport":{"xmin":-10.949,"ymin":-3,"xmax":11,"ymax":2},"showLabels":true,"degreeMode":false,"showGrid":true,"showAxes":true,"squareAxes":false,"labelXMode":"pi","labelYMode":""},"expressions":{"list":[{"id":1,"latex":"\\\\cos\\\\left(x\\\\space-\\\\space p\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#000000"},{"id":13,"latex":"p=1.64","domain":{"min":0,"max":10},"hidden":false,"color":"#4F81BD","sliderMin":-10,"sliderMax":10},{"id":14,"latex":"\\\\cos\\\\left(x\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#4F81BD"},{"id":17,"latex":"\\\\left(pt,\\\\space1\\\\right)","domain":{"min":0,"max":1},"hidden":false,"color":"#C0504D"}]}}\n    },\n    {\n      "title": "All the Trig Functions",\n      "graphHash": "v3hgzjtpo5",\n      "state": {"graph":{"viewport":{"xmin":-10,"ymin":-6.095,"xmax":10,"ymax":6.095},"showLabels":true,"degreeMode":false,"showGrid":true,"polarMode":false,"showAxes":true,"squareAxes":true,"labelXMode":"pi","labelYMode":""},"expressions":{"list":[{"id":28,"text":"Click on the icon next to each trig function to turn it on or off:"},{"id":27,"latex":"\\\\sin\\\\left(x\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#C0504D"},{"id":22,"latex":"\\\\cos\\\\left(x\\\\right)","domain":{"min":0,"max":10},"hidden":true,"color":"#8064A2"},{"id":23,"latex":"\\\\tan\\\\left(x\\\\right)","domain":{"min":0,"max":10},"hidden":true,"color":"#F79646"},{"id":24,"latex":"\\\\csc\\\\left(x\\\\right)","domain":{"min":0,"max":10},"hidden":true,"color":"#000000"},{"id":25,"latex":"\\\\sec\\\\left(x\\\\right)","domain":{"min":0,"max":10},"hidden":true,"color":"#4F81BD"},{"id":26,"latex":"\\\\cot\\\\left(x\\\\right)","domain":{"min":0,"max":10},"hidden":true,"color":"#9BBB59"}]}}\n    },\n    {\n      "title": "Wave Interference",\n      "graphHash": "ae1kce4fwm",\n      "state": {"graph":{"viewport":{"xmin":-10,"ymin":-5.961,"xmax":10,"ymax":5.961},"showLabels":true,"degreeMode":false,"showGrid":true,"showAxes":true,"squareAxes":true,"labelXMode":"","labelYMode":""},"expressions":{"list":[{"id":140,"latex":"a=-1.17","domain":{"min":0,"max":10},"hidden":false,"color":"#F79646","sliderMin":-10,"sliderMax":10},{"id":1,"latex":"f\\\\left(x\\\\right)=\\\\sin\\\\left(x\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#F79646"},{"id":2,"latex":"g\\\\left(x\\\\right)=\\\\sin\\\\left(x+a\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#F79646"},{"id":5,"latex":"f\\\\left(x\\\\right)+g\\\\left(x\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#8064A2"}]}}\n    },\n    {\n      "title": "Unit Circle",\n      "graphHash": "aer4wpiiad",\n      "state": {"graph":{"viewport":{"xmin":-2.5,"ymin":-1.49,"xmax":2.5,"ymax":1.4905},"showLabels":true,"degreeMode":true,"showGrid":false,"showAxes":true,"squareAxes":true,"labelXMode":"","labelYMode":""},"expressions":{"list":[{"id":1,"latex":"x^2+y^2=1","domain":{"min":0,"max":10},"hidden":false,"color":"#4F81BD"},{"id":19,"latex":"\\\\left(\\\\cos a,\\\\space\\\\sin a\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#000000"},{"id":20,"latex":"a=30","domain":{"min":0,"max":10},"hidden":false,"color":"#F79646","sliderMin":0,"sliderMax":360},{"id":22,"latex":"y=\\\\left(\\\\tan a\\\\right)\\\\cdot x\\\\left\\\\{0<x<\\\\cos a\\\\right\\\\}","domain":{"min":0,"max":10},"hidden":false,"color":"#C0504D"},{"id":26,"latex":"y=\\\\left(\\\\tan a\\\\right)\\\\cdot x\\\\left\\\\{\\\\cos a<x<0\\\\right\\\\}","domain":{"min":0,"max":10},"hidden":false,"color":"#C0504D"},{"id":23,"latex":"x=\\\\cos(a)\\\\left\\\\{0<y<\\\\sin(a)\\\\right\\\\}","domain":{"min":0,"max":10},"hidden":false,"color":"#C0504D"},{"id":27,"latex":"x=\\\\cos(a)\\\\left\\\\{\\\\sin(a)<y<0\\\\right\\\\}","domain":{"min":0,"max":10},"hidden":false,"color":"#C0504D"}]}}\n    }\n  ]\n},\n{\n  "section": "Conic Sections",\n  "examples": [\n    {\n      "title": "Circle",\n      "graphHash": "bkmtndf38y",\n      "state": {"graph":{"viewport":{"xmin":-10,"ymin":-5.961,"xmax":10,"ymax":5.961},"showLabels":true,"degreeMode":false,"showGrid":true,"showAxes":true,"squareAxes":true,"labelXMode":"","labelYMode":""},"expressions":{"list":[{"id":1,"latex":"\\\\left(x-a\\\\right)^2+\\\\left(y-b\\\\right)^2<r^2","domain":{"min":0,"max":10},"hidden":false,"color":"#C0504D"},{"id":6,"latex":"r\\\\space=\\\\space2.5","domain":{"min":0,"max":10},"hidden":true,"color":"#9BBB59","sliderMin":-10,"sliderMax":10},{"id":5,"latex":"a=0","domain":{"min":0,"max":10},"hidden":true,"color":"#4F81BD","sliderMin":-10,"sliderMax":10},{"id":4,"latex":"b=0","domain":{"min":0,"max":10},"hidden":true,"color":"#000000","sliderMin":-10,"sliderMax":10}]}}\n      } ,\n      {\n        "title": "Parabola and Focus",\n        "graphHash": "naug1puabq",\n        "state": {"graph":{"viewport":{"xmin":-6.122,"ymin":-3.492,"xmax":6.364,"ymax":5.114},"showLabels":true,"degreeMode":false,"showGrid":true,"showAxes":true,"squareAxes":false,"labelXMode":"","labelYMode":""},"expressions":{"list":[{"id":1,"latex":"y=\\\\frac{x^2}{4p}","domain":{"min":0,"max":10},"hidden":false,"color":"#4F81BD"},{"id":64,"latex":"p=1","domain":{"min":0,"max":10},"hidden":false,"color":"#000000","sliderMin":0.5,"sliderMax":5},{"id":65,"latex":"\\\\left(0,\\\\space p\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#000000"},{"id":81,"latex":"y\\\\space=\\\\space-p","domain":{"min":0,"max":10},"hidden":false,"color":"#000000"}]}}\n      },\n      {\n        "title": "Ellipse with Foci",\n        "graphHash": "fwn45vpf2z",\n        "state": {"graph":{"viewport":{"xmin":-8.918,"ymin":-5.215,"xmax":8.86,"ymax":5.324},"showLabels":true,"degreeMode":false,"showGrid":true,"showAxes":true,"squareAxes":true,"labelXMode":"","labelYMode":""},"expressions":{"list":[{"id":1,"latex":"\\\\frac{x^2}{a^2}+\\\\frac{y^2}{b^2}\\\\ge1","domain":{"min":0,"max":10},"hidden":false,"color":"#C0504D"},{"id":4,"latex":"a=5","domain":{"min":0,"max":10},"hidden":false,"color":"#8064A2","sliderMin":3,"sliderMax":6},{"id":2,"latex":"b=3","domain":{"min":0,"max":10},"hidden":false,"color":"#8064A2","sliderMin":1,"sliderMax":3},{"id":5,"latex":"c=\\\\sqrt{\\\\left(a^2-b^2\\\\right)}","domain":{"min":0,"max":10},"hidden":false,"color":"#000000"},{"id":6,"latex":"\\\\left(c,0\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#000000"},{"id":7,"latex":"\\\\left(-c,0\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#000000"}]}}\n      },\n      {\n        "title": "Hyperbola",\n        "graphHash": "321ynqvpjh",\n        "state": {"graph":{"viewport":{"xmin":-9.594,"ymin":-4.136,"xmax":10.406,"ymax":7.786},"showLabels":true,"degreeMode":false,"showGrid":true,"showAxes":true,"squareAxes":true,"labelXMode":"","labelYMode":""},"expressions":{"list":[{"id":23,"latex":"\\\\frac{y^2}{b^{2\\\\space}}-\\\\frac{x^2}{a^2}=1","domain":{"min":0,"max":10},"hidden":false,"color":"#9BBB59"},{"id":17,"latex":"\\\\frac{x^2}{a^2}-\\\\frac{y^2}{b^2}=1","domain":{"min":0,"max":10},"hidden":true,"color":"#4F81BD"},{"id":24,"latex":"a=1","domain":{"min":0,"max":10},"hidden":true,"color":"#9BBB59","sliderMin":0.01,"sliderMax":5},{"id":25,"latex":"b=1","domain":{"min":0,"max":10},"hidden":true,"color":"#C0504D","sliderMin":0.01,"sliderMax":5,"sliderInterval":""}]}}\n      }\n    ]\n  },\n{\n  "section": "Polar Graphing",\n  "examples": [\n    {\n      "title": "Polar Rose",\n      "graphHash": "zg6mokdc9e",\n      "state": {"graph":{"viewport":{"xmin":-2.1,"ymin":-2,"xmax":2.1,"ymax":2},"showLabels":true,"degreeMode":false,"showGrid":true,"polarMode":true,"showAxes":true,"squareAxes":true,"labelXMode":"","labelYMode":""},"expressions":{"list":[{"id":1,"latex":"r\\\\space\\\\le\\\\space\\\\sin\\\\left(\\\\frac{a}{b}\\\\theta\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#C0504D"},{"id":82,"latex":"a=5","domain":{"min":0,"max":10},"hidden":true,"color":"#F79646","sliderMin":1,"sliderMax":10,"sliderInterval":1},{"id":81,"latex":"b=6","domain":{"min":0,"max":10},"hidden":true,"color":"#8064A2","sliderMin":1,"sliderMax":10,"sliderInterval":1}]}}\n    },\n    {\n      "title": "Logarithmic Spiral",\n      "graphHash": "ucm7smj9fz",\n      "state": {"graph":{"viewport":{"xmin":-1200,"ymin":-1000,"xmax":1200,"ymax":1000},"showLabels":true,"degreeMode":false,"showGrid":true,"polarMode":true,"showAxes":true,"squareAxes":true,"labelXMode":"","labelYMode":""},"expressions":{"list":[{"id":83,"latex":"r\\\\space=\\\\space a^{\\\\theta}","domain":{"min":0,"max":10},"hidden":false,"color":"#000000"},{"id":84,"latex":"a=1.25","domain":{"min":0,"max":10},"hidden":true,"color":"#4F81BD","sliderMin":1.1,"sliderMax":5}]}}\n    },\n    {\n      "title": "Limacon",\n      "graphHash": "ie57pljxzm",\n      "state": {"graph":{"viewport":{"xmin":-8,"ymin":-10,"xmax":8,"ymax":10},"showLabels":true,"degreeMode":false,"showGrid":true,"polarMode":true,"showAxes":true,"squareAxes":true,"labelXMode":"","labelYMode":""},"expressions":{"list":[{"id":83,"latex":"r\\\\space=\\\\space a+b\\\\cdot\\\\cos\\\\left(\\\\theta\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#000000"},{"id":84,"latex":"a=2","domain":{"min":0,"max":10},"hidden":true,"color":"#4F81BD","sliderMin":0,"sliderMax":5},{"id":85,"latex":"b=3","domain":{"min":0,"max":10},"hidden":true,"color":"#9BBB59","sliderMin":0,"sliderMax":5}]}}\n    },\n    {\n      "title": "Polar Conic Sections",\n      "graphHash": "kk3axf8oon",\n      "state": {"graph":{"viewport":{"xmin":-11,"ymin":-5,"xmax":11,"ymax":5},"showLabels":true,"degreeMode":false,"showGrid":true,"polarMode":true,"showAxes":true,"squareAxes":true,"labelXMode":"","labelYMode":""},"expressions":{"list":[{"id":1,"latex":"r\\\\space=\\\\space\\\\frac{1}{1-a\\\\cdot\\\\cos\\\\left(\\\\theta-b\\\\right)}","domain":{"min":0,"max":10},"hidden":false,"color":"#C0504D"},{"id":3,"latex":"a=1","domain":{"min":0,"max":10},"hidden":true,"color":"#F79646","sliderMin":-10,"sliderMax":10},{"id":2,"latex":"b=0","domain":{"min":0,"max":10},"hidden":true,"color":"#8064A2","sliderMin":-10,"sliderMax":10}]}}\n    }\n  ]\n},\n{\n  "section": "Transformations",\n  "examples": [\n    {\n      "title": "Translating Any Function",\n      "graphHash": "0ksctv1hm4",\n      "state": {"graph": {"squareAxes": true, "showLabels": true, "showGrid": true, "showAxes": true, "labelXMode": "", "degreeMode": false, "labelYMode": "", "viewport": {"xmin": -7.901, "ymin": -4.379, "ymax": 4.368, "xmax": 7.902}}, "expressions": {"list": [{"color": "#C0504D", "latex": "f\\\\left(x\\\\right)=x^2+\\\\sin\\\\left(3x\\\\right)", "domain": {"max": 10, "min": 0}, "id": 1, "hidden":false}, {"text": "Function g(x) is a transformed version of function f(x).", "id": 49}, {"color": "#F79646", "latex": "g\\\\left(x\\\\right)=f\\\\left(x-h\\\\right)+k", "domain": {"max": 10, "min": 0}, "id": 45, "hidden":false}, {"text": "What effect does k have on the function g(x)?", "id": 51}, {"latex": "h=2", "domain": {"max": 10, "min": 0}, "color": "#000000", "sliderMin": -10, "hidden":false, "sliderMax": 10, "id": 46}, {"text": "What effect does h have on the function g(x)", "id": 53}, {"latex": "k=-1", "domain": {"max": 10, "min": 0}, "color": "#4F81BD", "sliderMin": -10, "hidden":false, "sliderMax": 10, "id": 47}]}}\n    },\n    {\n      "title": "Scaling Any Function",\n      "graphHash": "doxva7ciht",\n      "state": {"graph": {"squareAxes": true, "showLabels": true, "showGrid": true, "showAxes": true, "labelXMode": "", "degreeMode": false, "labelYMode": "", "viewport": {"xmin": -7.901, "ymin": -4.379, "ymax": 4.368, "xmax": 7.902}}, "expressions": {"list": [{"color": "#C0504D", "latex": "f\\\\left(x\\\\right)=x^2+\\\\sin\\\\left(3x\\\\right)", "domain": {"max": 10, "min": 0}, "id": 1, "hidden":false}, {"text": "Function g(x) is a transformed version of function f(x).", "id": 49}, {"color": "#F79646", "latex": "g\\\\left(x\\\\right)=af\\\\left(\\\\frac{x}{b}\\\\right)", "domain": {"max": 10, "min": 0}, "id": 45, "hidden":false}, {"text": "What effect does a have on the function g(x)?", "id": 51}, {"latex": "a=0.5", "domain": {"max": 10, "min": 0}, "color": "#000000", "sliderMin": -10, "hidden":false, "sliderMax": 10, "id": 46}, {"text": "What effect does b have on the function g(x)", "id": 53}, {"latex": "b=1", "domain": {"max": 10, "min": 0}, "color": "#4F81BD", "sliderMin": -10, "hidden":false, "sliderMax": 10, "id": 47}]}}\n    },\n    {\n      "title": "Reflections of a Function",\n      "graphHash": "ynmlumjvz8",\n      "state": {"graph":{"viewport":{"xmin":-10,"ymin":-5.961,"xmax":10,"ymax":5.961},"showLabels":true,"degreeMode":false,"showGrid":true,"showAxes":true,"squareAxes":true,"labelXMode":"","labelYMode":""},"expressions":{"list":[{"id":1,"latex":"f\\\\left(x\\\\right)=\\\\left(x-3\\\\right)^3-x+5","domain":{"min":0,"max":10},"hidden":false,"color":"#C0504D"},{"id":92,"latex":"-f\\\\left(x\\\\right)","domain":{"min":0,"max":10},"hidden":true,"color":"#4F81BD"},{"id":96,"latex":"f\\\\left(-x\\\\right)","domain":{"min":0,"max":10},"hidden":true,"color":"#9BBB59"},{"id":97,"latex":"-f\\\\left(-x\\\\right)","domain":{"min":0,"max":10},"hidden":true,"color":"#000000"}]}}\n    },\n    {\n      "title": "Inverse of a Function",\n      "graphHash": "tif5liedlj",\n      "state": {"graph":{"viewport":{"xmin":-10,"ymin":-5.928,"xmax":10,"ymax":5.929},"showLabels":true,"degreeMode":false,"showGrid":true,"showAxes":true,"squareAxes":true,"labelXMode":"","labelYMode":""},"expressions":{"list":[{"id":1,"latex":"f\\\\left(x\\\\right)=.2x^3+.1x^5","domain":{"min":0,"max":10},"hidden":false,"color":"#000000"},{"id":155,"latex":"x=f\\\\left(y\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#C0504D"},{"id":156,"latex":"y=x","domain":{"min":0,"max":10},"hidden":false,"color":"#8064A2"},{"id":158,"latex":"a=1.74","domain":{"min":0,"max":10},"hidden":false,"color":"#000000","sliderMin":-10,"sliderMax":10},{"id":157,"latex":"\\\\left(a,f\\\\left(a\\\\right)\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#000000"},{"id":159,"latex":"\\\\left(f\\\\left(a\\\\right),a\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#C0504D"}]}}\n    }\n  ]\n},\n{\n  "section": "Calculus",\n  "examples": [\n    {\n      "title": "Derivatives",\n      "graphHash": "aqgbwm3qfd",\n\n      "state": {"graph":{"viewport":{"xmin":-8.874,"ymin":-6.286,"xmax":11.127,"ymax":5.637},"showLabels":true,"degreeMode":false,"showGrid":true,"showAxes":true,"squareAxes":true,"labelXMode":"","labelYMode":""},"expressions":{"list":[{"id":1,"latex":"f\\\\left(x\\\\right)\\\\space=\\\\space ax^3+cx","domain":{"min":0,"max":10},"hidden":false,"color":"#C0504D"},{"id":150,"latex":"a=0.42","domain":{"min":0,"max":10},"hidden":true,"color":"#9BBB59","sliderMin":-10,"sliderMax":10},{"id":148,"latex":"c=-1.64","domain":{"min":0,"max":10},"hidden":true,"color":"#000000","sliderMin":-10,"sliderMax":10},{"id":146,"latex":"g\\\\left(x\\\\right)\\\\space=\\\\space\\\\frac{d}{dx}f\\\\left(x\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#8064A2"}]}}\n    },\n    {\n      "title": "Secant Line",\n      "graphHash": "irip8pnpdf",\n      "state": {"graph":{"viewport":{"xmin":-10,"ymin":-5.961,"xmax":10,"ymax":5.961},"showLabels":true,"degreeMode":false,"showGrid":true,"showAxes":true,"squareAxes":true,"labelXMode":"","labelYMode":""},"expressions":{"list":[{"id":3,"latex":"f\\\\left(x\\\\right)=\\\\sin\\\\left(x\\\\right)+.3x","domain":{"min":0,"max":10},"hidden":false,"color":"#4F81BD"},{"id":7,"latex":"a=0.23","domain":{"min":0,"max":10},"hidden":false,"color":"#4F81BD","sliderMin":-10,"sliderMax":10},{"id":13,"latex":"h=2","domain":{"min":0,"max":10},"hidden":false,"color":"#F79646","sliderMin":0.1,"sliderMax":2},{"id":16,"latex":"m=\\\\frac{\\\\left(f\\\\left(a+h\\\\right)-f\\\\left(a\\\\right)\\\\right)}{h}","domain":{"min":0,"max":10},"hidden":false,"color":"#4F81BD"},{"id":20,"latex":"y=m\\\\left(x-a\\\\right)+f\\\\left(a\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#C0504D"},{"id":23,"latex":"\\\\left(a,f\\\\left(a\\\\right)\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#8064A2"},{"id":24,"latex":"\\\\left(a+h,f\\\\left(a+h\\\\right)\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#8064A2"}]}}\n    },\n    {\n      "title": "Tangent Line",\n      "graphHash": "dlzhsldcgo",\n      "state": {"graph":{"viewport":{"xmin":-10,"ymin":-5.961,"xmax":10,"ymax":5.961},"showLabels":true,"degreeMode":false,"showGrid":true,"showAxes":true,"squareAxes":true,"labelXMode":"","labelYMode":""},"expressions":{"list":[{"id":3,"latex":"f\\\\left(x\\\\right)=\\\\sin\\\\left(x\\\\right)+.3x","domain":{"min":0,"max":10},"hidden":false,"color":"#4F81BD"},{"id":6,"latex":"g\\\\left(x\\\\right)=\\\\frac{d}{dx}f\\\\left(x\\\\right)","domain":{"min":0,"max":10},"hidden":true,"color":"#000000"},{"id":7,"latex":"a=1.27","domain":{"min":0,"max":10},"hidden":false,"color":"#4F81BD","sliderMin":-10,"sliderMax":10},{"id":12,"latex":"y=g\\\\left(a\\\\right)\\\\left(x-a\\\\right)+f\\\\left(a\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#C0504D"},{"id":13,"latex":"\\\\left(a,\\\\space f\\\\left(a\\\\right)\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#8064A2"}]}}\n    },\n    {\n      "title": "Taylor Expansion of sin(x)",\n      "graphHash": "gkjridbqfj",\n\n      "state": {"graph":{"viewport":{"xmin":-10,"ymin":-5.961,"xmax":10,"ymax":5.961},"showLabels":true,"degreeMode":false,"showGrid":true,"showAxes":true,"squareAxes":true,"labelXMode":"","labelYMode":""},"expressions":{"list":[{"id":1,"latex":"y\\\\space=\\\\space\\\\sin\\\\left(x\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#C0504D"},{"id":161,"latex":"y\\\\space=\\\\space\\\\sum_{n=0}^a\\\\frac{\\\\left(-1\\\\right)^nx^{\\\\left(2n+1\\\\right)}}{\\\\left(2n+1\\\\right)!}","domain":{"min":0,"max":10},"hidden":false,"color":"#8064A2"},{"id":162,"latex":"a=1","domain":{"min":0,"max":10},"hidden":true,"color":"#F79646","sliderMin":0,"sliderMax":10,"sliderInterval":1}]}}\n    }\n  ]\n}]'; });

define('mygraphs/examples', ['require', 'underscore', 'main/graph', 'text!data/resources_examples.json'], function(require) {
    var _ = require('underscore');
    var Graph = require('main/graph');
    var exampleGraphsString = require('text!data/resources_examples.json');

    // convert from sectioned examples to flat list
    var sectionedExamples = JSON.parse(exampleGraphsString);
    var flatExampleGraphs = [];
    _.each(sectionedExamples, function(section, i) {
        _.each(section.examples, function(example, j) {

            var exampleGraph = Graph({
                hash: example.graphHash,
                title: section.section + ": " + example.title,
                graphData: JSON.stringify(example.state),

                // TODO - we should inline the dataURL within the json
                thumbURL: 'https://s3.amazonaws.com/calc_thumbs/production/' + example.graphHash + '.png'
            });

            flatExampleGraphs.push(exampleGraph);
        });
    });


    return flatExampleGraphs;
});

define('loadcss!css/mygraphs', function() {});
define('mygraphs/item_model', ['require', 'pjs', 'underscore_model'], function(require) {
    var P = require('pjs');
    var UnderscoreModel = require('underscore_model');

    var ItemModel = P(UnderscoreModel, function(model, _super) {
        model.init = function() {
            _super.init.call(this);

            // TODO - not sure this belongs in the model
            this.visible = true;
            this.selected = false;
            this.selectable = true;

            var self = this;
            this.observe('selectable', function() {
                if (!self.selectable && self.selected) {
                    self.setProperty('selected', false);
                }
            });
        };
    });

    return ItemModel;
});


define('mygraphs/graphitem_model', ['require', 'pjs', './item_model'], function(require) {
    var P = require('pjs');
    var ItemModel = require('./item_model');

    var GraphItemModel = P(ItemModel, function(model, _super) {
        model.isGraph = true;

        model.init = function(graph) {
            _super.init.call(this);
            this.graph = graph;
        };

        model.matchesQuery = function(query) {
            return this.graph.displayTitle.toLowerCase().indexOf(query.toLowerCase()) >= 0;
        };
    });

    return GraphItemModel;
});


define('mygraphs/examplegraphitem_model', ['require', 'pjs', './graphitem_model'], function(require) {
    var P = require('pjs');
    var GraphItemModel = require('./graphitem_model');

    var ExampleGraphItemModel = P(GraphItemModel, function(model, _super) {
        model.isExampleGraph = true;
    });

    return ExampleGraphItemModel;
});

define('mygraphs/savedgraphitem_model', ['require', 'pjs', './graphitem_model'], function(require) {
    var P = require('pjs');
    var GraphItemModel = require('./graphitem_model');

    var SavedGraphItemModel = P(GraphItemModel, function(model, _super) {
        model.isSavedGraph = true;
    });

    return SavedGraphItemModel;
});
define('mygraphs/model', ['require', 'loadcss!css/mygraphs', 'pjs', 'underscore_model', './examplegraphitem_model', './savedgraphitem_model'], function(require) {
    require('loadcss!css/mygraphs');

    var P = require('pjs');
    var UnderscoreModel = require('underscore_model');
    var ExampleGraphItemModel = require('./examplegraphitem_model');
    var SavedGraphItemModel = require('./savedgraphitem_model');

    var MyGraphsModel = P(UnderscoreModel, function(model, _super) {

        model.init = function(exampleGraphs, graphsController) {
            _super.init.call(this);
            var self = this;

            this.graphsController = graphsController;
            this.__items = [];
            this.__selectedItem = null;
            this.filteredItemCount = 0;

            exampleGraphs.forEach(function(exampleGraph) {
                var item = ExampleGraphItemModel(exampleGraph);
                self.__addItemAt(item, self.__items.length); //add to end of __items
            });

            this.setProperty('isSpinning', false);

            this.observe('searchQuery', this.filterAllGraphs.bind(this));

            //note: on iPad, we'd expect that none of these triggers would be called
            //this is the less pretty way of doing this.graphsController.graphAddedCallbacks?.push ...
            if (!this.graphsController.hasOwnProperty('graphAddedCallbacks')) return;

            this.graphsController.graphAddedCallbacks.push(function(index) {
                var graph = self.graphsController.content[index];
                var graphItem = SavedGraphItemModel(graph);
                self.__addItemAt(graphItem, index);
            });

            this.graphsController.graphRemovedCallbacks.push(function(index) {
                self.__removeItemAt(index);
            });

            this.graphsController.startUpdatingGraphsCallbacks.push(function() {
                self.setProperty('isSpinning', true);
                self.__clearSavedGraphs();
            });
            this.graphsController.updateGraphsSuccessCallbacks.push(function() {
                self.setProperty('isSpinning', false);
                self.graphsController.content.forEach(function(savedGraph, i) {
                    var savedGraphItem = SavedGraphItemModel(savedGraph);
                    self.__addItemAt(savedGraphItem, i);
                });
            });
            this.graphsController.updateGraphsErrorCallbacks.push(function() {
                self.setProperty('isSpinning', false);
                // TODO error view not implemented. Might be nice to have a "try again"
                // button.
            });
            this.graphsController.clearCallbacks.push(function() {
                self.setProperty('isSpinning', true);
                self.__clearSavedGraphs();
            });
        };

        model.updateDisplayDates = function() {
            //note: on iPad, we'd expect that graphsController.content is an empty array
            this.graphsController.content.forEach(function(graph) {
                graph.updateDisplayDate();
            });
        };

        // TODO - optimize if need be to not call this when a single graph is deleted or
        // or added. But, I suspect that a single deletion or addition shouldn't be a bottleneck
        // as long as a complete refresh (login or logout) isn't a terrible bottleneck.
        model.filterAllGraphs = function() {
            var i;

            if (this.searchQuery) {
                var filteredItemCount = 0;
                for (i = 0; i < this.__items.length; i++) {
                    var item = this.__items[i];
                    if (item.matchesQuery(this.searchQuery)) {
                        filteredItemCount++;
                        item.setProperty('visible', true);
                    } else {
                        item.setProperty('visible', false);
                    }
                }
                this.setProperty('filteredItemCount', filteredItemCount);
            } else {
                for (i = 0; i < this.__items.length; i++) {
                    this.__items[i].setProperty('visible', true);
                }
                this.setProperty('filteredItemCount', this.__items.length);
            }
        };

        model.triggerItemAdded = function(item, index) {};
        model.__initItem = function(item) {
            item.mygraphs_list = this;
            item.observe('selected.' + this.guid, this.onSelectionChange.bind(this));
        };
        model.__addItemAt = function(item, index) {
            this.__items.splice(index, 0, item);
            this.__initItem(item);

            this.filterAllGraphs();
            this.triggerItemAdded(item, index);
        };

        model.triggerItemRemoved = function(item) {};
        model.__destructItem = function(item) {
            item.mygraphs_list = null;
            item.unobserve('.' + this.guid);
        };
        model.__removeItemAt = function(index) {
            var item = this.__items[index];
            this.__items.splice(index, 1);
            this.__destructItem(item);

            this.filterAllGraphs();
            this.triggerItemRemoved(item);
        };

        model.__clearSavedGraphs = function() {
            var oldItems = this.__items;
            this.__items = [];

            for (var i = 0; i < oldItems.length; i++) {
                var item = oldItems[i];
                if (item.isSavedGraph) {
                    // TODO - could save these up and remove all at once by adding a
                    // "triggerItemsRemoved([item1, item2, etc]) method"
                    this.__destructItem(item);
                    this.triggerItemRemoved(item);
                } else {
                    this.__items.push(item);
                }
            }

            this.filterAllGraphs();
        };

        model.getItems = function() {
            return this.__items;
        };

        model.getSelectedIndex = function() {
            if (!this.selectedItem) return -1;

            return this.__items.indexOf(this.selectedItem);
        };

        model.onSelectionChange = function(property, item) {

            if (item.selected) {
                // only 1 item can be selected at a time
                var cachedItem = this.selectedItem;
                this.setProperty('selectedItem', item);
                if (cachedItem) cachedItem.setProperty('selected', false);
            } else if (this.selectedItem === item) {
                this.setProperty('selectedItem', null);
            }
        };

        model.selectPrev = function() {
            var selectedIndex = this.getSelectedIndex();
            if (selectedIndex === -1) return;

            for (var i = selectedIndex - 1; i >= 0; i--) {
                var item = this.__items[i];
                if (item.selectable) {
                    item.setProperty('selected', true);
                    return true;
                }
            }

            return false;
        };

        model.selectNext = function(evt) {
            var selectedIndex = this.getSelectedIndex();
            var i, item;
            // nothing is selected, so select the first item that is selectable and has a graph. This
            // skips over the "new blank graph" option
            if (selectedIndex === -1) {
                for (i = 0; i < this.__items.length; i++) {
                    item = this.__items[i];
                    if (item.selectable && item.graph) {
                        item.setProperty('selected', true);
                        return true;
                    }
                }
            }

            for (i = selectedIndex + 1; i < this.__items.length; i++) {
                item = this.__items[i];
                if (item.selectable) {
                    item.setProperty('selected', true);
                    return true;
                }
            }

            return false;
        };
    });

    return MyGraphsModel;
});

define('mygraphs/item_view', ['require', 'pjs', 'underscore_view'], function(require) {
    var P = require('pjs');
    var UnderscoreView = require('underscore_view');

    var ItemView = P(UnderscoreView, function(view, _super) {

        view.init = function(model) {
            _super.init.call(this);
            this.model = model;
            this.model.observe('visible.' + this.guid, this.renderVisible.bind(this));
            this.model.observe('selected.' + this.guid, this.renderSelected.bind(this));
        };

        view.destruct = function() {
            this.model.unobserve('.' + this.guid);
        };

        view.renderSelected = function() {
            this.$().toggleClass('dcg-selected', this.model.selected);
        };

        view.renderVisible = function() {
            this.$().toggle(this.model.visible);
        };

        view.didCreateElement = function() {
            this.renderSelected();
            this.renderVisible();
        };
    });

    return ItemView;
});


/*
 * A handled event is one that should act like propagation was
 *  stopped, yet it's allowed to still bubble because other
 *  code might expect to see an event higher up on the dom.
 *
 * So the solution is to call 'handle()' when you don't
 *  want the event to be handled by any other other listeners.
 *  The listeners will still get called, but they can check
 *  that evt.wasHandled() == false to make sure that it
 *  should handle the event.
 *
 * You can namespace your event handlings so that two
 *  completely different parts of code can both use this
 *  utility. When you call 'wasHandled()', just pass in a
 *  string, and it will check that namespace. And when you
 *  call 'handle()', pass in a namespace string.
 *
 * For convienience, you can set the handleEvent attribute
 *  for any dom element and the 'wasHandled()' method will
 *  check if the event has passed through any dom element
 *  that should have handled the event.
 */

/* global jQuery */
;
(function($) {
    var GLOBAL_NAMESPACE = "_*_";

    $.Event.prototype.wasHandled = function(namespace) {

        namespace = namespace ? namespace : GLOBAL_NAMESPACE;
        var oe = this.originalEvent;
        var hb = oe && oe.handledBy;

        //check if it was explicitly handled in code
        if (hb && hb[namespace]) return true;

        // namespace wasn't handled
        if (namespace !== GLOBAL_NAMESPACE) return false;

        //Now, check if it was implicitly handled through
        //the dom attribute 'handleEvent'
        var dom = $(this.target).closest('[handleEvent]');
        //TEMPORARY: just return true instead of deeply parsing
        if (dom.length && dom[0] !== this.currentTarget) {
            return dom.attr('handleEvent') !== "false";
        }

        //must not have been handled
        return false;
    };

    $.Event.prototype.handle = function(namespace) {
        namespace = namespace ? namespace : GLOBAL_NAMESPACE;
        var oe = this.originalEvent;
        if (!oe) return; //can't handle this properly

        var hb = oe.handledBy;
        if (!hb) hb = oe.handledBy = {};

        hb[namespace] = true;
    };

})(jQuery);


define("jquery.handleevent", function() {});

define('mygraphs/graphitem_view', ['require', 'pjs', './item_view', 'jquery.handleevent'], function(require) {
    var P = require('pjs');
    var ItemView = require('./item_view');
    require('jquery.handleevent');

    var GraphItemView = P(ItemView, function(view, _super) {
        view.isGraphView = true;

        view.getTemplateParams = function() {
            return JSON.parse(JSON.stringify(this.model.graph));
        };

        view.didCreateElement = function() {
            _super.didCreateElement.call(this);

            var self = this;
            this.$().on('tap', function(evt) {
                if (evt.wasHandled()) return;

                if (self.model.selected) {
                    self.model.setProperty('selected', false);
                } else if (self.model.selectable) {
                    self.model.setProperty('selected', true);
                }
            });
        };
    });

    return GraphItemView;
});
define('template!mygraphs_examplegraph', ['underscore'], function(_) {
    return function(obj) {
        var __p = '';
        var print = function() { __p += Array.prototype.join.call(arguments, '') };
        with(obj || {}) {
            __p += '<li class="dcg-action-preview-graph graph-link-container example-graph">\n  <span class="dcg-example-ribbon"></span>\n  <span class="dcg-thumb" style="background-image: url(' +
                (thumbURL) +
                ')"></span>\n  <span class="dcg-title">' +
                (displayTitle) +
                '</span>\n  <span class="date">' +
                (t('example')) +
                '</span>\n</li>\n';
        }
        return __p;
    };
});
define('mygraphs/examplegraphitem_view', ['require', 'pjs', './graphitem_view', 'template!mygraphs_examplegraph'], function(require) {
    var P = require('pjs');
    var GraphItemView = require('./graphitem_view');
    var template = require('template!mygraphs_examplegraph');

    var ExampleGraphItemView = P(GraphItemView, function(view, _super) {
        view.template = template;
        view.isExampleGraphView = true;

        view.init = function(model) {
            _super.init.call(this, model);

            this.model.observe('visible', this.computeSelectable.bind(this));
            this.computeSelectable();
        };

        view.computeSelectable = function() {
            this.model.setProperty('selectable', this.model.visible);
        };
    });

    return ExampleGraphItemView;
});
define('template!mygraphs_savedgraph', ['underscore'], function(_) {
    return function(obj) {
        var __p = '';
        var print = function() { __p += Array.prototype.join.call(arguments, '') };
        with(obj || {}) {
            __p += '<li class="saved-graph graph-link-container">\n  <div class="graph-link dcg-action-preview-graph">\n    <span class="dcg-thumb" style="background-image: url(' +
                (thumbURL) +
                ')"></span>\n    <span class="dcg-title">' +
                (displayTitle) +
                '</span>\n    <span class="date dcg-variable-date">' +
                (displayDate) +
                '</span>\n    <span class="actions" handleEvent="true">\n      <span class="dcg-icon-remove dcg-action-removegraph"></span>\n    </span>\n  </div>\n  <div class=\'deleted\' handleEvent="true">\n\t  ' +
                (t('This graph has been deleted.')) +
                ' <a class=\'dcg-action-cancelremovegraph\'>' +
                (t('Undo')) +
                '</a>\n  </div>\n</li>';
        }
        return __p;
    };
});
define('mygraphs/savedgraphitem_view', ['require', 'pjs', './graphitem_view', 'template!mygraphs_savedgraph'], function(require) {
    var P = require('pjs');
    var GraphItemView = require('./graphitem_view');
    var template = require('template!mygraphs_savedgraph');

    var SavedGraphItemView = P(GraphItemView, function(view, _super) {
        view.template = template;
        view.isSavedGraphView = true;

        view.init = function(model) {
            _super.init.call(this, model);
            this.deleting = false;

            this.model.graph.observe('displayDate', this.renderDisplayDate.bind(this));
            this.model.observe('visible', this.computeSelectable.bind(this));
            this.observe('deleting', this.computeSelectable.bind(this));
            this.observe('deleting', this.renderDeleting.bind(this));

            this.computeSelectable();
        };

        view.computeSelectable = function() {
            this.model.setProperty('selectable', !this.deleting && this.model.visible);
        };

        view.didCreateElement = function() {
            _super.didCreateElement.call(this);
            this.renderDisplayDate();
            this.renderDeleting();

            this.$('.dcg-action-removegraph').on('tap', this.startDeleting.bind(this));
            this.$('.dcg-action-cancelremovegraph').on('tap', this.cancelDelete.bind(this));
        };

        view.destruct = function() {
            this.cancelDelete();
        };

        view.startDeleting = function() {
            this.setProperty('deleting', true);

            var self = this;
            this.deleteTimeout = setTimeout(function() {
                self.$('a').addClass('inactive');
                self.$().slideUp('fast');

                //rerender the preview arrow
                setTimeout(function() {
                    self.model.mygraphs_list.graphsController.remove(self.model.graph);
                }, 300);

            }, 3000);
        };

        view.cancelDelete = function() {
            this.setProperty('deleting', false);
            clearTimeout(this.deleteTimeout);
        };

        view.renderDeleting = function() {
            this.$().toggleClass('deleting', !!this.deleting);
        };

        view.renderDisplayDate = function() {
            var displayDate = this.model.graph.displayDate;
            if (displayDate !== this.lastDisplayDate) {
                this.lastDisplayDate = displayDate;
                this.$('.dcg-variable-date').text(displayDate);
            }
        };
    });

    return SavedGraphItemView;
});
define('template!mygraphs', ['underscore'], function(_) {
    return function(obj) {
        var __p = '';
        var print = function() { __p += Array.prototype.join.call(arguments, '') };
        with(obj || {}) {
            __p += '<div>\n  <div id="resources-container" class="hidden">\n    <div class="search-container">\n      <input id="search-mygraphs" type="text" placeholder="' +
                (t('search by title...')) +
                '" />\n      <span class="dcg-icon-search search-icon"></span>\n    </div>\n    <div class="scrollable">\n\n      ';
            if (maintenance) {;
                __p += '\n        <div class=\'maintenance-mode\'>\n          ' +
                    (t("Desmos is temporarily in maintenance mode. You can open example graphs, but won't be able to sign in, open your graphs, or save any changes. We're so sorry for the inconvenience.")) +
                    '\n        </div>\n\n      ';
            } else if (previewMode) {;
                __p += '\n        <div class=\'maintenance-mode\'>\n          ' +
                    (previewMessage) +
                    '\n          <br>\n          <a class=\'dcg-btn dcg-btn-green\' href=\'' +
                    (previewFeedbackUrl) +
                    '\' target=\'_blank\'>\n            ' +
                    (t("Share your thoughts!")) +
                    '\n          </a>\n        </div>\n\n\n      ';
            } else {;
                __p += '\n\n        ';
                if (accountsEnabled) {;
                    __p += '\n          <div class="login-reminder">\n            <a class=\'dcg-btn dcg-action-createaccount\'>\n              ' +
                        (t('Create Account')) +
                        '\n            </a>\n            ' +
                        (t('or')) +
                        '\n            <a class=\'dcg-action-login\'>\n              ' +
                        (t('Sign In')) +
                        '\n            </a>\n            <div>\n              ' +
                        (t('to save and share your graphs!')) +
                        '\n            </div>\n          </div>\n        ';
                };
                __p += '\n\n        <div class="new-blank-graph dcg-action-newblankgraph">\n          <div class="new-blank-graph-inner">\n            <span>+</span> ' +
                    (t('New Blank Graph')) +
                    '\n          </div>\n        </div>\n\n        ';
                if (accountsEnabled) {;
                    __p += '\n          <div class="template-spinning">\n            <img src="/img/spinner.gif" width="16px" height="16px" /> ' +
                        (t('loading graphs...')) +
                        '\n          </div>\n        ';
                };
                __p += '\n\n      ';
            };
            __p += '\n\n      <ul class="template-list">\n\n      </ul>\n      <div class=\'no-matches\'>\n        ' +
                (t("Sorry, we didn't find any graphs with that title.")) +
                '\n      </div>\n      <div class="dcg-mygraphs-branding">\n        <i class="dcg-icon-desmos"></i>\n      </div>\n    </div>\n\n\n    <div class="graph-preview">\n      <span class="dcg-btn dcg-pull-right dcg-btn-medium dcg-btn-gray dcg-action-cancel">\n        ' +
                (t('Cancel')) +
                '\n      </span>\n      <h4 class="dcg-title"></h4>\n      <div class="screenshot-container">\n        <div id="preview-calculator"></div>\n        <div class="screenshot-clickjack dcg-action-open-graph">\n          <span class="dcg-btn dcg-action-open-graph dcg-open-graph-btn dcg-btn-medium dcg-btn-blue">\n            ' +
                (t('Open Graph')) +
                '\n          </span>\n        </div>\n        <div class="dcg-loading-container">\n          loading...\n        </div>\n      </div>\n      <div class="active-arrow"><div class="dcg-graphic"></div></div>\n    </div>\n  </div>\n\n  <div id="resources-cover" class="dcg-action-close-resources"></div>\n</div>\n';
        }
        return __p;
    };
});
//Definition of built-in functions and variables

define('math/builtin', ['require'], function(require) {

    var BuiltIn = {};

    BuiltIn.mod = function(a, b) {
        return a - b * Math.floor(a / b);
    };

    BuiltIn.sign = function(x) {
        if (x === 0) return 0;
        if (x > 0) return 1;
        if (x < 0) return -1;
        return NaN;
    };

    BuiltIn.lcm = function(a, b) {
        a = Math.round(a);
        b = Math.round(b);
        var gcd = BuiltIn.getGCD(a, b);
        return Math.abs(a * b / gcd);
    };

    BuiltIn.gcd = function(a, b) {
        return BuiltIn.getGCD(a, b);
    };

    BuiltIn.nCr = function(n, r) {
        n = Math.round(n);
        r = Math.round(r);

        //Error conditions
        if (r > n || n < 0 || r < 0) {
            return 0;
        }

        var total = 1;
        for (var i = 0; i < r; i++) {
            total *= (n - i) / (i + 1);
        }
        return total;
    };

    BuiltIn.nPr = function(n, r) {
        n = Math.round(n);
        r = Math.round(r);

        //Error conditions
        if (r > n || n < 0 || r < 0) {
            return 0;
        }

        var total = 1;
        for (var i = 0; i < r; i++) {
            total *= (n - i);
        }
        return total;
    };

    BuiltIn.factorial = function(x) {
        return BuiltIn.gamma(x + 1);
    };

    BuiltIn._integerFactorial = function(n) {
        if (n !== Math.floor(n)) return NaN;
        if (n < 0) return NaN;
        if (n > 170) return NaN; // Overflows double point floats
        if (n === 0 || n === 1) return 1;

        var output = 1;
        for (var i = 2; i <= n; i++) output *= i;

        return output;
    };

    BuiltIn.gamma = function(x) {
        if (x === Math.floor(x)) return BuiltIn._integerFactorial(x - 1);
        // Euler's reflection formula
        if (x < 0) return Math.PI / (Math.sin(Math.PI * x) * BuiltIn.gamma(1 - x));
        return Math.exp(BuiltIn.lnGamma(x));
    };

    BuiltIn.lnGamma = function(x) {
        if (x < 0) return NaN; // Alternates between real and complex on integers.

        // 15 term rational approximation of lnGamma, valid for positive numbers.
        // Original source not known, but verified by JM using Mathematica to give
        // at least 14 correct digits of gamma = Math.exp(Math.lnGamma(x)) for
        // integers and half integers between 0 and 60, and at least 12 correct
        // digits up to 170.
        var cof = [
            57.1562356658629235, -59.5979603554754912,
            14.1360979747417471, -0.491913816097620199,
            0.339946499848118887e-4,
            0.465236289270485756e-4, -0.983744753048795646e-4,
            0.158088703224912494e-3, -0.210264441724104883e-3,
            0.217439618115212643e-3, -0.164318106536763890e-3,
            0.844182239838527433e-4, -0.261908384015814087e-4,
            0.368991826595316234e-5
        ];

        var s = 0.999999999999997092;
        for (var i = 0; i < 14; i++) s += cof[i] / (x + i + 1);

        var t = x + 5.24218750000000000;

        return (x + 0.5) * Math.log(t) - t + Math.log(2.5066282746310005 * s / x);
    };

    // BernoulliB_{2k} for k=1..14
    BuiltIn.bernoulliTable = [
        1 / 6, -1 / 30, 1 / 42, -1 / 30, 5 / 66, -691 / 2730, 7 / 6, -3617 / 510,
        43867 / 798, -174611 / 330, 854513 / 138, -236364091 / 2730, 8553103 / 6, -23749461029 / 870
    ];

    // mth derivative of cot(x)
    //
    // Used in evaluating reflection formula for polygamma
    //
    // Uses fact that (d/dx)^m cot(x) = p_m(cos(x))/sin(x)^{m+1} where p_m(x) is a
    // polynomial with coefficents that obey the following recursion relation:
    //
    // a_{m+1, n} = -((m - n + 2) a_{m, n-1} + (n+1) a_{m, n+1})
    //            = -(            t1         +        t2       )
    // a_{0, 0} = 0, a_{0, 1} = 1
    //
    // Could improve performance by taking advantage of fact that p is even/odd
    // when m is odd/even. Didn't feel worth the added trickiness.
    BuiltIn.cotDerivative = function(m, x) {
        /* jshint maxcomplexity:11 */
        if (m !== Math.floor(m)) return NaN;
        if (m < 0) return NaN;

        if (m === 0) return 1 / BuiltIn.tan(x);

        var sinx = BuiltIn.sin(x);
        if (m === 1) return -1 / (sinx * sinx);

        var cosx = BuiltIn.cos(x);
        if (m === 2) return 2 * cosx / (sinx * sinx * sinx);

        var aprev = [0, 2];
        var a;
        var mp, n;
        var t1, t2;
        for (mp = 3; mp <= m; mp++) {
            a = [];
            for (n = 0; n < mp; n++) {
                t1 = 0;
                t2 = 0;
                if (n > 0) t1 = (mp - n + 1) * aprev[n - 1];
                if (n + 2 < mp) t2 = (n + 1) * aprev[n + 1];
                a.push(-(t1 + t2));
            }
            aprev = a;
        }

        var s = 0;
        // Horner's method for polynomial evaluation
        for (n = m - 1; n >= 0; n--) s = a[n] + cosx * s;

        return s / Math.pow(sinx, m + 1);
    };

    // polyGamma(m, n) is the (m+1)th derivative of lnGamma(n)
    //
    // Implemented by differentiating Stirling's approximation:
    //
    // d/dn ln(Gamma(n)) = -\left(
    //         ln(n) + 1/2n + \sum_{k=1}^{\infty} B_{2k}/(2k n^{2k})
    //       /right)
    //
    // d^{m+1}/dn^{m+1} ln(Gamma(n)) =
    //      m! (-1)^{m + 1} \left(
    //        1/(m n^m) - 1/(2 n^{1+m}) +
    //        \sum_{k=1}^{\infty} B_{2k} (2k + m - 1)!/(m!(2k)!n^{2k+m})
    //      \right)
    //
    // B_{2k} are the Bernoulli numbers.
    //
    // Uses recurrence relation to bring arguments above 10, and reflection
    // formula for negative n. In this case, 14 term sum gives results accurate to
    // machine precision for values of m between 0 and at least 8.
    //
    // Only get 8 digits for polyGamma(100, 30)
    //
    // Recurrence relation:
    //
    // polyGamma(m, n) = polyGamma(m, n + 1) + (-1)^m m!/n^{m+1}
    //
    // Reflection formula:
    //
    // polyGamma(m, n) = (-1)^{m}polyGamma(m, 1 - n) - pi d^m/dn^m cot(pi*n)
    //
    // Can lose some accuracy in reflection formula for large m because of large
    // powers of trig functions.
    BuiltIn.polyGamma = function(m, n) {
        if (m < 0) return NaN;
        if (m !== Math.floor(m)) return NaN;
        var sign = (m % 2 === 0) ? -1 : 1;
        // Use reflection formula for negative n
        if (n < 0) {
            return -sign * BuiltIn.polyGamma(m, 1 - n) -
                Math.pow(Math.PI, m + 1) * BuiltIn.cotDerivative(m, Math.PI * n);
        }

        var mfac = BuiltIn.factorial(m);

        // Use recurrence relation to bring n above 10
        var s = 0;
        var npmm = Math.pow(n, -(m + 1));
        while (n < 10) {
            s += npmm;
            n++;
            npmm = Math.pow(n, -(m + 1));
        }

        s += (m === 0) ? -Math.log(n) : npmm * n / m;
        s += 0.5 * npmm;

        var bt = BuiltIn.bernoulliTable;
        var num = m + 1;
        var denom = 2;
        var pre = npmm * n * num / denom;
        var nsqinv = 1 / (n * n);
        for (var k = 1; k <= 14; k++) {
            pre *= nsqinv;
            s += pre * bt[k - 1];
            num++;
            denom++;
            pre *= num / denom;
            num++;
            denom++;
            pre *= num / denom;
        }
        return mfac * sign * s;
    };

    BuiltIn.getGCD = function(x, y) {
        //Only defined over integers
        var a = Math.round(x);
        var b = Math.round(y);

        // Positive values only
        if (a < 0)
            a = -a;
        if (b < 0)
            b = -b;

        // Reverse order if necessary.
        // b should be smaller than a
        if (b > a) {
            var temp = b;
            b = a;
            a = temp;
        }

        //GCD(0, x) = x
        if (b === 0) {
            return a;
        }

        var m = a % b;

        while (m > 0) {
            a = b;
            b = m;
            m = a % b;
        }

        return b;
    };

    // Returns a reduced fraction approximation of x with denominator less than
    // maxDenominator. maxDenominator defaults to 1e6.
    BuiltIn.toFraction = function(x, maxDenominator) {

        if (x === Infinity) return { n: Infinity, d: 1 };
        if (x === -Infinity) return { n: -Infinity, d: 1 };
        if (!isFinite(x)) return { n: NaN, d: 1 };

        var whole, n0 = 0,
            n1 = 1,
            d0 = 1,
            d1 = 0,
            n, d;
        if (!maxDenominator) maxDenominator = 1e6;
        while (true) {
            whole = Math.floor(x);
            n = whole * n1 + n0;
            d = whole * d1 + d0;
            if (d > maxDenominator) break;
            n0 = n1;
            d0 = d1;
            n1 = n;
            d1 = d;
            if (x === whole) break;
            x = 1 / (x - whole);
        }
        return { n: n1, d: d1 };
    };

    // Check if two values are equal to within the given number of bits of
    // precision. For numbers smaller than one, compares the difference in the
    // numbers to 1 instead of the larger of the numbers. This makes calculations like
    // BuiltIn.approx(Math.sin(Math.Pi), 0) work out.
    BuiltIn.approx = function(x1, x2, bits) {
        var m = Math.max(Math.max(Math.abs(x1), Math.abs(x2)), 1);
        var d = (bits === undefined) ? 0.5 : Math.pow(0.5, bits);
        return m === m + d * Math.abs(x2 - x1);
    };

    BuiltIn.log_base = function(n, base) { return Math.log(n) / Math.log(base) };

    BuiltIn.pow = function(x, n) {
        if (x >= 0 || n === Math.floor(n)) return Math.pow(x, n);
        var frac = BuiltIn.toFraction(n, 100);
        if (BuiltIn.approx(frac.n / frac.d, n, 2) && frac.d % 2 === 1) return (frac.n % 2 === 0 ? 1 : -1) * Math.pow(-x, n);
        return NaN;
    };
    BuiltIn.nthroot = function(x, n) { return BuiltIn.pow(x, 1 / n) };

    var PI_INV = 1 / Math.PI;

    //Trig functions
    // We do some work to make integer and half integer multiples of pi equal to 0 when they should be.
    BuiltIn.sin = function(x) {
        var absx = Math.abs(x);
        if (0.5 * (absx * PI_INV * 2 % 2) + absx === absx) return 0;
        return Math.sin(x);
    };

    BuiltIn.cos = function(x) {
        var absx = Math.abs(x);
        if (0.5 * ((absx * PI_INV * 2 + 1) % 2) + absx === absx) return 0;
        return Math.cos(x);
    };

    BuiltIn.tan = function(x) {
        var absx = Math.abs(x);
        if (0.5 * (absx * PI_INV * 2 % 2) + absx === absx) return 0;
        if (0.5 * ((absx * PI_INV * 2 + 1) % 2) + absx === absx) return Infinity;
        return Math.tan(x);
    };

    BuiltIn.sec = function(x) {
        var absx = Math.abs(x);
        if (0.5 * ((absx * PI_INV * 2 + 1) % 2) + absx === absx) return Infinity;
        return 1 / Math.cos(x);
    };

    BuiltIn.csc = function(x) {
        var absx = Math.abs(x);
        if (0.5 * (absx * PI_INV * 2 % 2) + absx === absx) return Infinity;
        return 1 / Math.sin(x);
    };

    BuiltIn.cot = function(x) {
        var absx = Math.abs(x);
        if (0.5 * (absx * PI_INV * 2 % 2) + absx === absx) return Infinity;
        if (0.5 * ((absx * PI_INV * 2 + 1) % 2) + absx === absx) return 0;
        return 1 / Math.tan(x);
    };

    //Inverse trig functions
    BuiltIn.acot = function(x) { return Math.PI / 2 - Math.atan(x) };
    BuiltIn.acsc = function(x) { return Math.asin(1 / x) };
    BuiltIn.asec = function(x) { return Math.acos(1 / x) };

    //Hyperbolic trig functions
    BuiltIn.sinh = function(x) { return (Math.exp(x) - Math.exp(-x)) / 2 };
    BuiltIn.cosh = function(x) { return (Math.exp(x) + Math.exp(-x)) / 2 };
    BuiltIn.tanh = function(x) {
        // This definition avoids overflow of sinh and cosh for large x
        if (x > 0) {
            return (1 - Math.exp(-2 * x)) / (1 + Math.exp(-2 * x));
        } else {
            return (Math.exp(2 * x) - 1) / (Math.exp(2 * x) + 1);
        }
    };

    BuiltIn.sech = function(x) { return 1 / BuiltIn.cosh(x) };
    BuiltIn.csch = function(x) { return 1 / BuiltIn.sinh(x) };
    BuiltIn.coth = function(x) { return 1 / BuiltIn.tanh(x) };

    //Inverse hyperbolic trig functions
    BuiltIn.asinh = function(x) { return Math.log(x + Math.sqrt(x * x + 1)) };
    BuiltIn.acosh = function(x) { return Math.log(x + Math.sqrt(x + 1) * Math.sqrt(x - 1)) };
    BuiltIn.atanh = function(x) { return 0.5 * Math.log((1 + x) / (1 - x)) };

    BuiltIn.asech = function(x) { return Math.log(1 / x + Math.sqrt((1 / x + 1)) * Math.sqrt((1 / x - 1))) };
    BuiltIn.acsch = function(x) { return Math.log(1 / x + Math.sqrt((1 / (x * x) + 1))) };
    BuiltIn.acoth = function(x) { return 0.5 * Math.log((x + 1) / (x - 1)) };

    BuiltIn.mean = function(list) {
        var total = 0;
        for (var i = 0; i < list.length; i++) {
            total += list[i];
        }
        return total / list.length;
    };

    BuiltIn.total = function(list) {
        var total = 0;
        for (var i = 0; i < list.length; i++) {
            total += list[i];
        }
        return total;
    };

    BuiltIn.length = function(list) {
        return list.length;
    };

    BuiltIn.listMin = function(list) {
        if (list.length < 1) return NaN;
        var min = list[0];
        if (isNaN(min)) return NaN;
        for (var i = 1; i < list.length; i++) {
            if (isNaN(list[i])) return NaN;
            if (list[i] < min) min = list[i];
        }
        return min;
    };

    BuiltIn.listMax = function(list) {
        if (list.length < 1) return NaN;
        var max = list[0];
        if (isNaN(max)) return NaN;
        for (var i = 1; i < list.length; i++) {
            if (isNaN(list[i])) return NaN;
            if (list[i] >= max) max = list[i];
        }
        return max;
    };

    BuiltIn.argMin = function(list) {
        // Our lists start indexing from 1, so returning 0 represents
        // no element of the list.
        if (list.length < 1) return 0;
        var min = list[0];
        if (isNaN(min)) return 0;
        var argMin = 0;
        for (var i = 1; i < list.length; i++) {
            if (isNaN(list[i])) return 0;
            if (list[i] < min) {
                argMin = i;
                min = list[i];
            }
        }
        return argMin + 1; // Convert between js and Desmos indexing conventions
    };

    BuiltIn.argMax = function(list) {
        if (list.length < 1) return 0;
        var max = list[0];
        if (isNaN(max)) return 0;
        var argMax = 0;
        for (var i = 1; i < list.length; i++) {
            if (list[i] >= max) {
                if (isNaN(list[i])) return 0;
                argMax = i;
                max = list[i];
            }
        }
        return argMax + 1; // Convert between js and Desmos indexing conventions
    };

    BuiltIn.var = function(list) {
        var m = BuiltIn.mean(list);
        var total = 0;
        for (var i = 0; i < list.length; i++) {
            var delta = list[i] - m;
            total += delta * delta;
        }
        return total / list.length;
    };

    // Pearson correlation coefficient
    BuiltIn.corr = function(l1, l2) {
        if (l1.length !== l2.length) return NaN;
        var len = l1.length;
        var m1 = BuiltIn.mean(l1);
        var m2 = BuiltIn.mean(l2);
        var d1, d2;
        var t1 = 0,
            t2 = 0,
            tc = 0;
        for (var i = 0; i < len; i++) {
            d1 = l1[i] - m1;
            d2 = l2[i] - m2;
            t1 += d1 * d1;
            t2 += d2 * d2;
            tc += d1 * d2;
        }
        return tc / Math.sqrt(t1 * t2);
    };

    BuiltIn.stdev = function(list) {
        var l = list.length;
        return Math.sqrt(BuiltIn.var(list) * l / (l - 1));
    };

    BuiltIn.stdevp = function(list) {
        return Math.sqrt(BuiltIn.var(list));
    };

    return BuiltIn;
});

// Utility for serializing/deserializing functions.
define('math/functions', ['require', 'math/builtin'], function(require) {
    var BuiltIn = require('math/builtin');

    function dehydrateGraphData(data) {
        for (var i = 0; i < data.length; i++) {
            if (data[i].compiled) {
                delete data[i].compiled.fn;
            }
        }
    }

    function rehydrateGraphData(data) {
        /* jshint evil: true */
        for (var i = 0; i < data.length; i++) {
            var compiled = data[i].compiled;
            if (compiled) {
                compiled.fn = closureFunctionWithBuiltIn(compiled.args, compiled.source);
            }
        }
    }

    //Helper function to auto-generate evaluateOnce calls from evaluation strings
    function createEvaluateFunction(evalExpressionFn, n) {
        /*jshint evil:true*/
        var argList = [];
        for (var i = 0; i < n; i++) {
            argList.push('values[' + i + ']');
        }
        return closureFunctionWithBuiltIn(['values'], 'return ' + evalExpressionFn(argList));
    }

    function closureFunctionWithBuiltIn(args, body) {
        /*jshint evil:true*/
        var argList = args.join(',');
        var functionString = "return (function(" + argList + "){" + body + "})";
        var compilerFunction = new Function(['BuiltIn'], functionString);
        return compilerFunction(BuiltIn);
    }

    return {
        dehydrateGraphData: dehydrateGraphData,
        rehydrateGraphData: rehydrateGraphData,
        closureFunctionWithBuiltIn: closureFunctionWithBuiltIn,
        createEvaluateFunction: createEvaluateFunction
    };
});

define('api/cross_origin_worker', ['require'], function(require) {

    return function(workerURL) {

        // IE workers fail if you put ?desmos_config= after the url.
        // They fail absolutely silently. The browsers doesn't make a request for the
        // javascript and no errors are thrown. This is my best attempt at feature-detecting
        // all versions of IE. Starting with IE11 microsoft wants to make it hard to sniff IE.
        // we aren't putting ?desmos_config= after the url, but we've hit too many snags with
        // IE workers to allow them. Disabling them outright until Microsoft gets its act together
        if (window.MSBlobBuilder) {
            return null;
        }

        var location = window.location;
        var a = document.createElement('a');
        a.href = workerURL;

        // IE doesn't correctly parse the relative URL we give it which results in .protocol being
        // returned as ':'. So we update the elements href with its own, now fully-qualified href.
        a.href = a.href;
        // Go home Internet Explorer - you're drunk.

        if (a.protocol === location.protocol && a.host === location.host) {
            return workerURL;
        }

        var codeString = 'importScripts(\'' + workerURL + '\');';

        var blob;
        try {
            blob = new Blob([codeString], { type: 'application/javascript' });
        } catch (e1) {
            try {
                var BlobBuilder = window.BlobBuilder ||
                    window.WebKitBlobBuilder ||
                    window.MozBlobBuilder;

                var blobBuilder = new BlobBuilder();
                blobBuilder.append(codeString);
                blob = blobBuilder.getBlob('application/javascript');
            } catch (e2) {
                return null; // can't create a blob, abort
            }
        }

        var URL = window.URL || window.webkitURL;
        return URL.createObjectURL(blob);
    };
});

define('numeric', [], function() {


    var numeric = (typeof exports === "undefined") ? (function numeric() {}) : (exports);
    if (typeof global !== "undefined") { global.numeric = numeric; }

    numeric.version = "1.2.6";

    // 1. Utility functions
    numeric.bench = function bench(f, interval) {
        var t1, t2, n, i;
        if (typeof interval === "undefined") { interval = 15; }
        n = 0.5;
        t1 = new Date();
        while (1) {
            n *= 2;
            for (i = n; i > 3; i -= 4) {
                f();
                f();
                f();
                f();
            }
            while (i > 0) {
                f();
                i--;
            }
            t2 = new Date();
            if (t2 - t1 > interval) break;
        }
        for (i = n; i > 3; i -= 4) {
            f();
            f();
            f();
            f();
        }
        while (i > 0) {
            f();
            i--;
        }
        t2 = new Date();
        return 1000 * (3 * n - 1) / (t2 - t1);
    }

    numeric._myIndexOf = (function _myIndexOf(w) {
        var n = this.length,
            k;
        for (k = 0; k < n; ++k)
            if (this[k] === w) return k;
        return -1;
    });
    numeric.myIndexOf = (Array.prototype.indexOf) ? Array.prototype.indexOf : numeric._myIndexOf;

    numeric.precision = 4;
    numeric.largeArray = 50;

    // Wrapper around `new Function` that closures in the `numeric` object.
    numeric.compile = function() {
        var args = Array.prototype.slice.call(arguments);
        var body = args.pop();
        body = 'return function (' + args.join(',') + ') {' + body + ';}';
        return (new Function(['numeric'], body))(numeric);
    }

    numeric.prettyPrint = function prettyPrint(x) {
        function fmtnum(x) {
            if (x === 0) { return '0'; }
            if (isNaN(x)) { return 'NaN'; }
            if (x < 0) { return '-' + fmtnum(-x); }
            if (isFinite(x)) {
                var scale = Math.floor(Math.log(x) / Math.log(10));
                var normalized = x / Math.pow(10, scale);
                var basic = normalized.toPrecision(numeric.precision);
                if (parseFloat(basic) === 10) {
                    scale++;
                    normalized = 1;
                    basic = normalized.toPrecision(numeric.precision);
                }
                return parseFloat(basic).toString() + 'e' + scale.toString();
            }
            return 'Infinity';
        }
        var ret = [];

        function foo(x) {
            var k;
            if (typeof x === "undefined") { ret.push(Array(numeric.precision + 8).join(' ')); return false; }
            if (typeof x === "string") { ret.push('"' + x + '"'); return false; }
            if (typeof x === "boolean") { ret.push(x.toString()); return false; }
            if (typeof x === "number") {
                var a = fmtnum(x);
                var b = x.toPrecision(numeric.precision);
                var c = parseFloat(x.toString()).toString();
                var d = [a, b, c, parseFloat(b).toString(), parseFloat(c).toString()];
                for (k = 1; k < d.length; k++) { if (d[k].length < a.length) a = d[k]; }
                ret.push(Array(numeric.precision + 8 - a.length).join(' ') + a);
                return false;
            }
            if (x === null) { ret.push("null"); return false; }
            if (typeof x === "function") {
                ret.push(x.toString());
                var flag = false;
                for (k in x) {
                    if (x.hasOwnProperty(k)) {
                        if (flag) ret.push(',\n');
                        else ret.push('\n{');
                        flag = true;
                        ret.push(k);
                        ret.push(': \n');
                        foo(x[k]);
                    }
                }
                if (flag) ret.push('}\n');
                return true;
            }
            if (x instanceof Array) {
                if (x.length > numeric.largeArray) { ret.push('...Large Array...'); return true; }
                var flag = false;
                ret.push('[');
                for (k = 0; k < x.length; k++) {
                    if (k > 0) { ret.push(','); if (flag) ret.push('\n '); }
                    flag = foo(x[k]);
                }
                ret.push(']');
                return true;
            }
            ret.push('{');
            var flag = false;
            for (k in x) {
                if (x.hasOwnProperty(k)) {
                    if (flag) ret.push(',\n');
                    flag = true;
                    ret.push(k);
                    ret.push(': \n');
                    foo(x[k]);
                }
            }
            ret.push('}');
            return true;
        }
        foo(x);
        return ret.join('');
    }

    numeric.parseDate = function parseDate(d) {
        function foo(d) {
            if (typeof d === 'string') { return Date.parse(d.replace(/-/g, '/')); }
            if (!(d instanceof Array)) { throw new Error("parseDate: parameter must be arrays of strings"); }
            var ret = [],
                k;
            for (k = 0; k < d.length; k++) { ret[k] = foo(d[k]); }
            return ret;
        }
        return foo(d);
    }

    numeric.parseFloat = function parseFloat_(d) {
        function foo(d) {
            if (typeof d === 'string') { return parseFloat(d); }
            if (!(d instanceof Array)) { throw new Error("parseFloat: parameter must be arrays of strings"); }
            var ret = [],
                k;
            for (k = 0; k < d.length; k++) { ret[k] = foo(d[k]); }
            return ret;
        }
        return foo(d);
    }

    numeric.parseCSV = function parseCSV(t) {
        var foo = t.split('\n');
        var j, k;
        var ret = [];
        var pat = /(([^'",]*)|('[^']*')|("[^"]*")),/g;
        var patnum = /^\s*(([+-]?[0-9]+(\.[0-9]*)?(e[+-]?[0-9]+)?)|([+-]?[0-9]*(\.[0-9]+)?(e[+-]?[0-9]+)?))\s*$/;
        var stripper = function(n) { return n.substr(0, n.length - 1); }
        var count = 0;
        for (k = 0; k < foo.length; k++) {
            var bar = (foo[k] + ",").match(pat),
                baz;
            if (bar.length > 0) {
                ret[count] = [];
                for (j = 0; j < bar.length; j++) {
                    baz = stripper(bar[j]);
                    if (patnum.test(baz)) { ret[count][j] = parseFloat(baz); } else ret[count][j] = baz;
                }
                count++;
            }
        }
        return ret;
    }

    numeric.toCSV = function toCSV(A) {
        var s = numeric.dim(A);
        var i, j, m, n, row, ret;
        m = s[0];
        n = s[1];
        ret = [];
        for (i = 0; i < m; i++) {
            row = [];
            for (j = 0; j < m; j++) { row[j] = A[i][j].toString(); }
            ret[i] = row.join(', ');
        }
        return ret.join('\n') + '\n';
    }

    numeric.getURL = function getURL(url) {
        var client = new XMLHttpRequest();
        client.open("GET", url, false);
        client.send();
        return client;
    }

    numeric.imageURL = function imageURL(img) {
        function base64(A) {
            var n = A.length,
                i, x, y, z, p, q, r, s;
            var key = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
            var ret = "";
            for (i = 0; i < n; i += 3) {
                x = A[i];
                y = A[i + 1];
                z = A[i + 2];
                p = x >> 2;
                q = ((x & 3) << 4) + (y >> 4);
                r = ((y & 15) << 2) + (z >> 6);
                s = z & 63;
                if (i + 1 >= n) { r = s = 64; } else if (i + 2 >= n) { s = 64; }
                ret += key.charAt(p) + key.charAt(q) + key.charAt(r) + key.charAt(s);
            }
            return ret;
        }

        function crc32Array(a, from, to) {
            if (typeof from === "undefined") { from = 0; }
            if (typeof to === "undefined") { to = a.length; }
            var table = [0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,
                0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91,
                0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
                0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5,
                0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,
                0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
                0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
                0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,
                0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
                0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,
                0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457,
                0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
                0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB,
                0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,
                0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
                0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD,
                0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683,
                0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
                0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7,
                0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,
                0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
                0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79,
                0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F,
                0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
                0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,
                0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21,
                0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
                0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,
                0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB,
                0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
                0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF,
                0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D
            ];

            var crc = -1,
                y = 0,
                n = a.length,
                i;

            for (i = from; i < to; i++) {
                y = (crc ^ a[i]) & 0xFF;
                crc = (crc >>> 8) ^ table[y];
            }

            return crc ^ (-1);
        }

        var h = img[0].length,
            w = img[0][0].length,
            s1, s2, next, k, length, a, b, i, j, adler32, crc32;
        var stream = [
            137, 80, 78, 71, 13, 10, 26, 10, //  0: PNG signature
            0, 0, 0, 13, //  8: IHDR Chunk length
            73, 72, 68, 82, // 12: "IHDR"
            (w >> 24) & 255, (w >> 16) & 255, (w >> 8) & 255, w & 255, // 16: Width
            (h >> 24) & 255, (h >> 16) & 255, (h >> 8) & 255, h & 255, // 20: Height
            8, // 24: bit depth
            2, // 25: RGB
            0, // 26: deflate
            0, // 27: no filter
            0, // 28: no interlace
            -1, -2, -3, -4, // 29: CRC
            -5, -6, -7, -8, // 33: IDAT Chunk length
            73, 68, 65, 84, // 37: "IDAT"
            // RFC 1950 header starts here
            8, // 41: RFC1950 CMF
            29 // 42: RFC1950 FLG
        ];
        crc32 = crc32Array(stream, 12, 29);
        stream[29] = (crc32 >> 24) & 255;
        stream[30] = (crc32 >> 16) & 255;
        stream[31] = (crc32 >> 8) & 255;
        stream[32] = (crc32) & 255;
        s1 = 1;
        s2 = 0;
        for (i = 0; i < h; i++) {
            if (i < h - 1) { stream.push(0); } else { stream.push(1); }
            a = (3 * w + 1 + (i === 0)) & 255;
            b = ((3 * w + 1 + (i === 0)) >> 8) & 255;
            stream.push(a);
            stream.push(b);
            stream.push((~a) & 255);
            stream.push((~b) & 255);
            if (i === 0) stream.push(0);
            for (j = 0; j < w; j++) {
                for (k = 0; k < 3; k++) {
                    a = img[k][i][j];
                    if (a > 255) a = 255;
                    else if (a < 0) a = 0;
                    else a = Math.round(a);
                    s1 = (s1 + a) % 65521;
                    s2 = (s2 + s1) % 65521;
                    stream.push(a);
                }
            }
            stream.push(0);
        }
        adler32 = (s2 << 16) + s1;
        stream.push((adler32 >> 24) & 255);
        stream.push((adler32 >> 16) & 255);
        stream.push((adler32 >> 8) & 255);
        stream.push((adler32) & 255);
        length = stream.length - 41;
        stream[33] = (length >> 24) & 255;
        stream[34] = (length >> 16) & 255;
        stream[35] = (length >> 8) & 255;
        stream[36] = (length) & 255;
        crc32 = crc32Array(stream, 37);
        stream.push((crc32 >> 24) & 255);
        stream.push((crc32 >> 16) & 255);
        stream.push((crc32 >> 8) & 255);
        stream.push((crc32) & 255);
        stream.push(0);
        stream.push(0);
        stream.push(0);
        stream.push(0);
        //    a = stream.length;
        stream.push(73); // I
        stream.push(69); // E
        stream.push(78); // N
        stream.push(68); // D
        stream.push(174); // CRC1
        stream.push(66); // CRC2
        stream.push(96); // CRC3
        stream.push(130); // CRC4
        return 'data:image/png;base64,' + base64(stream);
    }

    // 2. Linear algebra with Arrays.
    numeric._dim = function _dim(x) {
        var ret = [];
        while (typeof x === "object") {
            ret.push(x.length);
            x = x[0];
        }
        return ret;
    }

    numeric.dim = function dim(x) {
        var y, z;
        if (typeof x === "object") {
            y = x[0];
            if (typeof y === "object") {
                z = y[0];
                if (typeof z === "object") {
                    return numeric._dim(x);
                }
                return [x.length, y.length];
            }
            return [x.length];
        }
        return [];
    }

    numeric.mapreduce = function mapreduce(body, init) {
        return numeric.compile('x', 'accum', '_s', '_k',
            'if(typeof accum === "undefined") accum = ' + init + ';\n' +
            'if(typeof x === "number") { var xi = x; ' + body + '; return accum; }\n' +
            'if(typeof _s === "undefined") _s = numeric.dim(x);\n' +
            'if(typeof _k === "undefined") _k = 0;\n' +
            'var _n = _s[_k];\n' +
            'var i,xi;\n' +
            'if(_k < _s.length-1) {\n' +
            '    for(i=_n-1;i>=0;i--) {\n' +
            '        accum = arguments.callee(x[i],accum,_s,_k+1);\n' +
            '    }' +
            '    return accum;\n' +
            '}\n' +
            'for(i=_n-1;i>=1;i-=2) { \n' +
            '    xi = x[i];\n' +
            '    ' + body + ';\n' +
            '    xi = x[i-1];\n' +
            '    ' + body + ';\n' +
            '}\n' +
            'if(i === 0) {\n' +
            '    xi = x[i];\n' +
            '    ' + body + '\n' +
            '}\n' +
            'return accum;'
        );
    }
    numeric.mapreduce2 = function mapreduce2(body, setup) {
        return numeric.compile('x',
            'var n = x.length;\n' +
            'var i,xi;\n' + setup + ';\n' +
            'for(i=n-1;i!==-1;--i) { \n' +
            '    xi = x[i];\n' +
            '    ' + body + ';\n' +
            '}\n' +
            'return accum;'
        );
    }


    numeric.same = function same(x, y) {
        var i, n;
        if (!(x instanceof Array) || !(y instanceof Array)) { return false; }
        n = x.length;
        if (n !== y.length) { return false; }
        for (i = 0; i < n; i++) {
            if (x[i] === y[i]) { continue; }
            if (typeof x[i] === "object") { if (!same(x[i], y[i])) return false; } else { return false; }
        }
        return true;
    }

    numeric.rep = function rep(s, v, k) {
        if (typeof k === "undefined") { k = 0; }
        var n = s[k],
            ret = Array(n),
            i;
        if (k === s.length - 1) {
            for (i = n - 2; i >= 0; i -= 2) {
                ret[i + 1] = v;
                ret[i] = v;
            }
            if (i === -1) { ret[0] = v; }
            return ret;
        }
        for (i = n - 1; i >= 0; i--) { ret[i] = numeric.rep(s, v, k + 1); }
        return ret;
    }


    numeric.dotMMsmall = function dotMMsmall(x, y) {
        var i, j, k, p, q, r, ret, foo, bar, woo, i0, k0, p0, r0;
        p = x.length;
        q = y.length;
        r = y[0].length;
        ret = Array(p);
        for (i = p - 1; i >= 0; i--) {
            foo = Array(r);
            bar = x[i];
            for (k = r - 1; k >= 0; k--) {
                woo = bar[q - 1] * y[q - 1][k];
                for (j = q - 2; j >= 1; j -= 2) {
                    i0 = j - 1;
                    woo += bar[j] * y[j][k] + bar[i0] * y[i0][k];
                }
                if (j === 0) { woo += bar[0] * y[0][k]; }
                foo[k] = woo;
            }
            ret[i] = foo;
        }
        return ret;
    }
    numeric._getCol = function _getCol(A, j, x) {
        var n = A.length,
            i;
        for (i = n - 1; i > 0; --i) {
            x[i] = A[i][j];
            --i;
            x[i] = A[i][j];
        }
        if (i === 0) x[0] = A[0][j];
    }
    numeric.dotMMbig = function dotMMbig(x, y) {
        var gc = numeric._getCol,
            p = y.length,
            v = Array(p);
        var m = x.length,
            n = y[0].length,
            A = new Array(m),
            xj;
        var VV = numeric.dotVV;
        var i, j, k, z;
        --p;
        --m;
        for (i = m; i !== -1; --i) A[i] = Array(n);
        --n;
        for (i = n; i !== -1; --i) {
            gc(y, i, v);
            for (j = m; j !== -1; --j) {
                z = 0;
                xj = x[j];
                A[j][i] = VV(xj, v);
            }
        }
        return A;
    }

    numeric.dotMV = function dotMV(x, y) {
        var p = x.length,
            q = y.length,
            i;
        var ret = Array(p),
            dotVV = numeric.dotVV;
        for (i = p - 1; i >= 0; i--) { ret[i] = dotVV(x[i], y); }
        return ret;
    }

    numeric.dotVM = function dotVM(x, y) {
        var i, j, k, p, q, r, ret, foo, bar, woo, i0, k0, p0, r0, s1, s2, s3, baz, accum;
        p = x.length;
        q = y[0].length;
        ret = Array(q);
        for (k = q - 1; k >= 0; k--) {
            woo = x[p - 1] * y[p - 1][k];
            for (j = p - 2; j >= 1; j -= 2) {
                i0 = j - 1;
                woo += x[j] * y[j][k] + x[i0] * y[i0][k];
            }
            if (j === 0) { woo += x[0] * y[0][k]; }
            ret[k] = woo;
        }
        return ret;
    }

    numeric.dotVV = function dotVV(x, y) {
        var i, n = x.length,
            i1, ret = x[n - 1] * y[n - 1];
        for (i = n - 2; i >= 1; i -= 2) {
            i1 = i - 1;
            ret += x[i] * y[i] + x[i1] * y[i1];
        }
        if (i === 0) { ret += x[0] * y[0]; }
        return ret;
    }

    numeric.dot = function dot(x, y) {
        var d = numeric.dim;
        switch (d(x).length * 1000 + d(y).length) {
            case 2002:
                if (y.length < 10) return numeric.dotMMsmall(x, y);
                else return numeric.dotMMbig(x, y);
            case 2001:
                return numeric.dotMV(x, y);
            case 1002:
                return numeric.dotVM(x, y);
            case 1001:
                return numeric.dotVV(x, y);
            case 1000:
                return numeric.mulVS(x, y);
            case 1:
                return numeric.mulSV(x, y);
            case 0:
                return x * y;
            default:
                throw new Error('numeric.dot only works on vectors and matrices');
        }
    }

    numeric.diag = function diag(d) {
        var i, i1, j, n = d.length,
            A = Array(n),
            Ai;
        for (i = n - 1; i >= 0; i--) {
            Ai = Array(n);
            i1 = i + 2;
            for (j = n - 1; j >= i1; j -= 2) {
                Ai[j] = 0;
                Ai[j - 1] = 0;
            }
            if (j > i) { Ai[j] = 0; }
            Ai[i] = d[i];
            for (j = i - 1; j >= 1; j -= 2) {
                Ai[j] = 0;
                Ai[j - 1] = 0;
            }
            if (j === 0) { Ai[0] = 0; }
            A[i] = Ai;
        }
        return A;
    }
    numeric.getDiag = function(A) {
        var n = Math.min(A.length, A[0].length),
            i, ret = Array(n);
        for (i = n - 1; i >= 1; --i) {
            ret[i] = A[i][i];
            --i;
            ret[i] = A[i][i];
        }
        if (i === 0) {
            ret[0] = A[0][0];
        }
        return ret;
    }

    numeric.identity = function identity(n) { return numeric.diag(numeric.rep([n], 1)); }
    numeric.pointwise = function pointwise(params, body, setup) {
        if (typeof setup === "undefined") { setup = ""; }
        var fun = [];
        var k;
        var avec = /\[i\]$/,
            p, thevec = '';
        var haveret = false;
        for (k = 0; k < params.length; k++) {
            if (avec.test(params[k])) {
                p = params[k].substring(0, params[k].length - 3);
                thevec = p;
            } else { p = params[k]; }
            if (p === 'ret') haveret = true;
            fun.push(p);
        }
        fun[params.length] = '_s';
        fun[params.length + 1] = '_k';
        fun[params.length + 2] = (
            'if(typeof _s === "undefined") _s = numeric.dim(' + thevec + ');\n' +
            'if(typeof _k === "undefined") _k = 0;\n' +
            'var _n = _s[_k];\n' +
            'var i' + (haveret ? '' : ', ret = Array(_n)') + ';\n' +
            'if(_k < _s.length-1) {\n' +
            '    for(i=_n-1;i>=0;i--) ret[i] = arguments.callee(' + params.join(',') + ',_s,_k+1);\n' +
            '    return ret;\n' +
            '}\n' +
            setup + '\n' +
            'for(i=_n-1;i!==-1;--i) {\n' +
            '    ' + body + '\n' +
            '}\n' +
            'return ret;'
        );
        return numeric.compile.apply(null, fun);
    }
    numeric.pointwise2 = function pointwise2(params, body, setup) {
        if (typeof setup === "undefined") { setup = ""; }
        var fun = [];
        var k;
        var avec = /\[i\]$/,
            p, thevec = '';
        var haveret = false;
        for (k = 0; k < params.length; k++) {
            if (avec.test(params[k])) {
                p = params[k].substring(0, params[k].length - 3);
                thevec = p;
            } else { p = params[k]; }
            if (p === 'ret') haveret = true;
            fun.push(p);
        }
        fun[params.length] = (
            'var _n = ' + thevec + '.length;\n' +
            'var i' + (haveret ? '' : ', ret = Array(_n)') + ';\n' +
            setup + '\n' +
            'for(i=_n-1;i!==-1;--i) {\n' +
            body + '\n' +
            '}\n' +
            'return ret;'
        );
        return numeric.compile.apply(null, fun);
    }
    numeric._biforeach = (function _biforeach(x, y, s, k, f) {
        if (k === s.length - 1) { f(x, y); return; }
        var i, n = s[k];
        for (i = n - 1; i >= 0; i--) { _biforeach(typeof x === "object" ? x[i] : x, typeof y === "object" ? y[i] : y, s, k + 1, f); }
    });
    numeric._biforeach2 = (function _biforeach2(x, y, s, k, f) {
        if (k === s.length - 1) { return f(x, y); }
        var i, n = s[k],
            ret = Array(n);
        for (i = n - 1; i >= 0; --i) { ret[i] = _biforeach2(typeof x === "object" ? x[i] : x, typeof y === "object" ? y[i] : y, s, k + 1, f); }
        return ret;
    });
    numeric._foreach = (function _foreach(x, s, k, f) {
        if (k === s.length - 1) { f(x); return; }
        var i, n = s[k];
        for (i = n - 1; i >= 0; i--) { _foreach(x[i], s, k + 1, f); }
    });
    numeric._foreach2 = (function _foreach2(x, s, k, f) {
        if (k === s.length - 1) { return f(x); }
        var i, n = s[k],
            ret = Array(n);
        for (i = n - 1; i >= 0; i--) { ret[i] = _foreach2(x[i], s, k + 1, f); }
        return ret;
    });

    /*numeric.anyV = numeric.mapreduce('if(xi) return true;','false');
    numeric.allV = numeric.mapreduce('if(!xi) return false;','true');
    numeric.any = function(x) { if(typeof x.length === "undefined") return x; return numeric.anyV(x); }
    numeric.all = function(x) { if(typeof x.length === "undefined") return x; return numeric.allV(x); }*/

    numeric.ops2 = {
        add: '+',
        sub: '-',
        mul: '*',
        div: '/',
        mod: '%',
        and: '&&',
        or: '||',
        eq: '===',
        neq: '!==',
        lt: '<',
        gt: '>',
        leq: '<=',
        geq: '>=',
        band: '&',
        bor: '|',
        bxor: '^',
        lshift: '<<',
        rshift: '>>',
        rrshift: '>>>'
    };
    numeric.opseq = {
        addeq: '+=',
        subeq: '-=',
        muleq: '*=',
        diveq: '/=',
        modeq: '%=',
        lshifteq: '<<=',
        rshifteq: '>>=',
        rrshifteq: '>>>=',
        bandeq: '&=',
        boreq: '|=',
        bxoreq: '^='
    };
    numeric.mathfuns = ['abs', 'acos', 'asin', 'atan', 'ceil', 'cos',
        'exp', 'floor', 'log', 'round', 'sin', 'sqrt', 'tan',
        'isNaN', 'isFinite'
    ];
    numeric.mathfuns2 = ['atan2', 'pow', 'max', 'min'];
    numeric.ops1 = {
        neg: '-',
        not: '!',
        bnot: '~',
        clone: ''
    };
    numeric.mapreducers = {
        any: ['if(xi) return true;', 'var accum = false;'],
        all: ['if(!xi) return false;', 'var accum = true;'],
        sum: ['accum += xi;', 'var accum = 0;'],
        prod: ['accum *= xi;', 'var accum = 1;'],
        norm2Squared: ['accum += xi*xi;', 'var accum = 0;'],
        norminf: ['accum = max(accum,abs(xi));', 'var accum = 0, max = Math.max, abs = Math.abs;'],
        norm1: ['accum += abs(xi)', 'var accum = 0, abs = Math.abs;'],
        sup: ['accum = max(accum,xi);', 'var accum = -Infinity, max = Math.max;'],
        inf: ['accum = min(accum,xi);', 'var accum = Infinity, min = Math.min;']
    };

    (function() {
        var i, o;
        for (i = 0; i < numeric.mathfuns2.length; ++i) {
            o = numeric.mathfuns2[i];
            numeric.ops2[o] = o;
        }
        for (i in numeric.ops2) {
            if (numeric.ops2.hasOwnProperty(i)) {
                o = numeric.ops2[i];
                var code, codeeq, setup = '';
                if (numeric.myIndexOf.call(numeric.mathfuns2, i) !== -1) {
                    setup = 'var ' + o + ' = Math.' + o + ';\n';
                    code = function(r, x, y) { return r + ' = ' + o + '(' + x + ',' + y + ')'; };
                    codeeq = function(x, y) { return x + ' = ' + o + '(' + x + ',' + y + ')'; };
                } else {
                    code = function(r, x, y) { return r + ' = ' + x + ' ' + o + ' ' + y; };
                    if (numeric.opseq.hasOwnProperty(i + 'eq')) {
                        codeeq = function(x, y) { return x + ' ' + o + '= ' + y; };
                    } else {
                        codeeq = function(x, y) { return x + ' = ' + x + ' ' + o + ' ' + y; };
                    }
                }
                numeric[i + 'VV'] = numeric.pointwise2(['x[i]', 'y[i]'], code('ret[i]', 'x[i]', 'y[i]'), setup);
                numeric[i + 'SV'] = numeric.pointwise2(['x', 'y[i]'], code('ret[i]', 'x', 'y[i]'), setup);
                numeric[i + 'VS'] = numeric.pointwise2(['x[i]', 'y'], code('ret[i]', 'x[i]', 'y'), setup);
                numeric[i] = numeric.compile(
                    'var n = arguments.length, i, x = arguments[0], y;\n' +
                    'var VV = numeric.' + i + 'VV, VS = numeric.' + i + 'VS, SV = numeric.' + i + 'SV;\n' +
                    'var dim = numeric.dim;\n' +
                    'for(i=1;i!==n;++i) { \n' +
                    '  y = arguments[i];\n' +
                    '  if(typeof x === "object") {\n' +
                    '      if(typeof y === "object") x = numeric._biforeach2(x,y,dim(x),0,VV);\n' +
                    '      else x = numeric._biforeach2(x,y,dim(x),0,VS);\n' +
                    '  } else if(typeof y === "object") x = numeric._biforeach2(x,y,dim(y),0,SV);\n' +
                    '  else ' + codeeq('x', 'y') + '\n' +
                    '}\nreturn x;\n');
                numeric[o] = numeric[i];
                numeric[i + 'eqV'] = numeric.pointwise2(['ret[i]', 'x[i]'], codeeq('ret[i]', 'x[i]'), setup);
                numeric[i + 'eqS'] = numeric.pointwise2(['ret[i]', 'x'], codeeq('ret[i]', 'x'), setup);
                numeric[i + 'eq'] = numeric.compile(
                    'var n = arguments.length, i, x = arguments[0], y;\n' +
                    'var V = numeric.' + i + 'eqV, S = numeric.' + i + 'eqS\n' +
                    'var s = numeric.dim(x);\n' +
                    'for(i=1;i!==n;++i) { \n' +
                    '  y = arguments[i];\n' +
                    '  if(typeof y === "object") numeric._biforeach(x,y,s,0,V);\n' +
                    '  else numeric._biforeach(x,y,s,0,S);\n' +
                    '}\nreturn x;\n');
            }
        }
        for (i = 0; i < numeric.mathfuns2.length; ++i) {
            o = numeric.mathfuns2[i];
            delete numeric.ops2[o];
        }
        for (i = 0; i < numeric.mathfuns.length; ++i) {
            o = numeric.mathfuns[i];
            numeric.ops1[o] = o;
        }
        for (i in numeric.ops1) {
            if (numeric.ops1.hasOwnProperty(i)) {
                setup = '';
                o = numeric.ops1[i];
                if (numeric.myIndexOf.call(numeric.mathfuns, i) !== -1) {
                    if (Math.hasOwnProperty(o)) setup = 'var ' + o + ' = Math.' + o + ';\n';
                }
                numeric[i + 'eqV'] = numeric.pointwise2(['ret[i]'], 'ret[i] = ' + o + '(ret[i]);', setup);
                numeric[i + 'eq'] = numeric.compile('x',
                    'if(typeof x !== "object") return ' + o + 'x\n' +
                    'var i;\n' +
                    'var V = numeric.' + i + 'eqV;\n' +
                    'var s = numeric.dim(x);\n' +
                    'numeric._foreach(x,s,0,V);\n' +
                    'return x;\n');
                numeric[i + 'V'] = numeric.pointwise2(['x[i]'], 'ret[i] = ' + o + '(x[i]);', setup);
                numeric[i] = numeric.compile('x',
                    'if(typeof x !== "object") return ' + o + '(x)\n' +
                    'var i;\n' +
                    'var V = numeric.' + i + 'V;\n' +
                    'var s = numeric.dim(x);\n' +
                    'return numeric._foreach2(x,s,0,V);\n');
            }
        }
        for (i = 0; i < numeric.mathfuns.length; ++i) {
            o = numeric.mathfuns[i];
            delete numeric.ops1[o];
        }
        for (i in numeric.mapreducers) {
            if (numeric.mapreducers.hasOwnProperty(i)) {
                o = numeric.mapreducers[i];
                numeric[i + 'V'] = numeric.mapreduce2(o[0], o[1]);
                numeric[i] = numeric.compile('x', 's', 'k',
                    o[1] +
                    'if(typeof x !== "object") {' +
                    '    xi = x;\n' +
                    o[0] + ';\n' +
                    '    return accum;\n' +
                    '}' +
                    'if(typeof s === "undefined") s = numeric.dim(x);\n' +
                    'if(typeof k === "undefined") k = 0;\n' +
                    'if(k === s.length-1) return numeric.' + i + 'V(x);\n' +
                    'var xi;\n' +
                    'var n = x.length, i;\n' +
                    'for(i=n-1;i!==-1;--i) {\n' +
                    '   xi = arguments.callee(x[i]);\n' +
                    o[0] + ';\n' +
                    '}\n' +
                    'return accum;\n');
            }
        }
    }());

    numeric.truncVV = numeric.pointwise(['x[i]', 'y[i]'], 'ret[i] = round(x[i]/y[i])*y[i];', 'var round = Math.round;');
    numeric.truncVS = numeric.pointwise(['x[i]', 'y'], 'ret[i] = round(x[i]/y)*y;', 'var round = Math.round;');
    numeric.truncSV = numeric.pointwise(['x', 'y[i]'], 'ret[i] = round(x/y[i])*y[i];', 'var round = Math.round;');
    numeric.trunc = function trunc(x, y) {
        if (typeof x === "object") {
            if (typeof y === "object") return numeric.truncVV(x, y);
            return numeric.truncVS(x, y);
        }
        if (typeof y === "object") return numeric.truncSV(x, y);
        return Math.round(x / y) * y;
    }

    numeric.inv = function inv(x) {
        var s = numeric.dim(x),
            abs = Math.abs,
            m = s[0],
            n = s[1];
        var A = numeric.clone(x),
            Ai, Aj;
        var I = numeric.identity(m),
            Ii, Ij;
        var i, j, k, x;
        for (j = 0; j < n; ++j) {
            var i0 = -1;
            var v0 = -1;
            for (i = j; i !== m; ++i) {
                k = abs(A[i][j]);
                if (k > v0) {
                    i0 = i;
                    v0 = k;
                }
            }
            Aj = A[i0];
            A[i0] = A[j];
            A[j] = Aj;
            Ij = I[i0];
            I[i0] = I[j];
            I[j] = Ij;
            x = Aj[j];
            for (k = j; k !== n; ++k) Aj[k] /= x;
            for (k = n - 1; k !== -1; --k) Ij[k] /= x;
            for (i = m - 1; i !== -1; --i) {
                if (i !== j) {
                    Ai = A[i];
                    Ii = I[i];
                    x = Ai[j];
                    for (k = j + 1; k !== n; ++k) Ai[k] -= Aj[k] * x;
                    for (k = n - 1; k > 0; --k) {
                        Ii[k] -= Ij[k] * x;
                        --k;
                        Ii[k] -= Ij[k] * x;
                    }
                    if (k === 0) Ii[0] -= Ij[0] * x;
                }
            }
        }
        return I;
    }

    numeric.det = function det(x) {
        var s = numeric.dim(x);
        if (s.length !== 2 || s[0] !== s[1]) { throw new Error('numeric: det() only works on square matrices'); }
        var n = s[0],
            ret = 1,
            i, j, k, A = numeric.clone(x),
            Aj, Ai, alpha, temp, k1, k2, k3;
        for (j = 0; j < n - 1; j++) {
            k = j;
            for (i = j + 1; i < n; i++) { if (Math.abs(A[i][j]) > Math.abs(A[k][j])) { k = i; } }
            if (k !== j) {
                temp = A[k];
                A[k] = A[j];
                A[j] = temp;
                ret *= -1;
            }
            Aj = A[j];
            for (i = j + 1; i < n; i++) {
                Ai = A[i];
                alpha = Ai[j] / Aj[j];
                for (k = j + 1; k < n - 1; k += 2) {
                    k1 = k + 1;
                    Ai[k] -= Aj[k] * alpha;
                    Ai[k1] -= Aj[k1] * alpha;
                }
                if (k !== n) { Ai[k] -= Aj[k] * alpha; }
            }
            if (Aj[j] === 0) { return 0; }
            ret *= Aj[j];
        }
        return ret * A[j][j];
    }

    numeric.transpose = function transpose(x) {
        var i, j, m = x.length,
            n = x[0].length,
            ret = Array(n),
            A0, A1, Bj;
        for (j = 0; j < n; j++) ret[j] = Array(m);
        for (i = m - 1; i >= 1; i -= 2) {
            A1 = x[i];
            A0 = x[i - 1];
            for (j = n - 1; j >= 1; --j) {
                Bj = ret[j];
                Bj[i] = A1[j];
                Bj[i - 1] = A0[j];
                --j;
                Bj = ret[j];
                Bj[i] = A1[j];
                Bj[i - 1] = A0[j];
            }
            if (j === 0) {
                Bj = ret[0];
                Bj[i] = A1[0];
                Bj[i - 1] = A0[0];
            }
        }
        if (i === 0) {
            A0 = x[0];
            for (j = n - 1; j >= 1; --j) {
                ret[j][0] = A0[j];
                --j;
                ret[j][0] = A0[j];
            }
            if (j === 0) { ret[0][0] = A0[0]; }
        }
        return ret;
    }
    numeric.negtranspose = function negtranspose(x) {
        var i, j, m = x.length,
            n = x[0].length,
            ret = Array(n),
            A0, A1, Bj;
        for (j = 0; j < n; j++) ret[j] = Array(m);
        for (i = m - 1; i >= 1; i -= 2) {
            A1 = x[i];
            A0 = x[i - 1];
            for (j = n - 1; j >= 1; --j) {
                Bj = ret[j];
                Bj[i] = -A1[j];
                Bj[i - 1] = -A0[j];
                --j;
                Bj = ret[j];
                Bj[i] = -A1[j];
                Bj[i - 1] = -A0[j];
            }
            if (j === 0) {
                Bj = ret[0];
                Bj[i] = -A1[0];
                Bj[i - 1] = -A0[0];
            }
        }
        if (i === 0) {
            A0 = x[0];
            for (j = n - 1; j >= 1; --j) {
                ret[j][0] = -A0[j];
                --j;
                ret[j][0] = -A0[j];
            }
            if (j === 0) { ret[0][0] = -A0[0]; }
        }
        return ret;
    }

    numeric._random = function _random(s, k) {
        var i, n = s[k],
            ret = Array(n),
            rnd;
        if (k === s.length - 1) {
            rnd = Math.random;
            for (i = n - 1; i >= 1; i -= 2) {
                ret[i] = rnd();
                ret[i - 1] = rnd();
            }
            if (i === 0) { ret[0] = rnd(); }
            return ret;
        }
        for (i = n - 1; i >= 0; i--) ret[i] = _random(s, k + 1);
        return ret;
    }
    numeric.random = function random(s) { return numeric._random(s, 0); }

    numeric.norm2 = function norm2(x) { return Math.sqrt(numeric.norm2Squared(x)); }

    numeric.linspace = function linspace(a, b, n) {
        if (typeof n === "undefined") n = Math.max(Math.round(b - a) + 1, 1);
        if (n < 2) { return n === 1 ? [a] : []; }
        var i, ret = Array(n);
        n--;
        for (i = n; i >= 0; i--) { ret[i] = (i * b + (n - i) * a) / n; }
        return ret;
    }

    numeric.getBlock = function getBlock(x, from, to) {
        var s = numeric.dim(x);

        function foo(x, k) {
            var i, a = from[k],
                n = to[k] - a,
                ret = Array(n);
            if (k === s.length - 1) {
                for (i = n; i >= 0; i--) { ret[i] = x[i + a]; }
                return ret;
            }
            for (i = n; i >= 0; i--) { ret[i] = foo(x[i + a], k + 1); }
            return ret;
        }
        return foo(x, 0);
    }

    numeric.setBlock = function setBlock(x, from, to, B) {
        var s = numeric.dim(x);

        function foo(x, y, k) {
            var i, a = from[k],
                n = to[k] - a;
            if (k === s.length - 1) { for (i = n; i >= 0; i--) { x[i + a] = y[i]; } }
            for (i = n; i >= 0; i--) { foo(x[i + a], y[i], k + 1); }
        }
        foo(x, B, 0);
        return x;
    }

    numeric.getRange = function getRange(A, I, J) {
        var m = I.length,
            n = J.length;
        var i, j;
        var B = Array(m),
            Bi, AI;
        for (i = m - 1; i !== -1; --i) {
            B[i] = Array(n);
            Bi = B[i];
            AI = A[I[i]];
            for (j = n - 1; j !== -1; --j) Bi[j] = AI[J[j]];
        }
        return B;
    }

    numeric.blockMatrix = function blockMatrix(X) {
        var s = numeric.dim(X);
        if (s.length < 4) return numeric.blockMatrix([X]);
        var m = s[0],
            n = s[1],
            M, N, i, j, Xij;
        M = 0;
        N = 0;
        for (i = 0; i < m; ++i) M += X[i][0].length;
        for (j = 0; j < n; ++j) N += X[0][j][0].length;
        var Z = Array(M);
        for (i = 0; i < M; ++i) Z[i] = Array(N);
        var I = 0,
            J, ZI, k, l, Xijk;
        for (i = 0; i < m; ++i) {
            J = N;
            for (j = n - 1; j !== -1; --j) {
                Xij = X[i][j];
                J -= Xij[0].length;
                for (k = Xij.length - 1; k !== -1; --k) {
                    Xijk = Xij[k];
                    ZI = Z[I + k];
                    for (l = Xijk.length - 1; l !== -1; --l) ZI[J + l] = Xijk[l];
                }
            }
            I += X[i][0].length;
        }
        return Z;
    }

    numeric.tensor = function tensor(x, y) {
        if (typeof x === "number" || typeof y === "number") return numeric.mul(x, y);
        var s1 = numeric.dim(x),
            s2 = numeric.dim(y);
        if (s1.length !== 1 || s2.length !== 1) {
            throw new Error('numeric: tensor product is only defined for vectors');
        }
        var m = s1[0],
            n = s2[0],
            A = Array(m),
            Ai, i, j, xi;
        for (i = m - 1; i >= 0; i--) {
            Ai = Array(n);
            xi = x[i];
            for (j = n - 1; j >= 3; --j) {
                Ai[j] = xi * y[j];
                --j;
                Ai[j] = xi * y[j];
                --j;
                Ai[j] = xi * y[j];
                --j;
                Ai[j] = xi * y[j];
            }
            while (j >= 0) { Ai[j] = xi * y[j];--j; }
            A[i] = Ai;
        }
        return A;
    }

    // 3. The Tensor type T
    numeric.T = function T(x, y) {
        this.x = x;
        this.y = y;
    }
    numeric.t = function t(x, y) { return new numeric.T(x, y); }

    numeric.Tbinop = function Tbinop(rr, rc, cr, cc, setup) {
        var io = numeric.indexOf;
        if (typeof setup !== "string") {
            var k;
            setup = '';
            for (k in numeric) {
                if (numeric.hasOwnProperty(k) && (rr.indexOf(k) >= 0 || rc.indexOf(k) >= 0 || cr.indexOf(k) >= 0 || cc.indexOf(k) >= 0) && k.length > 1) {
                    setup += 'var ' + k + ' = numeric.' + k + ';\n';
                }
            }
        }
        return numeric.compile(['y'],
            'var x = this;\n' +
            'if(!(y instanceof numeric.T)) { y = new numeric.T(y); }\n' +
            setup + '\n' +
            'if(x.y) {' +
            '  if(y.y) {' +
            '    return new numeric.T(' + cc + ');\n' +
            '  }\n' +
            '  return new numeric.T(' + cr + ');\n' +
            '}\n' +
            'if(y.y) {\n' +
            '  return new numeric.T(' + rc + ');\n' +
            '}\n' +
            'return new numeric.T(' + rr + ');\n'
        );
    }

    numeric.T.prototype.add = numeric.Tbinop(
        'add(x.x,y.x)',
        'add(x.x,y.x),y.y',
        'add(x.x,y.x),x.y',
        'add(x.x,y.x),add(x.y,y.y)');
    numeric.T.prototype.sub = numeric.Tbinop(
        'sub(x.x,y.x)',
        'sub(x.x,y.x),neg(y.y)',
        'sub(x.x,y.x),x.y',
        'sub(x.x,y.x),sub(x.y,y.y)');
    numeric.T.prototype.mul = numeric.Tbinop(
        'mul(x.x,y.x)',
        'mul(x.x,y.x),mul(x.x,y.y)',
        'mul(x.x,y.x),mul(x.y,y.x)',
        'sub(mul(x.x,y.x),mul(x.y,y.y)),add(mul(x.x,y.y),mul(x.y,y.x))');

    numeric.T.prototype.reciprocal = function reciprocal() {
        var mul = numeric.mul,
            div = numeric.div;
        if (this.y) {
            var d = numeric.add(mul(this.x, this.x), mul(this.y, this.y));
            return new numeric.T(div(this.x, d), div(numeric.neg(this.y), d));
        }
        return new T(div(1, this.x));
    }
    numeric.T.prototype.div = function div(y) {
        if (!(y instanceof numeric.T)) y = new numeric.T(y);
        if (y.y) { return this.mul(y.reciprocal()); }
        var div = numeric.div;
        if (this.y) { return new numeric.T(div(this.x, y.x), div(this.y, y.x)); }
        return new numeric.T(div(this.x, y.x));
    }
    numeric.T.prototype.dot = numeric.Tbinop(
        'dot(x.x,y.x)',
        'dot(x.x,y.x),dot(x.x,y.y)',
        'dot(x.x,y.x),dot(x.y,y.x)',
        'sub(dot(x.x,y.x),dot(x.y,y.y)),add(dot(x.x,y.y),dot(x.y,y.x))'
    );
    numeric.T.prototype.transpose = function transpose() {
        var t = numeric.transpose,
            x = this.x,
            y = this.y;
        if (y) { return new numeric.T(t(x), t(y)); }
        return new numeric.T(t(x));
    }
    numeric.T.prototype.transjugate = function transjugate() {
        var t = numeric.transpose,
            x = this.x,
            y = this.y;
        if (y) { return new numeric.T(t(x), numeric.negtranspose(y)); }
        return new numeric.T(t(x));
    }
    numeric.Tunop = function Tunop(r, c, s) {
        if (typeof s !== "string") { s = ''; }
        return numeric.compile(
            'var x = this;\n' +
            s + '\n' +
            'if(x.y) {' +
            '  ' + c + ';\n' +
            '}\n' +
            r + ';\n'
        );
    }

    numeric.T.prototype.exp = numeric.Tunop(
        'return new numeric.T(ex)',
        'return new numeric.T(mul(cos(x.y),ex),mul(sin(x.y),ex))',
        'var ex = numeric.exp(x.x), cos = numeric.cos, sin = numeric.sin, mul = numeric.mul;');
    numeric.T.prototype.conj = numeric.Tunop(
        'return new numeric.T(x.x);',
        'return new numeric.T(x.x,numeric.neg(x.y));');
    numeric.T.prototype.neg = numeric.Tunop(
        'return new numeric.T(neg(x.x));',
        'return new numeric.T(neg(x.x),neg(x.y));',
        'var neg = numeric.neg;');
    numeric.T.prototype.sin = numeric.Tunop(
        'return new numeric.T(numeric.sin(x.x))',
        'return x.exp().sub(x.neg().exp()).div(new numeric.T(0,2));');
    numeric.T.prototype.cos = numeric.Tunop(
        'return new numeric.T(numeric.cos(x.x))',
        'return x.exp().add(x.neg().exp()).div(2);');
    numeric.T.prototype.abs = numeric.Tunop(
        'return new numeric.T(numeric.abs(x.x));',
        'return new numeric.T(numeric.sqrt(numeric.add(mul(x.x,x.x),mul(x.y,x.y))));',
        'var mul = numeric.mul;');
    numeric.T.prototype.log = numeric.Tunop(
        'return new numeric.T(numeric.log(x.x));',
        'var theta = new numeric.T(numeric.atan2(x.y,x.x)), r = x.abs();\n' +
        'return new numeric.T(numeric.log(r.x),theta.x);');
    numeric.T.prototype.norm2 = numeric.Tunop(
        'return numeric.norm2(x.x);',
        'var f = numeric.norm2Squared;\n' +
        'return Math.sqrt(f(x.x)+f(x.y));');
    numeric.T.prototype.inv = function inv() {
        var A = this;
        if (typeof A.y === "undefined") { return new numeric.T(numeric.inv(A.x)); }
        var n = A.x.length,
            i, j, k;
        var Rx = numeric.identity(n),
            Ry = numeric.rep([n, n], 0);
        var Ax = numeric.clone(A.x),
            Ay = numeric.clone(A.y);
        var Aix, Aiy, Ajx, Ajy, Rix, Riy, Rjx, Rjy;
        var i, j, k, d, d1, ax, ay, bx, by, temp;
        for (i = 0; i < n; i++) {
            ax = Ax[i][i];
            ay = Ay[i][i];
            d = ax * ax + ay * ay;
            k = i;
            for (j = i + 1; j < n; j++) {
                ax = Ax[j][i];
                ay = Ay[j][i];
                d1 = ax * ax + ay * ay;
                if (d1 > d) {
                    k = j;
                    d = d1;
                }
            }
            if (k !== i) {
                temp = Ax[i];
                Ax[i] = Ax[k];
                Ax[k] = temp;
                temp = Ay[i];
                Ay[i] = Ay[k];
                Ay[k] = temp;
                temp = Rx[i];
                Rx[i] = Rx[k];
                Rx[k] = temp;
                temp = Ry[i];
                Ry[i] = Ry[k];
                Ry[k] = temp;
            }
            Aix = Ax[i];
            Aiy = Ay[i];
            Rix = Rx[i];
            Riy = Ry[i];
            ax = Aix[i];
            ay = Aiy[i];
            for (j = i + 1; j < n; j++) {
                bx = Aix[j];
                by = Aiy[j];
                Aix[j] = (bx * ax + by * ay) / d;
                Aiy[j] = (by * ax - bx * ay) / d;
            }
            for (j = 0; j < n; j++) {
                bx = Rix[j];
                by = Riy[j];
                Rix[j] = (bx * ax + by * ay) / d;
                Riy[j] = (by * ax - bx * ay) / d;
            }
            for (j = i + 1; j < n; j++) {
                Ajx = Ax[j];
                Ajy = Ay[j];
                Rjx = Rx[j];
                Rjy = Ry[j];
                ax = Ajx[i];
                ay = Ajy[i];
                for (k = i + 1; k < n; k++) {
                    bx = Aix[k];
                    by = Aiy[k];
                    Ajx[k] -= bx * ax - by * ay;
                    Ajy[k] -= by * ax + bx * ay;
                }
                for (k = 0; k < n; k++) {
                    bx = Rix[k];
                    by = Riy[k];
                    Rjx[k] -= bx * ax - by * ay;
                    Rjy[k] -= by * ax + bx * ay;
                }
            }
        }
        for (i = n - 1; i > 0; i--) {
            Rix = Rx[i];
            Riy = Ry[i];
            for (j = i - 1; j >= 0; j--) {
                Rjx = Rx[j];
                Rjy = Ry[j];
                ax = Ax[j][i];
                ay = Ay[j][i];
                for (k = n - 1; k >= 0; k--) {
                    bx = Rix[k];
                    by = Riy[k];
                    Rjx[k] -= ax * bx - ay * by;
                    Rjy[k] -= ax * by + ay * bx;
                }
            }
        }
        return new numeric.T(Rx, Ry);
    }
    numeric.T.prototype.get = function get(i) {
        var x = this.x,
            y = this.y,
            k = 0,
            ik, n = i.length;
        if (y) {
            while (k < n) {
                ik = i[k];
                x = x[ik];
                y = y[ik];
                k++;
            }
            return new numeric.T(x, y);
        }
        while (k < n) {
            ik = i[k];
            x = x[ik];
            k++;
        }
        return new numeric.T(x);
    }
    numeric.T.prototype.set = function set(i, v) {
        var x = this.x,
            y = this.y,
            k = 0,
            ik, n = i.length,
            vx = v.x,
            vy = v.y;
        if (n === 0) {
            if (vy) { this.y = vy; } else if (y) { this.y = undefined; }
            this.x = x;
            return this;
        }
        if (vy) {
            if (y) { /* ok */ } else {
                y = numeric.rep(numeric.dim(x), 0);
                this.y = y;
            }
            while (k < n - 1) {
                ik = i[k];
                x = x[ik];
                y = y[ik];
                k++;
            }
            ik = i[k];
            x[ik] = vx;
            y[ik] = vy;
            return this;
        }
        if (y) {
            while (k < n - 1) {
                ik = i[k];
                x = x[ik];
                y = y[ik];
                k++;
            }
            ik = i[k];
            x[ik] = vx;
            if (vx instanceof Array) y[ik] = numeric.rep(numeric.dim(vx), 0);
            else y[ik] = 0;
            return this;
        }
        while (k < n - 1) {
            ik = i[k];
            x = x[ik];
            k++;
        }
        ik = i[k];
        x[ik] = vx;
        return this;
    }
    numeric.T.prototype.getRows = function getRows(i0, i1) {
        var n = i1 - i0 + 1,
            j;
        var rx = Array(n),
            ry, x = this.x,
            y = this.y;
        for (j = i0; j <= i1; j++) { rx[j - i0] = x[j]; }
        if (y) {
            ry = Array(n);
            for (j = i0; j <= i1; j++) { ry[j - i0] = y[j]; }
            return new numeric.T(rx, ry);
        }
        return new numeric.T(rx);
    }
    numeric.T.prototype.setRows = function setRows(i0, i1, A) {
        var j;
        var rx = this.x,
            ry = this.y,
            x = A.x,
            y = A.y;
        for (j = i0; j <= i1; j++) { rx[j] = x[j - i0]; }
        if (y) {
            if (!ry) {
                ry = numeric.rep(numeric.dim(rx), 0);
                this.y = ry;
            }
            for (j = i0; j <= i1; j++) { ry[j] = y[j - i0]; }
        } else if (ry) {
            for (j = i0; j <= i1; j++) { ry[j] = numeric.rep([x[j - i0].length], 0); }
        }
        return this;
    }
    numeric.T.prototype.getRow = function getRow(k) {
        var x = this.x,
            y = this.y;
        if (y) { return new numeric.T(x[k], y[k]); }
        return new numeric.T(x[k]);
    }
    numeric.T.prototype.setRow = function setRow(i, v) {
        var rx = this.x,
            ry = this.y,
            x = v.x,
            y = v.y;
        rx[i] = x;
        if (y) {
            if (!ry) {
                ry = numeric.rep(numeric.dim(rx), 0);
                this.y = ry;
            }
            ry[i] = y;
        } else if (ry) {
            ry = numeric.rep([x.length], 0);
        }
        return this;
    }

    numeric.T.prototype.getBlock = function getBlock(from, to) {
        var x = this.x,
            y = this.y,
            b = numeric.getBlock;
        if (y) { return new numeric.T(b(x, from, to), b(y, from, to)); }
        return new numeric.T(b(x, from, to));
    }
    numeric.T.prototype.setBlock = function setBlock(from, to, A) {
        if (!(A instanceof numeric.T)) A = new numeric.T(A);
        var x = this.x,
            y = this.y,
            b = numeric.setBlock,
            Ax = A.x,
            Ay = A.y;
        if (Ay) {
            if (!y) {
                this.y = numeric.rep(numeric.dim(this), 0);
                y = this.y;
            }
            b(x, from, to, Ax);
            b(y, from, to, Ay);
            return this;
        }
        b(x, from, to, Ax);
        if (y) b(y, from, to, numeric.rep(numeric.dim(Ax), 0));
    }
    numeric.T.rep = function rep(s, v) {
        var T = numeric.T;
        if (!(v instanceof T)) v = new T(v);
        var x = v.x,
            y = v.y,
            r = numeric.rep;
        if (y) return new T(r(s, x), r(s, y));
        return new T(r(s, x));
    }
    numeric.T.diag = function diag(d) {
        if (!(d instanceof numeric.T)) d = new numeric.T(d);
        var x = d.x,
            y = d.y,
            diag = numeric.diag;
        if (y) return new numeric.T(diag(x), diag(y));
        return new numeric.T(diag(x));
    }
    numeric.T.eig = function eig() {
        if (this.y) { throw new Error('eig: not implemented for complex matrices.'); }
        return numeric.eig(this.x);
    }
    numeric.T.identity = function identity(n) { return new numeric.T(numeric.identity(n)); }
    numeric.T.prototype.getDiag = function getDiag() {
        var n = numeric;
        var x = this.x,
            y = this.y;
        if (y) { return new n.T(n.getDiag(x), n.getDiag(y)); }
        return new n.T(n.getDiag(x));
    }

    // 4. Eigenvalues of real matrices

    numeric.house = function house(x) {
        var v = numeric.clone(x);
        var s = x[0] >= 0 ? 1 : -1;
        var alpha = s * numeric.norm2(x);
        v[0] += alpha;
        var foo = numeric.norm2(v);
        if (foo === 0) { /* this should not happen */ throw new Error('eig: internal error'); }
        return numeric.div(v, foo);
    }

    numeric.toUpperHessenberg = function toUpperHessenberg(me) {
        var s = numeric.dim(me);
        if (s.length !== 2 || s[0] !== s[1]) { throw new Error('numeric: toUpperHessenberg() only works on square matrices'); }
        var m = s[0],
            i, j, k, x, v, A = numeric.clone(me),
            B, C, Ai, Ci, Q = numeric.identity(m),
            Qi;
        for (j = 0; j < m - 2; j++) {
            x = Array(m - j - 1);
            for (i = j + 1; i < m; i++) { x[i - j - 1] = A[i][j]; }
            if (numeric.norm2(x) > 0) {
                v = numeric.house(x);
                B = numeric.getBlock(A, [j + 1, j], [m - 1, m - 1]);
                C = numeric.tensor(v, numeric.dot(v, B));
                for (i = j + 1; i < m; i++) {
                    Ai = A[i];
                    Ci = C[i - j - 1];
                    for (k = j; k < m; k++) Ai[k] -= 2 * Ci[k - j];
                }
                B = numeric.getBlock(A, [0, j + 1], [m - 1, m - 1]);
                C = numeric.tensor(numeric.dot(B, v), v);
                for (i = 0; i < m; i++) {
                    Ai = A[i];
                    Ci = C[i];
                    for (k = j + 1; k < m; k++) Ai[k] -= 2 * Ci[k - j - 1];
                }
                B = Array(m - j - 1);
                for (i = j + 1; i < m; i++) B[i - j - 1] = Q[i];
                C = numeric.tensor(v, numeric.dot(v, B));
                for (i = j + 1; i < m; i++) {
                    Qi = Q[i];
                    Ci = C[i - j - 1];
                    for (k = 0; k < m; k++) Qi[k] -= 2 * Ci[k];
                }
            }
        }
        return { H: A, Q: Q };
    }

    numeric.epsilon = 2.220446049250313e-16;

    numeric.QRFrancis = function(H, maxiter) {
        if (typeof maxiter === "undefined") { maxiter = 10000; }
        H = numeric.clone(H);
        var H0 = numeric.clone(H);
        var s = numeric.dim(H),
            m = s[0],
            x, v, a, b, c, d, det, tr, Hloc, Q = numeric.identity(m),
            Qi, Hi, B, C, Ci, i, j, k, iter;
        if (m < 3) {
            return {
                Q: Q,
                B: [
                    [0, m - 1]
                ]
            };
        }
        var epsilon = numeric.epsilon;
        for (iter = 0; iter < maxiter; iter++) {
            for (j = 0; j < m - 1; j++) {
                if (Math.abs(H[j + 1][j]) < epsilon * (Math.abs(H[j][j]) + Math.abs(H[j + 1][j + 1]))) {
                    var QH1 = numeric.QRFrancis(numeric.getBlock(H, [0, 0], [j, j]), maxiter);
                    var QH2 = numeric.QRFrancis(numeric.getBlock(H, [j + 1, j + 1], [m - 1, m - 1]), maxiter);
                    B = Array(j + 1);
                    for (i = 0; i <= j; i++) { B[i] = Q[i]; }
                    C = numeric.dot(QH1.Q, B);
                    for (i = 0; i <= j; i++) { Q[i] = C[i]; }
                    B = Array(m - j - 1);
                    for (i = j + 1; i < m; i++) { B[i - j - 1] = Q[i]; }
                    C = numeric.dot(QH2.Q, B);
                    for (i = j + 1; i < m; i++) { Q[i] = C[i - j - 1]; }
                    return { Q: Q, B: QH1.B.concat(numeric.add(QH2.B, j + 1)) };
                }
            }
            a = H[m - 2][m - 2];
            b = H[m - 2][m - 1];
            c = H[m - 1][m - 2];
            d = H[m - 1][m - 1];
            tr = a + d;
            det = (a * d - b * c);
            Hloc = numeric.getBlock(H, [0, 0], [2, 2]);
            if (tr * tr >= 4 * det) {
                var s1, s2;
                s1 = 0.5 * (tr + Math.sqrt(tr * tr - 4 * det));
                s2 = 0.5 * (tr - Math.sqrt(tr * tr - 4 * det));
                Hloc = numeric.add(numeric.sub(numeric.dot(Hloc, Hloc),
                        numeric.mul(Hloc, s1 + s2)),
                    numeric.diag(numeric.rep([3], s1 * s2)));
            } else {
                Hloc = numeric.add(numeric.sub(numeric.dot(Hloc, Hloc),
                        numeric.mul(Hloc, tr)),
                    numeric.diag(numeric.rep([3], det)));
            }
            x = [Hloc[0][0], Hloc[1][0], Hloc[2][0]];
            v = numeric.house(x);
            B = [H[0], H[1], H[2]];
            C = numeric.tensor(v, numeric.dot(v, B));
            for (i = 0; i < 3; i++) {
                Hi = H[i];
                Ci = C[i];
                for (k = 0; k < m; k++) Hi[k] -= 2 * Ci[k];
            }
            B = numeric.getBlock(H, [0, 0], [m - 1, 2]);
            C = numeric.tensor(numeric.dot(B, v), v);
            for (i = 0; i < m; i++) {
                Hi = H[i];
                Ci = C[i];
                for (k = 0; k < 3; k++) Hi[k] -= 2 * Ci[k];
            }
            B = [Q[0], Q[1], Q[2]];
            C = numeric.tensor(v, numeric.dot(v, B));
            for (i = 0; i < 3; i++) {
                Qi = Q[i];
                Ci = C[i];
                for (k = 0; k < m; k++) Qi[k] -= 2 * Ci[k];
            }
            var J;
            for (j = 0; j < m - 2; j++) {
                for (k = j; k <= j + 1; k++) {
                    if (Math.abs(H[k + 1][k]) < epsilon * (Math.abs(H[k][k]) + Math.abs(H[k + 1][k + 1]))) {
                        var QH1 = numeric.QRFrancis(numeric.getBlock(H, [0, 0], [k, k]), maxiter);
                        var QH2 = numeric.QRFrancis(numeric.getBlock(H, [k + 1, k + 1], [m - 1, m - 1]), maxiter);
                        B = Array(k + 1);
                        for (i = 0; i <= k; i++) { B[i] = Q[i]; }
                        C = numeric.dot(QH1.Q, B);
                        for (i = 0; i <= k; i++) { Q[i] = C[i]; }
                        B = Array(m - k - 1);
                        for (i = k + 1; i < m; i++) { B[i - k - 1] = Q[i]; }
                        C = numeric.dot(QH2.Q, B);
                        for (i = k + 1; i < m; i++) { Q[i] = C[i - k - 1]; }
                        return { Q: Q, B: QH1.B.concat(numeric.add(QH2.B, k + 1)) };
                    }
                }
                J = Math.min(m - 1, j + 3);
                x = Array(J - j);
                for (i = j + 1; i <= J; i++) { x[i - j - 1] = H[i][j]; }
                v = numeric.house(x);
                B = numeric.getBlock(H, [j + 1, j], [J, m - 1]);
                C = numeric.tensor(v, numeric.dot(v, B));
                for (i = j + 1; i <= J; i++) {
                    Hi = H[i];
                    Ci = C[i - j - 1];
                    for (k = j; k < m; k++) Hi[k] -= 2 * Ci[k - j];
                }
                B = numeric.getBlock(H, [0, j + 1], [m - 1, J]);
                C = numeric.tensor(numeric.dot(B, v), v);
                for (i = 0; i < m; i++) {
                    Hi = H[i];
                    Ci = C[i];
                    for (k = j + 1; k <= J; k++) Hi[k] -= 2 * Ci[k - j - 1];
                }
                B = Array(J - j);
                for (i = j + 1; i <= J; i++) B[i - j - 1] = Q[i];
                C = numeric.tensor(v, numeric.dot(v, B));
                for (i = j + 1; i <= J; i++) {
                    Qi = Q[i];
                    Ci = C[i - j - 1];
                    for (k = 0; k < m; k++) Qi[k] -= 2 * Ci[k];
                }
            }
        }
        throw new Error('numeric: eigenvalue iteration does not converge -- increase maxiter?');
    }

    numeric.eig = function eig(A, maxiter) {
        var QH = numeric.toUpperHessenberg(A);
        var QB = numeric.QRFrancis(QH.H, maxiter);
        var T = numeric.T;
        var n = A.length,
            i, k, flag = false,
            B = QB.B,
            H = numeric.dot(QB.Q, numeric.dot(QH.H, numeric.transpose(QB.Q)));
        var Q = new T(numeric.dot(QB.Q, QH.Q)),
            Q0;
        var m = B.length,
            j;
        var a, b, c, d, p1, p2, disc, x, y, p, q, n1, n2;
        var sqrt = Math.sqrt;
        for (k = 0; k < m; k++) {
            i = B[k][0];
            if (i === B[k][1]) {
                // nothing
            } else {
                j = i + 1;
                a = H[i][i];
                b = H[i][j];
                c = H[j][i];
                d = H[j][j];
                if (b === 0 && c === 0) continue;
                p1 = -a - d;
                p2 = a * d - b * c;
                disc = p1 * p1 - 4 * p2;
                if (disc >= 0) {
                    if (p1 < 0) x = -0.5 * (p1 - sqrt(disc));
                    else x = -0.5 * (p1 + sqrt(disc));
                    n1 = (a - x) * (a - x) + b * b;
                    n2 = c * c + (d - x) * (d - x);
                    if (n1 > n2) {
                        n1 = sqrt(n1);
                        p = (a - x) / n1;
                        q = b / n1;
                    } else {
                        n2 = sqrt(n2);
                        p = c / n2;
                        q = (d - x) / n2;
                    }
                    Q0 = new T([
                        [q, -p],
                        [p, q]
                    ]);
                    Q.setRows(i, j, Q0.dot(Q.getRows(i, j)));
                } else {
                    x = -0.5 * p1;
                    y = 0.5 * sqrt(-disc);
                    n1 = (a - x) * (a - x) + b * b;
                    n2 = c * c + (d - x) * (d - x);
                    if (n1 > n2) {
                        n1 = sqrt(n1 + y * y);
                        p = (a - x) / n1;
                        q = b / n1;
                        x = 0;
                        y /= n1;
                    } else {
                        n2 = sqrt(n2 + y * y);
                        p = c / n2;
                        q = (d - x) / n2;
                        x = y / n2;
                        y = 0;
                    }
                    Q0 = new T([
                        [q, -p],
                        [p, q]
                    ], [
                        [x, y],
                        [y, -x]
                    ]);
                    Q.setRows(i, j, Q0.dot(Q.getRows(i, j)));
                }
            }
        }
        var R = Q.dot(A).dot(Q.transjugate()),
            n = A.length,
            E = numeric.T.identity(n);
        for (j = 0; j < n; j++) {
            if (j > 0) {
                for (k = j - 1; k >= 0; k--) {
                    var Rk = R.get([k, k]),
                        Rj = R.get([j, j]);
                    if (numeric.neq(Rk.x, Rj.x) || numeric.neq(Rk.y, Rj.y)) {
                        x = R.getRow(k).getBlock([k], [j - 1]);
                        y = E.getRow(j).getBlock([k], [j - 1]);
                        E.set([j, k], (R.get([k, j]).neg().sub(x.dot(y))).div(Rk.sub(Rj)));
                    } else {
                        E.setRow(j, E.getRow(k));
                        continue;
                    }
                }
            }
        }
        for (j = 0; j < n; j++) {
            x = E.getRow(j);
            E.setRow(j, x.div(x.norm2()));
        }
        E = E.transpose();
        E = Q.transjugate().dot(E);
        return { lambda: R.getDiag(), E: E };
    };

    // 5. Compressed Column Storage matrices
    numeric.ccsSparse = function ccsSparse(A) {
        var m = A.length,
            n, foo, i, j, counts = [];
        for (i = m - 1; i !== -1; --i) {
            foo = A[i];
            for (j in foo) {
                j = parseInt(j);
                while (j >= counts.length) counts[counts.length] = 0;
                if (foo[j] !== 0) counts[j]++;
            }
        }
        var n = counts.length;
        var Ai = Array(n + 1);
        Ai[0] = 0;
        for (i = 0; i < n; ++i) Ai[i + 1] = Ai[i] + counts[i];
        var Aj = Array(Ai[n]),
            Av = Array(Ai[n]);
        for (i = m - 1; i !== -1; --i) {
            foo = A[i];
            for (j in foo) {
                if (foo[j] !== 0) {
                    counts[j]--;
                    Aj[Ai[j] + counts[j]] = i;
                    Av[Ai[j] + counts[j]] = foo[j];
                }
            }
        }
        return [Ai, Aj, Av];
    }
    numeric.ccsFull = function ccsFull(A) {
        var Ai = A[0],
            Aj = A[1],
            Av = A[2],
            s = numeric.ccsDim(A),
            m = s[0],
            n = s[1],
            i, j, j0, j1, k;
        var B = numeric.rep([m, n], 0);
        for (i = 0; i < n; i++) {
            j0 = Ai[i];
            j1 = Ai[i + 1];
            for (j = j0; j < j1; ++j) { B[Aj[j]][i] = Av[j]; }
        }
        return B;
    }
    numeric.ccsTSolve = function ccsTSolve(A, b, x, bj, xj) {
        var Ai = A[0],
            Aj = A[1],
            Av = A[2],
            m = Ai.length - 1,
            max = Math.max,
            n = 0;
        if (typeof bj === "undefined") x = numeric.rep([m], 0);
        if (typeof bj === "undefined") bj = numeric.linspace(0, x.length - 1);
        if (typeof xj === "undefined") xj = [];

        function dfs(j) {
            var k;
            if (x[j] !== 0) return;
            x[j] = 1;
            for (k = Ai[j]; k < Ai[j + 1]; ++k) dfs(Aj[k]);
            xj[n] = j;
            ++n;
        }
        var i, j, j0, j1, k, l, l0, l1, a;
        for (i = bj.length - 1; i !== -1; --i) { dfs(bj[i]); }
        xj.length = n;
        for (i = xj.length - 1; i !== -1; --i) { x[xj[i]] = 0; }
        for (i = bj.length - 1; i !== -1; --i) {
            j = bj[i];
            x[j] = b[j];
        }
        for (i = xj.length - 1; i !== -1; --i) {
            j = xj[i];
            j0 = Ai[j];
            j1 = max(Ai[j + 1], j0);
            for (k = j0; k !== j1; ++k) { if (Aj[k] === j) { x[j] /= Av[k]; break; } }
            a = x[j];
            for (k = j0; k !== j1; ++k) {
                l = Aj[k];
                if (l !== j) x[l] -= a * Av[k];
            }
        }
        return x;
    }
    numeric.ccsDFS = function ccsDFS(n) {
        this.k = Array(n);
        this.k1 = Array(n);
        this.j = Array(n);
    }
    numeric.ccsDFS.prototype.dfs = function dfs(J, Ai, Aj, x, xj, Pinv) {
        var m = 0,
            foo, n = xj.length;
        var k = this.k,
            k1 = this.k1,
            j = this.j,
            km, k11;
        if (x[J] !== 0) return;
        x[J] = 1;
        j[0] = J;
        k[0] = km = Ai[J];
        k1[0] = k11 = Ai[J + 1];
        while (1) {
            if (km >= k11) {
                xj[n] = j[m];
                if (m === 0) return;
                ++n;
                --m;
                km = k[m];
                k11 = k1[m];
            } else {
                foo = Pinv[Aj[km]];
                if (x[foo] === 0) {
                    x[foo] = 1;
                    k[m] = km;
                    ++m;
                    j[m] = foo;
                    km = Ai[foo];
                    k1[m] = k11 = Ai[foo + 1];
                } else ++km;
            }
        }
    }
    numeric.ccsLPSolve = function ccsLPSolve(A, B, x, xj, I, Pinv, dfs) {
        var Ai = A[0],
            Aj = A[1],
            Av = A[2],
            m = Ai.length - 1,
            n = 0;
        var Bi = B[0],
            Bj = B[1],
            Bv = B[2];

        var i, i0, i1, j, J, j0, j1, k, l, l0, l1, a;
        i0 = Bi[I];
        i1 = Bi[I + 1];
        xj.length = 0;
        for (i = i0; i < i1; ++i) { dfs.dfs(Pinv[Bj[i]], Ai, Aj, x, xj, Pinv); }
        for (i = xj.length - 1; i !== -1; --i) { x[xj[i]] = 0; }
        for (i = i0; i !== i1; ++i) {
            j = Pinv[Bj[i]];
            x[j] = Bv[i];
        }
        for (i = xj.length - 1; i !== -1; --i) {
            j = xj[i];
            j0 = Ai[j];
            j1 = Ai[j + 1];
            for (k = j0; k < j1; ++k) { if (Pinv[Aj[k]] === j) { x[j] /= Av[k]; break; } }
            a = x[j];
            for (k = j0; k < j1; ++k) {
                l = Pinv[Aj[k]];
                if (l !== j) x[l] -= a * Av[k];
            }
        }
        return x;
    }
    numeric.ccsLUP1 = function ccsLUP1(A, threshold) {
        var m = A[0].length - 1;
        var L = [numeric.rep([m + 1], 0), [],
                []
            ],
            U = [numeric.rep([m + 1], 0), [],
                []
            ];
        var Li = L[0],
            Lj = L[1],
            Lv = L[2],
            Ui = U[0],
            Uj = U[1],
            Uv = U[2];
        var x = numeric.rep([m], 0),
            xj = numeric.rep([m], 0);
        var i, j, k, j0, j1, a, e, c, d, K;
        var sol = numeric.ccsLPSolve,
            max = Math.max,
            abs = Math.abs;
        var P = numeric.linspace(0, m - 1),
            Pinv = numeric.linspace(0, m - 1);
        var dfs = new numeric.ccsDFS(m);
        if (typeof threshold === "undefined") { threshold = 1; }
        for (i = 0; i < m; ++i) {
            sol(L, A, x, xj, i, Pinv, dfs);
            a = -1;
            e = -1;
            for (j = xj.length - 1; j !== -1; --j) {
                k = xj[j];
                if (k <= i) continue;
                c = abs(x[k]);
                if (c > a) {
                    e = k;
                    a = c;
                }
            }
            if (abs(x[i]) < threshold * a) {
                j = P[i];
                a = P[e];
                P[i] = a;
                Pinv[a] = i;
                P[e] = j;
                Pinv[j] = e;
                a = x[i];
                x[i] = x[e];
                x[e] = a;
            }
            a = Li[i];
            e = Ui[i];
            d = x[i];
            Lj[a] = P[i];
            Lv[a] = 1;
            ++a;
            for (j = xj.length - 1; j !== -1; --j) {
                k = xj[j];
                c = x[k];
                xj[j] = 0;
                x[k] = 0;
                if (k <= i) {
                    Uj[e] = k;
                    Uv[e] = c;
                    ++e;
                } else {
                    Lj[a] = P[k];
                    Lv[a] = c / d;
                    ++a;
                }
            }
            Li[i + 1] = a;
            Ui[i + 1] = e;
        }
        for (j = Lj.length - 1; j !== -1; --j) { Lj[j] = Pinv[Lj[j]]; }
        return { L: L, U: U, P: P, Pinv: Pinv };
    }
    numeric.ccsDFS0 = function ccsDFS0(n) {
        this.k = Array(n);
        this.k1 = Array(n);
        this.j = Array(n);
    }
    numeric.ccsDFS0.prototype.dfs = function dfs(J, Ai, Aj, x, xj, Pinv, P) {
        var m = 0,
            foo, n = xj.length;
        var k = this.k,
            k1 = this.k1,
            j = this.j,
            km, k11;
        if (x[J] !== 0) return;
        x[J] = 1;
        j[0] = J;
        k[0] = km = Ai[Pinv[J]];
        k1[0] = k11 = Ai[Pinv[J] + 1];
        while (1) {
            if (isNaN(km)) throw new Error("Ow!");
            if (km >= k11) {
                xj[n] = Pinv[j[m]];
                if (m === 0) return;
                ++n;
                --m;
                km = k[m];
                k11 = k1[m];
            } else {
                foo = Aj[km];
                if (x[foo] === 0) {
                    x[foo] = 1;
                    k[m] = km;
                    ++m;
                    j[m] = foo;
                    foo = Pinv[foo];
                    km = Ai[foo];
                    k1[m] = k11 = Ai[foo + 1];
                } else ++km;
            }
        }
    }
    numeric.ccsLPSolve0 = function ccsLPSolve0(A, B, y, xj, I, Pinv, P, dfs) {
        var Ai = A[0],
            Aj = A[1],
            Av = A[2],
            m = Ai.length - 1,
            n = 0;
        var Bi = B[0],
            Bj = B[1],
            Bv = B[2];

        var i, i0, i1, j, J, j0, j1, k, l, l0, l1, a;
        i0 = Bi[I];
        i1 = Bi[I + 1];
        xj.length = 0;
        for (i = i0; i < i1; ++i) { dfs.dfs(Bj[i], Ai, Aj, y, xj, Pinv, P); }
        for (i = xj.length - 1; i !== -1; --i) {
            j = xj[i];
            y[P[j]] = 0;
        }
        for (i = i0; i !== i1; ++i) {
            j = Bj[i];
            y[j] = Bv[i];
        }
        for (i = xj.length - 1; i !== -1; --i) {
            j = xj[i];
            l = P[j];
            j0 = Ai[j];
            j1 = Ai[j + 1];
            for (k = j0; k < j1; ++k) { if (Aj[k] === l) { y[l] /= Av[k]; break; } }
            a = y[l];
            for (k = j0; k < j1; ++k) y[Aj[k]] -= a * Av[k];
            y[l] = a;
        }
    }
    numeric.ccsLUP0 = function ccsLUP0(A, threshold) {
        var m = A[0].length - 1;
        var L = [numeric.rep([m + 1], 0), [],
                []
            ],
            U = [numeric.rep([m + 1], 0), [],
                []
            ];
        var Li = L[0],
            Lj = L[1],
            Lv = L[2],
            Ui = U[0],
            Uj = U[1],
            Uv = U[2];
        var y = numeric.rep([m], 0),
            xj = numeric.rep([m], 0);
        var i, j, k, j0, j1, a, e, c, d, K;
        var sol = numeric.ccsLPSolve0,
            max = Math.max,
            abs = Math.abs;
        var P = numeric.linspace(0, m - 1),
            Pinv = numeric.linspace(0, m - 1);
        var dfs = new numeric.ccsDFS0(m);
        if (typeof threshold === "undefined") { threshold = 1; }
        for (i = 0; i < m; ++i) {
            sol(L, A, y, xj, i, Pinv, P, dfs);
            a = -1;
            e = -1;
            for (j = xj.length - 1; j !== -1; --j) {
                k = xj[j];
                if (k <= i) continue;
                c = abs(y[P[k]]);
                if (c > a) {
                    e = k;
                    a = c;
                }
            }
            if (abs(y[P[i]]) < threshold * a) {
                j = P[i];
                a = P[e];
                P[i] = a;
                Pinv[a] = i;
                P[e] = j;
                Pinv[j] = e;
            }
            a = Li[i];
            e = Ui[i];
            d = y[P[i]];
            Lj[a] = P[i];
            Lv[a] = 1;
            ++a;
            for (j = xj.length - 1; j !== -1; --j) {
                k = xj[j];
                c = y[P[k]];
                xj[j] = 0;
                y[P[k]] = 0;
                if (k <= i) {
                    Uj[e] = k;
                    Uv[e] = c;
                    ++e;
                } else {
                    Lj[a] = P[k];
                    Lv[a] = c / d;
                    ++a;
                }
            }
            Li[i + 1] = a;
            Ui[i + 1] = e;
        }
        for (j = Lj.length - 1; j !== -1; --j) { Lj[j] = Pinv[Lj[j]]; }
        return { L: L, U: U, P: P, Pinv: Pinv };
    }
    numeric.ccsLUP = numeric.ccsLUP0;

    numeric.ccsDim = function ccsDim(A) { return [numeric.sup(A[1]) + 1, A[0].length - 1]; }
    numeric.ccsGetBlock = function ccsGetBlock(A, i, j) {
        var s = numeric.ccsDim(A),
            m = s[0],
            n = s[1];
        if (typeof i === "undefined") { i = numeric.linspace(0, m - 1); } else if (typeof i === "number") { i = [i]; }
        if (typeof j === "undefined") { j = numeric.linspace(0, n - 1); } else if (typeof j === "number") { j = [j]; }
        var p, p0, p1, P = i.length,
            q, Q = j.length,
            r, jq, ip;
        var Bi = numeric.rep([n], 0),
            Bj = [],
            Bv = [],
            B = [Bi, Bj, Bv];
        var Ai = A[0],
            Aj = A[1],
            Av = A[2];
        var x = numeric.rep([m], 0),
            count = 0,
            flags = numeric.rep([m], 0);
        for (q = 0; q < Q; ++q) {
            jq = j[q];
            var q0 = Ai[jq];
            var q1 = Ai[jq + 1];
            for (p = q0; p < q1; ++p) {
                r = Aj[p];
                flags[r] = 1;
                x[r] = Av[p];
            }
            for (p = 0; p < P; ++p) {
                ip = i[p];
                if (flags[ip]) {
                    Bj[count] = p;
                    Bv[count] = x[i[p]];
                    ++count;
                }
            }
            for (p = q0; p < q1; ++p) {
                r = Aj[p];
                flags[r] = 0;
            }
            Bi[q + 1] = count;
        }
        return B;
    }

    numeric.ccsDot = function ccsDot(A, B) {
        var Ai = A[0],
            Aj = A[1],
            Av = A[2];
        var Bi = B[0],
            Bj = B[1],
            Bv = B[2];
        var sA = numeric.ccsDim(A),
            sB = numeric.ccsDim(B);
        var m = sA[0],
            n = sA[1],
            o = sB[1];
        var x = numeric.rep([m], 0),
            flags = numeric.rep([m], 0),
            xj = Array(m);
        var Ci = numeric.rep([o], 0),
            Cj = [],
            Cv = [],
            C = [Ci, Cj, Cv];
        var i, j, k, j0, j1, i0, i1, l, p, a, b;
        for (k = 0; k !== o; ++k) {
            j0 = Bi[k];
            j1 = Bi[k + 1];
            p = 0;
            for (j = j0; j < j1; ++j) {
                a = Bj[j];
                b = Bv[j];
                i0 = Ai[a];
                i1 = Ai[a + 1];
                for (i = i0; i < i1; ++i) {
                    l = Aj[i];
                    if (flags[l] === 0) {
                        xj[p] = l;
                        flags[l] = 1;
                        p = p + 1;
                    }
                    x[l] = x[l] + Av[i] * b;
                }
            }
            j0 = Ci[k];
            j1 = j0 + p;
            Ci[k + 1] = j1;
            for (j = p - 1; j !== -1; --j) {
                b = j0 + j;
                i = xj[j];
                Cj[b] = i;
                Cv[b] = x[i];
                flags[i] = 0;
                x[i] = 0;
            }
            Ci[k + 1] = Ci[k] + p;
        }
        return C;
    }

    numeric.ccsLUPSolve = function ccsLUPSolve(LUP, B) {
        var L = LUP.L,
            U = LUP.U,
            P = LUP.P;
        var Bi = B[0];
        var flag = false;
        if (typeof Bi !== "object") {
            B = [
                [0, B.length], numeric.linspace(0, B.length - 1), B
            ];
            Bi = B[0];
            flag = true;
        }
        var Bj = B[1],
            Bv = B[2];
        var n = L[0].length - 1,
            m = Bi.length - 1;
        var x = numeric.rep([n], 0),
            xj = Array(n);
        var b = numeric.rep([n], 0),
            bj = Array(n);
        var Xi = numeric.rep([m + 1], 0),
            Xj = [],
            Xv = [];
        var sol = numeric.ccsTSolve;
        var i, j, j0, j1, k, J, N = 0;
        for (i = 0; i < m; ++i) {
            k = 0;
            j0 = Bi[i];
            j1 = Bi[i + 1];
            for (j = j0; j < j1; ++j) {
                J = LUP.Pinv[Bj[j]];
                bj[k] = J;
                b[J] = Bv[j];
                ++k;
            }
            bj.length = k;
            sol(L, b, x, bj, xj);
            for (j = bj.length - 1; j !== -1; --j) b[bj[j]] = 0;
            sol(U, x, b, xj, bj);
            if (flag) return b;
            for (j = xj.length - 1; j !== -1; --j) x[xj[j]] = 0;
            for (j = bj.length - 1; j !== -1; --j) {
                J = bj[j];
                Xj[N] = J;
                Xv[N] = b[J];
                b[J] = 0;
                ++N;
            }
            Xi[i + 1] = N;
        }
        return [Xi, Xj, Xv];
    }

    numeric.ccsbinop = function ccsbinop(body, setup) {
        if (typeof setup === "undefined") setup = '';
        return numeric.compile('X', 'Y',
            'var Xi = X[0], Xj = X[1], Xv = X[2];\n' +
            'var Yi = Y[0], Yj = Y[1], Yv = Y[2];\n' +
            'var n = Xi.length-1,m = Math.max(numeric.sup(Xj),numeric.sup(Yj))+1;\n' +
            'var Zi = numeric.rep([n+1],0), Zj = [], Zv = [];\n' +
            'var x = numeric.rep([m],0),y = numeric.rep([m],0);\n' +
            'var xk,yk,zk;\n' +
            'var i,j,j0,j1,k,p=0;\n' +
            setup +
            'for(i=0;i<n;++i) {\n' +
            '  j0 = Xi[i]; j1 = Xi[i+1];\n' +
            '  for(j=j0;j!==j1;++j) {\n' +
            '    k = Xj[j];\n' +
            '    x[k] = 1;\n' +
            '    Zj[p] = k;\n' +
            '    ++p;\n' +
            '  }\n' +
            '  j0 = Yi[i]; j1 = Yi[i+1];\n' +
            '  for(j=j0;j!==j1;++j) {\n' +
            '    k = Yj[j];\n' +
            '    y[k] = Yv[j];\n' +
            '    if(x[k] === 0) {\n' +
            '      Zj[p] = k;\n' +
            '      ++p;\n' +
            '    }\n' +
            '  }\n' +
            '  Zi[i+1] = p;\n' +
            '  j0 = Xi[i]; j1 = Xi[i+1];\n' +
            '  for(j=j0;j!==j1;++j) x[Xj[j]] = Xv[j];\n' +
            '  j0 = Zi[i]; j1 = Zi[i+1];\n' +
            '  for(j=j0;j!==j1;++j) {\n' +
            '    k = Zj[j];\n' +
            '    xk = x[k];\n' +
            '    yk = y[k];\n' +
            body + '\n' +
            '    Zv[j] = zk;\n' +
            '  }\n' +
            '  j0 = Xi[i]; j1 = Xi[i+1];\n' +
            '  for(j=j0;j!==j1;++j) x[Xj[j]] = 0;\n' +
            '  j0 = Yi[i]; j1 = Yi[i+1];\n' +
            '  for(j=j0;j!==j1;++j) y[Yj[j]] = 0;\n' +
            '}\n' +
            'return [Zi,Zj,Zv];'
        );
    };

    (function() {
        var k, A, B, C;
        for (k in numeric.ops2) {
            if (isFinite(eval('1' + numeric.ops2[k] + '0'))) A = '[Y[0],Y[1],numeric.' + k + '(X,Y[2])]';
            else A = 'NaN';
            if (isFinite(eval('0' + numeric.ops2[k] + '1'))) B = '[X[0],X[1],numeric.' + k + '(X[2],Y)]';
            else B = 'NaN';
            if (isFinite(eval('1' + numeric.ops2[k] + '0')) && isFinite(eval('0' + numeric.ops2[k] + '1'))) C = 'numeric.ccs' + k + 'MM(X,Y)';
            else C = 'NaN';
            numeric['ccs' + k + 'MM'] = numeric.ccsbinop('zk = xk ' + numeric.ops2[k] + 'yk;');
            numeric['ccs' + k] = numeric.compile('X', 'Y',
                'if(typeof X === "number") return ' + A + ';\n' +
                'if(typeof Y === "number") return ' + B + ';\n' +
                'return ' + C + ';\n'
            );
        }
    }());

    numeric.ccsScatter = function ccsScatter(A) {
        var Ai = A[0],
            Aj = A[1],
            Av = A[2];
        var n = numeric.sup(Aj) + 1,
            m = Ai.length;
        var Ri = numeric.rep([n], 0),
            Rj = Array(m),
            Rv = Array(m);
        var counts = numeric.rep([n], 0),
            i;
        for (i = 0; i < m; ++i) counts[Aj[i]]++;
        for (i = 0; i < n; ++i) Ri[i + 1] = Ri[i] + counts[i];
        var ptr = Ri.slice(0),
            k, Aii;
        for (i = 0; i < m; ++i) {
            Aii = Aj[i];
            k = ptr[Aii];
            Rj[k] = Ai[i];
            Rv[k] = Av[i];
            ptr[Aii] = ptr[Aii] + 1;
        }
        return [Ri, Rj, Rv];
    }

    numeric.ccsGather = function ccsGather(A) {
        var Ai = A[0],
            Aj = A[1],
            Av = A[2];
        var n = Ai.length - 1,
            m = Aj.length;
        var Ri = Array(m),
            Rj = Array(m),
            Rv = Array(m);
        var i, j, j0, j1, p;
        p = 0;
        for (i = 0; i < n; ++i) {
            j0 = Ai[i];
            j1 = Ai[i + 1];
            for (j = j0; j !== j1; ++j) {
                Rj[p] = i;
                Ri[p] = Aj[j];
                Rv[p] = Av[j];
                ++p;
            }
        }
        return [Ri, Rj, Rv];
    }

    // The following sparse linear algebra routines are deprecated.

    numeric.sdim = function dim(A, ret, k) {
        if (typeof ret === "undefined") { ret = []; }
        if (typeof A !== "object") return ret;
        if (typeof k === "undefined") { k = 0; }
        if (!(k in ret)) { ret[k] = 0; }
        if (A.length > ret[k]) ret[k] = A.length;
        var i;
        for (i in A) {
            if (A.hasOwnProperty(i)) dim(A[i], ret, k + 1);
        }
        return ret;
    };

    numeric.sclone = function clone(A, k, n) {
        if (typeof k === "undefined") { k = 0; }
        if (typeof n === "undefined") { n = numeric.sdim(A).length; }
        var i, ret = Array(A.length);
        if (k === n - 1) {
            for (i in A) { if (A.hasOwnProperty(i)) ret[i] = A[i]; }
            return ret;
        }
        for (i in A) {
            if (A.hasOwnProperty(i)) ret[i] = clone(A[i], k + 1, n);
        }
        return ret;
    }

    numeric.sdiag = function diag(d) {
        var n = d.length,
            i, ret = Array(n),
            i1, i2, i3;
        for (i = n - 1; i >= 1; i -= 2) {
            i1 = i - 1;
            ret[i] = [];
            ret[i][i] = d[i];
            ret[i1] = [];
            ret[i1][i1] = d[i1];
        }
        if (i === 0) {
            ret[0] = [];
            ret[0][0] = d[i];
        }
        return ret;
    }

    numeric.sidentity = function identity(n) { return numeric.sdiag(numeric.rep([n], 1)); }

    numeric.stranspose = function transpose(A) {
        var ret = [],
            n = A.length,
            i, j, Ai;
        for (i in A) {
            if (!(A.hasOwnProperty(i))) continue;
            Ai = A[i];
            for (j in Ai) {
                if (!(Ai.hasOwnProperty(j))) continue;
                if (typeof ret[j] !== "object") { ret[j] = []; }
                ret[j][i] = Ai[j];
            }
        }
        return ret;
    }

    numeric.sLUP = function LUP(A, tol) {
        throw new Error("The function numeric.sLUP had a bug in it and has been removed. Please use the new numeric.ccsLUP function instead.");
    };

    numeric.sdotMM = function dotMM(A, B) {
        var p = A.length,
            q = B.length,
            BT = numeric.stranspose(B),
            r = BT.length,
            Ai, BTk;
        var i, j, k, accum;
        var ret = Array(p),
            reti;
        for (i = p - 1; i >= 0; i--) {
            reti = [];
            Ai = A[i];
            for (k = r - 1; k >= 0; k--) {
                accum = 0;
                BTk = BT[k];
                for (j in Ai) {
                    if (!(Ai.hasOwnProperty(j))) continue;
                    if (j in BTk) { accum += Ai[j] * BTk[j]; }
                }
                if (accum) reti[k] = accum;
            }
            ret[i] = reti;
        }
        return ret;
    }

    numeric.sdotMV = function dotMV(A, x) {
        var p = A.length,
            Ai, i, j;
        var ret = Array(p),
            accum;
        for (i = p - 1; i >= 0; i--) {
            Ai = A[i];
            accum = 0;
            for (j in Ai) {
                if (!(Ai.hasOwnProperty(j))) continue;
                if (x[j]) accum += Ai[j] * x[j];
            }
            if (accum) ret[i] = accum;
        }
        return ret;
    }

    numeric.sdotVM = function dotMV(x, A) {
        var i, j, Ai, alpha;
        var ret = [],
            accum;
        for (i in x) {
            if (!x.hasOwnProperty(i)) continue;
            Ai = A[i];
            alpha = x[i];
            for (j in Ai) {
                if (!Ai.hasOwnProperty(j)) continue;
                if (!ret[j]) { ret[j] = 0; }
                ret[j] += alpha * Ai[j];
            }
        }
        return ret;
    }

    numeric.sdotVV = function dotVV(x, y) {
        var i, ret = 0;
        for (i in x) { if (x[i] && y[i]) ret += x[i] * y[i]; }
        return ret;
    }

    numeric.sdot = function dot(A, B) {
        var m = numeric.sdim(A).length,
            n = numeric.sdim(B).length;
        var k = m * 1000 + n;
        switch (k) {
            case 0:
                return A * B;
            case 1001:
                return numeric.sdotVV(A, B);
            case 2001:
                return numeric.sdotMV(A, B);
            case 1002:
                return numeric.sdotVM(A, B);
            case 2002:
                return numeric.sdotMM(A, B);
            default:
                throw new Error('numeric.sdot not implemented for tensors of order ' + m + ' and ' + n);
        }
    }

    numeric.sscatter = function scatter(V) {
        var n = V[0].length,
            Vij, i, j, m = V.length,
            A = [],
            Aj;
        for (i = n - 1; i >= 0; --i) {
            if (!V[m - 1][i]) continue;
            Aj = A;
            for (j = 0; j < m - 2; j++) {
                Vij = V[j][i];
                if (!Aj[Vij]) Aj[Vij] = [];
                Aj = Aj[Vij];
            }
            Aj[V[j][i]] = V[j + 1][i];
        }
        return A;
    }

    numeric.sgather = function gather(A, ret, k) {
        if (typeof ret === "undefined") ret = [];
        if (typeof k === "undefined") k = [];
        var n, i, Ai;
        n = k.length;
        for (i in A) {
            if (A.hasOwnProperty(i)) {
                k[n] = parseInt(i);
                Ai = A[i];
                if (typeof Ai === "number") {
                    if (Ai) {
                        if (ret.length === 0) {
                            for (i = n + 1; i >= 0; --i) ret[i] = [];
                        }
                        for (i = n; i >= 0; --i) ret[i].push(k[i]);
                        ret[n + 1].push(Ai);
                    }
                } else gather(Ai, ret, k);
            }
        }
        if (k.length > n) k.pop();
        return ret;
    }

    // 6. Coordinate matrices
    numeric.cLU = function LU(A) {
        var I = A[0],
            J = A[1],
            V = A[2];
        var p = I.length,
            m = 0,
            i, j, k, a, b, c;
        for (i = 0; i < p; i++)
            if (I[i] > m) m = I[i];
        m++;
        var L = Array(m),
            U = Array(m),
            left = numeric.rep([m], Infinity),
            right = numeric.rep([m], -Infinity);
        var Ui, Uj, alpha;
        for (k = 0; k < p; k++) {
            i = I[k];
            j = J[k];
            if (j < left[i]) left[i] = j;
            if (j > right[i]) right[i] = j;
        }
        for (i = 0; i < m - 1; i++) { if (right[i] > right[i + 1]) right[i + 1] = right[i]; }
        for (i = m - 1; i >= 1; i--) { if (left[i] < left[i - 1]) left[i - 1] = left[i]; }
        var countL = 0,
            countU = 0;
        for (i = 0; i < m; i++) {
            U[i] = numeric.rep([right[i] - left[i] + 1], 0);
            L[i] = numeric.rep([i - left[i]], 0);
            countL += i - left[i] + 1;
            countU += right[i] - i + 1;
        }
        for (k = 0; k < p; k++) {
            i = I[k];
            U[i][J[k] - left[i]] = V[k];
        }
        for (i = 0; i < m - 1; i++) {
            a = i - left[i];
            Ui = U[i];
            for (j = i + 1; left[j] <= i && j < m; j++) {
                b = i - left[j];
                c = right[i] - i;
                Uj = U[j];
                alpha = Uj[b] / Ui[a];
                if (alpha) {
                    for (k = 1; k <= c; k++) { Uj[k + b] -= alpha * Ui[k + a]; }
                    L[j][i - left[j]] = alpha;
                }
            }
        }
        var Ui = [],
            Uj = [],
            Uv = [],
            Li = [],
            Lj = [],
            Lv = [];
        var p, q, foo;
        p = 0;
        q = 0;
        for (i = 0; i < m; i++) {
            a = left[i];
            b = right[i];
            foo = U[i];
            for (j = i; j <= b; j++) {
                if (foo[j - a]) {
                    Ui[p] = i;
                    Uj[p] = j;
                    Uv[p] = foo[j - a];
                    p++;
                }
            }
            foo = L[i];
            for (j = a; j < i; j++) {
                if (foo[j - a]) {
                    Li[q] = i;
                    Lj[q] = j;
                    Lv[q] = foo[j - a];
                    q++;
                }
            }
            Li[q] = i;
            Lj[q] = i;
            Lv[q] = 1;
            q++;
        }
        return { U: [Ui, Uj, Uv], L: [Li, Lj, Lv] };
    };

    numeric.cLUsolve = function LUsolve(lu, b) {
        var L = lu.L,
            U = lu.U,
            ret = numeric.clone(b);
        var Li = L[0],
            Lj = L[1],
            Lv = L[2];
        var Ui = U[0],
            Uj = U[1],
            Uv = U[2];
        var p = Ui.length,
            q = Li.length;
        var m = ret.length,
            i, j, k;
        k = 0;
        for (i = 0; i < m; i++) {
            while (Lj[k] < i) {
                ret[i] -= Lv[k] * ret[Lj[k]];
                k++;
            }
            k++;
        }
        k = p - 1;
        for (i = m - 1; i >= 0; i--) {
            while (Uj[k] > i) {
                ret[i] -= Uv[k] * ret[Uj[k]];
                k--;
            }
            ret[i] /= Uv[k];
            k--;
        }
        return ret;
    };

    numeric.cgrid = function grid(n, shape) {
        if (typeof n === "number") n = [n, n];
        var ret = numeric.rep(n, -1);
        var i, j, count;
        if (typeof shape !== "function") {
            switch (shape) {
                case 'L':
                    shape = function(i, j) { return (i >= n[0] / 2 || j < n[1] / 2); }
                    break;
                default:
                    shape = function(i, j) { return true; };
                    break;
            }
        }
        count = 0;
        for (i = 1; i < n[0] - 1; i++)
            for (j = 1; j < n[1] - 1; j++)
                if (shape(i, j)) {
                    ret[i][j] = count;
                    count++;
                }
        return ret;
    }

    numeric.cdelsq = function delsq(g) {
        var dir = [
            [-1, 0],
            [0, -1],
            [0, 1],
            [1, 0]
        ];
        var s = numeric.dim(g),
            m = s[0],
            n = s[1],
            i, j, k, p, q;
        var Li = [],
            Lj = [],
            Lv = [];
        for (i = 1; i < m - 1; i++)
            for (j = 1; j < n - 1; j++) {
                if (g[i][j] < 0) continue;
                for (k = 0; k < 4; k++) {
                    p = i + dir[k][0];
                    q = j + dir[k][1];
                    if (g[p][q] < 0) continue;
                    Li.push(g[i][j]);
                    Lj.push(g[p][q]);
                    Lv.push(-1);
                }
                Li.push(g[i][j]);
                Lj.push(g[i][j]);
                Lv.push(4);
            }
        return [Li, Lj, Lv];
    }

    numeric.cdotMV = function dotMV(A, x) {
        var ret, Ai = A[0],
            Aj = A[1],
            Av = A[2],
            k, p = Ai.length,
            N;
        N = 0;
        for (k = 0; k < p; k++) { if (Ai[k] > N) N = Ai[k]; }
        N++;
        ret = numeric.rep([N], 0);
        for (k = 0; k < p; k++) { ret[Ai[k]] += Av[k] * x[Aj[k]]; }
        return ret;
    }

    // 7. Splines

    numeric.Spline = function Spline(x, yl, yr, kl, kr) {
        this.x = x;
        this.yl = yl;
        this.yr = yr;
        this.kl = kl;
        this.kr = kr;
    }
    numeric.Spline.prototype._at = function _at(x1, p) {
        var x = this.x;
        var yl = this.yl;
        var yr = this.yr;
        var kl = this.kl;
        var kr = this.kr;
        var x1, a, b, t;
        var add = numeric.add,
            sub = numeric.sub,
            mul = numeric.mul;
        a = sub(mul(kl[p], x[p + 1] - x[p]), sub(yr[p + 1], yl[p]));
        b = add(mul(kr[p + 1], x[p] - x[p + 1]), sub(yr[p + 1], yl[p]));
        t = (x1 - x[p]) / (x[p + 1] - x[p]);
        var s = t * (1 - t);
        return add(add(add(mul(1 - t, yl[p]), mul(t, yr[p + 1])), mul(a, s * (1 - t))), mul(b, s * t));
    }
    numeric.Spline.prototype.at = function at(x0) {
        if (typeof x0 === "number") {
            var x = this.x;
            var n = x.length;
            var p, q, mid, floor = Math.floor,
                a, b, t;
            p = 0;
            q = n - 1;
            while (q - p > 1) {
                mid = floor((p + q) / 2);
                if (x[mid] <= x0) p = mid;
                else q = mid;
            }
            return this._at(x0, p);
        }
        var n = x0.length,
            i, ret = Array(n);
        for (i = n - 1; i !== -1; --i) ret[i] = this.at(x0[i]);
        return ret;
    }
    numeric.Spline.prototype.diff = function diff() {
        var x = this.x;
        var yl = this.yl;
        var yr = this.yr;
        var kl = this.kl;
        var kr = this.kr;
        var n = yl.length;
        var i, dx, dy;
        var zl = kl,
            zr = kr,
            pl = Array(n),
            pr = Array(n);
        var add = numeric.add,
            mul = numeric.mul,
            div = numeric.div,
            sub = numeric.sub;
        for (i = n - 1; i !== -1; --i) {
            dx = x[i + 1] - x[i];
            dy = sub(yr[i + 1], yl[i]);
            pl[i] = div(add(mul(dy, 6), mul(kl[i], -4 * dx), mul(kr[i + 1], -2 * dx)), dx * dx);
            pr[i + 1] = div(add(mul(dy, -6), mul(kl[i], 2 * dx), mul(kr[i + 1], 4 * dx)), dx * dx);
        }
        return new numeric.Spline(x, zl, zr, pl, pr);
    }
    numeric.Spline.prototype.roots = function roots() {
        function sqr(x) { return x * x; }

        function heval(y0, y1, k0, k1, x) {
            var A = k0 * 2 - (y1 - y0);
            var B = -k1 * 2 + (y1 - y0);
            var t = (x + 1) * 0.5;
            var s = t * (1 - t);
            return (1 - t) * y0 + t * y1 + A * s * (1 - t) + B * s * t;
        }
        var ret = [];
        var x = this.x,
            yl = this.yl,
            yr = this.yr,
            kl = this.kl,
            kr = this.kr;
        if (typeof yl[0] === "number") {
            yl = [yl];
            yr = [yr];
            kl = [kl];
            kr = [kr];
        }
        var m = yl.length,
            n = x.length - 1,
            i, j, k, y, s, t;
        var ai, bi, ci, di, ret = Array(m),
            ri, k0, k1, y0, y1, A, B, D, dx, cx, stops, z0, z1, zm, t0, t1, tm;
        var sqrt = Math.sqrt;
        for (i = 0; i !== m; ++i) {
            ai = yl[i];
            bi = yr[i];
            ci = kl[i];
            di = kr[i];
            ri = [];
            for (j = 0; j !== n; j++) {
                if (j > 0 && bi[j] * ai[j] < 0) ri.push(x[j]);
                dx = (x[j + 1] - x[j]);
                cx = x[j];
                y0 = ai[j];
                y1 = bi[j + 1];
                k0 = ci[j] / dx;
                k1 = di[j + 1] / dx;
                D = sqr(k0 - k1 + 3 * (y0 - y1)) + 12 * k1 * y0;
                A = k1 + 3 * y0 + 2 * k0 - 3 * y1;
                B = 3 * (k1 + k0 + 2 * (y0 - y1));
                if (D <= 0) {
                    z0 = A / B;
                    if (z0 > x[j] && z0 < x[j + 1]) stops = [x[j], z0, x[j + 1]];
                    else stops = [x[j], x[j + 1]];
                } else {
                    z0 = (A - sqrt(D)) / B;
                    z1 = (A + sqrt(D)) / B;
                    stops = [x[j]];
                    if (z0 > x[j] && z0 < x[j + 1]) stops.push(z0);
                    if (z1 > x[j] && z1 < x[j + 1]) stops.push(z1);
                    stops.push(x[j + 1]);
                }
                t0 = stops[0];
                z0 = this._at(t0, j);
                for (k = 0; k < stops.length - 1; k++) {
                    t1 = stops[k + 1];
                    z1 = this._at(t1, j);
                    if (z0 === 0) {
                        ri.push(t0);
                        t0 = t1;
                        z0 = z1;
                        continue;
                    }
                    if (z1 === 0 || z0 * z1 > 0) {
                        t0 = t1;
                        z0 = z1;
                        continue;
                    }
                    var side = 0;
                    while (1) {
                        tm = (z0 * t1 - z1 * t0) / (z0 - z1);
                        if (tm <= t0 || tm >= t1) { break; }
                        zm = this._at(tm, j);
                        if (zm * z1 > 0) {
                            t1 = tm;
                            z1 = zm;
                            if (side === -1) z0 *= 0.5;
                            side = -1;
                        } else if (zm * z0 > 0) {
                            t0 = tm;
                            z0 = zm;
                            if (side === 1) z1 *= 0.5;
                            side = 1;
                        } else break;
                    }
                    ri.push(tm);
                    t0 = stops[k + 1];
                    z0 = this._at(t0, j);
                }
                if (z1 === 0) ri.push(t1);
            }
            ret[i] = ri;
        }
        if (typeof this.yl[0] === "number") return ret[0];
        return ret;
    }
    numeric.spline = function spline(x, y, k1, kn) {
        var n = x.length,
            b = [],
            dx = [],
            dy = [];
        var i;
        var sub = numeric.sub,
            mul = numeric.mul,
            add = numeric.add;
        for (i = n - 2; i >= 0; i--) {
            dx[i] = x[i + 1] - x[i];
            dy[i] = sub(y[i + 1], y[i]);
        }
        if (typeof k1 === "string" || typeof kn === "string") {
            k1 = kn = "periodic";
        }
        // Build sparse tridiagonal system
        var T = [
            [],
            [],
            []
        ];
        switch (typeof k1) {
            case "undefined":
                b[0] = mul(3 / (dx[0] * dx[0]), dy[0]);
                T[0].push(0, 0);
                T[1].push(0, 1);
                T[2].push(2 / dx[0], 1 / dx[0]);
                break;
            case "string":
                b[0] = add(mul(3 / (dx[n - 2] * dx[n - 2]), dy[n - 2]), mul(3 / (dx[0] * dx[0]), dy[0]));
                T[0].push(0, 0, 0);
                T[1].push(n - 2, 0, 1);
                T[2].push(1 / dx[n - 2], 2 / dx[n - 2] + 2 / dx[0], 1 / dx[0]);
                break;
            default:
                b[0] = k1;
                T[0].push(0);
                T[1].push(0);
                T[2].push(1);
                break;
        }
        for (i = 1; i < n - 1; i++) {
            b[i] = add(mul(3 / (dx[i - 1] * dx[i - 1]), dy[i - 1]), mul(3 / (dx[i] * dx[i]), dy[i]));
            T[0].push(i, i, i);
            T[1].push(i - 1, i, i + 1);
            T[2].push(1 / dx[i - 1], 2 / dx[i - 1] + 2 / dx[i], 1 / dx[i]);
        }
        switch (typeof kn) {
            case "undefined":
                b[n - 1] = mul(3 / (dx[n - 2] * dx[n - 2]), dy[n - 2]);
                T[0].push(n - 1, n - 1);
                T[1].push(n - 2, n - 1);
                T[2].push(1 / dx[n - 2], 2 / dx[n - 2]);
                break;
            case "string":
                T[1][T[1].length - 1] = 0;
                break;
            default:
                b[n - 1] = kn;
                T[0].push(n - 1);
                T[1].push(n - 1);
                T[2].push(1);
                break;
        }
        if (typeof b[0] !== "number") b = numeric.transpose(b);
        else b = [b];
        var k = Array(b.length);
        if (typeof k1 === "string") {
            for (i = k.length - 1; i !== -1; --i) {
                k[i] = numeric.ccsLUPSolve(numeric.ccsLUP(numeric.ccsScatter(T)), b[i]);
                k[i][n - 1] = k[i][0];
            }
        } else {
            for (i = k.length - 1; i !== -1; --i) {
                k[i] = numeric.cLUsolve(numeric.cLU(T), b[i]);
            }
        }
        if (typeof y[0] === "number") k = k[0];
        else k = numeric.transpose(k);
        return new numeric.Spline(x, y, y, k, k);
    }

    // 8. FFT
    numeric.fftpow2 = function fftpow2(x, y) {
        var n = x.length;
        if (n === 1) return;
        var cos = Math.cos,
            sin = Math.sin,
            i, j;
        var xe = Array(n / 2),
            ye = Array(n / 2),
            xo = Array(n / 2),
            yo = Array(n / 2);
        j = n / 2;
        for (i = n - 1; i !== -1; --i) {
            --j;
            xo[j] = x[i];
            yo[j] = y[i];
            --i;
            xe[j] = x[i];
            ye[j] = y[i];
        }
        fftpow2(xe, ye);
        fftpow2(xo, yo);
        j = n / 2;
        var t, k = (-6.2831853071795864769252867665590057683943387987502116419 / n),
            ci, si;
        for (i = n - 1; i !== -1; --i) {
            --j;
            if (j === -1) j = n / 2 - 1;
            t = k * i;
            ci = cos(t);
            si = sin(t);
            x[i] = xe[j] + ci * xo[j] - si * yo[j];
            y[i] = ye[j] + ci * yo[j] + si * xo[j];
        }
    }
    numeric._ifftpow2 = function _ifftpow2(x, y) {
        var n = x.length;
        if (n === 1) return;
        var cos = Math.cos,
            sin = Math.sin,
            i, j;
        var xe = Array(n / 2),
            ye = Array(n / 2),
            xo = Array(n / 2),
            yo = Array(n / 2);
        j = n / 2;
        for (i = n - 1; i !== -1; --i) {
            --j;
            xo[j] = x[i];
            yo[j] = y[i];
            --i;
            xe[j] = x[i];
            ye[j] = y[i];
        }
        _ifftpow2(xe, ye);
        _ifftpow2(xo, yo);
        j = n / 2;
        var t, k = (6.2831853071795864769252867665590057683943387987502116419 / n),
            ci, si;
        for (i = n - 1; i !== -1; --i) {
            --j;
            if (j === -1) j = n / 2 - 1;
            t = k * i;
            ci = cos(t);
            si = sin(t);
            x[i] = xe[j] + ci * xo[j] - si * yo[j];
            y[i] = ye[j] + ci * yo[j] + si * xo[j];
        }
    }
    numeric.ifftpow2 = function ifftpow2(x, y) {
        numeric._ifftpow2(x, y);
        numeric.diveq(x, x.length);
        numeric.diveq(y, y.length);
    }
    numeric.convpow2 = function convpow2(ax, ay, bx, by) {
        numeric.fftpow2(ax, ay);
        numeric.fftpow2(bx, by);
        var i, n = ax.length,
            axi, bxi, ayi, byi;
        for (i = n - 1; i !== -1; --i) {
            axi = ax[i];
            ayi = ay[i];
            bxi = bx[i];
            byi = by[i];
            ax[i] = axi * bxi - ayi * byi;
            ay[i] = axi * byi + ayi * bxi;
        }
        numeric.ifftpow2(ax, ay);
    }
    numeric.T.prototype.fft = function fft() {
        var x = this.x,
            y = this.y;
        var n = x.length,
            log = Math.log,
            log2 = log(2),
            p = Math.ceil(log(2 * n - 1) / log2),
            m = Math.pow(2, p);
        var cx = numeric.rep([m], 0),
            cy = numeric.rep([m], 0),
            cos = Math.cos,
            sin = Math.sin;
        var k, c = (-3.141592653589793238462643383279502884197169399375105820 / n),
            t;
        var a = numeric.rep([m], 0),
            b = numeric.rep([m], 0),
            nhalf = Math.floor(n / 2);
        for (k = 0; k < n; k++) a[k] = x[k];
        if (typeof y !== "undefined")
            for (k = 0; k < n; k++) b[k] = y[k];
        cx[0] = 1;
        for (k = 1; k <= m / 2; k++) {
            t = c * k * k;
            cx[k] = cos(t);
            cy[k] = sin(t);
            cx[m - k] = cos(t);
            cy[m - k] = sin(t)
        }
        var X = new numeric.T(a, b),
            Y = new numeric.T(cx, cy);
        X = X.mul(Y);
        numeric.convpow2(X.x, X.y, numeric.clone(Y.x), numeric.neg(Y.y));
        X = X.mul(Y);
        X.x.length = n;
        X.y.length = n;
        return X;
    }
    numeric.T.prototype.ifft = function ifft() {
        var x = this.x,
            y = this.y;
        var n = x.length,
            log = Math.log,
            log2 = log(2),
            p = Math.ceil(log(2 * n - 1) / log2),
            m = Math.pow(2, p);
        var cx = numeric.rep([m], 0),
            cy = numeric.rep([m], 0),
            cos = Math.cos,
            sin = Math.sin;
        var k, c = (3.141592653589793238462643383279502884197169399375105820 / n),
            t;
        var a = numeric.rep([m], 0),
            b = numeric.rep([m], 0),
            nhalf = Math.floor(n / 2);
        for (k = 0; k < n; k++) a[k] = x[k];
        if (typeof y !== "undefined")
            for (k = 0; k < n; k++) b[k] = y[k];
        cx[0] = 1;
        for (k = 1; k <= m / 2; k++) {
            t = c * k * k;
            cx[k] = cos(t);
            cy[k] = sin(t);
            cx[m - k] = cos(t);
            cy[m - k] = sin(t)
        }
        var X = new numeric.T(a, b),
            Y = new numeric.T(cx, cy);
        X = X.mul(Y);
        numeric.convpow2(X.x, X.y, numeric.clone(Y.x), numeric.neg(Y.y));
        X = X.mul(Y);
        X.x.length = n;
        X.y.length = n;
        return X.div(n);
    }

    //9. Unconstrained optimization
    numeric.gradient = function gradient(f, x) {
        var n = x.length;
        var f0 = f(x);
        if (isNaN(f0)) throw new Error('gradient: f(x) is a NaN!');
        var max = Math.max;
        var i, x0 = numeric.clone(x),
            f1, f2, J = Array(n);
        var div = numeric.div,
            sub = numeric.sub,
            errest, roundoff, max = Math.max,
            eps = 1e-3,
            abs = Math.abs,
            min = Math.min;
        var t0, t1, t2, it = 0,
            d1, d2, N;
        for (i = 0; i < n; i++) {
            var h = max(1e-6 * f0, 1e-8);
            while (1) {
                ++it;
                if (it > 20) { throw new Error("Numerical gradient fails"); }
                x0[i] = x[i] + h;
                f1 = f(x0);
                x0[i] = x[i] - h;
                f2 = f(x0);
                x0[i] = x[i];
                if (isNaN(f1) || isNaN(f2)) { h /= 16; continue; }
                J[i] = (f1 - f2) / (2 * h);
                t0 = x[i] - h;
                t1 = x[i];
                t2 = x[i] + h;
                d1 = (f1 - f0) / h;
                d2 = (f0 - f2) / h;
                N = max(abs(J[i]), abs(f0), abs(f1), abs(f2), abs(t0), abs(t1), abs(t2), 1e-8);
                errest = min(max(abs(d1 - J[i]), abs(d2 - J[i]), abs(d1 - d2)) / N, h / N);
                if (errest > eps) { h /= 16; } else break;
            }
        }
        return J;
    }

    numeric.uncmin = function uncmin(f, x0, tol, gradient, maxit, callback, options) {
        var grad = numeric.gradient;
        if (typeof options === "undefined") { options = {}; }
        if (typeof tol === "undefined") { tol = 1e-8; }
        if (typeof gradient === "undefined") { gradient = function(x) { return grad(f, x); }; }
        if (typeof maxit === "undefined") maxit = 1000;
        x0 = numeric.clone(x0);
        var n = x0.length;
        var f0 = f(x0),
            f1, df0;
        if (isNaN(f0)) throw new Error('uncmin: f(x0) is a NaN!');
        var max = Math.max,
            norm2 = numeric.norm2;
        tol = max(tol, numeric.epsilon);
        var step, g0, g1, H1 = options.Hinv || numeric.identity(n);
        var dot = numeric.dot,
            inv = numeric.inv,
            sub = numeric.sub,
            add = numeric.add,
            ten = numeric.tensor,
            div = numeric.div,
            mul = numeric.mul;
        var all = numeric.all,
            isfinite = numeric.isFinite,
            neg = numeric.neg;
        var it = 0,
            i, s, x1, y, Hy, Hs, ys, i0, t, nstep, t1, t2;
        var msg = "";
        g0 = gradient(x0);
        while (it < maxit) {
            if (typeof callback === "function") { if (callback(it, x0, f0, g0, H1)) { msg = "Callback returned true"; break; } }
            if (!all(isfinite(g0))) { msg = "Gradient has Infinity or NaN"; break; }
            step = neg(dot(H1, g0));
            if (!all(isfinite(step))) { msg = "Search direction has Infinity or NaN"; break; }
            nstep = norm2(step);
            if (nstep < tol) { msg = "Newton step smaller than tol"; break; }
            t = 1;
            df0 = dot(g0, step);
            // line search
            x1 = x0;
            while (it < maxit) {
                if (t * nstep < tol) { break; }
                s = mul(step, t);
                x1 = add(x0, s);
                f1 = f(x1);
                if (f1 - f0 >= 0.1 * t * df0 || isNaN(f1)) {
                    t *= 0.5;
                    ++it;
                    continue;
                }
                break;
            }
            if (t * nstep < tol) { msg = "Line search step size smaller than tol"; break; }
            if (it === maxit) { msg = "maxit reached during line search"; break; }
            g1 = gradient(x1);
            y = sub(g1, g0);
            ys = dot(y, s);
            Hy = dot(H1, y);
            H1 = sub(add(H1,
                    mul(
                        (ys + dot(y, Hy)) / (ys * ys),
                        ten(s, s))),
                div(add(ten(Hy, s), ten(s, Hy)), ys));
            x0 = x1;
            f0 = f1;
            g0 = g1;
            ++it;
        }
        return { solution: x0, f: f0, gradient: g0, invHessian: H1, iterations: it, message: msg };
    }

    // 10. Ode solver (Dormand-Prince)
    numeric.Dopri = function Dopri(x, y, f, ymid, iterations, msg, events) {
        this.x = x;
        this.y = y;
        this.f = f;
        this.ymid = ymid;
        this.iterations = iterations;
        this.events = events;
        this.message = msg;
    }
    numeric.Dopri.prototype._at = function _at(xi, j) {
        function sqr(x) { return x * x; }
        var sol = this;
        var xs = sol.x;
        var ys = sol.y;
        var k1 = sol.f;
        var ymid = sol.ymid;
        var n = xs.length;
        var x0, x1, xh, y0, y1, yh, xi;
        var floor = Math.floor,
            h;
        var c = 0.5;
        var add = numeric.add,
            mul = numeric.mul,
            sub = numeric.sub,
            p, q, w;
        x0 = xs[j];
        x1 = xs[j + 1];
        y0 = ys[j];
        y1 = ys[j + 1];
        h = x1 - x0;
        xh = x0 + c * h;
        yh = ymid[j];
        p = sub(k1[j], mul(y0, 1 / (x0 - xh) + 2 / (x0 - x1)));
        q = sub(k1[j + 1], mul(y1, 1 / (x1 - xh) + 2 / (x1 - x0)));
        w = [sqr(xi - x1) * (xi - xh) / sqr(x0 - x1) / (x0 - xh),
            sqr(xi - x0) * sqr(xi - x1) / sqr(x0 - xh) / sqr(x1 - xh),
            sqr(xi - x0) * (xi - xh) / sqr(x1 - x0) / (x1 - xh),
            (xi - x0) * sqr(xi - x1) * (xi - xh) / sqr(x0 - x1) / (x0 - xh),
            (xi - x1) * sqr(xi - x0) * (xi - xh) / sqr(x0 - x1) / (x1 - xh)
        ];
        return add(add(add(add(mul(y0, w[0]),
                        mul(yh, w[1])),
                    mul(y1, w[2])),
                mul(p, w[3])),
            mul(q, w[4]));
    }
    numeric.Dopri.prototype.at = function at(x) {
        var i, j, k, floor = Math.floor;
        if (typeof x !== "number") {
            var n = x.length,
                ret = Array(n);
            for (i = n - 1; i !== -1; --i) {
                ret[i] = this.at(x[i]);
            }
            return ret;
        }
        var x0 = this.x;
        i = 0;
        j = x0.length - 1;
        while (j - i > 1) {
            k = floor(0.5 * (i + j));
            if (x0[k] <= x) i = k;
            else j = k;
        }
        return this._at(x, i);
    }

    numeric.dopri = function dopri(x0, x1, y0, f, tol, maxit, event) {
        if (typeof tol === "undefined") { tol = 1e-6; }
        if (typeof maxit === "undefined") { maxit = 1000; }
        var xs = [x0],
            ys = [y0],
            k1 = [f(x0, y0)],
            k2, k3, k4, k5, k6, k7, ymid = [];
        var A2 = 1 / 5;
        var A3 = [3 / 40, 9 / 40];
        var A4 = [44 / 45, -56 / 15, 32 / 9];
        var A5 = [19372 / 6561, -25360 / 2187, 64448 / 6561, -212 / 729];
        var A6 = [9017 / 3168, -355 / 33, 46732 / 5247, 49 / 176, -5103 / 18656];
        var b = [35 / 384, 0, 500 / 1113, 125 / 192, -2187 / 6784, 11 / 84];
        var bm = [0.5 * 6025192743 / 30085553152,
            0,
            0.5 * 51252292925 / 65400821598,
            0.5 * -2691868925 / 45128329728,
            0.5 * 187940372067 / 1594534317056,
            0.5 * -1776094331 / 19743644256,
            0.5 * 11237099 / 235043384
        ];
        var c = [1 / 5, 3 / 10, 4 / 5, 8 / 9, 1, 1];
        var e = [-71 / 57600, 0, 71 / 16695, -71 / 1920, 17253 / 339200, -22 / 525, 1 / 40];
        var i = 0,
            er, j;
        var h = (x1 - x0) / 10;
        var it = 0;
        var add = numeric.add,
            mul = numeric.mul,
            y1, erinf;
        var max = Math.max,
            min = Math.min,
            abs = Math.abs,
            norminf = numeric.norminf,
            pow = Math.pow;
        var any = numeric.any,
            lt = numeric.lt,
            and = numeric.and,
            sub = numeric.sub;
        var e0, e1, ev;
        var ret = new numeric.Dopri(xs, ys, k1, ymid, -1, "");
        if (typeof event === "function") e0 = event(x0, y0);
        while (x0 < x1 && it < maxit) {
            ++it;
            if (x0 + h > x1) h = x1 - x0;
            k2 = f(x0 + c[0] * h, add(y0, mul(A2 * h, k1[i])));
            k3 = f(x0 + c[1] * h, add(add(y0, mul(A3[0] * h, k1[i])), mul(A3[1] * h, k2)));
            k4 = f(x0 + c[2] * h, add(add(add(y0, mul(A4[0] * h, k1[i])), mul(A4[1] * h, k2)), mul(A4[2] * h, k3)));
            k5 = f(x0 + c[3] * h, add(add(add(add(y0, mul(A5[0] * h, k1[i])), mul(A5[1] * h, k2)), mul(A5[2] * h, k3)), mul(A5[3] * h, k4)));
            k6 = f(x0 + c[4] * h, add(add(add(add(add(y0, mul(A6[0] * h, k1[i])), mul(A6[1] * h, k2)), mul(A6[2] * h, k3)), mul(A6[3] * h, k4)), mul(A6[4] * h, k5)));
            y1 = add(add(add(add(add(y0, mul(k1[i], h * b[0])), mul(k3, h * b[2])), mul(k4, h * b[3])), mul(k5, h * b[4])), mul(k6, h * b[5]));
            k7 = f(x0 + h, y1);
            er = add(add(add(add(add(mul(k1[i], h * e[0]), mul(k3, h * e[2])), mul(k4, h * e[3])), mul(k5, h * e[4])), mul(k6, h * e[5])), mul(k7, h * e[6]));
            if (typeof er === "number") erinf = abs(er);
            else erinf = norminf(er);
            if (erinf > tol) { // reject
                h = 0.2 * h * pow(tol / erinf, 0.25);
                if (x0 + h === x0) {
                    ret.msg = "Step size became too small";
                    break;
                }
                continue;
            }
            ymid[i] = add(add(add(add(add(add(y0,
                                    mul(k1[i], h * bm[0])),
                                mul(k3, h * bm[2])),
                            mul(k4, h * bm[3])),
                        mul(k5, h * bm[4])),
                    mul(k6, h * bm[5])),
                mul(k7, h * bm[6]));
            ++i;
            xs[i] = x0 + h;
            ys[i] = y1;
            k1[i] = k7;
            if (typeof event === "function") {
                var yi, xl = x0,
                    xr = x0 + 0.5 * h,
                    xi;
                e1 = event(xr, ymid[i - 1]);
                ev = and(lt(e0, 0), lt(0, e1));
                if (!any(ev)) {
                    xl = xr;
                    xr = x0 + h;
                    e0 = e1;
                    e1 = event(xr, y1);
                    ev = and(lt(e0, 0), lt(0, e1));
                }
                if (any(ev)) {
                    var xc, yc, en, ei;
                    var side = 0,
                        sl = 1.0,
                        sr = 1.0;
                    while (1) {
                        if (typeof e0 === "number") xi = (sr * e1 * xl - sl * e0 * xr) / (sr * e1 - sl * e0);
                        else {
                            xi = xr;
                            for (j = e0.length - 1; j !== -1; --j) {
                                if (e0[j] < 0 && e1[j] > 0) xi = min(xi, (sr * e1[j] * xl - sl * e0[j] * xr) / (sr * e1[j] - sl * e0[j]));
                            }
                        }
                        if (xi <= xl || xi >= xr) break;
                        yi = ret._at(xi, i - 1);
                        ei = event(xi, yi);
                        en = and(lt(e0, 0), lt(0, ei));
                        if (any(en)) {
                            xr = xi;
                            e1 = ei;
                            ev = en;
                            sr = 1.0;
                            if (side === -1) sl *= 0.5;
                            else sl = 1.0;
                            side = -1;
                        } else {
                            xl = xi;
                            e0 = ei;
                            sl = 1.0;
                            if (side === 1) sr *= 0.5;
                            else sr = 1.0;
                            side = 1;
                        }
                    }
                    y1 = ret._at(0.5 * (x0 + xi), i - 1);
                    ret.f[i] = f(xi, yi);
                    ret.x[i] = xi;
                    ret.y[i] = yi;
                    ret.ymid[i - 1] = y1;
                    ret.events = ev;
                    ret.iterations = it;
                    return ret;
                }
            }
            x0 += h;
            y0 = y1;
            e0 = e1;
            h = min(0.8 * h * pow(tol / erinf, 0.25), 4 * h);
        }
        ret.iterations = it;
        return ret;
    }

    // 11. Ax = b
    numeric.LU = function(A, fast) {
        fast = fast || false;

        var abs = Math.abs;
        var i, j, k, absAjk, Akk, Ak, Pk, Ai;
        var max;
        var n = A.length,
            n1 = n - 1;
        var P = new Array(n);
        if (!fast) A = numeric.clone(A);

        for (k = 0; k < n; ++k) {
            Pk = k;
            Ak = A[k];
            max = abs(Ak[k]);
            for (j = k + 1; j < n; ++j) {
                absAjk = abs(A[j][k]);
                if (max < absAjk) {
                    max = absAjk;
                    Pk = j;
                }
            }
            P[k] = Pk;

            if (Pk != k) {
                A[k] = A[Pk];
                A[Pk] = Ak;
                Ak = A[k];
            }

            Akk = Ak[k];

            for (i = k + 1; i < n; ++i) {
                A[i][k] /= Akk;
            }

            for (i = k + 1; i < n; ++i) {
                Ai = A[i];
                for (j = k + 1; j < n1; ++j) {
                    Ai[j] -= Ai[k] * Ak[j];
                    ++j;
                    Ai[j] -= Ai[k] * Ak[j];
                }
                if (j === n1) Ai[j] -= Ai[k] * Ak[j];
            }
        }

        return {
            LU: A,
            P: P
        };
    }

    numeric.LUsolve = function LUsolve(LUP, b) {
        var i, j;
        var LU = LUP.LU;
        var n = LU.length;
        var x = numeric.clone(b);
        var P = LUP.P;
        var Pi, LUi, LUii, tmp;

        for (i = n - 1; i !== -1; --i) x[i] = b[i];
        for (i = 0; i < n; ++i) {
            Pi = P[i];
            if (P[i] !== i) {
                tmp = x[i];
                x[i] = x[Pi];
                x[Pi] = tmp;
            }

            LUi = LU[i];
            for (j = 0; j < i; ++j) {
                x[i] -= x[j] * LUi[j];
            }
        }

        for (i = n - 1; i >= 0; --i) {
            LUi = LU[i];
            for (j = i + 1; j < n; ++j) {
                x[i] -= x[j] * LUi[j];
            }

            x[i] /= LUi[i];
        }

        return x;
    }

    numeric.solve = function solve(A, b, fast) { return numeric.LUsolve(numeric.LU(A, fast), b); }

    // 12. Linear programming
    numeric.echelonize = function echelonize(A) {
        var s = numeric.dim(A),
            m = s[0],
            n = s[1];
        var I = numeric.identity(m);
        var P = Array(m);
        var i, j, k, l, Ai, Ii, Z, a;
        var abs = Math.abs;
        var diveq = numeric.diveq;
        A = numeric.clone(A);
        for (i = 0; i < m; ++i) {
            k = 0;
            Ai = A[i];
            Ii = I[i];
            for (j = 1; j < n; ++j)
                if (abs(Ai[k]) < abs(Ai[j])) k = j;
            P[i] = k;
            diveq(Ii, Ai[k]);
            diveq(Ai, Ai[k]);
            for (j = 0; j < m; ++j)
                if (j !== i) {
                    Z = A[j];
                    a = Z[k];
                    for (l = n - 1; l !== -1; --l) Z[l] -= Ai[l] * a;
                    Z = I[j];
                    for (l = m - 1; l !== -1; --l) Z[l] -= Ii[l] * a;
                }
        }
        return { I: I, A: A, P: P };
    }

    numeric.__solveLP = function __solveLP(c, A, b, tol, maxit, x, flag) {
        var sum = numeric.sum,
            log = numeric.log,
            mul = numeric.mul,
            sub = numeric.sub,
            dot = numeric.dot,
            div = numeric.div,
            add = numeric.add;
        var m = c.length,
            n = b.length,
            y;
        var unbounded = false,
            cb, i0 = 0;
        var alpha = 1.0;
        var f0, df0, AT = numeric.transpose(A),
            svd = numeric.svd,
            transpose = numeric.transpose,
            leq = numeric.leq,
            sqrt = Math.sqrt,
            abs = Math.abs;
        var muleq = numeric.muleq;
        var norm = numeric.norminf,
            any = numeric.any,
            min = Math.min;
        var all = numeric.all,
            gt = numeric.gt;
        var p = Array(m),
            A0 = Array(n),
            e = numeric.rep([n], 1),
            H;
        var solve = numeric.solve,
            z = sub(b, dot(A, x)),
            count;
        var dotcc = dot(c, c);
        var g;
        for (count = i0; count < maxit; ++count) {
            var i, j, d;
            for (i = n - 1; i !== -1; --i) A0[i] = div(A[i], z[i]);
            var A1 = transpose(A0);
            for (i = m - 1; i !== -1; --i) p[i] = ( /*x[i]+*/ sum(A1[i]));
            alpha = 0.25 * abs(dotcc / dot(c, p));
            var a1 = 100 * sqrt(dotcc / dot(p, p));
            if (!isFinite(alpha) || alpha > a1) alpha = a1;
            g = add(c, mul(alpha, p));
            H = dot(A1, A0);
            for (i = m - 1; i !== -1; --i) H[i][i] += 1;
            d = solve(H, div(g, alpha), true);
            var t0 = div(z, dot(A, d));
            var t = 1.0;
            for (i = n - 1; i !== -1; --i)
                if (t0[i] < 0) t = min(t, -0.999 * t0[i]);
            y = sub(x, mul(d, t));
            z = sub(b, dot(A, y));
            if (!all(gt(z, 0))) return { solution: x, message: "", iterations: count };
            x = y;
            if (alpha < tol) return { solution: y, message: "", iterations: count };
            if (flag) {
                var s = dot(c, g),
                    Ag = dot(A, g);
                unbounded = true;
                for (i = n - 1; i !== -1; --i)
                    if (s * Ag[i] < 0) { unbounded = false; break; }
            } else {
                if (x[m - 1] >= 0) unbounded = false;
                else unbounded = true;
            }
            if (unbounded) return { solution: y, message: "Unbounded", iterations: count };
        }
        return { solution: x, message: "maximum iteration count exceeded", iterations: count };
    }

    numeric._solveLP = function _solveLP(c, A, b, tol, maxit) {
        var m = c.length,
            n = b.length,
            y;
        var sum = numeric.sum,
            log = numeric.log,
            mul = numeric.mul,
            sub = numeric.sub,
            dot = numeric.dot,
            div = numeric.div,
            add = numeric.add;
        var c0 = numeric.rep([m], 0).concat([1]);
        var J = numeric.rep([n, 1], -1);
        var A0 = numeric.blockMatrix([
            [A, J]
        ]);
        var b0 = b;
        var y = numeric.rep([m], 0).concat(Math.max(0, numeric.sup(numeric.neg(b))) + 1);
        var x0 = numeric.__solveLP(c0, A0, b0, tol, maxit, y, false);
        var x = numeric.clone(x0.solution);
        x.length = m;
        var foo = numeric.inf(sub(b, dot(A, x)));
        if (foo < 0) { return { solution: NaN, message: "Infeasible", iterations: x0.iterations }; }
        var ret = numeric.__solveLP(c, A, b, tol, maxit - x0.iterations, x, true);
        ret.iterations += x0.iterations;
        return ret;
    };

    numeric.solveLP = function solveLP(c, A, b, Aeq, beq, tol, maxit) {
        if (typeof maxit === "undefined") maxit = 1000;
        if (typeof tol === "undefined") tol = numeric.epsilon;
        if (typeof Aeq === "undefined") return numeric._solveLP(c, A, b, tol, maxit);
        var m = Aeq.length,
            n = Aeq[0].length,
            o = A.length;
        var B = numeric.echelonize(Aeq);
        var flags = numeric.rep([n], 0);
        var P = B.P;
        var Q = [];
        var i;
        for (i = P.length - 1; i !== -1; --i) flags[P[i]] = 1;
        for (i = n - 1; i !== -1; --i)
            if (flags[i] === 0) Q.push(i);
        var g = numeric.getRange;
        var I = numeric.linspace(0, m - 1),
            J = numeric.linspace(0, o - 1);
        var Aeq2 = g(Aeq, I, Q),
            A1 = g(A, J, P),
            A2 = g(A, J, Q),
            dot = numeric.dot,
            sub = numeric.sub;
        var A3 = dot(A1, B.I);
        var A4 = sub(A2, dot(A3, Aeq2)),
            b4 = sub(b, dot(A3, beq));
        var c1 = Array(P.length),
            c2 = Array(Q.length);
        for (i = P.length - 1; i !== -1; --i) c1[i] = c[P[i]];
        for (i = Q.length - 1; i !== -1; --i) c2[i] = c[Q[i]];
        var c4 = sub(c2, dot(c1, dot(B.I, Aeq2)));
        var S = numeric._solveLP(c4, A4, b4, tol, maxit);
        var x2 = S.solution;
        if (x2 !== x2) return S;
        var x1 = dot(B.I, sub(beq, dot(Aeq2, x2)));
        var x = Array(c.length);
        for (i = P.length - 1; i !== -1; --i) x[P[i]] = x1[i];
        for (i = Q.length - 1; i !== -1; --i) x[Q[i]] = x2[i];
        return { solution: x, message: S.message, iterations: S.iterations };
    }

    numeric.MPStoLP = function MPStoLP(MPS) {
            if (MPS instanceof String) { MPS.split('\n'); }
            var state = 0;
            var states = ['Initial state', 'NAME', 'ROWS', 'COLUMNS', 'RHS', 'BOUNDS', 'ENDATA'];
            var n = MPS.length;
            var i, j, z, N = 0,
                rows = {},
                sign = [],
                rl = 0,
                vars = {},
                nv = 0;
            var name;
            var c = [],
                A = [],
                b = [];

            function err(e) { throw new Error('MPStoLP: ' + e + '\nLine ' + i + ': ' + MPS[i] + '\nCurrent state: ' + states[state] + '\n'); }
            for (i = 0; i < n; ++i) {
                z = MPS[i];
                var w0 = z.match(/\S*/g);
                var w = [];
                for (j = 0; j < w0.length; ++j)
                    if (w0[j] !== "") w.push(w0[j]);
                if (w.length === 0) continue;
                for (j = 0; j < states.length; ++j)
                    if (z.substr(0, states[j].length) === states[j]) break;
                if (j < states.length) {
                    state = j;
                    if (j === 1) { name = w[1]; }
                    if (j === 6) return { name: name, c: c, A: numeric.transpose(A), b: b, rows: rows, vars: vars };
                    continue;
                }
                switch (state) {
                    case 0:
                    case 1:
                        err('Unexpected line');
                    case 2:
                        switch (w[0]) {
                            case 'N':
                                if (N === 0) N = w[1];
                                else err('Two or more N rows');
                                break;
                            case 'L':
                                rows[w[1]] = rl;
                                sign[rl] = 1;
                                b[rl] = 0;
                                ++rl;
                                break;
                            case 'G':
                                rows[w[1]] = rl;
                                sign[rl] = -1;
                                b[rl] = 0;
                                ++rl;
                                break;
                            case 'E':
                                rows[w[1]] = rl;
                                sign[rl] = 0;
                                b[rl] = 0;
                                ++rl;
                                break;
                            default:
                                err('Parse error ' + numeric.prettyPrint(w));
                        }
                        break;
                    case 3:
                        if (!vars.hasOwnProperty(w[0])) {
                            vars[w[0]] = nv;
                            c[nv] = 0;
                            A[nv] = numeric.rep([rl], 0);
                            ++nv;
                        }
                        var p = vars[w[0]];
                        for (j = 1; j < w.length; j += 2) {
                            if (w[j] === N) { c[p] = parseFloat(w[j + 1]); continue; }
                            var q = rows[w[j]];
                            A[p][q] = (sign[q] < 0 ? -1 : 1) * parseFloat(w[j + 1]);
                        }
                        break;
                    case 4:
                        for (j = 1; j < w.length; j += 2) b[rows[w[j]]] = (sign[rows[w[j]]] < 0 ? -1 : 1) * parseFloat(w[j + 1]);
                        break;
                    case 5:
                        /*FIXME*/
                        break;
                    case 6:
                        err('Internal error');
                }
            }
            err('Reached end of file without ENDATA');
        }
        // seedrandom.js version 2.0.
        // Author: David Bau 4/2/2011
        //
        // Defines a method Math.seedrandom() that, when called, substitutes
        // an explicitly seeded RC4-based algorithm for Math.random().  Also
        // supports automatic seeding from local or network sources of entropy.
        //
        // Usage:
        //
        //   <script src=http://davidbau.com/encode/seedrandom-min.js></script>
        //
        //   Math.seedrandom('yipee'); Sets Math.random to a function that is
        //                             initialized using the given explicit seed.
        //
        //   Math.seedrandom();        Sets Math.random to a function that is
        //                             seeded using the current time, dom state,
        //                             and other accumulated local entropy.
        //                             The generated seed string is returned.
        //
        //   Math.seedrandom('yowza', true);
        //                             Seeds using the given explicit seed mixed
        //                             together with accumulated entropy.
        //
        //   <script src="http://bit.ly/srandom-512"></script>
        //                             Seeds using physical random bits downloaded
        //                             from random.org.
        //
        //   <script src="https://jsonlib.appspot.com/urandom?callback=Math.seedrandom">
        //   </script>                 Seeds using urandom bits from call.jsonlib.com,
        //                             which is faster than random.org.
        //
        // Examples:
        //
        //   Math.seedrandom("hello");            // Use "hello" as the seed.
        //   document.write(Math.random());       // Always 0.5463663768140734
        //   document.write(Math.random());       // Always 0.43973793770592234
        //   var rng1 = Math.random;              // Remember the current prng.
        //
        //   var autoseed = Math.seedrandom();    // New prng with an automatic seed.
        //   document.write(Math.random());       // Pretty much unpredictable.
        //
        //   Math.random = rng1;                  // Continue "hello" prng sequence.
        //   document.write(Math.random());       // Always 0.554769432473455
        //
        //   Math.seedrandom(autoseed);           // Restart at the previous seed.
        //   document.write(Math.random());       // Repeat the 'unpredictable' value.
        //
        // Notes:
        //
        // Each time seedrandom('arg') is called, entropy from the passed seed
        // is accumulated in a pool to help generate future seeds for the
        // zero-argument form of Math.seedrandom, so entropy can be injected over
        // time by calling seedrandom with explicit data repeatedly.
        //
        // On speed - This javascript implementation of Math.random() is about
        // 3-10x slower than the built-in Math.random() because it is not native
        // code, but this is typically fast enough anyway.  Seeding is more expensive,
        // especially if you use auto-seeding.  Some details (timings on Chrome 4):
        //
        // Our Math.random()            - avg less than 0.002 milliseconds per call
        // seedrandom('explicit')       - avg less than 0.5 milliseconds per call
        // seedrandom('explicit', true) - avg less than 2 milliseconds per call
        // seedrandom()                 - avg about 38 milliseconds per call
        //
        // LICENSE (BSD):
        //
        // Copyright 2010 David Bau, all rights reserved.
        //
        // Redistribution and use in source and binary forms, with or without
        // modification, are permitted provided that the following conditions are met:
        //
        //   1. Redistributions of source code must retain the above copyright
        //      notice, this list of conditions and the following disclaimer.
        //
        //   2. Redistributions in binary form must reproduce the above copyright
        //      notice, this list of conditions and the following disclaimer in the
        //      documentation and/or other materials provided with the distribution.
        //
        //   3. Neither the name of this module nor the names of its contributors may
        //      be used to endorse or promote products derived from this software
        //      without specific prior written permission.
        //
        // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
        // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
        // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
        // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
        // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
        // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
        // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
        // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
        // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
        // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        //
        /**
         * All code is in an anonymous closure to keep the global namespace clean.
         *
         * @param {number=} overflow
         * @param {number=} startdenom
         */

    // Patched by Seb so that seedrandom.js does not pollute the Math object.
    // My tests suggest that doing Math.trouble = 1 makes Math lookups about 5%
    // slower.
    numeric.seedrandom = { pow: Math.pow, random: Math.random };

    (function(pool, math, width, chunks, significance, overflow, startdenom) {


        //
        // seedrandom()
        // This is the seedrandom function described above.
        //
        math['seedrandom'] = function seedrandom(seed, use_entropy) {
            var key = [];
            var arc4;

            // Flatten the seed string or build one from local entropy if needed.
            seed = mixkey(flatten(
                use_entropy ? [seed, pool] :
                arguments.length ? seed : [new Date().getTime(), pool, window], 3), key);

            // Use the seed to initialize an ARC4 generator.
            arc4 = new ARC4(key);

            // Mix the randomness into accumulated entropy.
            mixkey(arc4.S, pool);

            // Override Math.random

            // This function returns a random double in [0, 1) that contains
            // randomness in every bit of the mantissa of the IEEE 754 value.

            math['random'] = function random() { // Closure to return a random double:
                var n = arc4.g(chunks); // Start with a numerator n < 2 ^ 48
                var d = startdenom; //   and denominator d = 2 ^ 48.
                var x = 0; //   and no 'extra last byte'.
                while (n < significance) { // Fill up all significant digits by
                    n = (n + x) * width; //   shifting numerator and
                    d *= width; //   denominator and generating a
                    x = arc4.g(1); //   new least-significant-byte.
                }
                while (n >= overflow) { // To avoid rounding up, before adding
                    n /= 2; //   last byte, shift everything
                    d /= 2; //   right using integer math until
                    x >>>= 1; //   we have exactly the desired bits.
                }
                return (n + x) / d; // Form the number within [0, 1).
            };

            // Return the seed that was used
            return seed;
        };

        //
        // ARC4
        //
        // An ARC4 implementation.  The constructor takes a key in the form of
        // an array of at most (width) integers that should be 0 <= x < (width).
        //
        // The g(count) method returns a pseudorandom integer that concatenates
        // the next (count) outputs from ARC4.  Its return value is a number x
        // that is in the range 0 <= x < (width ^ count).
        //
        /** @constructor */
        function ARC4(key) {
            var t, u, me = this,
                keylen = key.length;
            var i = 0,
                j = me.i = me.j = me.m = 0;
            me.S = [];
            me.c = [];

            // The empty key [] is treated as [0].
            if (!keylen) { key = [keylen++]; }

            // Set up S using the standard key scheduling algorithm.
            while (i < width) { me.S[i] = i++; }
            for (i = 0; i < width; i++) {
                t = me.S[i];
                j = lowbits(j + t + key[i % keylen]);
                u = me.S[j];
                me.S[i] = u;
                me.S[j] = t;
            }

            // The "g" method returns the next (count) outputs as one number.
            me.g = function getnext(count) {
                var s = me.S;
                var i = lowbits(me.i + 1);
                var t = s[i];
                var j = lowbits(me.j + t);
                var u = s[j];
                s[i] = u;
                s[j] = t;
                var r = s[lowbits(t + u)];
                while (--count) {
                    i = lowbits(i + 1);
                    t = s[i];
                    j = lowbits(j + t);
                    u = s[j];
                    s[i] = u;
                    s[j] = t;
                    r = r * width + s[lowbits(t + u)];
                }
                me.i = i;
                me.j = j;
                return r;
            };
            // For robust unpredictability discard an initial batch of values.
            // See http://www.rsa.com/rsalabs/node.asp?id=2009
            me.g(width);
        }

        //
        // flatten()
        // Converts an object tree to nested arrays of strings.
        //
        /** @param {Object=} result
         * @param {string=} prop
         * @param {string=} typ */
        function flatten(obj, depth, result, prop, typ) {
            result = [];
            typ = typeof(obj);
            if (depth && typ == 'object') {
                for (prop in obj) {
                    if (prop.indexOf('S') < 5) { // Avoid FF3 bug (local/sessionStorage)
                        try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
                    }
                }
            }
            return (result.length ? result : obj + (typ != 'string' ? '\0' : ''));
        }

        //
        // mixkey()
        // Mixes a string seed into a key that is an array of integers, and
        // returns a shortened string seed that is equivalent to the result key.
        //
        /** @param {number=} smear
         * @param {number=} j */
        function mixkey(seed, key, smear, j) {
            seed += ''; // Ensure the seed is a string
            smear = 0;
            for (j = 0; j < seed.length; j++) {
                key[lowbits(j)] =
                    lowbits((smear ^= key[lowbits(j)] * 19) + seed.charCodeAt(j));
            }
            seed = '';
            for (j in key) { seed += String.fromCharCode(key[j]); }
            return seed;
        }

        //
        // lowbits()
        // A quick "n mod width" for width a power of 2.
        //
        function lowbits(n) { return n & (width - 1); }

        //
        // The following constants are related to IEEE 754 limits.
        //
        startdenom = math.pow(width, chunks);
        significance = math.pow(2, significance);
        overflow = significance * 2;

        //
        // When seedrandom.js is loaded, we immediately mix a few bits
        // from the built-in RNG into the entropy pool.  Because we do
        // not want to intefere with determinstic PRNG state later,
        // seedrandom will not call math.random on its own again after
        // initialization.
        //
        mixkey(math.random(), pool);

        // End anonymous scope, and pass initial values.
    }(
        [], // pool: entropy pool starts empty
        numeric.seedrandom, // math: package containing random, pow, and seedrandom
        256, // width: each RC4 output is 0 <= x < 256
        6, // chunks: at least six RC4 outputs for each double
        52 // significance: there are 52 significant digits in a double
    ));
    /* This file is a slightly modified version of quadprog.js from Alberto Santini.
     * It has been slightly modified by SÃ©bastien Loisel to make sure that it handles
     * 0-based Arrays instead of 1-based Arrays.
     * License is in resources/LICENSE.quadprog */
    (function(exports) {

        function base0to1(A) {
            if (typeof A !== "object") { return A; }
            var ret = [],
                i, n = A.length;
            for (i = 0; i < n; i++) ret[i + 1] = base0to1(A[i]);
            return ret;
        }

        function base1to0(A) {
            if (typeof A !== "object") { return A; }
            var ret = [],
                i, n = A.length;
            for (i = 1; i < n; i++) ret[i - 1] = base1to0(A[i]);
            return ret;
        }

        function dpori(a, lda, n) {
            var i, j, k, kp1, t;

            for (k = 1; k <= n; k = k + 1) {
                a[k][k] = 1 / a[k][k];
                t = -a[k][k];
                //~ dscal(k - 1, t, a[1][k], 1);
                for (i = 1; i < k; i = i + 1) {
                    a[i][k] = t * a[i][k];
                }

                kp1 = k + 1;
                if (n < kp1) {
                    break;
                }
                for (j = kp1; j <= n; j = j + 1) {
                    t = a[k][j];
                    a[k][j] = 0;
                    //~ daxpy(k, t, a[1][k], 1, a[1][j], 1);
                    for (i = 1; i <= k; i = i + 1) {
                        a[i][j] = a[i][j] + (t * a[i][k]);
                    }
                }
            }

        }

        function dposl(a, lda, n, b) {
            var i, k, kb, t;

            for (k = 1; k <= n; k = k + 1) {
                //~ t = ddot(k - 1, a[1][k], 1, b[1], 1);
                t = 0;
                for (i = 1; i < k; i = i + 1) {
                    t = t + (a[i][k] * b[i]);
                }

                b[k] = (b[k] - t) / a[k][k];
            }

            for (kb = 1; kb <= n; kb = kb + 1) {
                k = n + 1 - kb;
                b[k] = b[k] / a[k][k];
                t = -b[k];
                //~ daxpy(k - 1, t, a[1][k], 1, b[1], 1);
                for (i = 1; i < k; i = i + 1) {
                    b[i] = b[i] + (t * a[i][k]);
                }
            }
        }

        function dpofa(a, lda, n, info) {
            var i, j, jm1, k, t, s;

            for (j = 1; j <= n; j = j + 1) {
                info[1] = j;
                s = 0;
                jm1 = j - 1;
                if (jm1 < 1) {
                    s = a[j][j] - s;
                    if (s <= 0) {
                        break;
                    }
                    a[j][j] = Math.sqrt(s);
                } else {
                    for (k = 1; k <= jm1; k = k + 1) {
                        //~ t = a[k][j] - ddot(k - 1, a[1][k], 1, a[1][j], 1);
                        t = a[k][j];
                        for (i = 1; i < k; i = i + 1) {
                            t = t - (a[i][j] * a[i][k]);
                        }
                        t = t / a[k][k];
                        a[k][j] = t;
                        s = s + t * t;
                    }
                    s = a[j][j] - s;
                    if (s <= 0) {
                        break;
                    }
                    a[j][j] = Math.sqrt(s);
                }
                info[1] = 0;
            }
        }

        function qpgen2(dmat, dvec, fddmat, n, sol, crval, amat,
            bvec, fdamat, q, meq, iact, nact, iter, work, ierr) {

            var i, j, l, l1, info, it1, iwzv, iwrv, iwrm, iwsv, iwuv, nvl, r, iwnbv,
                temp, sum, t1, tt, gc, gs, nu,
                t1inf, t2min,
                vsmall, tmpa, tmpb,
                go;

            r = Math.min(n, q);
            l = 2 * n + (r * (r + 5)) / 2 + 2 * q + 1;

            vsmall = 1.0e-60;
            do {
                vsmall = vsmall + vsmall;
                tmpa = 1 + 0.1 * vsmall;
                tmpb = 1 + 0.2 * vsmall;
            } while (tmpa <= 1 || tmpb <= 1);

            for (i = 1; i <= n; i = i + 1) {
                work[i] = dvec[i];
            }
            for (i = n + 1; i <= l; i = i + 1) {
                work[i] = 0;
            }
            for (i = 1; i <= q; i = i + 1) {
                iact[i] = 0;
            }

            info = [];

            if (ierr[1] === 0) {
                dpofa(dmat, fddmat, n, info);
                if (info[1] !== 0) {
                    ierr[1] = 2;
                    return;
                }
                dposl(dmat, fddmat, n, dvec);
                dpori(dmat, fddmat, n);
            } else {
                for (j = 1; j <= n; j = j + 1) {
                    sol[j] = 0;
                    for (i = 1; i <= j; i = i + 1) {
                        sol[j] = sol[j] + dmat[i][j] * dvec[i];
                    }
                }
                for (j = 1; j <= n; j = j + 1) {
                    dvec[j] = 0;
                    for (i = j; i <= n; i = i + 1) {
                        dvec[j] = dvec[j] + dmat[j][i] * sol[i];
                    }
                }
            }

            crval[1] = 0;
            for (j = 1; j <= n; j = j + 1) {
                sol[j] = dvec[j];
                crval[1] = crval[1] + work[j] * sol[j];
                work[j] = 0;
                for (i = j + 1; i <= n; i = i + 1) {
                    dmat[i][j] = 0;
                }
            }
            crval[1] = -crval[1] / 2;
            ierr[1] = 0;

            iwzv = n;
            iwrv = iwzv + n;
            iwuv = iwrv + r;
            iwrm = iwuv + r + 1;
            iwsv = iwrm + (r * (r + 1)) / 2;
            iwnbv = iwsv + q;

            for (i = 1; i <= q; i = i + 1) {
                sum = 0;
                for (j = 1; j <= n; j = j + 1) {
                    sum = sum + amat[j][i] * amat[j][i];
                }
                work[iwnbv + i] = Math.sqrt(sum);
            }
            nact = 0;
            iter[1] = 0;
            iter[2] = 0;

            function fn_goto_50() {
                iter[1] = iter[1] + 1;

                l = iwsv;
                for (i = 1; i <= q; i = i + 1) {
                    l = l + 1;
                    sum = -bvec[i];
                    for (j = 1; j <= n; j = j + 1) {
                        sum = sum + amat[j][i] * sol[j];
                    }
                    if (Math.abs(sum) < vsmall) {
                        sum = 0;
                    }
                    if (i > meq) {
                        work[l] = sum;
                    } else {
                        work[l] = -Math.abs(sum);
                        if (sum > 0) {
                            for (j = 1; j <= n; j = j + 1) {
                                amat[j][i] = -amat[j][i];
                            }
                            bvec[i] = -bvec[i];
                        }
                    }
                }

                for (i = 1; i <= nact; i = i + 1) {
                    work[iwsv + iact[i]] = 0;
                }

                nvl = 0;
                temp = 0;
                for (i = 1; i <= q; i = i + 1) {
                    if (work[iwsv + i] < temp * work[iwnbv + i]) {
                        nvl = i;
                        temp = work[iwsv + i] / work[iwnbv + i];
                    }
                }
                if (nvl === 0) {
                    return 999;
                }

                return 0;
            }

            function fn_goto_55() {
                for (i = 1; i <= n; i = i + 1) {
                    sum = 0;
                    for (j = 1; j <= n; j = j + 1) {
                        sum = sum + dmat[j][i] * amat[j][nvl];
                    }
                    work[i] = sum;
                }

                l1 = iwzv;
                for (i = 1; i <= n; i = i + 1) {
                    work[l1 + i] = 0;
                }
                for (j = nact + 1; j <= n; j = j + 1) {
                    for (i = 1; i <= n; i = i + 1) {
                        work[l1 + i] = work[l1 + i] + dmat[i][j] * work[j];
                    }
                }

                t1inf = true;
                for (i = nact; i >= 1; i = i - 1) {
                    sum = work[i];
                    l = iwrm + (i * (i + 3)) / 2;
                    l1 = l - i;
                    for (j = i + 1; j <= nact; j = j + 1) {
                        sum = sum - work[l] * work[iwrv + j];
                        l = l + j;
                    }
                    sum = sum / work[l1];
                    work[iwrv + i] = sum;
                    if (iact[i] < meq) {
                        // continue;
                        break;
                    }
                    if (sum < 0) {
                        // continue;
                        break;
                    }
                    t1inf = false;
                    it1 = i;
                }

                if (!t1inf) {
                    t1 = work[iwuv + it1] / work[iwrv + it1];
                    for (i = 1; i <= nact; i = i + 1) {
                        if (iact[i] < meq) {
                            // continue;
                            break;
                        }
                        if (work[iwrv + i] < 0) {
                            // continue;
                            break;
                        }
                        temp = work[iwuv + i] / work[iwrv + i];
                        if (temp < t1) {
                            t1 = temp;
                            it1 = i;
                        }
                    }
                }

                sum = 0;
                for (i = iwzv + 1; i <= iwzv + n; i = i + 1) {
                    sum = sum + work[i] * work[i];
                }
                if (Math.abs(sum) <= vsmall) {
                    if (t1inf) {
                        ierr[1] = 1;
                        // GOTO 999
                        return 999;
                    } else {
                        for (i = 1; i <= nact; i = i + 1) {
                            work[iwuv + i] = work[iwuv + i] - t1 * work[iwrv + i];
                        }
                        work[iwuv + nact + 1] = work[iwuv + nact + 1] + t1;
                        // GOTO 700
                        return 700;
                    }
                } else {
                    sum = 0;
                    for (i = 1; i <= n; i = i + 1) {
                        sum = sum + work[iwzv + i] * amat[i][nvl];
                    }
                    tt = -work[iwsv + nvl] / sum;
                    t2min = true;
                    if (!t1inf) {
                        if (t1 < tt) {
                            tt = t1;
                            t2min = false;
                        }
                    }

                    for (i = 1; i <= n; i = i + 1) {
                        sol[i] = sol[i] + tt * work[iwzv + i];
                        if (Math.abs(sol[i]) < vsmall) {
                            sol[i] = 0;
                        }
                    }

                    crval[1] = crval[1] + tt * sum * (tt / 2 + work[iwuv + nact + 1]);
                    for (i = 1; i <= nact; i = i + 1) {
                        work[iwuv + i] = work[iwuv + i] - tt * work[iwrv + i];
                    }
                    work[iwuv + nact + 1] = work[iwuv + nact + 1] + tt;

                    if (t2min) {
                        nact = nact + 1;
                        iact[nact] = nvl;

                        l = iwrm + ((nact - 1) * nact) / 2 + 1;
                        for (i = 1; i <= nact - 1; i = i + 1) {
                            work[l] = work[i];
                            l = l + 1;
                        }

                        if (nact === n) {
                            work[l] = work[n];
                        } else {
                            for (i = n; i >= nact + 1; i = i - 1) {
                                if (work[i] === 0) {
                                    // continue;
                                    break;
                                }
                                gc = Math.max(Math.abs(work[i - 1]), Math.abs(work[i]));
                                gs = Math.min(Math.abs(work[i - 1]), Math.abs(work[i]));
                                if (work[i - 1] >= 0) {
                                    temp = Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));
                                } else {
                                    temp = -Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));
                                }
                                gc = work[i - 1] / temp;
                                gs = work[i] / temp;

                                if (gc === 1) {
                                    // continue;
                                    break;
                                }
                                if (gc === 0) {
                                    work[i - 1] = gs * temp;
                                    for (j = 1; j <= n; j = j + 1) {
                                        temp = dmat[j][i - 1];
                                        dmat[j][i - 1] = dmat[j][i];
                                        dmat[j][i] = temp;
                                    }
                                } else {
                                    work[i - 1] = temp;
                                    nu = gs / (1 + gc);
                                    for (j = 1; j <= n; j = j + 1) {
                                        temp = gc * dmat[j][i - 1] + gs * dmat[j][i];
                                        dmat[j][i] = nu * (dmat[j][i - 1] + temp) - dmat[j][i];
                                        dmat[j][i - 1] = temp;

                                    }
                                }
                            }
                            work[l] = work[nact];
                        }
                    } else {
                        sum = -bvec[nvl];
                        for (j = 1; j <= n; j = j + 1) {
                            sum = sum + sol[j] * amat[j][nvl];
                        }
                        if (nvl > meq) {
                            work[iwsv + nvl] = sum;
                        } else {
                            work[iwsv + nvl] = -Math.abs(sum);
                            if (sum > 0) {
                                for (j = 1; j <= n; j = j + 1) {
                                    amat[j][nvl] = -amat[j][nvl];
                                }
                                bvec[nvl] = -bvec[nvl];
                            }
                        }
                        // GOTO 700
                        return 700;
                    }
                }

                return 0;
            }

            function fn_goto_797() {
                l = iwrm + (it1 * (it1 + 1)) / 2 + 1;
                l1 = l + it1;
                if (work[l1] === 0) {
                    // GOTO 798
                    return 798;
                }
                gc = Math.max(Math.abs(work[l1 - 1]), Math.abs(work[l1]));
                gs = Math.min(Math.abs(work[l1 - 1]), Math.abs(work[l1]));
                if (work[l1 - 1] >= 0) {
                    temp = Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));
                } else {
                    temp = -Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));
                }
                gc = work[l1 - 1] / temp;
                gs = work[l1] / temp;

                if (gc === 1) {
                    // GOTO 798
                    return 798;
                }
                if (gc === 0) {
                    for (i = it1 + 1; i <= nact; i = i + 1) {
                        temp = work[l1 - 1];
                        work[l1 - 1] = work[l1];
                        work[l1] = temp;
                        l1 = l1 + i;
                    }
                    for (i = 1; i <= n; i = i + 1) {
                        temp = dmat[i][it1];
                        dmat[i][it1] = dmat[i][it1 + 1];
                        dmat[i][it1 + 1] = temp;
                    }
                } else {
                    nu = gs / (1 + gc);
                    for (i = it1 + 1; i <= nact; i = i + 1) {
                        temp = gc * work[l1 - 1] + gs * work[l1];
                        work[l1] = nu * (work[l1 - 1] + temp) - work[l1];
                        work[l1 - 1] = temp;
                        l1 = l1 + i;
                    }
                    for (i = 1; i <= n; i = i + 1) {
                        temp = gc * dmat[i][it1] + gs * dmat[i][it1 + 1];
                        dmat[i][it1 + 1] = nu * (dmat[i][it1] + temp) - dmat[i][it1 + 1];
                        dmat[i][it1] = temp;
                    }
                }

                return 0;
            }

            function fn_goto_798() {
                l1 = l - it1;
                for (i = 1; i <= it1; i = i + 1) {
                    work[l1] = work[l];
                    l = l + 1;
                    l1 = l1 + 1;
                }

                work[iwuv + it1] = work[iwuv + it1 + 1];
                iact[it1] = iact[it1 + 1];
                it1 = it1 + 1;
                if (it1 < nact) {
                    // GOTO 797
                    return 797;
                }

                return 0;
            }

            function fn_goto_799() {
                work[iwuv + nact] = work[iwuv + nact + 1];
                work[iwuv + nact + 1] = 0;
                iact[nact] = 0;
                nact = nact - 1;
                iter[2] = iter[2] + 1;

                return 0;
            }

            go = 0;
            while (true) {
                go = fn_goto_50();
                if (go === 999) {
                    return;
                }
                while (true) {
                    go = fn_goto_55();
                    if (go === 0) {
                        break;
                    }
                    if (go === 999) {
                        return;
                    }
                    if (go === 700) {
                        if (it1 === nact) {
                            fn_goto_799();
                        } else {
                            while (true) {
                                fn_goto_797();
                                go = fn_goto_798();
                                if (go !== 797) {
                                    break;
                                }
                            }
                            fn_goto_799();
                        }
                    }
                }
            }

        }

        function solveQP(Dmat, dvec, Amat, bvec, meq, factorized) {
            Dmat = base0to1(Dmat);
            dvec = base0to1(dvec);
            Amat = base0to1(Amat);
            var i, n, q,
                nact, r,
                crval = [],
                iact = [],
                sol = [],
                work = [],
                iter = [],
                message;

            meq = meq || 0;
            factorized = factorized ? base0to1(factorized) : [undefined, 0];
            bvec = bvec ? base0to1(bvec) : [];

            // In Fortran the array index starts from 1
            n = Dmat.length - 1;
            q = Amat[1].length - 1;

            if (!bvec) {
                for (i = 1; i <= q; i = i + 1) {
                    bvec[i] = 0;
                }
            }
            for (i = 1; i <= q; i = i + 1) {
                iact[i] = 0;
            }
            nact = 0;
            r = Math.min(n, q);
            for (i = 1; i <= n; i = i + 1) {
                sol[i] = 0;
            }
            crval[1] = 0;
            for (i = 1; i <= (2 * n + (r * (r + 5)) / 2 + 2 * q + 1); i = i + 1) {
                work[i] = 0;
            }
            for (i = 1; i <= 2; i = i + 1) {
                iter[i] = 0;
            }

            qpgen2(Dmat, dvec, n, n, sol, crval, Amat,
                bvec, n, q, meq, iact, nact, iter, work, factorized);

            message = "";
            if (factorized[1] === 1) {
                message = "constraints are inconsistent, no solution!";
            }
            if (factorized[1] === 2) {
                message = "matrix D in quadratic function is not positive definite!";
            }

            return {
                solution: base1to0(sol),
                value: base1to0(crval),
                unconstrained_solution: base1to0(dvec),
                iterations: base1to0(iter),
                iact: base1to0(iact),
                message: message
            };
        }
        exports.solveQP = solveQP;
    }(numeric));
    /*
    Shanti Rao sent me this routine by private email. I had to modify it
    slightly to work on Arrays instead of using a Matrix object.
    It is apparently translated from http://stitchpanorama.sourceforge.net/Python/svd.py
    */

    numeric.svd = function svd(A) {
        var temp;
        //Compute the thin SVD from G. H. Golub and C. Reinsch, Numer. Math. 14, 403-420 (1970)
        var prec = numeric.epsilon; //Math.pow(2,-52) // assumes double prec
        var tolerance = 1.e-64/prec;
        var itmax = 50;
        var c = 0;
        var i = 0;
        var j = 0;
        var k = 0;
        var l = 0;

        var u = numeric.clone(A);
        var m = u.length;

        var n = u[0].length;

        if (m < n) throw "Need more rows than columns"

        var e = new Array(n);
        var q = new Array(n);
        for (i = 0; i < n; i++) e[i] = q[i] = 0.0;
        var v = numeric.rep([n, n], 0);
        //  v.zero();

        function pythag(a, b) {
            a = Math.abs(a)
            b = Math.abs(b)
            if (a > b)
                return a * Math.sqrt(1.0 + (b * b / a / a))
            else if (b == 0.0)
                return a
            return b * Math.sqrt(1.0 + (a * a / b / b))
        }

        //Householder's reduction to bidiagonal form

        var f = 0.0;
        var g = 0.0;
        var h = 0.0;
        var x = 0.0;
        var y = 0.0;
        var z = 0.0;
        var s = 0.0;

        for (i = 0; i < n; i++) {
            e[i] = g;
            s = 0.0;
            l = i + 1;
            for (j = i; j < m; j++)
                s += (u[j][i] * u[j][i]);
            if (s <= tolerance)
                g = 0.0;
            else {
                f = u[i][i];
                g = Math.sqrt(s);
                if (f >= 0.0) g = -g;
                h = f * g - s
                u[i][i] = f - g;
                for (j = l; j < n; j++) {
                    s = 0.0
                    for (k = i; k < m; k++)
                        s += u[k][i] * u[k][j]
                    f = s / h
                    for (k = i; k < m; k++)
                        u[k][j] += f * u[k][i]
                }
            }
            q[i] = g
            s = 0.0
            for (j = l; j < n; j++)
                s = s + u[i][j] * u[i][j]
            if (s <= tolerance)
                g = 0.0
            else {
                f = u[i][i + 1]
                g = Math.sqrt(s)
                if (f >= 0.0) g = -g
                h = f * g - s
                u[i][i + 1] = f - g;
                for (j = l; j < n; j++) e[j] = u[i][j] / h
                for (j = l; j < m; j++) {
                    s = 0.0
                    for (k = l; k < n; k++)
                        s += (u[j][k] * u[i][k])
                    for (k = l; k < n; k++)
                        u[j][k] += s * e[k]
                }
            }
            y = Math.abs(q[i]) + Math.abs(e[i])
            if (y > x)
                x = y
        }

        // accumulation of right hand gtransformations
        for (i = n - 1; i != -1; i += -1) {
            if (g != 0.0) {
                h = g * u[i][i + 1]
                for (j = l; j < n; j++)
                    v[j][i] = u[i][j] / h
                for (j = l; j < n; j++) {
                    s = 0.0
                    for (k = l; k < n; k++)
                        s += u[i][k] * v[k][j]
                    for (k = l; k < n; k++)
                        v[k][j] += (s * v[k][i])
                }
            }
            for (j = l; j < n; j++) {
                v[i][j] = 0;
                v[j][i] = 0;
            }
            v[i][i] = 1;
            g = e[i]
            l = i
        }

        // accumulation of left hand transformations
        for (i = n - 1; i != -1; i += -1) {
            l = i + 1
            g = q[i]
            for (j = l; j < n; j++)
                u[i][j] = 0;
            if (g != 0.0) {
                h = u[i][i] * g
                for (j = l; j < n; j++) {
                    s = 0.0
                    for (k = l; k < m; k++) s += u[k][i] * u[k][j];
                    f = s / h
                    for (k = i; k < m; k++) u[k][j] += f * u[k][i];
                }
                for (j = i; j < m; j++) u[j][i] = u[j][i] / g;
            } else
                for (j = i; j < m; j++) u[j][i] = 0;
            u[i][i] += 1;
        }

        // diagonalization of the bidiagonal form
        prec = prec * x
        for (k = n - 1; k != -1; k += -1) {
            for (var iteration = 0; iteration < itmax; iteration++) { // test f splitting
                var test_convergence = false
                for (l = k; l != -1; l += -1) {
                    if (Math.abs(e[l]) <= prec) {
                        test_convergence = true
                        break
                    }
                    if (Math.abs(q[l - 1]) <= prec)
                        break
                }
                if (!test_convergence) { // cancellation of e[l] if l>0
                    c = 0.0
                    s = 1.0
                    var l1 = l - 1
                    for (i = l; i < k + 1; i++) {
                        f = s * e[i]
                        e[i] = c * e[i]
                        if (Math.abs(f) <= prec)
                            break
                        g = q[i]
                        h = pythag(f, g)
                        q[i] = h
                        c = g / h
                        s = -f / h
                        for (j = 0; j < m; j++) {
                            y = u[j][l1]
                            z = u[j][i]
                            u[j][l1] = y * c + (z * s)
                            u[j][i] = -y * s + (z * c)
                        }
                    }
                }
                // test f convergence
                z = q[k]
                if (l == k) { //convergence
                    if (z < 0.0) { //q[k] is made non-negative
                        q[k] = -z
                        for (j = 0; j < n; j++)
                            v[j][k] = -v[j][k]
                    }
                    break //break out of iteration loop and move on to next k value
                }
                if (iteration >= itmax - 1)
                    throw 'Error: no convergence.'
                        // shift from bottom 2x2 minor
                x = q[l]
                y = q[k - 1]
                g = e[k - 1]
                h = e[k]
                f = ((y - z) * (y + z) + (g - h) * (g + h)) / (2.0 * h * y)
                g = pythag(f, 1.0)
                if (f < 0.0)
                    f = ((x - z) * (x + z) + h * (y / (f - g) - h)) / x
                else
                    f = ((x - z) * (x + z) + h * (y / (f + g) - h)) / x
                    // next QR transformation
                c = 1.0
                s = 1.0
                for (i = l + 1; i < k + 1; i++) {
                    g = e[i]
                    y = q[i]
                    h = s * g
                    g = c * g
                    z = pythag(f, h)
                    e[i - 1] = z
                    c = f / z
                    s = h / z
                    f = x * c + g * s
                    g = -x * s + g * c
                    h = y * s
                    y = y * c
                    for (j = 0; j < n; j++) {
                        x = v[j][i - 1]
                        z = v[j][i]
                        v[j][i - 1] = x * c + z * s
                        v[j][i] = -x * s + z * c
                    }
                    z = pythag(f, h)
                    q[i - 1] = z
                    c = f / z
                    s = h / z
                    f = c * g + s * y
                    x = -s * g + c * y
                    for (j = 0; j < m; j++) {
                        y = u[j][i - 1]
                        z = u[j][i]
                        u[j][i - 1] = y * c + z * s
                        u[j][i] = -y * s + z * c
                    }
                }
                e[l] = 0.0
                e[k] = f
                q[k] = x
            }
        }

        //vt= transpose(v)
        //return (u,q,vt)
        for (i = 0; i < q.length; i++)
            if (q[i] < prec) q[i] = 0

            //sort eigenvalues
        for (i = 0; i < n; i++) {
            //writeln(q)
            for (j = i - 1; j >= 0; j--) {
                if (q[j] < q[i]) {
                    //  writeln(i,'-',j)
                    c = q[j]
                    q[j] = q[i]
                    q[i] = c
                    for (k = 0; k < u.length; k++) {
                        temp = u[k][i];
                        u[k][i] = u[k][j];
                        u[k][j] = temp;
                    }
                    for (k = 0; k < v.length; k++) {
                        temp = v[k][i];
                        v[k][i] = v[k][j];
                        v[k][j] = temp;
                    }
                    //     u.swapCols(i,j)
                    //     v.swapCols(i,j)
                    i = j
                }
            }
        }

        return { U: u, S: q, V: v }
    };

    return numeric;

});
// Helper functions for computing distance.
//
// The name of this should probably be changed, once we learn what other
// kinds of things we're including here.

define('math/distance', ['require', 'math/builtin', 'numeric'], function(require) {
    var Builtin = require('math/builtin');
    var Numeric = require('numeric');

    var Distance = {
        // sqrt(x^2 + y^2), computed to avoid overflow and underflow.
        // http://en.wikipedia.org/wiki/Hypot
        hypot: function(x, y) {
            if (x === 0 && y === 0) {
                return 0;
            }
            if (Math.abs(x) > Math.abs(y)) {
                return Math.abs(x) * Math.sqrt((y / x) * (y / x) + 1);
            } else {
                return Math.abs(y) * Math.sqrt((x / y) * (x / y) + 1);
            }
        },

        // (x1 + x2)/2, computed to avoid overflow.
        mean: function(x1, x2) {
            return ((x1 > 0) === (x2 > 0)) ? x1 + 0.5 * (x2 - x1) : 0.5 * (x1 + x2);
        },

        dot: function(x1, y1, x2, y2) {
            return x1 * x2 + y1 * y2;
        },

        // Consider the line extending the segment, parameterized as
        // v1 + t (v2 - v1), where p, v1, and v2 are (xp, yp), (x1, y1), and
        // (x2, y2) respectively.
        //
        // Return the value of the parameter t for the projected point of p onto
        // the line through the segment.
        //
        // It falls where t = [(p-v) . (w-v)] / |w-v|^2
        //
        // Returns 0 in the degenerate case where v1 === v2.
        pointToSegmentParameter: function(xp, yp, x1, y1, x2, y2) {
            var line_length = this.hypot(x2 - x1, y2 - y1);

            // Degenerate case of a point to a point
            if (line_length === 0) return 0;

            var t = this.dot(
                (xp - x1) / line_length,
                (yp - y1) / line_length,
                (x2 - x1) / line_length,
                (y2 - y1) / line_length
            );

            return t;
        },

        closestPointOnSegment: function(xp, yp, x1, y1, x2, y2) {
            var t = this.pointToSegmentParameter(xp, yp, x1, y1, x2, y2);

            if (t <= 0) return [x1, y1];
            if (t >= 1) return [x2, y2];
            return [x1 + t * (x2 - x1), y1 + t * (y2 - y1)];
        },

        // Shortest distance from a point to a line segment
        // http://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment
        pointToSegment: function(xp, yp, x1, y1, x2, y2) {
            var p = this.closestPointOnSegment(xp, yp, x1, y1, x2, y2);
            return this.hypot(xp - p[0], yp - p[1]);
        },

        // (Near) 0 if x3, y3 lies on the line from x1, y1 to x2, y2.
        // Positive if x3, y3 is on the left of the line, so that the points form a
        // triangle with clockwise orientation.
        isLine: function(x1, y1, x2, y2, x3, y3) {
            var S = Numeric.svd([
                [x1, y1, 1],
                [x2, y2, 1],
                [x3, y3, 1]
            ]).S;
            return Builtin.approx(S[S.length - 1] / S[0], 0);
        },

        isCircle: function(x1, y1, x2, y2, x3, y3, x4, y4) {
            var S = Numeric.svd([
                [x1 * x1 + y1 * y1, x1, y1, 1],
                [x2 * x2 + y2 * y2, x2, y2, 1],
                [x3 * x3 + y3 * y3, x3, y3, 1],
                [x4 * x4 + y4 * y4, x4, y4, 1]
            ]).S;
            return Builtin.approx(S[S.length - 1] / S[0], 0);
        },

        // (Near) 0 if x6, y6 lies on the conic defined by the first five points.
        // I don't quite know how to interpret the sign for a general conic.
        isConic: function(x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6) {
            var S = Numeric.svd([
                [x1 * x1, y1 * y1, 2 * x1 * y1, x1, y1, 1],
                [x2 * x2, y2 * y2, 2 * x2 * y2, x2, y2, 1],
                [x3 * x3, y3 * y3, 2 * x3 * y3, x3, y3, 1],
                [x4 * x4, y4 * y4, 2 * x4 * y4, x4, y4, 1],
                [x5 * x5, y5 * y5, 2 * x5 * y5, x5, y5, 1],
                [x6 * x6, y6 * y6, 2 * x6 * y6, x6, y6, 1]
            ]).S;
            return Builtin.approx(S[S.length - 1] / S[0], 0);
        },

        conicQuadraticParameters: function(x1, y1, x2, y2, x3, y3, x4, y4, x5, y5) {
            return {
                a: Numeric.det([
                    [y1 * y1, 2 * x1 * y1, x1, y1, 1],
                    [y2 * y2, 2 * x2 * y2, x2, y2, 1],
                    [y3 * y3, 2 * x3 * y3, x3, y3, 1],
                    [y4 * y4, 2 * x4 * y4, x4, y4, 1],
                    [y5 * y5, 2 * x5 * y5, x5, y5, 1]
                ]),

                b: Numeric.det([
                    [x1 * x1, y1 * y1, x1, y1, 1],
                    [x2 * x2, y2 * y2, x2, y2, 1],
                    [x3 * x3, y3 * y3, x3, y3, 1],
                    [x4 * x4, y4 * y4, x4, y4, 1],
                    [x5 * x5, y5 * y5, x5, y5, 1]
                ]),

                c: -Numeric.det([
                    [x1 * x1, 2 * x1 * y1, x1, y1, 1],
                    [x2 * x2, 2 * x2 * y2, x2, y2, 1],
                    [x3 * x3, 2 * x3 * y3, x3, y3, 1],
                    [x4 * x4, 2 * x4 * y4, x4, y4, 1],
                    [x5 * x5, 2 * x5 * y5, x5, y5, 1]
                ])
            };
        },

        // Classify a set of 6 points as line, circle, parabola, hyperbola, ellipse, or none for not a conic.
        classifyConic: function(x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6) {
            if (Distance.isLine(x1, y1, x3, y3, x6, y6)) return 'line';
            if (Distance.isCircle(x1, y1, x2, y2, x5, y5, x6, y6)) return 'circle';
            if (!Distance.isConic(x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6)) return 'none';

            var p = Distance.conicQuadraticParameters(x1, y1, x2, y2, x3, y3, x4, y4, x5, y5);
            var S = Numeric.svd([
                [p.a, p.b],
                [p.b, p.c]
            ]).S;

            if (Builtin.approx(S[S.length - 1] / S[0], 0, 20)) return 'parabola';
            return (p.b * p.b > p.a * p.c) ? 'hyperbola' : 'ellipse';

        }
    };

    return Distance;
});

// Utilites for finding and refining points of interest in samled functions.
//
// bisect* are low level functions take endpoints and a function, and return
// a single [x, f(x)] pair, where f is the function that was passed in, or
// null if a non-finite value of the function is encountered during
// evaluation. These methods have preconditions on the endpoints that callers
// are expected to enforce (because they are called recursively). They bisect
// to machine precision.
//
// find* are higher level. They take an array of segments and a function.
// Each segment is an array of points representing a polyline that
// approximates the function over a range where the function is expected to be
// continuous. No more than one zero and one extremum will be returned between
// individual point pairs in the segments list.
//
// findPOIs collects the results of all the find* methods together.


define('math/poi', ['require', 'console', './builtin', './distance'], function(require) {
    var console = require('console');
    var BuiltIn = require('./builtin');
    var Distance = require('./distance');

    // floatMiddle is a helper function for bisecting floats. Necessary because
    // floats are denser near 0 than they are elsewhere, so using a normal mean
    // results in slow bisection to 0.
    //
    // This function returns the arithmetic mean if both numbers have
    // magnitude larger than 1e-2, 0 if the numbers are small and have opposite
    // signs, and the signed geometric mean if the numbers have the same sign. The
    // geometric mean bisects the exponent instead of the mantissa, which is what
    // we want near 0.

    function floatMiddle(a, b) {
        var tmp;
        if (a > b) {
            tmp = a;
            a = b;
            b = tmp;
        }
        var aPos = a > 0;
        var bPos = b > 0;
        var aLarge = Math.abs(a) > 1e-2;
        var bLarge = Math.abs(b) > 1e-2;
        if (aLarge || bLarge) return Distance.mean(a, b);
        if (a === 0) return b * Math.abs(b);
        if (b === 0) return a * Math.abs(a);
        if (aPos !== bPos) return 0;
        var gMean = (aPos) ? Math.sqrt(a * b) : -Math.sqrt(a * b);
        // Check if the geometric mean actually lies between the numbers (it might
        // not because of floating point rounding). If it does not, return the
        // normal mean, which is computed in a way that guarantees it will be
        // between the inputs.
        return ((gMean >= a) && (b >= gMean)) ? gMean : Distance.mean(a, b);
    }

    function bisectZero(x0, y0, x2, y2, fn) {
        // Preconditions:
        // 1. y0 and y2 are finite and non-zero and have opposite sign
        if (!(isFinite(y0) && isFinite(y2) && (y0 < 0) !== (y2 < 0))) {
            console.log('bisectZero called with bad y values', [y0, y2]);
            return;
        }

        while (true) {
            var x1 = floatMiddle(x0, x2);
            var y1 = fn(x1);

            if (!isFinite(y1)) return null;

            // We can't bisect any further; return x for side with y closer to 0.
            if (x1 === x0 || x1 === x2) {
                return Math.abs(y0) <= Math.abs(y2) ? [x0, y0] : [x2, y2];
            }

            // Found a 0 early. Check if we're on a flat, and return the center of it.
            if (y1 === 0) return flatCenter(x0, y0, x1, y1, x2, y2, fn);

            // Bisect on side that brackets zero
            if ((y0 < 0) !== (y1 < 0)) {
                x2 = x1;
                y2 = y1;
            } else {
                x0 = x1;
                y0 = y1;
            }
        }
    }

    // Returns the center of a possibly flat region with constant value y1
    function flatCenter(x0, y0, x1, y1, x2, y2, fn) {
        // Preconditions:
        // 1. x0 < x1 < x2

        var edge;
        if (!isFinite(y1)) return;

        if (!isFinite(y0)) {
            edge = bisectFinite(x0, y0, x1, y1, fn);
            x0 = edge[0];
            y0 = edge[1];
        }

        if (!isFinite(y2)) {
            edge = bisectFinite(x1, y1, x2, y2, fn);
            x2 = edge[0];
            y2 = edge[1];
        }

        var flatLeft, flatRight;

        if (y0 === y1) {
            flatLeft = [x0, y0];
        } else {
            flatLeft = bisectConstant(x0, y0, x1, y1, fn, y1);
        }

        if (y2 === y1) {
            flatRight = [x2, y2];
        } else {
            flatRight = bisectConstant(x1, y1, x2, y2, fn, y1);
        }

        var xc = floatMiddle(flatLeft[0], flatRight[0]);
        return [xc, fn(xc)];
    }

    function bisectFinite(x0, y0, x2, y2, fn) {
        // Preconditions:
        // 1. isFinite(y0) !== isFinite(y2)
        if (isFinite(y0) === isFinite(y2)) {
            console.log('bisectFinite called with bad y values', [y0, y2]);
            return;
        }

        while (true) {
            var x1 = floatMiddle(x0, x2);
            var y1 = fn(x1);

            // We can't bisect any further; return [x, y] pair for side that is finite.
            if (x1 === x0 || x1 === x2) return isFinite(y0) ? [x0, y0] : [x2, y2];

            // Bisect on side that brackets zero
            if (isFinite(y1) !== isFinite(y0)) {
                x2 = x1;
                y2 = y1;
            } else {
                x0 = x1;
                y0 = y1;
            }
        }
    }

    function bisectConstant(x0, y0, x2, y2, fn, constant) {
        // Preconditions:
        // 1. (y0 === constant) !== (y2 === constant)
        if ((y0 === constant) === (y2 === constant)) {
            console.log('bisectConstant called with bad y values', [y0, y2, constant]);
            return;
        }

        while (true) {
            var x1 = floatMiddle(x0, x2);
            var y1 = fn(x1);

            // We can't bisect any further; return [x, y] pair for side with
            // y === constant
            if (x1 === x0 || x1 === x2) return (y0 === constant) ? [x0, y0] : [x2, y2];

            if ((y1 === constant) !== (y0 === constant)) {
                x2 = x1;
                y2 = y1;
            } else {
                x0 = x1;
                y0 = y1;
            }
        }
    }

    function bisectExtremum(x0, y0, x2, y2, x4, y4, fn) {
        /* jshint maxcomplexity:11 */
        // Preconditions:
        // 1. x0 < x2 < x4
        // 2. y0, y2, and y4 are finite, non-equal, and y2 > y0 === y2 > y4.
        if (!(x0 < x2 && x2 < x4)) {
            console.log('bisectExtremum called with bad x values', [x0, x2, x4]);
            return;
        }
        if (!(
                (isFinite(y0) && isFinite(y2) && isFinite(y4)) &&
                (y0 !== y2 && y2 !== y4) &&
                (y2 > y0) === (y2 > y4)
            )) {
            console.log('bisectExtremum called with bad y values', [y0, y2, y4]);
            return;
        }

        while (true) {
            var x1 = floatMiddle(x0, x2);
            var y1 = fn(x1);
            var x3 = floatMiddle(x2, x4);
            var y3 = fn(x3);

            if (!isFinite(y1) || !isFinite(y3)) return null;

            // We can't bisect any further; return x and y for most extreme value
            if (x1 === x0 || x1 === x2 || x3 === x2 || x3 === x4) {
                if ((y1 > y2) === (y2 > y0)) return [x1, y1];
                if ((y3 > y2) === (y2 > y0)) return [x3, y3];
                return [x2, y2];
            }

            // We've hit a flat. Find its edges and return x and y for its center.
            if (y1 === y2 || y3 === y2) {
                return flatCenter(x0, y0, x2, y2, x4, y4, fn);
            }

            // Bisect on side that brackets zero
            if ((y1 > y0) === (y2 > y0) && (y1 > y0) === (y1 > y2)) {
                x4 = x2;
                y4 = y2;
                x2 = x1;
                y2 = y1;
            } else if ((y3 > y4) === (y2 > y4) && (y3 > y2) === (y3 > y4)) {
                x0 = x2;
                y0 = y2;
                x2 = x3;
                y2 = y3;
            } else {
                x0 = x1;
                y0 = y1;
                x4 = x3;
                y4 = y3;
            }
        }
    }

    // Returns larget jump among 4 points. Used in final step of bisectJump
    function largestJump(x0, y0, x1, y1, x2, y2, x3, y3) {
        // Preconditions:
        // 1. y0, y1, y2, and y3 are all finite
        var d1 = Math.abs(y1 - y0);
        var d2 = Math.abs(y2 - y1);
        var d3 = Math.abs(y3 - y2);

        if (d1 > d2 && d1 > d3) return [
            [x0, y0],
            [x1, y1]
        ];
        if (d3 > d2 && d3 > d1) return [
            [x2, y2],
            [x3, y3]
        ];
        return [
            [x1, y1],
            [x2, y2]
        ];
    }

    // Tries to find the largest jump in an interval. Returns left side and right
    // side of jump as [[xl, yl], [xr, yr]], or null if no jump was found.
    // Tolerance is allowed to be 0, and this works for some smooth functions,
    // but returns false positives for others.
    function bisectJump(x0, y0, x2, y2, x4, y4, fn, tolerance) {
        /* jshint maxcomplexity:15 */
        // Preconditions:
        // 1. x0 < x2 < x4
        // 2. y0, y2, and y4 are all finite.
        // Also expect x2 - x0 ~= x4 - x2
        if (!(x0 < x2 && x2 < x4)) {
            console.log('bisectJump called with bad x values', [x0, x2, x4]);
            return;
        }
        if (!isFinite(y0) || !isFinite(y4)) {
            console.log('bisectJump called with bad y values', [y0, y2, y4]);
            return;
        }

        if (!isFinite(y2)) {
            return [bisectFinite(x0, y0, x2, y2, fn), bisectFinite(x2, y2, x4, y4, fn)];
        }

        if (Math.abs(y2 - ((x4 - x2) * y0 + (x2 - x0) * y4) / (x4 - x0)) < tolerance) return null;

        while (true) {
            var x1 = floatMiddle(x0, x2);
            var y1 = fn(x1);
            var x3 = floatMiddle(x2, x4);
            var y3 = fn(x3);
            var dy1 = Math.abs(y1 - Distance.mean(y0, y2));
            var dy3 = Math.abs(y3 - Distance.mean(y2, y4));
            var left;
            var right;
            if (!tolerance) tolerance = 0;

            if (dy1 <= tolerance && dy3 <= tolerance) return null;

            // An undefined region counts as a jump.
            if (!isFinite(y1)) {
                left = bisectFinite(x0, y0, x1, y1, fn);
                right = bisectFinite(x1, y1, x4, y4, fn);
                return [left, right];
            }

            if (!isFinite(y3)) {
                left = bisectFinite(x0, y0, x3, y3, fn);
                right = bisectFinite(x3, y3, x4, y4, fn);
                return [left, right];
            }

            if ((x1 === x0 || x1 === x2) && (x3 === x2 || x3 === x4)) {
                if (Math.abs(y2 - y0) > Math.abs(y4 - y2)) {
                    left = [x0, y0];
                    right = [x2, y2];
                } else {
                    left = [x2, y2];
                    right = [x4, y4];
                }
                return [left, right];
            } else if (x1 === x0 || x1 === x2) {
                return largestJump(x0, y0, x2, y2, x3, y3, x4, y4);
            } else if (x3 === x2 || x3 === x4) {
                return largestJump(x0, y0, x1, y1, x2, y2, x4, y4);
            }

            if (dy1 > dy3) {
                x4 = x2;
                y4 = y2;
                x2 = x1;
                y2 = y1;
            } else {
                x0 = x2;
                y0 = y2;
                x2 = x3;
                y2 = y3;
            }
        }
    }

    function findZeros(segments, fn) {
        var segment;
        var accumulator = { x: [], y: [] };
        var x0;
        var y0;
        var x2;
        var y2;
        var zero;
        var flatLeft;
        for (var i = 0, li = segments.length; i < li; i++) {
            segment = segments[i];
            flatLeft = undefined;
            if (segment[1] === 0) flatLeft = [segment[0], segment[1]];
            for (var j = 0, lj = segment.length; j < lj - 2; j = j + 2) {
                x0 = segment[j];
                y0 = segment[j + 1];
                x2 = segment[j + 2];
                y2 = segment[j + 3];

                if (!flatLeft) {
                    if (y2 === 0) {
                        // Entering left side of a potential flat. Save its position.
                        flatLeft = [x0, y0];
                    } else if ((y0 < 0) !== (y2 < 0)) {
                        zero = bisectZero(x0, y0, x2, y2, fn);
                        if (zero) {
                            accumulator.x.push(zero[0]);
                            accumulator.y.push(zero[1]);
                        }
                    }
                } else {
                    if (y2 !== 0) {
                        // Leaving right side of a flat. Add its center as a root.
                        // Don't label zeros that start on segment boundaries.
                        if (flatLeft[0] !== segment[0]) {
                            zero = flatCenter(flatLeft[0], flatLeft[1], x0, y0, x2, y2, fn);
                            accumulator.x.push(zero[0]);
                            accumulator.y.push(zero[1]);
                        }
                        flatLeft = undefined;
                    }
                    // Otherwise we're in the middle of the flat; do nothing
                }
            }
            // Don't label zero that ends on a segment boundary.
        }

        return accumulator;
    }

    function findExtrema(segments, fn, derivative) {
        /* jshint maxcomplexity:13 */
        var segment;
        var accumulator = { x: [], y: [] };
        var x0;
        var y0;
        var x2;
        var y2;
        var x4;
        var y4;
        var extremum;
        var flatLeft;
        for (var i = 0, li = segments.length; i < li; i++) {
            segment = segments[i];
            for (var j = 0, lj = segment.length; j < lj - 4; j = j + 2) {
                x0 = segment[j];
                y0 = segment[j + 1];
                x2 = segment[j + 2];
                y2 = segment[j + 3];
                x4 = segment[j + 4];
                y4 = segment[j + 5];

                //TODO handle extremal endpoints.
                if (!(isFinite(y0) && isFinite(y2) && isFinite(y4))) continue;

                if (y0 !== y2 && y2 === y4) {
                    // Entering left side of a flat. Save its position.
                    flatLeft = [x0, y0];
                } else if (y0 === y2 && y2 !== y4 && flatLeft) {
                    // Leaving right side of a flat.
                    if ((y2 > flatLeft[1]) === (y2 > y4)) {
                        // Flat is an extremum. Push it's center.
                        extremum = flatCenter(flatLeft[0], flatLeft[1], x2, y2, x4, y4, fn);
                        accumulator.x.push(extremum[0]);
                        accumulator.y.push(extremum[1]);
                    }
                    flatLeft = undefined;
                } else if (y0 === y2 && y2 === y4) {
                    // Middle of a flat, do nothing
                } else if ((y2 > y0) === (y2 > y4)) {
                    if (derivative) {
                        // If we have derivative information, find zeros of the derivative
                        // to find extrema. This gives greater accuracy in the argmax/argmin
                        // because the original function is flat at the extrema, but its
                        // derivative is (usually) not.

                        // Make sure we satisfy prereqs of bisectZero
                        if ((derivative(x0) > 0) === (derivative(x4) > 0)) continue;
                        extremum = bisectZero(
                            x0, derivative(x0),
                            x4, derivative(x4),
                            derivative
                        );
                        // Currently treat maxima and minima the same
                        if (extremum) {
                            accumulator.x.push(extremum[0]);
                            accumulator.y.push(fn(extremum[0]));
                        }
                    } else {
                        extremum = bisectExtremum(x0, y0, x2, y2, x4, y4, fn);
                        // Currently treat maxima and minima the same
                        if (extremum) {
                            accumulator.x.push(extremum[0]);
                            accumulator.y.push(extremum[1]);
                        }
                    }
                }
            }
        }
        return accumulator;
    }

    function findIntercept(segments, fn) {
        var intercept = fn(0);
        if (!isFinite(intercept)) return { x: [], y: [] };
        return { x: [0], y: [fn(0)] };
    }

    function findEdges(segments, fn) {
        var slen = segments.length;
        var accumulator = { x: [], y: [] };
        //TODO work out robust system for labeling holes so that we can label all
        // edges.
        //
        // For now, only label edges that are close to zero as zeros.

        for (var i = 0; i < slen; i++) {
            var segment = segments[i];
            if (parseFloat(segment[1].toFixed(7)) === 0) {
                accumulator.x.push(segment[0]);
                accumulator.y.push(segment[1]);
            }

            if (parseFloat(segment[segment.length - 1].toFixed(7)) === 0) {
                accumulator.x.push(segment[segment.length - 2]);
                accumulator.y.push(segment[segment.length - 1]);
            }
        }
        return accumulator;
    }

    function findPOIs(segments, fn, derivative) {
        var zeros = findZeros(segments, fn);
        var edges = findEdges(segments, fn);

        // Not displaying edges right now; combine them with zeros.
        zeros.x.push.apply(zeros.x, edges.x);
        zeros.y.push.apply(zeros.y, edges.y);

        return {
            zeros: zeros,
            intercept: findIntercept(segments, fn),
            extrema: findExtrema(segments, fn, derivative)
        };
    }

    // indicatorFn is a function that is 0 where two curves intersect, and
    // indicatorSamples is a series of samples of this function. For two
    // y vs x curves, the indicator function is just the difference between
    // the two curves. For intersecting a y vs x curve with an x vs y curve,
    // e.g. y = f(x) and x = g(y), a suitable indicator function is
    // x - g(f(x)). fn1 is used at the end to get y values from the x values
    // that are roots of the indicator function.
    function findIntersections(indicatorSamples, fn1, indicatorFn) {

        var zeros = findZeros(indicatorSamples, indicatorFn);
        var i, elen, zlen;

        // Find tangent intersections.
        var extrema = findExtrema(indicatorSamples, indicatorFn);
        for (i = 0, elen = extrema.x.length; i < elen; i++) {
            if (BuiltIn.approx(extrema.y[i], 0)) {
                zeros.x.push(extrema.x[i]);
                zeros.y.push(extrema.y[i]);
            }
        }

        // Find original function intersection y values.
        for (i = 0, zlen = zeros.x.length; i < zlen; i++) {
            zeros.y[i] = fn1(zeros.x[i]);
        }
        return zeros;
    }

    return {
        bisectJump: bisectJump,
        bisectExtremum: bisectExtremum,
        bisectFinite: bisectFinite,
        bisectZero: bisectZero,
        findExtrema: findExtrema,
        findZeros: findZeros,
        findPOIs: findPOIs,
        findIntersections: findIntersections,

        //Enums for POI type
        INTERSECTION: 1001,
        ZERO: 1002,
        INTERCEPT: 1003,
        EXTREMUM: 1004,
        EDGE: 1005,
        DEFINITION: 1006
    };

});

define('graphing/graphmode', {
    X: 1,
    Y: 2,
    XYPOINT: 3,
    XYPOINT_MOVABLE: 4,
    PARAMETRIC: 5,
    POLAR: 6,
    POLYGONFILL: 7,
    IMPLICIT: 8,
    NONE: 10
});

define('math/plotter', ['require', 'pjs', './distance', './poi', 'graphing/graphmode'], function(require) {
    var P = require('pjs');
    var Distance = require('./distance');
    var POI = require('./poi');
    var GRAPHMODE = require('graphing/graphmode');

    var Accumulator = P(function(proto) {
        proto.init = function(domain) {
            this.domain = domain;
            if (domain) {
                this.xtolerance = domain.xtolerance || domain.tolerance || 0;
                this.ytolerance = domain.ytolerance || domain.tolerance || 0;
                this.map = domain.map;
            } else {
                this.xtolerance = this.ytolerance = 0;
            }
            this.segments = [];
            this.segment = null;
            // Second point added to colinear set; defines line direction
            this.pivotPoint = null;
            // Most recent point in colinear set
            this.pendingPoint = null;
        };

        proto.colinear = function(p0, p1, p2) {
            if (this.map) {
                p0 = this.map(p0);
                p1 = this.map(p1);
                p2 = this.map(p2);
            }

            var t = Distance.pointToSegmentParameter(
                p2[0], p2[1],
                p0[0], p0[1],
                p1[0], p1[1]
            );

            if (t < 1) return false;

            var closestPoint = [
                p0[0] + t * (p1[0] - p0[0]),
                p0[1] + t * (p1[1] - p0[1])
            ];

            return (
                Math.abs(p2[0] - closestPoint[0]) <= this.xtolerance &&
                Math.abs(p2[1] - closestPoint[1]) <= this.ytolerance
            );
        };

        proto.addPoint = function(p) {
            this.n += 1;

            if (!this.segment) {
                this.segment = [p[0], p[1]]; //First point of the segment
                return;
            }

            if (this.xtolerance < 0 && this.ytolerance < 0) {
                this.segment.push(p[0], p[1]);
                return;
            }

            if (!this.pivotPoint) {
                this.pivotPoint = p;
                this.pendingPoint = p;
                return;
            }

            // Check if the new point lies on the line segment defined by the
            // last flushed point and the pivot point. If not, flush the pending
            // point and start a new linear section.
            var lastPoint = [
                this.segment[this.segment.length - 2],
                this.segment[this.segment.length - 1]
            ];

            if (!this.colinear(lastPoint, this.pivotPoint, p)) {
                this.flushPending();
                this.pivotPoint = p;
            }

            this.pendingPoint = p;
        };

        proto.flushPending = function() {
            if (this.pendingPoint) { //Only happens when we have a segment
                this.segment.push(this.pendingPoint[0], this.pendingPoint[1]);
                this.pivotPoint = null;
                this.pendingPoint = null;
            }
        };

        proto.breakSegment = function() {
            this.flushPending();

            if (this.segment) {
                if (this.segment.length > 2) {
                    this.segments.push(this.segment);
                }
                this.segment = null;
            }
        };

        proto.getSegments = function() {
            this.breakSegment();
            return this.segments;
        };

        proto.finish = function() {
            return {
                segments: this.getSegments(),
                resolved: true
            };
        };

        proto.exhaust = function() {};
    });

    //Simple sampling of a [x(t), y(t)] function.
    //Domain is provided in terms of the independent variable
    //PARAMETERS
    //fn(int) => [x, y]
    //domain = {min, max, step}
    //RETURNS
    //Unclipped list of segments which can be passed directly into onGraph
    function sampleParametricNaive(fn, domain) {
        var accumulator = new Accumulator();
        var point;
        for (var independent = domain.min; independent <= domain.max + domain.step / 2; independent += domain.step) {
            point = fn(independent);
            if (isFinite(point[0]) && isFinite(point[1])) {
                accumulator.addPoint(point);
            } else {
                accumulator.breakSegment();
            }
        }
        return accumulator.finish();
    }

    //Simple sampling of a y(x) function.
    //PARAMETERS
    //fn(int) => y
    //domain = {min, max, step}
    //RETURNS
    //Unclipped list of segments which can be passed directly into onGraph
    function sampleXYNaive(fn, domain) {
        var accumulator = new Accumulator(domain);
        var y;
        for (var x = domain.min; x <= domain.max + domain.step / 2; x += domain.step) {
            y = fn(x);
            if (isFinite(y)) {
                accumulator.addPoint([x, y]);
            } else {
                accumulator.breakSegment();
            }
        }
        return accumulator.finish();
    }

    function sampleLinear(linearCoefficients, domain) {
        var accumulator = new Accumulator(domain);
        accumulator.addPoint([domain.min, linearCoefficients[0] + domain.min * linearCoefficients[1]]);
        accumulator.addPoint([domain.max, linearCoefficients[0] + domain.max * linearCoefficients[1]]);
        return accumulator.finish();
    }

    // Only returns a jump if we also find a jump when previousPoint and point are
    // perturbed by stepPerturbation.
    function _bisectJumpRobust(previousPoint, point, params) {
        var x0, y0, x1, y1, x2, y2;
        var fn = params.fn;
        var jumpTolerance = params.jumpTolerance;
        var stepPerturbation = params.stepPerturbation;

        x0 = previousPoint[0];
        y0 = previousPoint[1];
        x2 = point[0];
        y2 = point[1];
        x1 = Distance.mean(x0, x2);
        y1 = fn(x1);

        var jump = POI.bisectJump(x0, y0, x1, y1, x2, y2, fn, jumpTolerance);

        if (!jump) return;

        // If we found a jump, check whether we still find one with a small perturbation
        // to the left or the right.
        var perturbations = [-stepPerturbation, stepPerturbation];
        for (var i = 0; i < perturbations.length; i++) {
            x0 = previousPoint[0] + perturbations[i];
            y0 = fn(x0);
            if (!isFinite(y0)) {
                x0 = previousPoint[0];
                y0 = previousPoint[1];
            }
            x2 = point[0] + perturbations[i];
            y2 = fn(x2);
            if (!isFinite(y2)) {
                x2 = point[0];
                y2 = point[1];
            }
            x1 = Distance.mean(x0, x2);
            y1 = fn(x1);

            if (POI.bisectJump(x0, y0, x1, y1, x2, y2, fn, jumpTolerance)) return jump;
        }

        // If we made it here, we didn't find a jump under either perturbation, so just
        // conclude that the jump was not robust and return nothing.
    }

    var _handleJump = function(previousPoint, point, params) {
        if (!isFinite(params.jumpTolerance) || (params.jumpTolerance <= 0)) return;
        var jump = _bisectJumpRobust(previousPoint, point, params);
        if (jump) {
            params.accumulator.addPoint(jump[0]);
            params.accumulator.breakSegment();
            params.accumulator.addPoint(jump[1]);
        }
    };

    // Thre are a few pieces of state and configuration that need to get passed to
    // subroutines in sampleXY. This is just a simple container to keep track of
    // them.
    //
    // _handleJump used to be defined inside samlpeXY to close over all of these
    // variables, but it gets called a ton, so it's worth a bit of bureaucracy to
    // avoid paying the runtime cost of closures.
    var SampleXYParameters = function(fn, domain) {
        this.accumulator = new Accumulator(domain);
        this.fn = fn;
        this.jumpTolerance = domain.ytolerance || domain.tolerance;
        this.stepPerturbation = domain.step / 10;
    };

    function sampleXY(fn, domain) {

        var params = new SampleXYParameters(fn, domain);
        var edge;
        var x = domain.min;
        var y = fn(x);
        var previousPoint = [x, y];

        if (isFinite(y)) params.accumulator.addPoint([x, y]);
        for (x += domain.step; x <= domain.max + domain.step / 2; x += domain.step) {
            var xp = x;
            y = fn(xp);

            // If y isn't finite, try two nearby values to see if we can find an x with a finite y.
            // Policy is to try to avoid numerically spurious jumps and holes by ignoring them if
            // they have no influence outside a region that we could have missed by sampling with
            // a small offset.
            // https://github.com/desmosinc/knox/issues/2230
            // https://github.com/desmosinc/knox/issues/4151
            if (!isFinite(y)) {
                xp = x + params.stepPerturbation;
                y = fn(xp);
            }
            if (!isFinite(y)) {
                xp = x - params.stepPerturbation;
                y = fn(xp);
            }

            if (isFinite(y) && isFinite(previousPoint[1])) {
                _handleJump(previousPoint, [xp, y], params);
                params.accumulator.addPoint([xp, y]);
            } else if (isFinite(y) && !isFinite(previousPoint[1])) {
                edge = POI.bisectFinite(previousPoint[0], previousPoint[1], xp, y, fn);
                if (edge[0] !== xp) params.accumulator.addPoint(edge);
                _handleJump(edge, [xp, y], params);
                params.accumulator.addPoint([xp, y]);
            } else if (!isFinite(y) && isFinite(previousPoint[1])) {
                edge = POI.bisectFinite(previousPoint[0], previousPoint[1], xp, y, fn);
                _handleJump(previousPoint, edge, params);
                if (edge[0] !== previousPoint[0]) params.accumulator.addPoint(edge);
                params.accumulator.breakSegment();
            }
            previousPoint = [xp, y];
        }
        return params.accumulator.finish();
    }

    function findPiPeriod(fn, domain, trigAngleMultiplier, allowAntiperiods) {
        // If the function is periodic by a multiple of 2*pi, or antiperiodic by
        // a multiple of pi within the domain, return the period.
        //
        // Can optionally pass true to find antiperiods if they exist.
        var min = domain.min;
        var range = domain.max - domain.min;
        var tolerance = (domain.xtolerance && domain.ytolerance) ?
            Math.min(domain.xtolerance, domain.ytolerance) :
            domain.tolerance;
        var piRange = Math.floor(range / (Math.PI / trigAngleMultiplier));
        var n, m, period;

        function isPeriod(fn, n) {
            var sign = (n % 2 === 0) ? 1 : -1;
            if (!allowAntiperiods && sign === -1) return false;
            var nPI = n * (Math.PI / trigAngleMultiplier);
            var vals = [min, min + 1, min + 2, min + 3];

            for (var i = 0, ilen = vals.length; i < ilen; i++) {
                if (
                    isFinite(fn(vals[i])) !== isFinite(fn(vals[i] + nPI)) ||
                    Math.abs(fn(vals[i]) - sign * fn(vals[i] + nPI)) > tolerance
                ) {
                    return false;
                }
            }

            return true;
        }

        for (n = 1; n <= piRange; n++) {
            if (isPeriod(fn, n)) {
                period = n;
                // Check if integer multiples of the period are also periods
                for (m = 2; m * n <= piRange; m++) {
                    if (!isPeriod(fn, m * n)) period = undefined;
                }
                if (period) break;
            }
        }

        if (!period) return null;

        return period * (Math.PI / trigAngleMultiplier);
    }

    function mapPolar(p) {
        return [p[1] * Math.cos(p[0]), p[1] * Math.sin(p[0])];
    }

    function samplePolar(fn, domain) {
        // Don't allow line coallescing, since linear segments of a polar
        // equation don't map to lines on the graph paper.
        domain.map = mapPolar;
        return sampleXY(fn, domain);
    }

    // Helper for calling a function at steps along a range that makes sure we
    // hit start and endpoints exactly.
    //
    // TODO, use this in sampling xy also. Not
    // doing that for now because I don't want to step on Eric's toes with
    // extrema interleaving system that is being concurrently developed.
    function eachStep(domain, fn) {
        var min = domain.min;
        var max = domain.max;
        var step = domain.step;
        var range = max - min;
        var nsteps = Math.ceil(range / step);
        var newStep = range / nsteps;
        for (var n = 0; n < nsteps; n++) {
            fn(min + n * newStep);
        }
        fn(max);
    }

    function sampleParametricRecursive(fn, domain) {
        if (domain.max < domain.min) { return [] }

        var accumulator = new Accumulator(domain);

        //Sampling parameters
        var subdivision_levels = 10;

        //Initialize for first pass through loop
        var t0 = domain.min;
        var p0 = fn(t0);
        if (isFinite(p0[0]) && isFinite(p0[1])) {
            accumulator.addPoint(p0);
        }

        var p1;
        // Note, processes first point twice; but that's okay.
        eachStep(domain, function(t1) {
            p1 = fn(t1);
            subsampleParametricRecursive(fn, t0, p0, t1, p1, subdivision_levels, accumulator);
            t0 = t1;
            p0 = p1;
        });

        return accumulator.finish();
    }

    function subsampleParametricRecursive(fn, t0, p0, t1, p1, subdivision_levels_left, accumulator) {
        /* jshint maxcomplexity:13 */
        if (t1 === t0) return; // Nothing new to add, but don't need to break;

        var xtolerance = accumulator.xtolerance,
            ytolerance = accumulator.ytolerance;
        var t_mid = Distance.mean(t0, t1);
        var p_mid = fn(t_mid, true);

        var p0_valid = isFinite(p0[0]) && isFinite(p0[1]);
        var p1_valid = isFinite(p1[0]) && isFinite(p1[1]);
        var p_mid_valid = isFinite(p_mid[0]) && isFinite(p_mid[1]);

        if (subdivision_levels_left === 0 || t_mid === t0 || t_mid === t1) {
            accumulator.breakSegment(); //Didn't converge.
            if (p1_valid) accumulator.addPoint(p1);
            return;
        }

        // Don't need to break segment, since p0 should already have been processed.
        if (!p0_valid && !p1_valid) return;

        if (p0_valid !== p1_valid) {
            // We're at the edge of where the function is defined.
            // Subdivide until we find where edge point to machine precision.
            var original_t0 = t0;
            var original_t1 = t1;
            var original_p0 = p0;
            var original_p1 = p1;

            while (t0 !== t_mid && t_mid !== t1) {

                if (p_mid_valid == p0_valid) {
                    t0 = t_mid;
                    p0 = p_mid;
                    p0_valid = p_mid_valid;
                } else {
                    t1 = t_mid;
                    p1 = p_mid;
                    p1_valid = p_mid_valid;
                }

                t_mid = t0 + (t1 - t0) / 2;
                p_mid = fn(t_mid, true);
                p_mid_valid = isFinite(p_mid[0]) && isFinite(p_mid[1]);
            } //When this loop terminates, t_mid equals either t0 or t1

            if (p0_valid) {
                subsampleParametricRecursive(fn, original_t0, original_p0, t0, p0, subdivision_levels_left - 1, accumulator);
                accumulator.breakSegment();
            } else {
                accumulator.breakSegment();
                accumulator.addPoint(p1);
                subsampleParametricRecursive(fn, t1, p1, original_t1, original_p1, subdivision_levels_left - 1, accumulator);
            }
            return;
        }

        if (p0_valid && p_mid_valid && p1_valid) {

            var t = Distance.pointToSegmentParameter(
                p_mid[0],
                p_mid[1],
                p0[0],
                p0[1],
                p1[0],
                p1[1]
            );

            // If the new point lies betwen 20 % and 80 % of the way between the
            // outer points, and the distance from the segment to the new point is
            // less than tolerance, add the rightmost point, and stop recursing.
            if (
                t > 0.2 &&
                t < 0.8 &&
                Math.abs(p_mid[0] - (p0[0] + t * (p1[0] - p0[0]))) <= xtolerance &&
                Math.abs(p_mid[1] - (p0[1] + t * (p1[1] - p0[1]))) <= ytolerance
            ) {
                accumulator.addPoint(p1);
                return;
            }
        }

        // If we didn't stop, recurse. Don't recurse between two points that are
        // equal, since this will make us do a lot of work if our point becomes
        // independent of t over some range.
        if (!(p0[0] === p_mid[0] && p0[1] === p_mid[1])) {
            subsampleParametricRecursive(fn, t0, p0, t_mid, p_mid, subdivision_levels_left - 1, accumulator);
        }
        if (!(p1[0] === p_mid[0] && p1[1] === p_mid[1])) {
            subsampleParametricRecursive(fn, t_mid, p_mid, t1, p1, subdivision_levels_left - 1, accumulator);
        }
    }

    function sampleImplicitRecursive(fn, domain) {
        var xmin = domain.xmin;
        var ymin = domain.ymin;
        var xmax = domain.xmax;
        var ymax = domain.ymax;

        var a = 6; // Devide the grid at least a times
        var b = 0; // Allow up to b extra subdivisions locally

        var maxSegments = 10000;
        // Perform an iterative deepening depth first search on how many segments we will produce.
        // This allows us to go to very high precision locally for mostly simple functions that have a few kinks,
        // while still limiting the total number of line segments that we'll ever return to the draw routine.
        var opts;
        var pointCount;
        var lastPointCount = -1;
        var exhaustedCount;
        var incrementPointCount = function() { pointCount++; };
        var incrementExhuastedCount = function() { exhaustedCount++; };

        var maxDepth = 12;

        while (true) {
            pointCount = 0;
            exhaustedCount = 0;

            opts = {
                fn: fn,
                mindepth: b,
                accumulator: { push: incrementPointCount, exhaust: incrementExhuastedCount },
                xtolerance: domain.xtolerance,
                ytolerance: domain.ytolerance
            };

            subsampleImplicitRecursive(
                opts, a + b,
                xmin, ymax, fn(xmin, ymax),
                xmax, ymax, fn(xmax, ymax),
                xmax, ymin, fn(xmax, ymin),
                xmin, ymin, fn(xmin, ymin)
            );

            if (pointCount === lastPointCount || pointCount > maxSegments) {
                b--;
                break;
            }

            if (exhaustedCount === 0) {
                break;
            } else {
                b += Math.max(1, Math.floor(Math.log((maxSegments - pointCount) / exhaustedCount) / Math.log(4)));
                if (b > maxDepth) {
                    b = maxDepth;
                    break;
                }
            }

            lastPointCount = pointCount;
        }

        var resolved = pointCount < maxSegments;

        var accumulator = [];
        var noop = function() {};

        opts = {
            fn: fn,
            mindepth: b,
            accumulator: {
                push: function() { Array.prototype.push.apply(accumulator, arguments); }, //Avoiding bind for phantomjs
                exhaust: noop
            },
            xtolerance: domain.xtolerance,
            ytolerance: domain.ytolerance
        };

        subsampleImplicitRecursive(
            opts, a + b,
            xmin, ymax, fn(xmin, ymax),
            xmax, ymax, fn(xmax, ymax),
            xmax, ymin, fn(xmax, ymin),
            xmin, ymin, fn(xmin, ymin)
        );

        return {
            segments: accumulator,
            resolved: resolved
        };
    }

    function subsampleImplicitRecursive(
        opts, depth,
        xtl, ytl, ftl,
        xtr, ytr, ftr,
        xbr, ybr, fbr,
        xbl, ybl, fbl
    ) {
        /* jshint maxcomplexity:19 */
        var fn = opts.fn;
        var mindepth = opts.mindepth;
        var accumulator = opts.accumulator;
        var xtolerance = opts.xtolerance;
        var ytolerance = opts.ytolerance;

        if (!depth) depth = 0;
        if (depth < 0) {
            accumulator.exhaust();
            return;
        }

        // No point in continuing to divide once the grid edges are
        // smaller than the tolerances.
        if (Math.abs(xtl - xtr) < 2 * xtolerance && Math.abs(ytl - ybl) < 2 * ytolerance) {
            depth = 0;
        }

        depth--;

        // Calculate midpoints of 4 edges, and the midpoint of the box.
        var xtm = 0.5 * (xtl + xtr);
        var ytm = 0.5 * (ytl + ytr);
        var ftm = fn(xtm, ytm);

        var xml = 0.5 * (xtl + xbl);
        var yml = 0.5 * (ytl + ybl);
        var fml = fn(xml, yml);

        var xmr = 0.5 * (xtr + xbr);
        var ymr = 0.5 * (ytr + ybr);
        var fmr = fn(xmr, ymr);

        var xbm = 0.5 * (xbl + xbr);
        var ybm = 0.5 * (ybl + ybr);
        var fbm = fn(xbm, ybm);

        var xmm = 0.5 * (xml + xmr);
        var ymm = 0.5 * (ytm + ybm);
        var fmm = fn(xmm, ymm);

        // Descend recursively into each of the 4 subboxes of the current box.
        var descend = function() {
            subsampleImplicitRecursive(
                opts, depth,
                xtl, ytl, ftl,
                xtm, ytm, ftm,
                xmm, ymm, fmm,
                xml, yml, fml
            );
            subsampleImplicitRecursive(
                opts, depth,
                xtm, ytm, ftm,
                xtr, ytr, ftr,
                xmr, ymr, fmr,
                xmm, ymm, fmm
            );
            subsampleImplicitRecursive(
                opts, depth,
                xmm, ymm, fmm,
                xmr, ymr, fmr,
                xbr, ybr, fbr,
                xbm, ybm, fbm
            );
            subsampleImplicitRecursive(
                opts, depth,
                xml, yml, fml,
                xmm, ymm, fmm,
                xbm, ybm, fbm,
                xbl, ybl, fbl
            );
        };

        if (depth > mindepth) return descend();

        // If box contains both finite and non-finite vertices, descend
        if (
            isFinite(ftl) !== isFinite(ftr) ||
            isFinite(ftl) !== isFinite(fbr) ||
            isFinite(ftl) !== isFinite(fbl)
        ) return descend();

        // Check for oxo or xox edges and descend.
        if (ftl > 0 === ftr > 0 && ftm > 0 !== ftl > 0) {
            return descend();
        }
        if (ftr > 0 === fbr > 0 && fmr > 0 !== ftr > 0) {
            return descend();
        }
        if (fbr > 0 === fbl > 0 && fbm > 0 !== fbr > 0) {
            return descend();
        }
        if (fbl > 0 === ftl > 0 && fml > 0 !== fbl > 0) {
            return descend();
        }

        // Check for xo/ox or ox/xo boxes and descend.
        if (ftl > 0 !== ftr > 0 && ftr > 0 !== fbr > 0 && fbr > 0 !== fbl > 0) {
            return descend();
        }

        // Check for oo/oo or xx/xx boxes and do nothing
        if (ftl > 0 === ftr > 0 && ftr > 0 === fbr > 0 && fbr > 0 === fbl > 0) {
            return;
        }

        // At this point, we know there are exactly two xo or ox edges in the box.
        // Interpolate is called with a 3-point edge (corner, midpoint, corner),
        // and if the signs of the function values are appropriate, pushes an edge
        // intersection onto the intersections accumulator.
        var intersections = [];
        var interpolate = function(x0, y0, f0, x1, y1, f1, x2, y2, f2) {
            /* jshint maxcomplexity:11 */
            var code = 1 * (f0 > 0) + 2 * (f1 > 0) + 4 * (f2 > 0);

            var a, xm0, xm1, ym0, ym1;
            switch (code) {
                case 0:
                    return false; // ooo
                case 7:
                    return false; // xxx

                case 2:
                    return true; // oxo
                case 5:
                    return true; // xox

                case 1: // xoo
                    a = f0 / (f0 - f2);
                    xm0 = (1 - a) * x0 + a * x2;
                    ym0 = (1 - a) * y0 + a * y2;
                    a = f0 / (f0 - f1);
                    xm1 = (1 - a) * x0 + a * x1;
                    ym1 = (1 - a) * y0 + a * y1;
                    break;

                case 4: // oox
                    a = f2 / (f2 - f0);
                    xm0 = (1 - a) * x2 + a * x0;
                    ym0 = (1 - a) * y2 + a * y0;
                    a = f2 / (f2 - f1);
                    xm1 = (1 - a) * x2 + a * x1;
                    ym1 = (1 - a) * y2 + a * y1;
                    break;

                case 3: // xxo
                    a = f0 / (f0 - f2);
                    xm0 = (1 - a) * x0 + a * x2;
                    ym0 = (1 - a) * y0 + a * y2;
                    a = f1 / (f1 - f2);
                    xm1 = (1 - a) * x1 + a * x2;
                    ym1 = (1 - a) * y1 + a * y2;
                    break;

                case 6: // oxx
                    a = f2 / (f2 - f0);
                    xm0 = (1 - a) * x2 + a * x0;
                    ym0 = (1 - a) * y2 + a * y0;
                    a = f1 / (f1 - f0);
                    xm1 = (1 - a) * x1 + a * x0;
                    ym1 = (1 - a) * y1 + a * y0;
                    break;
            }

            if (Math.abs(xm1 - xm0) > xtolerance || Math.abs(ym1 - ym0) > ytolerance) {
                if (depth >= 0) {
                    return true; // At recursion bottom, just draw the line.
                } else {
                    accumulator.exhaust();
                }
            }
            intersections.push(xm1, ym1);
            return false;
        };

        // Interpolate each of the 4 edges, and descend if the interpolate routine
        // indicates further precision is necessary.
        if (interpolate(xtl, ytl, ftl, xtm, ytm, ftm, xtr, ytr, ftr)) {
            return descend();
        }
        if (interpolate(xtr, ytr, ftr, xmr, ymr, fmr, xbr, ybr, fbr)) {
            return descend();
        }
        if (interpolate(xbr, ybr, fbr, xbm, ybm, fbm, xbl, ybl, fbl)) {
            return descend();
        }
        if (interpolate(xbl, ybl, fbl, xml, yml, fml, xtl, ytl, ftl)) {
            return descend();
        }

        // Check for differing signs on either side of intersection midpoint
        var x1 = intersections[0];
        var y1 = intersections[1];
        var x2 = intersections[2];
        var y2 = intersections[3];

        var xm = Distance.mean(x1, x2);
        var ym = Distance.mean(y1, y2);

        var dx = x2 - x1;
        var dy = y2 - y1;

        var length = Distance.hypot(dx, dy);

        var fm = fn(xm, ym);
        var f1 = fn(xm + dy / length * ytolerance, ym - dx / length * xtolerance);
        var f2 = fn(xm - dy / length * ytolerance, ym + dx / length * xtolerance);

        if (f1 > fm === f2 > fm) return descend(); // Looks like an asymptote, not a 0 crossing.
        if (f1 > 0 === f2 > 0) {
            if (depth >= 0) {
                return descend();
            } else {
                accumulator.exhaust();
            }
        }

        accumulator.push(intersections);
    }

    function validateViewState(viewState) {
        if (!viewState) return false;
        var xmin = viewState.viewport.xmin;
        var xmax = viewState.viewport.xmax;
        var ymin = viewState.viewport.ymin;
        var ymax = viewState.viewport.ymax;
        if (!isFinite(xmin) || !isFinite(xmax) || xmax <= xmin) return false;
        if (!isFinite(ymin) || !isFinite(ymax) || ymax <= ymin) return false;
        if (!isFinite(viewState.screen.width) || viewState.screen.width <= 0) return false;
        if (!isFinite(viewState.screen.height) || viewState.screen.height <= 0) return false;
        return true;
    }

    // May return false to indicate either an unrecoginzed GRAPHMODE,
    // or function with a domain that doesn't overlap the viewport.
    function computeDomain(viewState, graphInfo, fn) {
        var xmin = viewState.viewport.xmin;
        var xmax = viewState.viewport.xmax;
        var ymin = viewState.viewport.ymin;
        var ymax = viewState.viewport.ymax;
        var trigAngleMultiplier = viewState.trigAngleMultiplier || 1.0;

        var oversample = viewState.oversample || 4;
        var xtolerance = 1 / oversample * (xmax - xmin) / viewState.screen.width;
        var ytolerance = 1 / oversample * (ymax - ymin) / viewState.screen.height;
        var domainBound = graphInfo.domainBound;

        var domain;
        switch (graphInfo.graphMode) {
            case GRAPHMODE.X:
                ymin = Math.max(ymin, domainBound[0]);
                ymax = Math.min(ymax, domainBound[1]);
                if (!isFinite(ymax) || !isFinite(ymin) || ymax <= ymin) return false;
                domain = {
                    min: ymin,
                    max: ymax,
                    xtolerance: ytolerance, // Note, switched
                    ytolerance: xtolerance,
                    step: ytolerance
                };
                break;
            case GRAPHMODE.Y:
                xmin = Math.max(xmin, domainBound[0]);
                xmax = Math.min(xmax, domainBound[1]);
                if (!isFinite(xmax) || !isFinite(xmin) || xmax <= xmin) return false;
                domain = {
                    min: xmin,
                    max: xmax,
                    xtolerance: xtolerance,
                    ytolerance: ytolerance,
                    step: xtolerance
                };
                break;
            case GRAPHMODE.POLAR:
                domain = {
                    min: 0,
                    max: 2 * Math.PI / trigAngleMultiplier * 6,
                    step: (2 * Math.PI / trigAngleMultiplier) / 1000,
                    tolerance: Math.min(xtolerance, ytolerance)
                };
                var period = findPiPeriod(fn, domain, trigAngleMultiplier, graphInfo.operator === '=');
                if (period) domain.max = domain.min + period;
                break;
            case GRAPHMODE.PARAMETRIC:
                //this catch fixes a bug where center coordinate of image
                //with free variables of t would crash
                if (graphInfo.domain) domain = {
                    min: graphInfo.domain.min,
                    max: graphInfo.domain.max,
                    step: graphInfo.domain.step,
                    xtolerance: xtolerance,
                    ytolerance: ytolerance
                };
                break;
            case GRAPHMODE.IMPLICIT:
                domain = {
                    xmin: xmin,
                    xmax: xmax,
                    ymin: ymin,
                    ymax: ymax,
                    xtolerance: xtolerance,
                    ytolerance: ytolerance
                };
                break;
            default:
                return false;
        }
        return domain;
    }

    function classifyBranchConic(segments) {
        var conic, segmentConic;
        if (segments.length === 1 && segments[0].length === 4) return 'line';
        for (var i = 0; i < segments.length; i++) {
            var segment = segments[i];
            var len = segment.length;
            if (len < 12) return 'unknown';
            try {
                segmentConic = Distance.classifyConic(
                    segment[0], segment[1],
                    segment[2 * Math.floor(1 * len / 12)], segment[2 * Math.floor(1 * len / 12) + 1],
                    segment[2 * Math.floor(2 * len / 12)], segment[2 * Math.floor(2 * len / 12) + 1],
                    segment[2 * Math.floor(3 * len / 12)], segment[2 * Math.floor(3 * len / 12) + 1],
                    segment[2 * Math.floor(4 * len / 12)], segment[2 * Math.floor(4 * len / 12) + 1],
                    segment[len - 2], segment[len - 1]
                );
            } catch (e) {
                // numeric.js's SVD routine can fail to converge and throw an error.
                return 'unknown';
            }

            if (segmentConic === 'none') return 'none';
            if (conic && segmentConic !== conic) return 'none';
            conic = segmentConic;
        }
        return conic;
    }

    //Computes domain, decides what function to use, and returns answer
    function computeGraphData(viewState, graphInfo, fn, derivative) {
        /* jshint maxcomplexity:12 */
        var domain = computeDomain(viewState, graphInfo, fn);
        var segmentData;
        var segments;
        var tmp;
        if (!domain) {
            segments = [];
            segmentData = { resolved: true };
        } else {
            switch (graphInfo.graphMode) {
                case GRAPHMODE.X:
                case GRAPHMODE.Y:
                    segmentData = graphInfo.isLinear ? sampleLinear(graphInfo.linearCoefficients, domain) : sampleXY(fn, domain);
                    break;
                case GRAPHMODE.POLAR:
                    segmentData = samplePolar(fn, domain);
                    break;
                case GRAPHMODE.IMPLICIT:
                    segmentData = sampleImplicitRecursive(fn, domain);
                    break;
                case GRAPHMODE.PARAMETRIC:
                    if (!domain.step) domain.step = (domain.max - domain.min) / 1000;
                    segmentData = sampleParametricRecursive(fn, domain);
            }

            segments = segmentData.segments;
        }


        var poi = [];
        if (
            graphInfo.graphMode !== GRAPHMODE.PARAMETRIC &&
            graphInfo.graphMode !== GRAPHMODE.IMPLICIT
        ) {
            poi = POI.findPOIs(segments, fn, derivative);
            segments = interleaveExtrema(segments, poi);
        }

        // Flip POI representation if necessary
        if (graphInfo.graphMode === GRAPHMODE.X) {
            for (var type in poi) {
                if (!poi.hasOwnProperty(type)) continue;
                tmp = poi[type].y;
                poi[type].y = poi[type].x;
                poi[type].x = tmp;
            }
        }

        var datum = {
            segments: segments,
            resolved: segmentData.resolved,
            graphMode: graphInfo.graphMode,
            color: graphInfo.color,
            style: graphInfo.style,
            operator: graphInfo.operator,
            poi: poi,
            conic: (graphInfo.graphMode === GRAPHMODE.IMPLICIT) ? 'unknown' : classifyBranchConic(segments),
            expr: null //compiled.fn
        };
        return datum;
    }

    function interleaveExtrema(segments, poi) {
        var nsegments = segments.length;
        var segment;
        var newSegments = Array(nsegments);
        var newSegment;
        var slen;
        var extrema = poi.extrema;
        var j = 0;
        var elen = extrema.x.length;

        for (var n = 0; n < nsegments; n++) {
            segment = segments[n];
            slen = segment.length;
            newSegment = [];
            for (var i = 0; i < slen; i = i + 2) {
                // push extrema between last point and current point onto
                // accumulator.
                while (j < elen && extrema.x[j] <= segment[i]) {
                    // Don't push the same point twice
                    if (extrema.x[j] !== segment[i]) {
                        newSegment.push(extrema.x[j], extrema.y[j]);
                    }
                    j++;
                }
                // push current point onto accumulator.
                newSegment.push(segment[i], segment[i + 1]);
            }
            newSegments[n] = newSegment;
        }
        return newSegments;
    }

    function polygonFromSegments(bottom_segments, top_segments, graphMode) {
        //TODO - respect graphMode (by pushing in proper order)
        var i, j, p, segment;
        var polygon = [];
        var map;
        switch (graphMode) {
            case GRAPHMODE.POLAR:
                map = this.mapPolar;
                break;
            case GRAPHMODE.X:
                map = function(p) { return [p[1], p[0]]; };
                break;
        }
        for (i = 0; i < bottom_segments.length; i++) {
            segment = bottom_segments[i];
            for (j = 0; j < segment.length; j += 2) {
                p = [segment[j], segment[j + 1]];
                if (map) p = map(p);
                polygon.push(p[0], p[1]);
            }
        }
        for (i = top_segments.length - 1; i >= 0; i--) {
            segment = top_segments[i];
            for (j = segment.length - 2; j >= 0; j -= 2) {
                p = [segment[j], segment[j + 1]];
                if (map) p = map(p);
                polygon.push(p[0], p[1]);
            }
        }
        return polygon;
    }


    function polygonsFromSegments(bottom_segments, top_segments, graphMode) {
        var last_x = function(segments) {
            var last_segment = segments[segments.length - 1];
            return last_segment[last_segment.length - 2];
        };

        var polygons = [];
        //Until we have pulled the last segment:
        //Continue to pull segments from the top and the bottom until we find two which end at the same point.
        //When that happens, close the polygon, and start another one.
        var i_top = 0;
        var i_bottom = 0;
        var current_bottom = [];
        var current_top = [];
        var top_x = -Infinity;
        var bottom_x = -Infinity;

        while (true) {

            if (top_x <= bottom_x) {
                if (i_top >= top_segments.length) break;
                current_top.push(top_segments[i_top++]);
            }
            if (bottom_x <= top_x) {
                if (i_bottom >= bottom_segments.length) break;
                current_bottom.push(bottom_segments[i_bottom++]);
            }
            top_x = last_x(current_top);
            bottom_x = last_x(current_bottom);

            if (top_x == bottom_x) {
                polygons.push(polygonFromSegments(current_bottom, current_top, graphMode));
                current_top = [];
                current_bottom = [];
            }
        }
        return polygons;
    }

    return {
        Accumulator: Accumulator,
        sampleParametricNaive: sampleParametricNaive,
        sampleXYNaive: sampleXYNaive,
        sampleLinear: sampleLinear,
        sampleXY: sampleXY,
        findPiPeriod: findPiPeriod,
        samplePolar: samplePolar,
        sampleParametricRecursive: sampleParametricRecursive,
        subsampleParametricRecursive: subsampleParametricRecursive,
        sampleImplicitRecursive: sampleImplicitRecursive,
        subsampleImplicitRecursive: subsampleImplicitRecursive,
        validateViewState: validateViewState,
        computeDomain: computeDomain,
        computeGraphData: computeGraphData,
        polygonsFromSegments: polygonsFromSegments
    };
});

define('jison', [], function() {
    var parser = {
        trace: function trace() {},
        yy: {},
        symbols_: { "error": 2, "sentence": 3, "expr": 4, "EOF": 5, "assignment": 6, "equation": 7, "function_declaration": 8, "regression": 9, "ordered_pair_list": 10, "double_inequality": 11, "boolean": 12, "identifier": 13, "=": 14, "FUNCTION_PROTOTYPE": 15, ",": 16, "~": 17, "comparator": 18, "IDENTIFIER_BASE": 19, "ordered_pair_list_elements": 20, "ordered_pair": 21, "(": 22, ")": 23, "list": 24, "[": 25, "list_elements": 26, "]": 27, "range": 28, "optional_commas_ellipsis": 29, "...": 30, "list_element_access": 31, "expr_atom": 32, "expr_sum": 33, "<": 34, ">": 35, ">=": 36, "<=": 37, "+": 38, "expr_product": 39, "-": 40, "expr_atom_impmul": 41, "*": 42, "/": 43, "exponent": 44, "^N": 45, "^I": 46, "^": 47, "{": 48, "}": 49, "function_call": 50, "function_call_unary": 51, "trig_function_call": 52, "log_function_call": 53, "ln_function_call": 54, "left|": 55, "right|": 56, "FRAC": 57, "SQRT": 58, "!": 59, "repeated_operator": 60, "DERIVATIVE": 61, "expr_piecewise": 62, "constant": 63, "NUMBER": 64, "repeated_operator_symbol": 65, "SUM": 66, "PROD": 67, "_": 68, "{_visible": 69, "piecewise_list": 70, "}_visible": 71, "incomplete_piecewise_list": 72, "piecewise_element": 73, ":": 74, "trig_function": 75, "TRIG_FUNCTION": 76, "log_prefix": 77, "LOG": 78, "LOG_BASE_N": 79, "LN": 80, "function_argument_list": 81, "$accept": 0, "$end": 1 },
        terminals_: { 2: "error", 5: "EOF", 14: "=", 15: "FUNCTION_PROTOTYPE", 16: ",", 17: "~", 19: "IDENTIFIER_BASE", 22: "(", 23: ")", 25: "[", 27: "]", 30: "...", 34: "<", 35: ">", 36: ">=", 37: "<=", 38: "+", 40: "-", 42: "*", 43: "/", 45: "^N", 46: "^I", 47: "^", 48: "{", 49: "}", 55: "left|", 56: "right|", 57: "FRAC", 58: "SQRT", 59: "!", 61: "DERIVATIVE", 64: "NUMBER", 66: "SUM", 67: "PROD", 68: "_", 69: "{_visible", 71: "}_visible", 74: ":", 76: "TRIG_FUNCTION", 78: "LOG", 79: "LOG_BASE_N", 80: "LN" },
        productions_: [0, [3, 2],
            [3, 2],
            [3, 2],
            [3, 2],
            [3, 2],
            [3, 2],
            [3, 2],
            [3, 2],
            [3, 3],
            [3, 2],
            [3, 4],
            [3, 1],
            [6, 3],
            [9, 3],
            [7, 3],
            [11, 5],
            [13, 1],
            [10, 1],
            [20, 1],
            [20, 3],
            [21, 5],
            [24, 3],
            [28, 5],
            [29, 1],
            [29, 2],
            [29, 2],
            [29, 3],
            [26, 1],
            [26, 3],
            [31, 4],
            [4, 1],
            [18, 1],
            [18, 1],
            [18, 1],
            [18, 1],
            [12, 3],
            [12, 3],
            [12, 5],
            [33, 3],
            [33, 3],
            [33, 1],
            [39, 2],
            [39, 3],
            [39, 3],
            [39, 1],
            [44, 1],
            [44, 1],
            [44, 4],
            [41, 1],
            [41, 1],
            [41, 1],
            [41, 1],
            [41, 1],
            [41, 1],
            [41, 3],
            [41, 3],
            [41, 3],
            [41, 2],
            [41, 7],
            [41, 4],
            [41, 7],
            [41, 2],
            [41, 1],
            [41, 2],
            [41, 1],
            [32, 1],
            [32, 3],
            [32, 2],
            [32, 2],
            [32, 2],
            [32, 1],
            [32, 1],
            [32, 1],
            [32, 1],
            [65, 1],
            [65, 1],
            [60, 9],
            [62, 3],
            [62, 2],
            [70, 3],
            [70, 1],
            [72, 3],
            [72, 1],
            [73, 3],
            [73, 1],
            [63, 1],
            [63, 2],
            [51, 5],
            [51, 4],
            [75, 1],
            [52, 4],
            [52, 2],
            [52, 7],
            [52, 9],
            [52, 3],
            [52, 5],
            [77, 1],
            [77, 1],
            [77, 3],
            [77, 5],
            [53, 4],
            [53, 2],
            [53, 5],
            [53, 3],
            [54, 4],
            [54, 2],
            [54, 5],
            [54, 3],
            [50, 4],
            [81, 3],
            [81, 3],
            [8, 2]
        ],
        performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {

            var $0 = $$.length - 1;
            switch (yystate) {
                case 1:
                    return $$[$0 - 1];
                    break;
                case 2:
                    return $$[$0 - 1];
                    break;
                case 3:
                    return $$[$0 - 1];
                    break;
                case 4:
                    return $$[$0 - 1];
                    break;
                case 5:
                    return $$[$0 - 1];
                    break;
                case 6:
                    return $$[$0 - 1];
                    break;
                case 7:
                    return $$[$0 - 1];
                    break;
                case 8:
                    return $$[$0 - 1];
                    break;
                case 9:
                    return yy.ErrorMsg.missingRHS($$[$0 - 2]._symbol);
                    break;
                case 10:
                    var symbol = yy.parseFunctionDeclaration($$[$0 - 1]).identifier._symbol;
                    return yy.ErrorMsg.missingRHS(symbol);

                    break;
                case 11:
                    return yy.ErrorMsg.malformedPoint();
                    break;
                case 12:
                    return yy.ErrorMsg.blankExpression();
                    break;
                case 13:
                    this.$ = yy.Assignment($$[$0 - 2], $$[$0]);
                    yy.setInput(this.$, this._$);

                    break;
                case 14:
                    this.$ = yy.Regression($$[$0 - 2], $$[$0]);
                    yy.setInput(this.$, this._$);

                    break;
                case 15:
                    this.$ = yy.Equation($$[$0 - 2], $$[$0]);
                    yy.setInput(this.$, this._$);

                    break;
                case 16:
                    this.$ = yy.DoubleInequality([$$[$0 - 4], $$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0]]);
                    yy.setInput(this.$, this._$);

                    break;
                case 17:
                    this.$ = yy.Identifier(yytext);
                    yy.setInput(this.$, this._$);

                    break;
                case 18:
                    this.$ = yy.OrderedPair.fromList($$[$0]);
                    yy.setInput(this.$, this._$);

                    break;
                case 19:
                    this.$ = [($$[$0])];
                    break;
                case 20:
                    $$[$0 - 2].push($$[$0]);
                    this.$ = $$[$0 - 2]
                    break;
                case 21:
                    this.$ = yy.OrderedPair([$$[$0 - 3], $$[$0 - 1]]);
                    break;
                case 22:
                    this.$ = yy.List($$[$0 - 1]);
                    yy.setInput(this.$, this._$);

                    break;
                case 23:
                    this.$ = yy.Range([yy.List($$[$0 - 3]), yy.List($$[$0 - 1])]);
                    break;
                case 28:
                    this.$ = [$$[$0]]
                    break;
                case 29:
                    $$[$0 - 2].push($$[$0]);
                    this.$ = $$[$0 - 2]
                    break;
                case 30:
                    this.$ = yy.ListAccess([$$[$0 - 3], $$[$0 - 1]])
                    break;
                case 31:
                    this.$ = $$[$0];
                    yy.setInput(this.$, this._$);

                    break;
                case 32:
                    this.$ = '<'
                    break;
                case 33:
                    this.$ = '>'
                    break;
                case 34:
                    this.$ = '>='
                    break;
                case 35:
                    this.$ = '<='
                    break;
                case 36:
                    this.$ = yy.Comparator[$$[$0 - 1]]([$$[$0 - 2], $$[$0]]);
                    yy.setInput(this.$, this._$);

                    break;
                case 37:
                    this.$ = yy.Comparator['=']([$$[$0 - 2], $$[$0]]);
                    yy.setInput(this.$, this._$);

                    break;
                case 38:
                    var c1 = yy.Comparator[$$[$0 - 3]]([$$[$0 - 4], $$[$0 - 2]]);
                    var c2 = yy.Comparator[$$[$0 - 1]]([$$[$0 - 2], $$[$0]]);
                    this.$ = yy.And([c1, c2]);
                    yy.setInput(this.$, this._$);

                    break;
                case 39:
                    this.$ = yy.Add([$$[$0 - 2], $$[$0]]);
                    break;
                case 40:
                    this.$ = yy.Subtract([$$[$0 - 2], $$[$0]]);
                    break;
                case 41:
                    this.$ = $$[$0]
                    break;
                case 42:
                    this.$ = yy.Multiply([$$[$0 - 1], $$[$0]]);
                    break;
                case 43:
                    this.$ = yy.Multiply([$$[$0 - 2], $$[$0]]);
                    break;
                case 44:
                    this.$ = yy.Divide([$$[$0 - 2], $$[$0]]);
                    break;
                case 45:
                    this.$ = $$[$0];
                    break;
                case 46:
                    this.$ = yy.Constant(Number($$[$0]));
                    break;
                case 47:
                    this.$ = yy.Identifier($$[$0]);
                    break;
                case 48:
                    this.$ = $$[$0 - 1];
                    break;
                case 49:
                    this.$ = $$[$0];
                    break;
                case 50:
                    this.$ = $$[$0];
                    break;
                case 51:
                    this.$ = $$[$0];
                    break;
                case 52:
                    this.$ = $$[$0];
                    break;
                case 53:
                    this.$ = $$[$0];
                    break;
                case 54:
                    this.$ = $$[$0];
                    break;
                case 55:
                    this.$ = $$[$0 - 1];
                    break;
                case 56:
                    this.$ = $$[$0 - 1];
                    break;
                case 57:
                    this.$ = yy.FunctionCall('\\abs', [$$[$0 - 1]]);
                    break;
                case 58:
                    this.$ = yy.Exponent([$$[$0 - 1], $$[$0]]);
                    break;
                case 59:
                    this.$ = yy.Divide([$$[$0 - 4], $$[$0 - 1]]);
                    break;
                case 60:
                    this.$ = yy.FunctionCall('\\sqrt', [$$[$0 - 1]]);
                    break;
                case 61:
                    this.$ = yy.FunctionCall('\\nthroot', [$$[$0 - 1], $$[$0 - 4]]);
                    break;
                case 62:
                    this.$ = yy.FunctionCall('\\factorial', [$$[$0 - 1]])
                    break;
                case 63:
                    this.$ = $$[$0];
                    break;
                case 64:
                    this.$ = yy.Derivative($$[$0 - 1], [$$[$0]]);
                    break;
                case 65:
                    this.$ = $$[$0]
                    break;
                case 66:
                    this.$ = $$[$0];
                    break;
                case 67:
                    this.$ = yy.Negative([yy.Exponent([yy.Constant(Number($$[$0 - 1])), $$[$0]])]);
                    break;
                case 68:
                    this.$ = yy.Exponent([$$[$0 - 1], $$[$0]]);
                    break;
                case 69:
                    this.$ = yy.FunctionCall('\\factorial', [$$[$0 - 1]])
                    break;
                case 70:
                    this.$ = yy.Negative([$$[$0]])
                    break;
                case 71:
                    this.$ = $$[$0]
                    break;
                case 72:
                    this.$ = $$[$0]
                    break;
                case 73:
                    this.$ = $$[$0]
                    break;
                case 74:
                    this.$ = $$[$0]
                    break;
                case 75:
                    this.$ = yy.Sum;
                    break;
                case 76:
                    this.$ = yy.Product;
                    break;
                case 77:
                    this.$ = $$[$0 - 8]([$$[$0 - 5], $$[$0 - 3], $$[$0 - 1], $$[$0]]);
                    break;
                case 78:
                    this.$ = yy.Piecewise.chain($$[$0 - 1]);
                    break;
                case 79:
                    this.$ = yy.Constant(1);
                    break;
                case 80:
                    $$[$0 - 2].push({ condition: yy.Constant(true), if_expr: $$[$0] });
                    this.$ = $$[$0 - 2];
                    break;
                case 81:
                    this.$ = $$[$0]
                    break;
                case 82:
                    $$[$0 - 2].push($$[$0]);
                    this.$ = $$[$0 - 2];
                    break;
                case 83:
                    this.$ = [$$[$0]];
                    break;
                case 84:
                    this.$ = { condition: $$[$0 - 2], if_expr: $$[$0] };
                    break;
                case 85:
                    this.$ = { condition: $$[$0], if_expr: yy.Constant(1) };
                    break;
                case 86:
                    this.$ = yy.Constant(Number(yytext));
                    break;
                case 87:
                    this.$ = yy.Constant(-$$[$0])
                    break;
                case 88:
                    this.$ = yy.FunctionExponent([$$[$0 - 4], $$[$0 - 2], $$[$0]]);
                    break;
                case 89:
                    this.$ = yy.FunctionCall($$[$0 - 3], [$$[$0 - 1]]);
                    break;
                case 90:
                    this.$ = yy.Identifier(yytext);
                    break;
                case 91:
                    this.$ = yy.FunctionCall($$[$0 - 3], [$$[$0 - 1]]);
                    break;
                case 92:
                    if (!$$[$0].okForImplicitFunction()) { throw yy.ErrorMsg.badTrigImplicitMultiply(); };
                    this.$ = yy.FunctionCall($$[$0 - 1], [$$[$0]]);

                    break;
                case 93:
                    if (!$$[$0].okForImplicitFunction()) { throw yy.ErrorMsg.badTrigImplicitMultiply(); };
                    if ($$[$0 - 2].constantValue != 1) { throw yy.ErrorMsg.badTrigExponent($$[$0 - 6]._symbol); };
                    this.$ = yy.FunctionCall(yy.Identifier(yy.inverses[$$[$0 - 6]._symbol]), [$$[$0]]);

                    break;
                case 94:
                    if ($$[$0 - 4].constantValue != 1) { throw yy.ErrorMsg.badTrigExponent($$[$0 - 8]._symbol); };
                    this.$ = yy.FunctionCall(yy.Identifier(yy.inverses[$$[$0 - 8]._symbol]), [$$[$0 - 1]]);

                    break;
                case 95:
                    if (!$$[$0].okForImplicitFunction()) { throw yy.ErrorMsg.badTrigImplicitMultiply(); };
                    if ($$[$0 - 1] != "2") { throw yy.ErrorMsg.badTrigExponent($$[$0 - 2]._symbol); };
                    this.$ = yy.Exponent([yy.FunctionCall($$[$0 - 2], [$$[$0]]), yy.Constant(2)]);

                    break;
                case 96:
                    if ($$[$0 - 3] != "2") { throw yy.ErrorMsg.badTrigExponent($$[$0 - 4]._symbol); };
                    this.$ = yy.Exponent([yy.FunctionCall($$[$0 - 4], [$$[$0 - 1]]), yy.Constant(2)]);

                    break;
                case 97:
                    this.$ = yy.Constant(10)
                    break;
                case 98:
                    this.$ = yy.Constant(Number(yytext));
                    break;
                case 99:
                    this.$ = $$[$0]
                    break;
                case 100:
                    this.$ = $$[$0 - 1]
                    break;
                case 101:
                    this.$ = yy.FunctionCall(yy.Identifier('log'), [$$[$0 - 1], $$[$0 - 3]])
                    break;
                case 102:
                    if (!$$[$0].okForImplicitFunction()) { throw yy.ErrorMsg.badLogImplicitMultiply(); };
                    this.$ = yy.FunctionCall(yy.Identifier('log'), [$$[$0], $$[$0 - 1]])

                    break;
                case 103:
                    if ($$[$0 - 3] != "2") { throw yy.ErrorMsg.badLogExponent('log'); }
                    this.$ = yy.Exponent([yy.FunctionCall(yy.Identifier('log'), [$$[$0 - 1], $$[$0 - 4]]), yy.Constant(2)])

                    break;
                case 104:
                    if (!$$[$0].okForImplicitFunction()) { throw yy.ErrorMsg.badLogImplicitMultiply(); };
                    if ($$[$0 - 1] != "2") { throw yy.ErrorMsg.badLogExponent('log'); }
                    this.$ = yy.Exponent([yy.FunctionCall(yy.Identifier('log'), [$$[$0], $$[$0 - 2]]), yy.Constant(2)])

                    break;
                case 105:
                    this.$ = yy.FunctionCall(yy.Identifier('ln'), [$$[$0 - 1]])
                    break;
                case 106:
                    if (!$$[$0].okForImplicitFunction()) { throw yy.ErrorMsg.badLogImplicitMultiply(); };
                    this.$ = yy.FunctionCall(yy.Identifier('ln'), [$$[$0]])

                    break;
                case 107:
                    if ($$[$0 - 3] != "2") { throw yy.ErrorMsg.badLogExponent('ln'); }
                    this.$ = yy.Exponent([yy.FunctionCall(yy.Identifier('ln'), [$$[$0 - 1]]), yy.Constant(2)])

                    break;
                case 108:
                    if (!$$[$0].okForImplicitFunction()) { throw yy.ErrorMsg.badLogImplicitMultiply(); };
                    if ($$[$0 - 1] != "2") { throw yy.ErrorMsg.badLogExponent('ln'); }
                    this.$ = yy.Exponent([yy.FunctionCall(yy.Identifier('ln'), [$$[$0]]), yy.Constant(2)])

                    break;
                case 109:
                    this.$ = yy.FunctionCall($$[$0 - 3], $$[$0 - 1]);
                    break;
                case 110:
                    this.$ = $$[$0 - 2].concat([$$[$0]]);
                    break;
                case 111:
                    this.$ = [$$[$0 - 2], $$[$0]];
                    break;
                case 112:
                    var val = yy.parseFunctionDeclaration($$[$0 - 1]);
                    this.$ = yy.FunctionDefinition(val.identifier, val.args, $$[$0]);
                    yy.setInput(this.$, this._$);

                    break;
            }
        },
        table: [{ 3: 1, 4: 2, 5: [1, 12], 6: 3, 7: 4, 8: 5, 9: 6, 10: 7, 11: 8, 12: 9, 13: 10, 15: [1, 11], 19: [1, 15], 20: 14, 21: 17, 22: [1, 19], 24: 22, 25: [1, 27], 28: 23, 31: 24, 32: 18, 33: 13, 39: 16, 40: [1, 21], 41: 25, 48: [1, 33], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 57: [1, 35], 58: [1, 36], 60: 37, 61: [1, 38], 62: 39, 63: 20, 64: [1, 26], 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 1: [3] }, { 5: [1, 50], 14: [1, 52], 16: [1, 51], 17: [1, 53], 18: 54, 34: [1, 55], 35: [1, 56], 36: [1, 57], 37: [1, 58] }, { 5: [1, 59] }, { 5: [1, 60] }, { 5: [1, 61] }, { 5: [1, 62] }, { 5: [1, 63] }, { 5: [1, 64] }, { 5: [1, 65] }, { 5: [2, 49], 14: [1, 66], 16: [2, 49], 17: [2, 49], 19: [2, 49], 22: [1, 67], 25: [2, 49], 34: [2, 49], 35: [2, 49], 36: [2, 49], 37: [2, 49], 38: [2, 49], 40: [2, 49], 42: [2, 49], 43: [2, 49], 45: [2, 49], 46: [2, 49], 47: [2, 49], 48: [2, 49], 55: [2, 49], 57: [2, 49], 58: [2, 49], 59: [2, 49], 61: [2, 49], 66: [2, 49], 67: [2, 49], 69: [2, 49], 76: [2, 49], 78: [2, 49], 79: [2, 49], 80: [2, 49] }, { 4: 69, 5: [1, 68], 13: 70, 19: [1, 15], 22: [1, 71], 24: 22, 25: [1, 27], 28: 23, 31: 24, 32: 18, 33: 13, 39: 16, 40: [1, 21], 41: 25, 48: [1, 33], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 57: [1, 35], 58: [1, 36], 60: 37, 61: [1, 38], 62: 39, 63: 20, 64: [1, 26], 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 1: [2, 12] }, { 5: [2, 31], 14: [2, 31], 16: [2, 31], 17: [2, 31], 19: [2, 31], 22: [2, 31], 23: [2, 31], 25: [2, 31], 27: [2, 31], 30: [2, 31], 34: [2, 31], 35: [2, 31], 36: [2, 31], 37: [2, 31], 38: [1, 72], 40: [1, 73], 42: [2, 31], 43: [2, 31], 45: [2, 31], 46: [2, 31], 47: [2, 31], 48: [2, 31], 49: [2, 31], 55: [2, 31], 56: [2, 31], 57: [2, 31], 58: [2, 31], 59: [2, 31], 61: [2, 31], 66: [2, 31], 67: [2, 31], 69: [2, 31], 71: [2, 31], 74: [2, 31], 76: [2, 31], 78: [2, 31], 79: [2, 31], 80: [2, 31] }, { 5: [2, 18], 16: [1, 74] }, { 5: [2, 17], 14: [2, 17], 16: [2, 17], 17: [2, 17], 19: [2, 17], 22: [2, 17], 23: [2, 17], 25: [2, 17], 27: [2, 17], 30: [2, 17], 34: [2, 17], 35: [2, 17], 36: [2, 17], 37: [2, 17], 38: [2, 17], 40: [2, 17], 42: [2, 17], 43: [2, 17], 45: [2, 17], 46: [2, 17], 47: [2, 17], 48: [2, 17], 49: [2, 17], 55: [2, 17], 56: [2, 17], 57: [2, 17], 58: [2, 17], 59: [2, 17], 61: [2, 17], 64: [2, 17], 66: [2, 17], 67: [2, 17], 69: [2, 17], 71: [2, 17], 74: [2, 17], 76: [2, 17], 78: [2, 17], 79: [2, 17], 80: [2, 17] }, { 5: [2, 41], 13: 70, 14: [2, 41], 16: [2, 41], 17: [2, 41], 19: [1, 15], 22: [1, 71], 23: [2, 41], 25: [2, 41], 27: [2, 41], 30: [2, 41], 34: [2, 41], 35: [2, 41], 36: [2, 41], 37: [2, 41], 38: [2, 41], 40: [2, 41], 41: 75, 42: [1, 76], 43: [1, 77], 45: [2, 41], 46: [2, 41], 47: [2, 41], 48: [1, 33], 49: [2, 41], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 56: [2, 41], 57: [1, 35], 58: [1, 36], 59: [2, 41], 60: 37, 61: [1, 38], 62: 39, 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 71: [2, 41], 74: [2, 41], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 5: [2, 19], 16: [2, 19] }, { 5: [2, 45], 14: [2, 45], 16: [2, 45], 17: [2, 45], 19: [2, 45], 22: [2, 45], 23: [2, 45], 25: [1, 80], 27: [2, 45], 30: [2, 45], 34: [2, 45], 35: [2, 45], 36: [2, 45], 37: [2, 45], 38: [2, 45], 40: [2, 45], 42: [2, 45], 43: [2, 45], 44: 78, 45: [1, 81], 46: [1, 82], 47: [1, 83], 48: [2, 45], 49: [2, 45], 55: [2, 45], 56: [2, 45], 57: [2, 45], 58: [2, 45], 59: [1, 79], 61: [2, 45], 66: [2, 45], 67: [2, 45], 69: [2, 45], 71: [2, 45], 74: [2, 45], 76: [2, 45], 78: [2, 45], 79: [2, 45], 80: [2, 45] }, { 4: 84, 13: 70, 19: [1, 15], 22: [1, 71], 24: 22, 25: [1, 27], 28: 23, 31: 24, 32: 18, 33: 13, 39: 16, 40: [1, 21], 41: 25, 48: [1, 33], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 57: [1, 35], 58: [1, 36], 60: 37, 61: [1, 38], 62: 39, 63: 20, 64: [1, 26], 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 5: [2, 66], 14: [2, 66], 16: [2, 66], 17: [2, 66], 19: [2, 66], 22: [2, 66], 23: [2, 66], 25: [2, 66], 27: [2, 66], 30: [2, 66], 34: [2, 66], 35: [2, 66], 36: [2, 66], 37: [2, 66], 38: [2, 66], 40: [2, 66], 42: [2, 66], 43: [2, 66], 45: [2, 66], 46: [2, 66], 47: [2, 66], 48: [2, 66], 49: [2, 66], 55: [2, 66], 56: [2, 66], 57: [2, 66], 58: [2, 66], 59: [2, 66], 61: [2, 66], 66: [2, 66], 67: [2, 66], 69: [2, 66], 71: [2, 66], 74: [2, 66], 76: [2, 66], 78: [2, 66], 79: [2, 66], 80: [2, 66] }, { 13: 70, 19: [1, 15], 22: [1, 71], 24: 22, 25: [1, 27], 28: 23, 31: 24, 32: 86, 40: [1, 21], 41: 25, 48: [1, 33], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 57: [1, 35], 58: [1, 36], 60: 37, 61: [1, 38], 62: 39, 63: 20, 64: [1, 85], 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 5: [2, 71], 14: [2, 71], 16: [2, 71], 17: [2, 71], 19: [2, 71], 22: [2, 71], 23: [2, 71], 25: [2, 71], 27: [2, 71], 30: [2, 71], 34: [2, 71], 35: [2, 71], 36: [2, 71], 37: [2, 71], 38: [2, 71], 40: [2, 71], 42: [2, 71], 43: [2, 71], 45: [2, 71], 46: [2, 71], 47: [2, 71], 48: [2, 71], 49: [2, 71], 55: [2, 71], 56: [2, 71], 57: [2, 71], 58: [2, 71], 59: [2, 71], 61: [2, 71], 66: [2, 71], 67: [2, 71], 69: [2, 71], 71: [2, 71], 74: [2, 71], 76: [2, 71], 78: [2, 71], 79: [2, 71], 80: [2, 71] }, { 5: [2, 72], 14: [2, 72], 16: [2, 72], 17: [2, 72], 19: [2, 72], 22: [2, 72], 23: [2, 72], 25: [2, 72], 27: [2, 72], 30: [2, 72], 34: [2, 72], 35: [2, 72], 36: [2, 72], 37: [2, 72], 38: [2, 72], 40: [2, 72], 42: [2, 72], 43: [2, 72], 45: [2, 72], 46: [2, 72], 47: [2, 72], 48: [2, 72], 49: [2, 72], 55: [2, 72], 56: [2, 72], 57: [2, 72], 58: [2, 72], 59: [2, 72], 61: [2, 72], 66: [2, 72], 67: [2, 72], 69: [2, 72], 71: [2, 72], 74: [2, 72], 76: [2, 72], 78: [2, 72], 79: [2, 72], 80: [2, 72] }, { 5: [2, 73], 14: [2, 73], 16: [2, 73], 17: [2, 73], 19: [2, 73], 22: [2, 73], 23: [2, 73], 25: [2, 73], 27: [2, 73], 30: [2, 73], 34: [2, 73], 35: [2, 73], 36: [2, 73], 37: [2, 73], 38: [2, 73], 40: [2, 73], 42: [2, 73], 43: [2, 73], 45: [2, 73], 46: [2, 73], 47: [2, 73], 48: [2, 73], 49: [2, 73], 55: [2, 73], 56: [2, 73], 57: [2, 73], 58: [2, 73], 59: [2, 73], 61: [2, 73], 66: [2, 73], 67: [2, 73], 69: [2, 73], 71: [2, 73], 74: [2, 73], 76: [2, 73], 78: [2, 73], 79: [2, 73], 80: [2, 73] }, { 5: [2, 74], 14: [2, 74], 16: [2, 74], 17: [2, 74], 19: [2, 74], 22: [2, 74], 23: [2, 74], 25: [2, 74], 27: [2, 74], 30: [2, 74], 34: [2, 74], 35: [2, 74], 36: [2, 74], 37: [2, 74], 38: [2, 74], 40: [2, 74], 42: [2, 74], 43: [2, 74], 44: 87, 45: [1, 81], 46: [1, 82], 47: [1, 83], 48: [2, 74], 49: [2, 74], 55: [2, 74], 56: [2, 74], 57: [2, 74], 58: [2, 74], 59: [1, 88], 61: [2, 74], 66: [2, 74], 67: [2, 74], 69: [2, 74], 71: [2, 74], 74: [2, 74], 76: [2, 74], 78: [2, 74], 79: [2, 74], 80: [2, 74] }, { 5: [2, 86], 14: [2, 86], 16: [2, 86], 17: [2, 86], 19: [2, 86], 22: [2, 86], 23: [2, 86], 25: [2, 86], 27: [2, 86], 30: [2, 86], 34: [2, 86], 35: [2, 86], 36: [2, 86], 37: [2, 86], 38: [2, 86], 40: [2, 86], 42: [2, 86], 43: [2, 86], 45: [2, 86], 46: [2, 86], 47: [2, 86], 48: [2, 86], 49: [2, 86], 55: [2, 86], 56: [2, 86], 57: [2, 86], 58: [2, 86], 59: [2, 86], 61: [2, 86], 66: [2, 86], 67: [2, 86], 69: [2, 86], 71: [2, 86], 74: [2, 86], 76: [2, 86], 78: [2, 86], 79: [2, 86], 80: [2, 86] }, { 4: 90, 13: 70, 19: [1, 15], 22: [1, 71], 24: 22, 25: [1, 27], 26: 89, 28: 23, 31: 24, 32: 18, 33: 13, 39: 16, 40: [1, 21], 41: 25, 48: [1, 33], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 57: [1, 35], 58: [1, 36], 60: 37, 61: [1, 38], 62: 39, 63: 20, 64: [1, 26], 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 5: [2, 50], 14: [2, 50], 16: [2, 50], 17: [2, 50], 19: [2, 50], 22: [2, 50], 23: [2, 50], 25: [2, 50], 27: [2, 50], 30: [2, 50], 34: [2, 50], 35: [2, 50], 36: [2, 50], 37: [2, 50], 38: [2, 50], 40: [2, 50], 42: [2, 50], 43: [2, 50], 45: [2, 50], 46: [2, 50], 47: [2, 50], 48: [2, 50], 49: [2, 50], 55: [2, 50], 56: [2, 50], 57: [2, 50], 58: [2, 50], 59: [2, 50], 61: [2, 50], 66: [2, 50], 67: [2, 50], 69: [2, 50], 71: [2, 50], 74: [2, 50], 76: [2, 50], 78: [2, 50], 79: [2, 50], 80: [2, 50] }, { 5: [2, 51], 14: [2, 51], 16: [2, 51], 17: [2, 51], 19: [2, 51], 22: [2, 51], 23: [2, 51], 25: [2, 51], 27: [2, 51], 30: [2, 51], 34: [2, 51], 35: [2, 51], 36: [2, 51], 37: [2, 51], 38: [2, 51], 40: [2, 51], 42: [2, 51], 43: [2, 51], 45: [2, 51], 46: [2, 51], 47: [2, 51], 48: [2, 51], 49: [2, 51], 55: [2, 51], 56: [2, 51], 57: [2, 51], 58: [2, 51], 59: [2, 51], 61: [2, 51], 66: [2, 51], 67: [2, 51], 69: [2, 51], 71: [2, 51], 74: [2, 51], 76: [2, 51], 78: [2, 51], 79: [2, 51], 80: [2, 51] }, { 5: [2, 52], 14: [2, 52], 16: [2, 52], 17: [2, 52], 19: [2, 52], 22: [2, 52], 23: [2, 52], 25: [2, 52], 27: [2, 52], 30: [2, 52], 34: [2, 52], 35: [2, 52], 36: [2, 52], 37: [2, 52], 38: [2, 52], 40: [2, 52], 42: [2, 52], 43: [2, 52], 45: [2, 52], 46: [2, 52], 47: [2, 52], 48: [2, 52], 49: [2, 52], 55: [2, 52], 56: [2, 52], 57: [2, 52], 58: [2, 52], 59: [2, 52], 61: [2, 52], 66: [2, 52], 67: [2, 52], 69: [2, 52], 71: [2, 52], 74: [2, 52], 76: [2, 52], 78: [2, 52], 79: [2, 52], 80: [2, 52] }, { 5: [2, 53], 14: [2, 53], 16: [2, 53], 17: [2, 53], 19: [2, 53], 22: [2, 53], 23: [2, 53], 25: [2, 53], 27: [2, 53], 30: [2, 53], 34: [2, 53], 35: [2, 53], 36: [2, 53], 37: [2, 53], 38: [2, 53], 40: [2, 53], 42: [2, 53], 43: [2, 53], 45: [2, 53], 46: [2, 53], 47: [2, 53], 48: [2, 53], 49: [2, 53], 55: [2, 53], 56: [2, 53], 57: [2, 53], 58: [2, 53], 59: [2, 53], 61: [2, 53], 66: [2, 53], 67: [2, 53], 69: [2, 53], 71: [2, 53], 74: [2, 53], 76: [2, 53], 78: [2, 53], 79: [2, 53], 80: [2, 53] }, { 5: [2, 54], 14: [2, 54], 16: [2, 54], 17: [2, 54], 19: [2, 54], 22: [2, 54], 23: [2, 54], 25: [2, 54], 27: [2, 54], 30: [2, 54], 34: [2, 54], 35: [2, 54], 36: [2, 54], 37: [2, 54], 38: [2, 54], 40: [2, 54], 42: [2, 54], 43: [2, 54], 45: [2, 54], 46: [2, 54], 47: [2, 54], 48: [2, 54], 49: [2, 54], 55: [2, 54], 56: [2, 54], 57: [2, 54], 58: [2, 54], 59: [2, 54], 61: [2, 54], 66: [2, 54], 67: [2, 54], 69: [2, 54], 71: [2, 54], 74: [2, 54], 76: [2, 54], 78: [2, 54], 79: [2, 54], 80: [2, 54] }, { 4: 91, 13: 70, 19: [1, 15], 22: [1, 71], 24: 22, 25: [1, 27], 28: 23, 31: 24, 32: 18, 33: 13, 39: 16, 40: [1, 21], 41: 25, 48: [1, 33], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 57: [1, 35], 58: [1, 36], 60: 37, 61: [1, 38], 62: 39, 63: 20, 64: [1, 26], 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 4: 92, 13: 70, 19: [1, 15], 22: [1, 71], 24: 22, 25: [1, 27], 28: 23, 31: 24, 32: 18, 33: 13, 39: 16, 40: [1, 21], 41: 25, 48: [1, 33], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 57: [1, 35], 58: [1, 36], 60: 37, 61: [1, 38], 62: 39, 63: 20, 64: [1, 26], 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 48: [1, 93] }, { 25: [1, 95], 48: [1, 94] }, { 5: [2, 63], 14: [2, 63], 16: [2, 63], 17: [2, 63], 19: [2, 63], 22: [2, 63], 23: [2, 63], 25: [2, 63], 27: [2, 63], 30: [2, 63], 34: [2, 63], 35: [2, 63], 36: [2, 63], 37: [2, 63], 38: [2, 63], 40: [2, 63], 42: [2, 63], 43: [2, 63], 45: [2, 63], 46: [2, 63], 47: [2, 63], 48: [2, 63], 49: [2, 63], 55: [2, 63], 56: [2, 63], 57: [2, 63], 58: [2, 63], 59: [2, 63], 61: [2, 63], 66: [2, 63], 67: [2, 63], 69: [2, 63], 71: [2, 63], 74: [2, 63], 76: [2, 63], 78: [2, 63], 79: [2, 63], 80: [2, 63] }, { 13: 70, 19: [1, 15], 22: [1, 71], 24: 22, 25: [1, 27], 28: 23, 31: 24, 32: 18, 39: 96, 40: [1, 21], 41: 25, 48: [1, 33], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 57: [1, 35], 58: [1, 36], 60: 37, 61: [1, 38], 62: 39, 63: 20, 64: [1, 26], 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 5: [2, 65], 14: [2, 65], 16: [2, 65], 17: [2, 65], 19: [2, 65], 22: [2, 65], 23: [2, 65], 25: [2, 65], 27: [2, 65], 30: [2, 65], 34: [2, 65], 35: [2, 65], 36: [2, 65], 37: [2, 65], 38: [2, 65], 40: [2, 65], 42: [2, 65], 43: [2, 65], 45: [2, 65], 46: [2, 65], 47: [2, 65], 48: [2, 65], 49: [2, 65], 55: [2, 65], 56: [2, 65], 57: [2, 65], 58: [2, 65], 59: [2, 65], 61: [2, 65], 66: [2, 65], 67: [2, 65], 69: [2, 65], 71: [2, 65], 74: [2, 65], 76: [2, 65], 78: [2, 65], 79: [2, 65], 80: [2, 65] }, { 13: 70, 19: [1, 15], 22: [1, 97], 24: 22, 25: [1, 27], 28: 23, 31: 24, 32: 18, 39: 98, 40: [1, 21], 41: 25, 45: [1, 100], 47: [1, 99], 48: [1, 33], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 57: [1, 35], 58: [1, 36], 60: 37, 61: [1, 38], 62: 39, 63: 20, 64: [1, 26], 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 13: 70, 19: [1, 15], 22: [1, 101], 24: 22, 25: [1, 27], 28: 23, 31: 24, 32: 18, 39: 102, 40: [1, 21], 41: 25, 45: [1, 103], 48: [1, 33], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 57: [1, 35], 58: [1, 36], 60: 37, 61: [1, 38], 62: 39, 63: 20, 64: [1, 26], 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 13: 70, 19: [1, 15], 22: [1, 104], 24: 22, 25: [1, 27], 28: 23, 31: 24, 32: 18, 39: 105, 40: [1, 21], 41: 25, 45: [1, 106], 48: [1, 33], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 57: [1, 35], 58: [1, 36], 60: 37, 61: [1, 38], 62: 39, 63: 20, 64: [1, 26], 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 68: [1, 107] }, { 4: 113, 12: 112, 13: 70, 19: [1, 15], 22: [1, 71], 24: 22, 25: [1, 27], 28: 23, 31: 24, 32: 18, 33: 13, 39: 16, 40: [1, 21], 41: 25, 48: [1, 33], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 57: [1, 35], 58: [1, 36], 60: 37, 61: [1, 38], 62: 39, 63: 20, 64: [1, 26], 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 70: 108, 71: [1, 109], 72: 110, 73: 111, 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 19: [2, 90], 22: [2, 90], 25: [2, 90], 40: [2, 90], 45: [2, 90], 47: [2, 90], 48: [2, 90], 55: [2, 90], 57: [2, 90], 58: [2, 90], 61: [2, 90], 64: [2, 90], 66: [2, 90], 67: [2, 90], 69: [2, 90], 76: [2, 90], 78: [2, 90], 79: [2, 90], 80: [2, 90] }, { 19: [2, 97], 22: [2, 97], 25: [2, 97], 40: [2, 97], 45: [2, 97], 48: [2, 97], 55: [2, 97], 57: [2, 97], 58: [2, 97], 61: [2, 97], 64: [2, 97], 66: [2, 97], 67: [2, 97], 68: [1, 114], 69: [2, 97], 76: [2, 97], 78: [2, 97], 79: [2, 97], 80: [2, 97] }, { 19: [2, 98], 22: [2, 98], 25: [2, 98], 40: [2, 98], 45: [2, 98], 48: [2, 98], 55: [2, 98], 57: [2, 98], 58: [2, 98], 61: [2, 98], 64: [2, 98], 66: [2, 98], 67: [2, 98], 69: [2, 98], 76: [2, 98], 78: [2, 98], 79: [2, 98], 80: [2, 98] }, { 68: [2, 75] }, { 68: [2, 76] }, { 1: [2, 1] }, { 4: 115, 13: 70, 19: [1, 15], 22: [1, 71], 24: 22, 25: [1, 27], 28: 23, 31: 24, 32: 18, 33: 13, 39: 16, 40: [1, 21], 41: 25, 48: [1, 33], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 57: [1, 35], 58: [1, 36], 60: 37, 61: [1, 38], 62: 39, 63: 20, 64: [1, 26], 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 4: 116, 13: 70, 19: [1, 15], 22: [1, 71], 24: 22, 25: [1, 27], 28: 23, 31: 24, 32: 18, 33: 13, 39: 16, 40: [1, 21], 41: 25, 48: [1, 33], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 57: [1, 35], 58: [1, 36], 60: 37, 61: [1, 38], 62: 39, 63: 20, 64: [1, 26], 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 4: 117, 13: 70, 19: [1, 15], 22: [1, 71], 24: 22, 25: [1, 27], 28: 23, 31: 24, 32: 18, 33: 13, 39: 16, 40: [1, 21], 41: 25, 48: [1, 33], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 57: [1, 35], 58: [1, 36], 60: 37, 61: [1, 38], 62: 39, 63: 20, 64: [1, 26], 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 4: 119, 13: 118, 19: [1, 15], 22: [1, 71], 24: 22, 25: [1, 27], 28: 23, 31: 24, 32: 18, 33: 13, 39: 16, 40: [1, 21], 41: 25, 48: [1, 33], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 57: [1, 35], 58: [1, 36], 60: 37, 61: [1, 38], 62: 39, 63: 20, 64: [1, 26], 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 19: [2, 32], 22: [2, 32], 25: [2, 32], 40: [2, 32], 48: [2, 32], 55: [2, 32], 57: [2, 32], 58: [2, 32], 61: [2, 32], 64: [2, 32], 66: [2, 32], 67: [2, 32], 69: [2, 32], 76: [2, 32], 78: [2, 32], 79: [2, 32], 80: [2, 32] }, { 19: [2, 33], 22: [2, 33], 25: [2, 33], 40: [2, 33], 48: [2, 33], 55: [2, 33], 57: [2, 33], 58: [2, 33], 61: [2, 33], 64: [2, 33], 66: [2, 33], 67: [2, 33], 69: [2, 33], 76: [2, 33], 78: [2, 33], 79: [2, 33], 80: [2, 33] }, { 19: [2, 34], 22: [2, 34], 25: [2, 34], 40: [2, 34], 48: [2, 34], 55: [2, 34], 57: [2, 34], 58: [2, 34], 61: [2, 34], 64: [2, 34], 66: [2, 34], 67: [2, 34], 69: [2, 34], 76: [2, 34], 78: [2, 34], 79: [2, 34], 80: [2, 34] }, { 19: [2, 35], 22: [2, 35], 25: [2, 35], 40: [2, 35], 48: [2, 35], 55: [2, 35], 57: [2, 35], 58: [2, 35], 61: [2, 35], 64: [2, 35], 66: [2, 35], 67: [2, 35], 69: [2, 35], 76: [2, 35], 78: [2, 35], 79: [2, 35], 80: [2, 35] }, { 1: [2, 2] }, { 1: [2, 3] }, { 1: [2, 4] }, { 1: [2, 5] }, { 1: [2, 6] }, { 1: [2, 7] }, { 1: [2, 8] }, { 4: 121, 5: [1, 120], 13: 70, 19: [1, 15], 22: [1, 71], 24: 22, 25: [1, 27], 28: 23, 31: 24, 32: 18, 33: 13, 39: 16, 40: [1, 21], 41: 25, 48: [1, 33], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 57: [1, 35], 58: [1, 36], 60: 37, 61: [1, 38], 62: 39, 63: 20, 64: [1, 26], 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 4: 123, 13: 70, 19: [1, 15], 22: [1, 71], 24: 22, 25: [1, 27], 28: 23, 31: 24, 32: 18, 33: 13, 39: 16, 40: [1, 21], 41: 25, 48: [1, 33], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 57: [1, 35], 58: [1, 36], 60: 37, 61: [1, 38], 62: 39, 63: 20, 64: [1, 26], 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42], 81: 122 }, { 1: [2, 10] }, { 5: [2, 112] }, { 5: [2, 49], 14: [2, 49], 16: [2, 49], 17: [2, 49], 19: [2, 49], 22: [1, 67], 23: [2, 49], 25: [2, 49], 27: [2, 49], 30: [2, 49], 34: [2, 49], 35: [2, 49], 36: [2, 49], 37: [2, 49], 38: [2, 49], 40: [2, 49], 42: [2, 49], 43: [2, 49], 45: [2, 49], 46: [2, 49], 47: [2, 49], 48: [2, 49], 49: [2, 49], 55: [2, 49], 56: [2, 49], 57: [2, 49], 58: [2, 49], 59: [2, 49], 61: [2, 49], 66: [2, 49], 67: [2, 49], 69: [2, 49], 71: [2, 49], 74: [2, 49], 76: [2, 49], 78: [2, 49], 79: [2, 49], 80: [2, 49] }, { 4: 124, 13: 70, 19: [1, 15], 22: [1, 71], 24: 22, 25: [1, 27], 28: 23, 31: 24, 32: 18, 33: 13, 39: 16, 40: [1, 21], 41: 25, 48: [1, 33], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 57: [1, 35], 58: [1, 36], 60: 37, 61: [1, 38], 62: 39, 63: 20, 64: [1, 26], 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 13: 70, 19: [1, 15], 22: [1, 71], 24: 22, 25: [1, 27], 28: 23, 31: 24, 32: 18, 39: 125, 40: [1, 21], 41: 25, 48: [1, 33], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 57: [1, 35], 58: [1, 36], 60: 37, 61: [1, 38], 62: 39, 63: 20, 64: [1, 26], 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 13: 70, 19: [1, 15], 22: [1, 71], 24: 22, 25: [1, 27], 28: 23, 31: 24, 32: 18, 39: 126, 40: [1, 21], 41: 25, 48: [1, 33], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 57: [1, 35], 58: [1, 36], 60: 37, 61: [1, 38], 62: 39, 63: 20, 64: [1, 26], 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 21: 127, 22: [1, 128] }, { 5: [2, 42], 14: [2, 42], 16: [2, 42], 17: [2, 42], 19: [2, 42], 22: [2, 42], 23: [2, 42], 25: [2, 42], 27: [2, 42], 30: [2, 42], 34: [2, 42], 35: [2, 42], 36: [2, 42], 37: [2, 42], 38: [2, 42], 40: [2, 42], 42: [2, 42], 43: [2, 42], 44: 87, 45: [1, 81], 46: [1, 82], 47: [1, 83], 48: [2, 42], 49: [2, 42], 55: [2, 42], 56: [2, 42], 57: [2, 42], 58: [2, 42], 59: [1, 88], 61: [2, 42], 66: [2, 42], 67: [2, 42], 69: [2, 42], 71: [2, 42], 74: [2, 42], 76: [2, 42], 78: [2, 42], 79: [2, 42], 80: [2, 42] }, { 13: 70, 19: [1, 15], 22: [1, 71], 24: 22, 25: [1, 27], 28: 23, 31: 24, 32: 129, 40: [1, 21], 41: 25, 48: [1, 33], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 57: [1, 35], 58: [1, 36], 60: 37, 61: [1, 38], 62: 39, 63: 20, 64: [1, 26], 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 13: 70, 19: [1, 15], 22: [1, 71], 24: 22, 25: [1, 27], 28: 23, 31: 24, 32: 130, 40: [1, 21], 41: 25, 48: [1, 33], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 57: [1, 35], 58: [1, 36], 60: 37, 61: [1, 38], 62: 39, 63: 20, 64: [1, 26], 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 5: [2, 68], 14: [2, 68], 16: [2, 68], 17: [2, 68], 19: [2, 68], 22: [2, 68], 23: [2, 68], 25: [2, 68], 27: [2, 68], 30: [2, 68], 34: [2, 68], 35: [2, 68], 36: [2, 68], 37: [2, 68], 38: [2, 68], 40: [2, 68], 42: [2, 68], 43: [2, 68], 45: [2, 68], 46: [2, 68], 47: [2, 68], 48: [2, 68], 49: [2, 68], 55: [2, 68], 56: [2, 68], 57: [2, 68], 58: [2, 68], 59: [2, 68], 61: [2, 68], 66: [2, 68], 67: [2, 68], 69: [2, 68], 71: [2, 68], 74: [2, 68], 76: [2, 68], 78: [2, 68], 79: [2, 68], 80: [2, 68] }, { 5: [2, 69], 14: [2, 69], 16: [2, 69], 17: [2, 69], 19: [2, 69], 22: [2, 69], 23: [2, 69], 25: [2, 69], 27: [2, 69], 30: [2, 69], 34: [2, 69], 35: [2, 69], 36: [2, 69], 37: [2, 69], 38: [2, 69], 40: [2, 69], 42: [2, 69], 43: [2, 69], 45: [2, 69], 46: [2, 69], 47: [2, 69], 48: [2, 69], 49: [2, 69], 55: [2, 69], 56: [2, 69], 57: [2, 69], 58: [2, 69], 59: [2, 69], 61: [2, 69], 66: [2, 69], 67: [2, 69], 69: [2, 69], 71: [2, 69], 74: [2, 69], 76: [2, 69], 78: [2, 69], 79: [2, 69], 80: [2, 69] }, { 4: 131, 13: 70, 19: [1, 15], 22: [1, 71], 24: 22, 25: [1, 27], 28: 23, 31: 24, 32: 18, 33: 13, 39: 16, 40: [1, 21], 41: 25, 48: [1, 33], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 57: [1, 35], 58: [1, 36], 60: 37, 61: [1, 38], 62: 39, 63: 20, 64: [1, 26], 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 5: [2, 46], 14: [2, 46], 16: [2, 46], 17: [2, 46], 19: [2, 46], 22: [2, 46], 23: [2, 46], 25: [2, 46], 27: [2, 46], 30: [2, 46], 34: [2, 46], 35: [2, 46], 36: [2, 46], 37: [2, 46], 38: [2, 46], 40: [2, 46], 42: [2, 46], 43: [2, 46], 45: [2, 46], 46: [2, 46], 47: [2, 46], 48: [2, 46], 49: [2, 46], 55: [2, 46], 56: [2, 46], 57: [2, 46], 58: [2, 46], 59: [2, 46], 61: [2, 46], 64: [2, 46], 66: [2, 46], 67: [2, 46], 69: [2, 46], 71: [2, 46], 74: [2, 46], 76: [2, 46], 78: [2, 46], 79: [2, 46], 80: [2, 46] }, { 5: [2, 47], 14: [2, 47], 16: [2, 47], 17: [2, 47], 19: [2, 47], 22: [2, 47], 23: [2, 47], 25: [2, 47], 27: [2, 47], 30: [2, 47], 34: [2, 47], 35: [2, 47], 36: [2, 47], 37: [2, 47], 38: [2, 47], 40: [2, 47], 42: [2, 47], 43: [2, 47], 45: [2, 47], 46: [2, 47], 47: [2, 47], 48: [2, 47], 49: [2, 47], 55: [2, 47], 56: [2, 47], 57: [2, 47], 58: [2, 47], 59: [2, 47], 61: [2, 47], 64: [2, 47], 66: [2, 47], 67: [2, 47], 69: [2, 47], 71: [2, 47], 74: [2, 47], 76: [2, 47], 78: [2, 47], 79: [2, 47], 80: [2, 47] }, { 48: [1, 132] }, { 16: [1, 133], 23: [1, 134] }, { 5: [2, 87], 14: [2, 87], 16: [2, 87], 17: [2, 87], 19: [2, 87], 22: [2, 87], 23: [2, 87], 25: [2, 87], 27: [2, 87], 30: [2, 87], 34: [2, 87], 35: [2, 87], 36: [2, 87], 37: [2, 87], 38: [2, 87], 40: [2, 87], 42: [2, 87], 43: [2, 87], 44: 135, 45: [1, 81], 46: [1, 82], 47: [1, 83], 48: [2, 87], 49: [2, 87], 55: [2, 87], 56: [2, 87], 57: [2, 87], 58: [2, 87], 59: [2, 87], 61: [2, 87], 66: [2, 87], 67: [2, 87], 69: [2, 87], 71: [2, 87], 74: [2, 87], 76: [2, 87], 78: [2, 87], 79: [2, 87], 80: [2, 87] }, { 5: [2, 70], 14: [2, 70], 16: [2, 70], 17: [2, 70], 19: [2, 70], 22: [2, 70], 23: [2, 70], 25: [1, 80], 27: [2, 70], 30: [2, 70], 34: [2, 70], 35: [2, 70], 36: [2, 70], 37: [2, 70], 38: [2, 70], 40: [2, 70], 42: [2, 70], 43: [2, 70], 44: 78, 45: [1, 81], 46: [1, 82], 47: [1, 83], 48: [2, 70], 49: [2, 70], 55: [2, 70], 56: [2, 70], 57: [2, 70], 58: [2, 70], 59: [1, 79], 61: [2, 70], 66: [2, 70], 67: [2, 70], 69: [2, 70], 71: [2, 70], 74: [2, 70], 76: [2, 70], 78: [2, 70], 79: [2, 70], 80: [2, 70] }, { 5: [2, 58], 14: [2, 58], 16: [2, 58], 17: [2, 58], 19: [2, 58], 22: [2, 58], 23: [2, 58], 25: [2, 58], 27: [2, 58], 30: [2, 58], 34: [2, 58], 35: [2, 58], 36: [2, 58], 37: [2, 58], 38: [2, 58], 40: [2, 58], 42: [2, 58], 43: [2, 58], 45: [2, 58], 46: [2, 58], 47: [2, 58], 48: [2, 58], 49: [2, 58], 55: [2, 58], 56: [2, 58], 57: [2, 58], 58: [2, 58], 59: [2, 58], 61: [2, 58], 66: [2, 58], 67: [2, 58], 69: [2, 58], 71: [2, 58], 74: [2, 58], 76: [2, 58], 78: [2, 58], 79: [2, 58], 80: [2, 58] }, { 5: [2, 62], 14: [2, 62], 16: [2, 62], 17: [2, 62], 19: [2, 62], 22: [2, 62], 23: [2, 62], 25: [2, 62], 27: [2, 62], 30: [2, 62], 34: [2, 62], 35: [2, 62], 36: [2, 62], 37: [2, 62], 38: [2, 62], 40: [2, 62], 42: [2, 62], 43: [2, 62], 45: [2, 62], 46: [2, 62], 47: [2, 62], 48: [2, 62], 49: [2, 62], 55: [2, 62], 56: [2, 62], 57: [2, 62], 58: [2, 62], 59: [2, 62], 61: [2, 62], 66: [2, 62], 67: [2, 62], 69: [2, 62], 71: [2, 62], 74: [2, 62], 76: [2, 62], 78: [2, 62], 79: [2, 62], 80: [2, 62] }, { 16: [1, 138], 27: [1, 136], 29: 137, 30: [1, 139] }, { 16: [2, 28], 27: [2, 28], 30: [2, 28] }, { 49: [1, 140] }, { 56: [1, 141] }, { 4: 142, 13: 70, 19: [1, 15], 22: [1, 71], 24: 22, 25: [1, 27], 28: 23, 31: 24, 32: 18, 33: 13, 39: 16, 40: [1, 21], 41: 25, 48: [1, 33], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 57: [1, 35], 58: [1, 36], 60: 37, 61: [1, 38], 62: 39, 63: 20, 64: [1, 26], 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 4: 143, 13: 70, 19: [1, 15], 22: [1, 71], 24: 22, 25: [1, 27], 28: 23, 31: 24, 32: 18, 33: 13, 39: 16, 40: [1, 21], 41: 25, 48: [1, 33], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 57: [1, 35], 58: [1, 36], 60: 37, 61: [1, 38], 62: 39, 63: 20, 64: [1, 26], 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 4: 144, 13: 70, 19: [1, 15], 22: [1, 71], 24: 22, 25: [1, 27], 28: 23, 31: 24, 32: 18, 33: 13, 39: 16, 40: [1, 21], 41: 25, 48: [1, 33], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 57: [1, 35], 58: [1, 36], 60: 37, 61: [1, 38], 62: 39, 63: 20, 64: [1, 26], 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 5: [2, 64], 13: 70, 14: [2, 64], 16: [2, 64], 17: [2, 64], 19: [1, 15], 22: [1, 71], 23: [2, 64], 25: [2, 64], 27: [2, 64], 30: [2, 64], 34: [2, 64], 35: [2, 64], 36: [2, 64], 37: [2, 64], 38: [2, 64], 40: [2, 64], 41: 75, 42: [1, 76], 43: [1, 77], 45: [2, 64], 46: [2, 64], 47: [2, 64], 48: [1, 33], 49: [2, 64], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 56: [2, 64], 57: [1, 35], 58: [1, 36], 59: [2, 64], 60: 37, 61: [1, 38], 62: 39, 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 71: [2, 64], 74: [2, 64], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 4: 145, 13: 70, 19: [1, 15], 22: [1, 71], 24: 22, 25: [1, 27], 28: 23, 31: 24, 32: 18, 33: 13, 39: 16, 40: [1, 21], 41: 25, 48: [1, 33], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 57: [1, 35], 58: [1, 36], 60: 37, 61: [1, 38], 62: 39, 63: 20, 64: [1, 26], 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 5: [2, 92], 13: 70, 14: [2, 92], 16: [2, 92], 17: [2, 92], 19: [1, 15], 22: [1, 71], 23: [2, 92], 25: [2, 92], 27: [2, 92], 30: [2, 92], 34: [2, 92], 35: [2, 92], 36: [2, 92], 37: [2, 92], 38: [2, 92], 40: [2, 92], 41: 75, 42: [1, 76], 43: [1, 77], 45: [2, 92], 46: [2, 92], 47: [2, 92], 48: [1, 33], 49: [2, 92], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 56: [2, 92], 57: [1, 35], 58: [1, 36], 59: [2, 92], 60: 37, 61: [1, 38], 62: 39, 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 71: [2, 92], 74: [2, 92], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 48: [1, 146] }, { 13: 70, 19: [1, 15], 22: [1, 148], 24: 22, 25: [1, 27], 28: 23, 31: 24, 32: 18, 39: 147, 40: [1, 21], 41: 25, 48: [1, 33], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 57: [1, 35], 58: [1, 36], 60: 37, 61: [1, 38], 62: 39, 63: 20, 64: [1, 26], 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 4: 149, 13: 70, 19: [1, 15], 22: [1, 71], 24: 22, 25: [1, 27], 28: 23, 31: 24, 32: 18, 33: 13, 39: 16, 40: [1, 21], 41: 25, 48: [1, 33], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 57: [1, 35], 58: [1, 36], 60: 37, 61: [1, 38], 62: 39, 63: 20, 64: [1, 26], 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 5: [2, 102], 13: 70, 14: [2, 102], 16: [2, 102], 17: [2, 102], 19: [1, 15], 22: [1, 71], 23: [2, 102], 25: [2, 102], 27: [2, 102], 30: [2, 102], 34: [2, 102], 35: [2, 102], 36: [2, 102], 37: [2, 102], 38: [2, 102], 40: [2, 102], 41: 75, 42: [1, 76], 43: [1, 77], 45: [2, 102], 46: [2, 102], 47: [2, 102], 48: [1, 33], 49: [2, 102], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 56: [2, 102], 57: [1, 35], 58: [1, 36], 59: [2, 102], 60: 37, 61: [1, 38], 62: 39, 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 71: [2, 102], 74: [2, 102], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 13: 70, 19: [1, 15], 22: [1, 150], 24: 22, 25: [1, 27], 28: 23, 31: 24, 32: 18, 39: 151, 40: [1, 21], 41: 25, 48: [1, 33], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 57: [1, 35], 58: [1, 36], 60: 37, 61: [1, 38], 62: 39, 63: 20, 64: [1, 26], 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 4: 152, 13: 70, 19: [1, 15], 22: [1, 71], 24: 22, 25: [1, 27], 28: 23, 31: 24, 32: 18, 33: 13, 39: 16, 40: [1, 21], 41: 25, 48: [1, 33], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 57: [1, 35], 58: [1, 36], 60: 37, 61: [1, 38], 62: 39, 63: 20, 64: [1, 26], 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 5: [2, 106], 13: 70, 14: [2, 106], 16: [2, 106], 17: [2, 106], 19: [1, 15], 22: [1, 71], 23: [2, 106], 25: [2, 106], 27: [2, 106], 30: [2, 106], 34: [2, 106], 35: [2, 106], 36: [2, 106], 37: [2, 106], 38: [2, 106], 40: [2, 106], 41: 75, 42: [1, 76], 43: [1, 77], 45: [2, 106], 46: [2, 106], 47: [2, 106], 48: [1, 33], 49: [2, 106], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 56: [2, 106], 57: [1, 35], 58: [1, 36], 59: [2, 106], 60: 37, 61: [1, 38], 62: 39, 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 71: [2, 106], 74: [2, 106], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 13: 70, 19: [1, 15], 22: [1, 153], 24: 22, 25: [1, 27], 28: 23, 31: 24, 32: 18, 39: 154, 40: [1, 21], 41: 25, 48: [1, 33], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 57: [1, 35], 58: [1, 36], 60: 37, 61: [1, 38], 62: 39, 63: 20, 64: [1, 26], 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 48: [1, 155] }, { 71: [1, 156] }, { 5: [2, 79], 14: [2, 79], 16: [2, 79], 17: [2, 79], 19: [2, 79], 22: [2, 79], 23: [2, 79], 25: [2, 79], 27: [2, 79], 30: [2, 79], 34: [2, 79], 35: [2, 79], 36: [2, 79], 37: [2, 79], 38: [2, 79], 40: [2, 79], 42: [2, 79], 43: [2, 79], 45: [2, 79], 46: [2, 79], 47: [2, 79], 48: [2, 79], 49: [2, 79], 55: [2, 79], 56: [2, 79], 57: [2, 79], 58: [2, 79], 59: [2, 79], 61: [2, 79], 66: [2, 79], 67: [2, 79], 69: [2, 79], 71: [2, 79], 74: [2, 79], 76: [2, 79], 78: [2, 79], 79: [2, 79], 80: [2, 79] }, { 16: [1, 157], 71: [2, 81] }, { 16: [2, 83], 71: [2, 83] }, { 16: [2, 85], 71: [2, 85], 74: [1, 158] }, { 14: [1, 160], 18: 159, 34: [1, 55], 35: [1, 56], 36: [1, 57], 37: [1, 58] }, { 13: 161, 19: [1, 15], 48: [1, 162] }, { 5: [1, 163] }, { 5: [2, 15] }, { 5: [2, 14] }, { 5: [2, 49], 18: 164, 19: [2, 49], 22: [1, 67], 25: [2, 49], 34: [1, 55], 35: [1, 56], 36: [1, 57], 37: [1, 58], 38: [2, 49], 40: [2, 49], 42: [2, 49], 43: [2, 49], 45: [2, 49], 46: [2, 49], 47: [2, 49], 48: [2, 49], 55: [2, 49], 57: [2, 49], 58: [2, 49], 59: [2, 49], 61: [2, 49], 66: [2, 49], 67: [2, 49], 69: [2, 49], 76: [2, 49], 78: [2, 49], 79: [2, 49], 80: [2, 49] }, { 5: [2, 36], 16: [2, 36], 18: 165, 34: [1, 55], 35: [1, 56], 36: [1, 57], 37: [1, 58], 71: [2, 36], 74: [2, 36] }, { 1: [2, 9] }, { 5: [2, 13] }, { 16: [1, 167], 23: [1, 166] }, { 16: [1, 169], 23: [1, 168] }, { 23: [1, 134] }, { 5: [2, 39], 13: 70, 14: [2, 39], 16: [2, 39], 17: [2, 39], 19: [1, 15], 22: [1, 71], 23: [2, 39], 25: [2, 39], 27: [2, 39], 30: [2, 39], 34: [2, 39], 35: [2, 39], 36: [2, 39], 37: [2, 39], 38: [2, 39], 40: [2, 39], 41: 75, 42: [1, 76], 43: [1, 77], 45: [2, 39], 46: [2, 39], 47: [2, 39], 48: [1, 33], 49: [2, 39], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 56: [2, 39], 57: [1, 35], 58: [1, 36], 59: [2, 39], 60: 37, 61: [1, 38], 62: 39, 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 71: [2, 39], 74: [2, 39], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 5: [2, 40], 13: 70, 14: [2, 40], 16: [2, 40], 17: [2, 40], 19: [1, 15], 22: [1, 71], 23: [2, 40], 25: [2, 40], 27: [2, 40], 30: [2, 40], 34: [2, 40], 35: [2, 40], 36: [2, 40], 37: [2, 40], 38: [2, 40], 40: [2, 40], 41: 75, 42: [1, 76], 43: [1, 77], 45: [2, 40], 46: [2, 40], 47: [2, 40], 48: [1, 33], 49: [2, 40], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 56: [2, 40], 57: [1, 35], 58: [1, 36], 59: [2, 40], 60: 37, 61: [1, 38], 62: 39, 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 71: [2, 40], 74: [2, 40], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 5: [2, 20], 16: [2, 20] }, { 4: 170, 13: 70, 19: [1, 15], 22: [1, 71], 24: 22, 25: [1, 27], 28: 23, 31: 24, 32: 18, 33: 13, 39: 16, 40: [1, 21], 41: 25, 48: [1, 33], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 57: [1, 35], 58: [1, 36], 60: 37, 61: [1, 38], 62: 39, 63: 20, 64: [1, 26], 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 5: [2, 43], 14: [2, 43], 16: [2, 43], 17: [2, 43], 19: [2, 43], 22: [2, 43], 23: [2, 43], 25: [1, 80], 27: [2, 43], 30: [2, 43], 34: [2, 43], 35: [2, 43], 36: [2, 43], 37: [2, 43], 38: [2, 43], 40: [2, 43], 42: [2, 43], 43: [2, 43], 44: 78, 45: [1, 81], 46: [1, 82], 47: [1, 83], 48: [2, 43], 49: [2, 43], 55: [2, 43], 56: [2, 43], 57: [2, 43], 58: [2, 43], 59: [1, 79], 61: [2, 43], 66: [2, 43], 67: [2, 43], 69: [2, 43], 71: [2, 43], 74: [2, 43], 76: [2, 43], 78: [2, 43], 79: [2, 43], 80: [2, 43] }, { 5: [2, 44], 14: [2, 44], 16: [2, 44], 17: [2, 44], 19: [2, 44], 22: [2, 44], 23: [2, 44], 25: [1, 80], 27: [2, 44], 30: [2, 44], 34: [2, 44], 35: [2, 44], 36: [2, 44], 37: [2, 44], 38: [2, 44], 40: [2, 44], 42: [2, 44], 43: [2, 44], 44: 78, 45: [1, 81], 46: [1, 82], 47: [1, 83], 48: [2, 44], 49: [2, 44], 55: [2, 44], 56: [2, 44], 57: [2, 44], 58: [2, 44], 59: [1, 79], 61: [2, 44], 66: [2, 44], 67: [2, 44], 69: [2, 44], 71: [2, 44], 74: [2, 44], 76: [2, 44], 78: [2, 44], 79: [2, 44], 80: [2, 44] }, { 27: [1, 171] }, { 4: 172, 13: 70, 19: [1, 15], 22: [1, 71], 24: 22, 25: [1, 27], 28: 23, 31: 24, 32: 18, 33: 13, 39: 16, 40: [1, 21], 41: 25, 48: [1, 33], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 57: [1, 35], 58: [1, 36], 60: 37, 61: [1, 38], 62: 39, 63: 20, 64: [1, 26], 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 4: 173, 13: 70, 19: [1, 15], 22: [1, 71], 24: 22, 25: [1, 27], 28: 23, 31: 24, 32: 18, 33: 13, 39: 16, 40: [1, 21], 41: 25, 48: [1, 33], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 57: [1, 35], 58: [1, 36], 60: 37, 61: [1, 38], 62: 39, 63: 20, 64: [1, 26], 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 5: [2, 55], 14: [2, 55], 16: [2, 55], 17: [2, 55], 19: [2, 55], 22: [2, 55], 23: [2, 55], 25: [2, 55], 27: [2, 55], 30: [2, 55], 34: [2, 55], 35: [2, 55], 36: [2, 55], 37: [2, 55], 38: [2, 55], 40: [2, 55], 42: [2, 55], 43: [2, 55], 45: [2, 55], 46: [2, 55], 47: [2, 55], 48: [2, 55], 49: [2, 55], 55: [2, 55], 56: [2, 55], 57: [2, 55], 58: [2, 55], 59: [2, 55], 61: [2, 55], 66: [2, 55], 67: [2, 55], 69: [2, 55], 71: [2, 55], 74: [2, 55], 76: [2, 55], 78: [2, 55], 79: [2, 55], 80: [2, 55] }, { 5: [2, 67], 14: [2, 67], 16: [2, 67], 17: [2, 67], 19: [2, 67], 22: [2, 67], 23: [2, 67], 25: [2, 67], 27: [2, 67], 30: [2, 67], 34: [2, 67], 35: [2, 67], 36: [2, 67], 37: [2, 67], 38: [2, 67], 40: [2, 67], 42: [2, 67], 43: [2, 67], 45: [2, 67], 46: [2, 67], 47: [2, 67], 48: [2, 67], 49: [2, 67], 55: [2, 67], 56: [2, 67], 57: [2, 67], 58: [2, 67], 59: [2, 67], 61: [2, 67], 66: [2, 67], 67: [2, 67], 69: [2, 67], 71: [2, 67], 74: [2, 67], 76: [2, 67], 78: [2, 67], 79: [2, 67], 80: [2, 67] }, { 5: [2, 22], 14: [2, 22], 16: [2, 22], 17: [2, 22], 19: [2, 22], 22: [2, 22], 23: [2, 22], 25: [2, 22], 27: [2, 22], 30: [2, 22], 34: [2, 22], 35: [2, 22], 36: [2, 22], 37: [2, 22], 38: [2, 22], 40: [2, 22], 42: [2, 22], 43: [2, 22], 45: [2, 22], 46: [2, 22], 47: [2, 22], 48: [2, 22], 49: [2, 22], 55: [2, 22], 56: [2, 22], 57: [2, 22], 58: [2, 22], 59: [2, 22], 61: [2, 22], 66: [2, 22], 67: [2, 22], 69: [2, 22], 71: [2, 22], 74: [2, 22], 76: [2, 22], 78: [2, 22], 79: [2, 22], 80: [2, 22] }, { 4: 90, 13: 70, 19: [1, 15], 22: [1, 71], 24: 22, 25: [1, 27], 26: 174, 28: 23, 31: 24, 32: 18, 33: 13, 39: 16, 40: [1, 21], 41: 25, 48: [1, 33], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 57: [1, 35], 58: [1, 36], 60: 37, 61: [1, 38], 62: 39, 63: 20, 64: [1, 26], 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 4: 175, 13: 70, 19: [1, 15], 22: [1, 71], 24: 22, 25: [1, 27], 28: 23, 30: [1, 176], 31: 24, 32: 18, 33: 13, 39: 16, 40: [1, 21], 41: 25, 48: [1, 33], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 57: [1, 35], 58: [1, 36], 60: 37, 61: [1, 38], 62: 39, 63: 20, 64: [1, 26], 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 16: [1, 177], 19: [2, 24], 22: [2, 24], 25: [2, 24], 40: [2, 24], 48: [2, 24], 55: [2, 24], 57: [2, 24], 58: [2, 24], 61: [2, 24], 64: [2, 24], 66: [2, 24], 67: [2, 24], 69: [2, 24], 76: [2, 24], 78: [2, 24], 79: [2, 24], 80: [2, 24] }, { 5: [2, 56], 14: [2, 56], 16: [2, 56], 17: [2, 56], 19: [2, 56], 22: [2, 56], 23: [2, 56], 25: [2, 56], 27: [2, 56], 30: [2, 56], 34: [2, 56], 35: [2, 56], 36: [2, 56], 37: [2, 56], 38: [2, 56], 40: [2, 56], 42: [2, 56], 43: [2, 56], 45: [2, 56], 46: [2, 56], 47: [2, 56], 48: [2, 56], 49: [2, 56], 55: [2, 56], 56: [2, 56], 57: [2, 56], 58: [2, 56], 59: [2, 56], 61: [2, 56], 66: [2, 56], 67: [2, 56], 69: [2, 56], 71: [2, 56], 74: [2, 56], 76: [2, 56], 78: [2, 56], 79: [2, 56], 80: [2, 56] }, { 5: [2, 57], 14: [2, 57], 16: [2, 57], 17: [2, 57], 19: [2, 57], 22: [2, 57], 23: [2, 57], 25: [2, 57], 27: [2, 57], 30: [2, 57], 34: [2, 57], 35: [2, 57], 36: [2, 57], 37: [2, 57], 38: [2, 57], 40: [2, 57], 42: [2, 57], 43: [2, 57], 45: [2, 57], 46: [2, 57], 47: [2, 57], 48: [2, 57], 49: [2, 57], 55: [2, 57], 56: [2, 57], 57: [2, 57], 58: [2, 57], 59: [2, 57], 61: [2, 57], 66: [2, 57], 67: [2, 57], 69: [2, 57], 71: [2, 57], 74: [2, 57], 76: [2, 57], 78: [2, 57], 79: [2, 57], 80: [2, 57] }, { 49: [1, 178] }, { 49: [1, 179] }, { 27: [1, 180] }, { 23: [1, 181] }, { 40: [1, 182] }, { 5: [2, 95], 13: 70, 14: [2, 95], 16: [2, 95], 17: [2, 95], 19: [1, 15], 22: [1, 71], 23: [2, 95], 25: [2, 95], 27: [2, 95], 30: [2, 95], 34: [2, 95], 35: [2, 95], 36: [2, 95], 37: [2, 95], 38: [2, 95], 40: [2, 95], 41: 75, 42: [1, 76], 43: [1, 77], 45: [2, 95], 46: [2, 95], 47: [2, 95], 48: [1, 33], 49: [2, 95], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 56: [2, 95], 57: [1, 35], 58: [1, 36], 59: [2, 95], 60: 37, 61: [1, 38], 62: 39, 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 71: [2, 95], 74: [2, 95], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 4: 183, 13: 70, 19: [1, 15], 22: [1, 71], 24: 22, 25: [1, 27], 28: 23, 31: 24, 32: 18, 33: 13, 39: 16, 40: [1, 21], 41: 25, 48: [1, 33], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 57: [1, 35], 58: [1, 36], 60: 37, 61: [1, 38], 62: 39, 63: 20, 64: [1, 26], 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 23: [1, 184] }, { 4: 185, 13: 70, 19: [1, 15], 22: [1, 71], 24: 22, 25: [1, 27], 28: 23, 31: 24, 32: 18, 33: 13, 39: 16, 40: [1, 21], 41: 25, 48: [1, 33], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 57: [1, 35], 58: [1, 36], 60: 37, 61: [1, 38], 62: 39, 63: 20, 64: [1, 26], 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 5: [2, 104], 13: 70, 14: [2, 104], 16: [2, 104], 17: [2, 104], 19: [1, 15], 22: [1, 71], 23: [2, 104], 25: [2, 104], 27: [2, 104], 30: [2, 104], 34: [2, 104], 35: [2, 104], 36: [2, 104], 37: [2, 104], 38: [2, 104], 40: [2, 104], 41: 75, 42: [1, 76], 43: [1, 77], 45: [2, 104], 46: [2, 104], 47: [2, 104], 48: [1, 33], 49: [2, 104], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 56: [2, 104], 57: [1, 35], 58: [1, 36], 59: [2, 104], 60: 37, 61: [1, 38], 62: 39, 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 71: [2, 104], 74: [2, 104], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 23: [1, 186] }, { 4: 187, 13: 70, 19: [1, 15], 22: [1, 71], 24: 22, 25: [1, 27], 28: 23, 31: 24, 32: 18, 33: 13, 39: 16, 40: [1, 21], 41: 25, 48: [1, 33], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 57: [1, 35], 58: [1, 36], 60: 37, 61: [1, 38], 62: 39, 63: 20, 64: [1, 26], 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 5: [2, 108], 13: 70, 14: [2, 108], 16: [2, 108], 17: [2, 108], 19: [1, 15], 22: [1, 71], 23: [2, 108], 25: [2, 108], 27: [2, 108], 30: [2, 108], 34: [2, 108], 35: [2, 108], 36: [2, 108], 37: [2, 108], 38: [2, 108], 40: [2, 108], 41: 75, 42: [1, 76], 43: [1, 77], 45: [2, 108], 46: [2, 108], 47: [2, 108], 48: [1, 33], 49: [2, 108], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 56: [2, 108], 57: [1, 35], 58: [1, 36], 59: [2, 108], 60: 37, 61: [1, 38], 62: 39, 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 71: [2, 108], 74: [2, 108], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 13: 188, 19: [1, 15] }, { 5: [2, 78], 14: [2, 78], 16: [2, 78], 17: [2, 78], 19: [2, 78], 22: [2, 78], 23: [2, 78], 25: [2, 78], 27: [2, 78], 30: [2, 78], 34: [2, 78], 35: [2, 78], 36: [2, 78], 37: [2, 78], 38: [2, 78], 40: [2, 78], 42: [2, 78], 43: [2, 78], 45: [2, 78], 46: [2, 78], 47: [2, 78], 48: [2, 78], 49: [2, 78], 55: [2, 78], 56: [2, 78], 57: [2, 78], 58: [2, 78], 59: [2, 78], 61: [2, 78], 66: [2, 78], 67: [2, 78], 69: [2, 78], 71: [2, 78], 74: [2, 78], 76: [2, 78], 78: [2, 78], 79: [2, 78], 80: [2, 78] }, { 4: 189, 12: 112, 13: 70, 19: [1, 15], 22: [1, 71], 24: 22, 25: [1, 27], 28: 23, 31: 24, 32: 18, 33: 13, 39: 16, 40: [1, 21], 41: 25, 48: [1, 33], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 57: [1, 35], 58: [1, 36], 60: 37, 61: [1, 38], 62: 39, 63: 20, 64: [1, 26], 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 73: 190, 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 4: 191, 13: 70, 19: [1, 15], 22: [1, 71], 24: 22, 25: [1, 27], 28: 23, 31: 24, 32: 18, 33: 13, 39: 16, 40: [1, 21], 41: 25, 48: [1, 33], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 57: [1, 35], 58: [1, 36], 60: 37, 61: [1, 38], 62: 39, 63: 20, 64: [1, 26], 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 4: 119, 13: 70, 19: [1, 15], 22: [1, 71], 24: 22, 25: [1, 27], 28: 23, 31: 24, 32: 18, 33: 13, 39: 16, 40: [1, 21], 41: 25, 48: [1, 33], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 57: [1, 35], 58: [1, 36], 60: 37, 61: [1, 38], 62: 39, 63: 20, 64: [1, 26], 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 4: 192, 13: 70, 19: [1, 15], 22: [1, 71], 24: 22, 25: [1, 27], 28: 23, 31: 24, 32: 18, 33: 13, 39: 16, 40: [1, 21], 41: 25, 48: [1, 33], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 57: [1, 35], 58: [1, 36], 60: 37, 61: [1, 38], 62: 39, 63: 20, 64: [1, 26], 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 19: [2, 99], 22: [2, 99], 25: [2, 99], 40: [2, 99], 45: [2, 99], 48: [2, 99], 55: [2, 99], 57: [2, 99], 58: [2, 99], 61: [2, 99], 64: [2, 99], 66: [2, 99], 67: [2, 99], 69: [2, 99], 76: [2, 99], 78: [2, 99], 79: [2, 99], 80: [2, 99] }, { 4: 193, 13: 70, 19: [1, 15], 22: [1, 71], 24: 22, 25: [1, 27], 28: 23, 31: 24, 32: 18, 33: 13, 39: 16, 40: [1, 21], 41: 25, 48: [1, 33], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 57: [1, 35], 58: [1, 36], 60: 37, 61: [1, 38], 62: 39, 63: 20, 64: [1, 26], 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 1: [2, 11] }, { 4: 194, 13: 70, 19: [1, 15], 22: [1, 71], 24: 22, 25: [1, 27], 28: 23, 31: 24, 32: 18, 33: 13, 39: 16, 40: [1, 21], 41: 25, 48: [1, 33], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 57: [1, 35], 58: [1, 36], 60: 37, 61: [1, 38], 62: 39, 63: 20, 64: [1, 26], 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 4: 195, 13: 70, 19: [1, 15], 22: [1, 71], 24: 22, 25: [1, 27], 28: 23, 31: 24, 32: 18, 33: 13, 39: 16, 40: [1, 21], 41: 25, 48: [1, 33], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 57: [1, 35], 58: [1, 36], 60: 37, 61: [1, 38], 62: 39, 63: 20, 64: [1, 26], 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 5: [2, 109], 14: [2, 109], 16: [2, 109], 17: [2, 109], 19: [2, 109], 22: [2, 109], 23: [2, 109], 25: [2, 109], 27: [2, 109], 30: [2, 109], 34: [2, 109], 35: [2, 109], 36: [2, 109], 37: [2, 109], 38: [2, 109], 40: [2, 109], 42: [2, 109], 43: [2, 109], 45: [2, 109], 46: [2, 109], 47: [2, 109], 48: [2, 109], 49: [2, 109], 55: [2, 109], 56: [2, 109], 57: [2, 109], 58: [2, 109], 59: [2, 109], 61: [2, 109], 66: [2, 109], 67: [2, 109], 69: [2, 109], 71: [2, 109], 74: [2, 109], 76: [2, 109], 78: [2, 109], 79: [2, 109], 80: [2, 109] }, { 4: 196, 13: 70, 19: [1, 15], 22: [1, 71], 24: 22, 25: [1, 27], 28: 23, 31: 24, 32: 18, 33: 13, 39: 16, 40: [1, 21], 41: 25, 48: [1, 33], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 57: [1, 35], 58: [1, 36], 60: 37, 61: [1, 38], 62: 39, 63: 20, 64: [1, 26], 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 5: [2, 89], 14: [2, 89], 16: [2, 89], 17: [2, 89], 19: [2, 89], 22: [2, 89], 23: [2, 89], 25: [2, 89], 27: [2, 89], 30: [2, 89], 34: [2, 89], 35: [2, 89], 36: [2, 89], 37: [2, 89], 38: [2, 89], 40: [2, 89], 42: [2, 89], 43: [2, 89], 44: 197, 45: [1, 81], 46: [1, 82], 47: [1, 83], 48: [2, 89], 49: [2, 89], 55: [2, 89], 56: [2, 89], 57: [2, 89], 58: [2, 89], 59: [2, 89], 61: [2, 89], 66: [2, 89], 67: [2, 89], 69: [2, 89], 71: [2, 89], 74: [2, 89], 76: [2, 89], 78: [2, 89], 79: [2, 89], 80: [2, 89] }, { 4: 198, 13: 70, 19: [1, 15], 22: [1, 71], 24: 22, 25: [1, 27], 28: 23, 31: 24, 32: 18, 33: 13, 39: 16, 40: [1, 21], 41: 25, 48: [1, 33], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 57: [1, 35], 58: [1, 36], 60: 37, 61: [1, 38], 62: 39, 63: 20, 64: [1, 26], 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 16: [1, 133] }, { 5: [2, 30], 14: [2, 30], 16: [2, 30], 17: [2, 30], 19: [2, 30], 22: [2, 30], 23: [2, 30], 25: [2, 30], 27: [2, 30], 30: [2, 30], 34: [2, 30], 35: [2, 30], 36: [2, 30], 37: [2, 30], 38: [2, 30], 40: [2, 30], 42: [2, 30], 43: [2, 30], 45: [2, 30], 46: [2, 30], 47: [2, 30], 48: [2, 30], 49: [2, 30], 55: [2, 30], 56: [2, 30], 57: [2, 30], 58: [2, 30], 59: [2, 30], 61: [2, 30], 66: [2, 30], 67: [2, 30], 69: [2, 30], 71: [2, 30], 74: [2, 30], 76: [2, 30], 78: [2, 30], 79: [2, 30], 80: [2, 30] }, { 49: [1, 199] }, { 23: [1, 200] }, { 16: [1, 202], 27: [1, 201] }, { 16: [2, 29], 27: [2, 29], 30: [2, 29] }, { 16: [1, 203], 19: [2, 25], 22: [2, 25], 25: [2, 25], 40: [2, 25], 48: [2, 25], 55: [2, 25], 57: [2, 25], 58: [2, 25], 61: [2, 25], 64: [2, 25], 66: [2, 25], 67: [2, 25], 69: [2, 25], 76: [2, 25], 78: [2, 25], 79: [2, 25], 80: [2, 25] }, { 19: [2, 26], 22: [2, 26], 25: [2, 26], 40: [2, 26], 48: [2, 26], 55: [2, 26], 57: [2, 26], 58: [2, 26], 61: [2, 26], 64: [2, 26], 66: [2, 26], 67: [2, 26], 69: [2, 26], 76: [2, 26], 78: [2, 26], 79: [2, 26], 80: [2, 26] }, { 48: [1, 204] }, { 5: [2, 60], 14: [2, 60], 16: [2, 60], 17: [2, 60], 19: [2, 60], 22: [2, 60], 23: [2, 60], 25: [2, 60], 27: [2, 60], 30: [2, 60], 34: [2, 60], 35: [2, 60], 36: [2, 60], 37: [2, 60], 38: [2, 60], 40: [2, 60], 42: [2, 60], 43: [2, 60], 45: [2, 60], 46: [2, 60], 47: [2, 60], 48: [2, 60], 49: [2, 60], 55: [2, 60], 56: [2, 60], 57: [2, 60], 58: [2, 60], 59: [2, 60], 61: [2, 60], 66: [2, 60], 67: [2, 60], 69: [2, 60], 71: [2, 60], 74: [2, 60], 76: [2, 60], 78: [2, 60], 79: [2, 60], 80: [2, 60] }, { 48: [1, 205] }, { 5: [2, 91], 14: [2, 91], 16: [2, 91], 17: [2, 91], 19: [2, 91], 22: [2, 91], 23: [2, 91], 25: [2, 91], 27: [2, 91], 30: [2, 91], 34: [2, 91], 35: [2, 91], 36: [2, 91], 37: [2, 91], 38: [2, 91], 40: [2, 91], 42: [2, 91], 43: [2, 91], 45: [2, 91], 46: [2, 91], 47: [2, 91], 48: [2, 91], 49: [2, 91], 55: [2, 91], 56: [2, 91], 57: [2, 91], 58: [2, 91], 59: [2, 91], 61: [2, 91], 66: [2, 91], 67: [2, 91], 69: [2, 91], 71: [2, 91], 74: [2, 91], 76: [2, 91], 78: [2, 91], 79: [2, 91], 80: [2, 91] }, { 40: [1, 207], 63: 206, 64: [1, 26] }, { 23: [1, 208] }, { 5: [2, 101], 14: [2, 101], 16: [2, 101], 17: [2, 101], 19: [2, 101], 22: [2, 101], 23: [2, 101], 25: [2, 101], 27: [2, 101], 30: [2, 101], 34: [2, 101], 35: [2, 101], 36: [2, 101], 37: [2, 101], 38: [2, 101], 40: [2, 101], 42: [2, 101], 43: [2, 101], 45: [2, 101], 46: [2, 101], 47: [2, 101], 48: [2, 101], 49: [2, 101], 55: [2, 101], 56: [2, 101], 57: [2, 101], 58: [2, 101], 59: [2, 101], 61: [2, 101], 66: [2, 101], 67: [2, 101], 69: [2, 101], 71: [2, 101], 74: [2, 101], 76: [2, 101], 78: [2, 101], 79: [2, 101], 80: [2, 101] }, { 23: [1, 209] }, { 5: [2, 105], 14: [2, 105], 16: [2, 105], 17: [2, 105], 19: [2, 105], 22: [2, 105], 23: [2, 105], 25: [2, 105], 27: [2, 105], 30: [2, 105], 34: [2, 105], 35: [2, 105], 36: [2, 105], 37: [2, 105], 38: [2, 105], 40: [2, 105], 42: [2, 105], 43: [2, 105], 45: [2, 105], 46: [2, 105], 47: [2, 105], 48: [2, 105], 49: [2, 105], 55: [2, 105], 56: [2, 105], 57: [2, 105], 58: [2, 105], 59: [2, 105], 61: [2, 105], 66: [2, 105], 67: [2, 105], 69: [2, 105], 71: [2, 105], 74: [2, 105], 76: [2, 105], 78: [2, 105], 79: [2, 105], 80: [2, 105] }, { 23: [1, 210] }, { 14: [1, 211] }, { 14: [1, 160], 18: 159, 34: [1, 55], 35: [1, 56], 36: [1, 57], 37: [1, 58], 71: [2, 80] }, { 16: [2, 82], 71: [2, 82] }, { 16: [2, 84], 71: [2, 84] }, { 16: [2, 37], 71: [2, 37], 74: [2, 37] }, { 49: [1, 212] }, { 5: [2, 16] }, { 5: [2, 38], 16: [2, 38], 71: [2, 38], 74: [2, 38] }, { 16: [2, 110], 23: [2, 110] }, { 5: [2, 88], 14: [2, 88], 16: [2, 88], 17: [2, 88], 19: [2, 88], 22: [2, 88], 23: [2, 88], 25: [2, 88], 27: [2, 88], 30: [2, 88], 34: [2, 88], 35: [2, 88], 36: [2, 88], 37: [2, 88], 38: [2, 88], 40: [2, 88], 42: [2, 88], 43: [2, 88], 45: [2, 88], 46: [2, 88], 47: [2, 88], 48: [2, 88], 49: [2, 88], 55: [2, 88], 56: [2, 88], 57: [2, 88], 58: [2, 88], 59: [2, 88], 61: [2, 88], 66: [2, 88], 67: [2, 88], 69: [2, 88], 71: [2, 88], 74: [2, 88], 76: [2, 88], 78: [2, 88], 79: [2, 88], 80: [2, 88] }, { 16: [2, 111], 23: [2, 111] }, { 5: [2, 48], 14: [2, 48], 16: [2, 48], 17: [2, 48], 19: [2, 48], 22: [2, 48], 23: [2, 48], 25: [2, 48], 27: [2, 48], 30: [2, 48], 34: [2, 48], 35: [2, 48], 36: [2, 48], 37: [2, 48], 38: [2, 48], 40: [2, 48], 42: [2, 48], 43: [2, 48], 45: [2, 48], 46: [2, 48], 47: [2, 48], 48: [2, 48], 49: [2, 48], 55: [2, 48], 56: [2, 48], 57: [2, 48], 58: [2, 48], 59: [2, 48], 61: [2, 48], 64: [2, 48], 66: [2, 48], 67: [2, 48], 69: [2, 48], 71: [2, 48], 74: [2, 48], 76: [2, 48], 78: [2, 48], 79: [2, 48], 80: [2, 48] }, { 5: [2, 21], 16: [2, 21] }, { 5: [2, 23], 14: [2, 23], 16: [2, 23], 17: [2, 23], 19: [2, 23], 22: [2, 23], 23: [2, 23], 25: [2, 23], 27: [2, 23], 30: [2, 23], 34: [2, 23], 35: [2, 23], 36: [2, 23], 37: [2, 23], 38: [2, 23], 40: [2, 23], 42: [2, 23], 43: [2, 23], 45: [2, 23], 46: [2, 23], 47: [2, 23], 48: [2, 23], 49: [2, 23], 55: [2, 23], 56: [2, 23], 57: [2, 23], 58: [2, 23], 59: [2, 23], 61: [2, 23], 66: [2, 23], 67: [2, 23], 69: [2, 23], 71: [2, 23], 74: [2, 23], 76: [2, 23], 78: [2, 23], 79: [2, 23], 80: [2, 23] }, { 4: 175, 13: 70, 19: [1, 15], 22: [1, 71], 24: 22, 25: [1, 27], 28: 23, 31: 24, 32: 18, 33: 13, 39: 16, 40: [1, 21], 41: 25, 48: [1, 33], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 57: [1, 35], 58: [1, 36], 60: 37, 61: [1, 38], 62: 39, 63: 20, 64: [1, 26], 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 19: [2, 27], 22: [2, 27], 25: [2, 27], 40: [2, 27], 48: [2, 27], 55: [2, 27], 57: [2, 27], 58: [2, 27], 61: [2, 27], 64: [2, 27], 66: [2, 27], 67: [2, 27], 69: [2, 27], 76: [2, 27], 78: [2, 27], 79: [2, 27], 80: [2, 27] }, { 4: 213, 13: 70, 19: [1, 15], 22: [1, 71], 24: 22, 25: [1, 27], 28: 23, 31: 24, 32: 18, 33: 13, 39: 16, 40: [1, 21], 41: 25, 48: [1, 33], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 57: [1, 35], 58: [1, 36], 60: 37, 61: [1, 38], 62: 39, 63: 20, 64: [1, 26], 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 4: 214, 13: 70, 19: [1, 15], 22: [1, 71], 24: 22, 25: [1, 27], 28: 23, 31: 24, 32: 18, 33: 13, 39: 16, 40: [1, 21], 41: 25, 48: [1, 33], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 57: [1, 35], 58: [1, 36], 60: 37, 61: [1, 38], 62: 39, 63: 20, 64: [1, 26], 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 49: [1, 215] }, { 64: [1, 216] }, { 5: [2, 96], 14: [2, 96], 16: [2, 96], 17: [2, 96], 19: [2, 96], 22: [2, 96], 23: [2, 96], 25: [2, 96], 27: [2, 96], 30: [2, 96], 34: [2, 96], 35: [2, 96], 36: [2, 96], 37: [2, 96], 38: [2, 96], 40: [2, 96], 42: [2, 96], 43: [2, 96], 45: [2, 96], 46: [2, 96], 47: [2, 96], 48: [2, 96], 49: [2, 96], 55: [2, 96], 56: [2, 96], 57: [2, 96], 58: [2, 96], 59: [2, 96], 61: [2, 96], 66: [2, 96], 67: [2, 96], 69: [2, 96], 71: [2, 96], 74: [2, 96], 76: [2, 96], 78: [2, 96], 79: [2, 96], 80: [2, 96] }, { 5: [2, 103], 14: [2, 103], 16: [2, 103], 17: [2, 103], 19: [2, 103], 22: [2, 103], 23: [2, 103], 25: [2, 103], 27: [2, 103], 30: [2, 103], 34: [2, 103], 35: [2, 103], 36: [2, 103], 37: [2, 103], 38: [2, 103], 40: [2, 103], 42: [2, 103], 43: [2, 103], 45: [2, 103], 46: [2, 103], 47: [2, 103], 48: [2, 103], 49: [2, 103], 55: [2, 103], 56: [2, 103], 57: [2, 103], 58: [2, 103], 59: [2, 103], 61: [2, 103], 66: [2, 103], 67: [2, 103], 69: [2, 103], 71: [2, 103], 74: [2, 103], 76: [2, 103], 78: [2, 103], 79: [2, 103], 80: [2, 103] }, { 5: [2, 107], 14: [2, 107], 16: [2, 107], 17: [2, 107], 19: [2, 107], 22: [2, 107], 23: [2, 107], 25: [2, 107], 27: [2, 107], 30: [2, 107], 34: [2, 107], 35: [2, 107], 36: [2, 107], 37: [2, 107], 38: [2, 107], 40: [2, 107], 42: [2, 107], 43: [2, 107], 45: [2, 107], 46: [2, 107], 47: [2, 107], 48: [2, 107], 49: [2, 107], 55: [2, 107], 56: [2, 107], 57: [2, 107], 58: [2, 107], 59: [2, 107], 61: [2, 107], 66: [2, 107], 67: [2, 107], 69: [2, 107], 71: [2, 107], 74: [2, 107], 76: [2, 107], 78: [2, 107], 79: [2, 107], 80: [2, 107] }, { 4: 217, 13: 70, 19: [1, 15], 22: [1, 71], 24: 22, 25: [1, 27], 28: 23, 31: 24, 32: 18, 33: 13, 39: 16, 40: [1, 21], 41: 25, 48: [1, 33], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 57: [1, 35], 58: [1, 36], 60: 37, 61: [1, 38], 62: 39, 63: 20, 64: [1, 26], 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 19: [2, 100], 22: [2, 100], 25: [2, 100], 40: [2, 100], 45: [2, 100], 48: [2, 100], 55: [2, 100], 57: [2, 100], 58: [2, 100], 61: [2, 100], 64: [2, 100], 66: [2, 100], 67: [2, 100], 69: [2, 100], 76: [2, 100], 78: [2, 100], 79: [2, 100], 80: [2, 100] }, { 49: [1, 218] }, { 49: [1, 219] }, { 13: 70, 19: [1, 15], 22: [1, 221], 24: 22, 25: [1, 27], 28: 23, 31: 24, 32: 18, 39: 220, 40: [1, 21], 41: 25, 48: [1, 33], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 57: [1, 35], 58: [1, 36], 60: 37, 61: [1, 38], 62: 39, 63: 20, 64: [1, 26], 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 49: [2, 87] }, { 49: [1, 222] }, { 5: [2, 59], 14: [2, 59], 16: [2, 59], 17: [2, 59], 19: [2, 59], 22: [2, 59], 23: [2, 59], 25: [2, 59], 27: [2, 59], 30: [2, 59], 34: [2, 59], 35: [2, 59], 36: [2, 59], 37: [2, 59], 38: [2, 59], 40: [2, 59], 42: [2, 59], 43: [2, 59], 45: [2, 59], 46: [2, 59], 47: [2, 59], 48: [2, 59], 49: [2, 59], 55: [2, 59], 56: [2, 59], 57: [2, 59], 58: [2, 59], 59: [2, 59], 61: [2, 59], 66: [2, 59], 67: [2, 59], 69: [2, 59], 71: [2, 59], 74: [2, 59], 76: [2, 59], 78: [2, 59], 79: [2, 59], 80: [2, 59] }, { 5: [2, 61], 14: [2, 61], 16: [2, 61], 17: [2, 61], 19: [2, 61], 22: [2, 61], 23: [2, 61], 25: [2, 61], 27: [2, 61], 30: [2, 61], 34: [2, 61], 35: [2, 61], 36: [2, 61], 37: [2, 61], 38: [2, 61], 40: [2, 61], 42: [2, 61], 43: [2, 61], 45: [2, 61], 46: [2, 61], 47: [2, 61], 48: [2, 61], 49: [2, 61], 55: [2, 61], 56: [2, 61], 57: [2, 61], 58: [2, 61], 59: [2, 61], 61: [2, 61], 66: [2, 61], 67: [2, 61], 69: [2, 61], 71: [2, 61], 74: [2, 61], 76: [2, 61], 78: [2, 61], 79: [2, 61], 80: [2, 61] }, { 5: [2, 93], 13: 70, 14: [2, 93], 16: [2, 93], 17: [2, 93], 19: [1, 15], 22: [1, 71], 23: [2, 93], 25: [2, 93], 27: [2, 93], 30: [2, 93], 34: [2, 93], 35: [2, 93], 36: [2, 93], 37: [2, 93], 38: [2, 93], 40: [2, 93], 41: 75, 42: [1, 76], 43: [1, 77], 45: [2, 93], 46: [2, 93], 47: [2, 93], 48: [1, 33], 49: [2, 93], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 56: [2, 93], 57: [1, 35], 58: [1, 36], 59: [2, 93], 60: 37, 61: [1, 38], 62: 39, 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 71: [2, 93], 74: [2, 93], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 4: 223, 13: 70, 19: [1, 15], 22: [1, 71], 24: 22, 25: [1, 27], 28: 23, 31: 24, 32: 18, 33: 13, 39: 16, 40: [1, 21], 41: 25, 48: [1, 33], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 57: [1, 35], 58: [1, 36], 60: 37, 61: [1, 38], 62: 39, 63: 20, 64: [1, 26], 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 44: 224, 45: [1, 81], 46: [1, 82], 47: [1, 83] }, { 23: [1, 225] }, { 4: 226, 13: 70, 19: [1, 15], 22: [1, 71], 24: 22, 25: [1, 27], 28: 23, 31: 24, 32: 18, 33: 13, 39: 16, 40: [1, 21], 41: 25, 48: [1, 33], 50: 28, 51: 29, 52: 30, 53: 31, 54: 32, 55: [1, 34], 57: [1, 35], 58: [1, 36], 60: 37, 61: [1, 38], 62: 39, 63: 20, 64: [1, 26], 65: 43, 66: [1, 48], 67: [1, 49], 69: [1, 44], 75: 40, 76: [1, 45], 77: 41, 78: [1, 46], 79: [1, 47], 80: [1, 42] }, { 5: [2, 94], 14: [2, 94], 16: [2, 94], 17: [2, 94], 19: [2, 94], 22: [2, 94], 23: [2, 94], 25: [2, 94], 27: [2, 94], 30: [2, 94], 34: [2, 94], 35: [2, 94], 36: [2, 94], 37: [2, 94], 38: [2, 94], 40: [2, 94], 42: [2, 94], 43: [2, 94], 45: [2, 94], 46: [2, 94], 47: [2, 94], 48: [2, 94], 49: [2, 94], 55: [2, 94], 56: [2, 94], 57: [2, 94], 58: [2, 94], 59: [2, 94], 61: [2, 94], 66: [2, 94], 67: [2, 94], 69: [2, 94], 71: [2, 94], 74: [2, 94], 76: [2, 94], 78: [2, 94], 79: [2, 94], 80: [2, 94] }, { 5: [2, 77], 14: [2, 77], 16: [2, 77], 17: [2, 77], 19: [2, 77], 22: [2, 77], 23: [2, 77], 25: [2, 77], 27: [2, 77], 30: [2, 77], 34: [2, 77], 35: [2, 77], 36: [2, 77], 37: [2, 77], 38: [2, 77], 40: [2, 77], 42: [2, 77], 43: [2, 77], 45: [2, 77], 46: [2, 77], 47: [2, 77], 48: [2, 77], 49: [2, 77], 55: [2, 77], 56: [2, 77], 57: [2, 77], 58: [2, 77], 59: [2, 77], 61: [2, 77], 66: [2, 77], 67: [2, 77], 69: [2, 77], 71: [2, 77], 74: [2, 77], 76: [2, 77], 78: [2, 77], 79: [2, 77], 80: [2, 77] }],
        defaultActions: { 12: [2, 12], 48: [2, 75], 49: [2, 76], 50: [2, 1], 59: [2, 2], 60: [2, 3], 61: [2, 4], 62: [2, 5], 63: [2, 6], 64: [2, 7], 65: [2, 8], 68: [2, 10], 69: [2, 112], 116: [2, 15], 117: [2, 14], 120: [2, 9], 121: [2, 13], 163: [2, 11], 194: [2, 16], 216: [2, 87] },
        parseError: function parseError(str, hash) {
            throw new Error(str);
        },
        parse: function parse(input) {
            var self = this,
                stack = [0],
                vstack = [null],
                lstack = [],
                table = this.table,
                yytext = "",
                yylineno = 0,
                yyleng = 0,
                recovering = 0,
                TERROR = 2,
                EOF = 1;
            this.lexer.setInput(input);
            this.lexer.yy = this.yy;
            this.yy.lexer = this.lexer;
            this.yy.parser = this;
            if (typeof this.lexer.yylloc == "undefined")
                this.lexer.yylloc = {};
            var yyloc = this.lexer.yylloc;
            lstack.push(yyloc);
            var ranges = this.lexer.options && this.lexer.options.ranges;
            if (typeof this.yy.parseError === "function")
                this.parseError = this.yy.parseError;

            function popStack(n) {
                stack.length = stack.length - 2 * n;
                vstack.length = vstack.length - n;
                lstack.length = lstack.length - n;
            }

            function lex() {
                var token;
                token = self.lexer.lex() || 1;
                if (typeof token !== "number") {
                    token = self.symbols_[token] || token;
                }
                return token;
            }
            var symbol, preErrorSymbol, state, action, a, r, yyval = {},
                p, len, newState, expected;
            while (true) {
                state = stack[stack.length - 1];
                if (this.defaultActions[state]) {
                    action = this.defaultActions[state];
                } else {
                    if (symbol === null || typeof symbol == "undefined") {
                        symbol = lex();
                    }
                    action = table[state] && table[state][symbol];
                }
                if (typeof action === "undefined" || !action.length || !action[0]) {
                    var errStr = "";
                    if (!recovering) {
                        expected = [];
                        for (p in table[state])
                            if (this.terminals_[p] && p > 2) {
                                expected.push("'" + this.terminals_[p] + "'");
                            }
                        if (this.lexer.showPosition) {
                            errStr = "Parse error on line " + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
                        } else {
                            errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == 1 ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
                        }
                        this.parseError(errStr, { text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected: expected });
                    }
                }
                if (action[0] instanceof Array && action.length > 1) {
                    throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
                }
                switch (action[0]) {
                    case 1:
                        stack.push(symbol);
                        vstack.push(this.lexer.yytext);
                        lstack.push(this.lexer.yylloc);
                        stack.push(action[1]);
                        symbol = null;
                        if (!preErrorSymbol) {
                            yyleng = this.lexer.yyleng;
                            yytext = this.lexer.yytext;
                            yylineno = this.lexer.yylineno;
                            yyloc = this.lexer.yylloc;
                            if (recovering > 0)
                                recovering--;
                        } else {
                            symbol = preErrorSymbol;
                            preErrorSymbol = null;
                        }
                        break;
                    case 2:
                        len = this.productions_[action[1]][1];
                        yyval.$ = vstack[vstack.length - len];
                        yyval._$ = { first_line: lstack[lstack.length - (len || 1)].first_line, last_line: lstack[lstack.length - 1].last_line, first_column: lstack[lstack.length - (len || 1)].first_column, last_column: lstack[lstack.length - 1].last_column };
                        if (ranges) {
                            yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
                        }
                        r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
                        if (typeof r !== "undefined") {
                            return r;
                        }
                        if (len) {
                            stack = stack.slice(0, -1 * len * 2);
                            vstack = vstack.slice(0, -1 * len);
                            lstack = lstack.slice(0, -1 * len);
                        }
                        stack.push(this.productions_[action[1]][0]);
                        vstack.push(yyval.$);
                        lstack.push(yyval._$);
                        newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
                        stack.push(newState);
                        break;
                    case 3:
                        return true;
                }
            }
            return true;
        }
    };
    /* Jison generated lexer */
    var lexer = (function() {
        var lexer = ({
            EOF: 1,
            parseError: function parseError(str, hash) {
                if (this.yy.parser) {
                    this.yy.parser.parseError(str, hash);
                } else {
                    throw new Error(str);
                }
            },
            setInput: function(input) {
                this._input = input;
                this._more = this._less = this.done = false;
                this.yylineno = this.yyleng = 0;
                this.yytext = this.matched = this.match = '';
                this.conditionStack = ['INITIAL'];
                this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 };
                if (this.options.ranges) this.yylloc.range = [0, 0];
                this.offset = 0;
                return this;
            },
            input: function() {
                var ch = this._input[0];
                this.yytext += ch;
                this.yyleng++;
                this.offset++;
                this.match += ch;
                this.matched += ch;
                var lines = ch.match(/(?:\r\n?|\n).*/g);
                if (lines) {
                    this.yylineno++;
                    this.yylloc.last_line++;
                } else {
                    this.yylloc.last_column++;
                }
                if (this.options.ranges) this.yylloc.range[1]++;

                this._input = this._input.slice(1);
                return ch;
            },
            unput: function(ch) {
                var len = ch.length;
                var lines = ch.split(/(?:\r\n?|\n)/g);

                this._input = ch + this._input;
                this.yytext = this.yytext.substr(0, this.yytext.length - len - 1);
                //this.yyleng -= len;
                this.offset -= len;
                var oldLines = this.match.split(/(?:\r\n?|\n)/g);
                this.match = this.match.substr(0, this.match.length - 1);
                this.matched = this.matched.substr(0, this.matched.length - 1);

                if (lines.length - 1) this.yylineno -= lines.length - 1;
                var r = this.yylloc.range;

                this.yylloc = {
                    first_line: this.yylloc.first_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.first_column,
                    last_column: lines ?
                        (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
                };

                if (this.options.ranges) {
                    this.yylloc.range = [r[0], r[0] + this.yyleng - len];
                }
                return this;
            },
            more: function() {
                this._more = true;
                return this;
            },
            less: function(n) {
                this.unput(this.match.slice(n));
            },
            pastInput: function() {
                var past = this.matched.substr(0, this.matched.length - this.match.length);
                return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, "");
            },
            upcomingInput: function() {
                var next = this.match;
                if (next.length < 20) {
                    next += this._input.substr(0, 20 - next.length);
                }
                return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
            },
            showPosition: function() {
                var pre = this.pastInput();
                var c = new Array(pre.length + 1).join("-");
                return pre + this.upcomingInput() + "\n" + c + "^";
            },
            next: function() {
                if (this.done) {
                    return this.EOF;
                }
                if (!this._input) this.done = true;

                var token,
                    match,
                    tempMatch,
                    index,
                    col,
                    lines;
                if (!this._more) {
                    this.yytext = '';
                    this.match = '';
                }
                var rules = this._currentRules();
                for (var i = 0; i < rules.length; i++) {
                    tempMatch = this._input.match(this.rules[rules[i]]);
                    if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                        match = tempMatch;
                        index = i;
                        if (!this.options.flex) break;
                    }
                }
                if (match) {
                    lines = match[0].match(/(?:\r\n?|\n).*/g);
                    if (lines) this.yylineno += lines.length;
                    this.yylloc = {
                        first_line: this.yylloc.last_line,
                        last_line: this.yylineno + 1,
                        first_column: this.yylloc.last_column,
                        last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
                    };
                    this.yytext += match[0];
                    this.match += match[0];
                    this.matches = match;
                    this.yyleng = this.yytext.length;
                    if (this.options.ranges) {
                        this.yylloc.range = [this.offset, this.offset += this.yyleng];
                    }
                    this._more = false;
                    this._input = this._input.slice(match[0].length);
                    this.matched += match[0];
                    token = this.performAction.call(this, this.yy, this, rules[index], this.conditionStack[this.conditionStack.length - 1]);
                    if (this.done && this._input) this.done = false;
                    if (token) return token;
                    else return;
                }
                if (this._input === "") {
                    return this.EOF;
                } else {
                    return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), { text: "", token: null, line: this.yylineno });
                }
            },
            lex: function lex() {
                var r = this.next();
                if (typeof r !== 'undefined') {
                    return r;
                } else {
                    return this.lex();
                }
            },
            begin: function begin(condition) {
                this.conditionStack.push(condition);
            },
            popState: function popState() {
                return this.conditionStack.pop();
            },
            _currentRules: function _currentRules() {
                return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
            },
            topState: function() {
                return this.conditionStack[this.conditionStack.length - 2];
            },
            pushState: function begin(condition) {
                this.begin(condition);
            }
        });
        lexer.options = {};
        lexer.performAction = function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {

            var YYSTATE = YY_START
            switch ($avoiding_name_collisions) {
                case 0:
                    /* skip whitespace */
                    break;
                case 1:
                    return 48
                    break;
                case 2:
                    return 49
                    break;
                case 3:
                    return 'MATH_SHIFT'
                    break;
                case 4:
                    yy_.yytext = this.matches[this.matches.length - 1];
                    return 45
                    break;
                case 5:
                    yy_.yytext = this.matches[this.matches.length - 1];
                    return 46
                    break;
                case 6:
                    return 47
                    break;
                case 7:
                    yy_.yytext = Number(this.matches[2]) + Number(this.matches[5]) / Number(this.matches[6]);
                    return 64
                    break;
                case 8:
                    return 64
                    break;
                case 9:
                    return 42
                    break;
                case 10:
                    return 43
                    break;
                case 11:
                    yy_.yytext = this.matches[3];
                    return 61
                    break;
                case 12:
                    yy_.yytext = this.matches[this.matches.length - 1];
                    return 79
                    break;
                case 13:
                    return 80
                    break;
                case 14:
                    return 78
                    break;
                case 15:
                    return 57
                    break;
                case 16:
                    return 58
                    break;
                case 17:
                    return 66
                    break;
                case 18:
                    return 67
                    break;
                case 19:
                    return 19
                    break;
                case 20:
                    return 55 /* rely on mathquill */
                    break;
                case 21:
                    return 56 /* for pairing */
                    break;
                case 22:
                    return 40
                    break;
                case 23:
                    return 38
                    break;
                case 24:
                    return 14
                    break;
                case 25:
                    return 17
                    break;
                case 26:
                    return "..."
                    break;
                case 27:
                    return 68
                    break;
                case 28:
                    return 59
                    break;
                case 29:
                    return 5
                    break;
                case 30:
                    return 22
                    break;
                case 31:
                    return 23
                    break;
                case 32:
                    return 25
                    break;
                case 33:
                    return 27
                    break;
                case 34:
                    return 69
                    break;
                case 35:
                    return 71
                    break;
                case 36:
                    return 74
                    break;
                case 37:
                    return 36
                    break;
                case 38:
                    return 37
                    break;
                case 39:
                    return 35
                    break;
                case 40:
                    return 34
                    break;
                case 41:
                    return 16
                    break;
                case 42:
                    return 15
                    break;
                case 43:
                    return 76 /* sin, cos, sinh, ln*/
                    break;
                case 44:
                    yy_.yytext = '\\sign';
                    return 19
                    break;
                case 45:
                    yy_.yytext = '\\gcd';
                    return 19
                    break;
                case 46:
                    yy_.yytext = '\\lcm';
                    return 19
                    break;
                case 47:
                    yy_.yytext = '\\stdevp';
                    return 19
                    break;
                case 48:
                    yy_.yytext = '\\stdevp';
                    return 19
                    break;
                case 49:
                    yy_.yytext = '\\stdev';
                    return 19
                    break;
                case 50:
                    yy_.yytext = '\\stdev';
                    return 19
                    break;
                case 51:
                    yy_.yytext = '\\var';
                    return 19
                    break;
                case 52:
                    return 19 /* Predefined functions, as well as user-defined variables.  Doesn't include subscripts */
                    break;
                case 53:
                    /* skip LINE_START if it's not needed for something else */
                    break;
                case 54:
                    return 'UNRECOGNIZED'
                    break;
            }
        };
        lexer.rules = [/^(?:(\\space|\\:|\s)+)/, /^(?:\{)/, /^(?:\})/, /^(?:\$)/, /^(?:\^([0-9]))/, /^(?:\^([a-zA-Z]))/, /^(?:\^)/, /^(?:(([0-9]+)((?:\s|\\space|\\:)*)\\frac((?:\s|\\space|\\:)*)\{([0-9]+)\}\{([0-9]+)\}))/, /^(?:[0-9]+(\.[0-9]+)?|(\.[0-9]+))/, /^(?:\*|(\\cdot))/, /^(?:\/)/, /^(?:(\\frac((?:\s|\\space|\\:)*)\{d\}\{d(((\\[a-zA-Z]+|[a-zA-Z])(_[a-zA-Z0-9]|_\{[a-zA-Z0-9]+\})?))\}))/, /^(?:(\\log)((?:\s|\\space|\\:)*)*_([0-9]))/, /^(?:(\\ln))/, /^(?:(\\log))/, /^(?:(\\frac))/, /^(?:(\\sqrt))/, /^(?:(\\sum))/, /^(?:(\\prod))/, /^(?:(\\length))/, /^(?:\\left\|)/, /^(?:\\right\|)/, /^(?:-)/, /^(?:\+)/, /^(?:=)/, /^(?:~)/, /^(?:\.\.\.)/, /^(?:[_])/, /^(?:!)/, /^(?:$)/, /^(?:(\()|\\left\()/, /^(?:(\))|\\right\))/, /^(?:(\[)|\\left\[)/, /^(?:(\])|\\right\])/, /^(?:(\\\{)|\\left\\\{)/, /^(?:(\\\})|\\right\\\})/, /^(?::)/, /^(?:(\\ge|>=))/, /^(?:(\\le|<=))/, /^(?:(\\gt|>))/, /^(?:(\\lt|<))/, /^(?:,)/, /^(?:(###)(((?:\s|\\space|\\:)*)((\\[a-zA-Z]+|[a-zA-Z])(_[a-zA-Z0-9]|_\{[a-zA-Z0-9]+\})?)((?:\s|\\space|\\:)*)(\\left\(|\()((?:\s|\\space|\\:)*)((\\[a-zA-Z]+|[a-zA-Z])(_[a-zA-Z0-9]|_\{[a-zA-Z0-9]+\})?)(((?:\s|\\space|\\:)*),((?:\s|\\space|\\:)*)((\\[a-zA-Z]+|[a-zA-Z])(_[a-zA-Z0-9]|_\{[a-zA-Z0-9]+\})?)((?:\s|\\space|\\:)*))*((?:\s|\\space|\\:)*)(\\right\)|\))((?:\s|\\space|\\:)*)=))/, /^(?:(\\(arc)?(sin|cos|tan|cot|sec|csc)h?))/, /^(?:(\\signum))/, /^(?:(\\(gcf|mcd)))/, /^(?:(\\mcm))/, /^(?:(\\stdDevP))/, /^(?:(\\stddevp))/, /^(?:(\\stdDev))/, /^(?:(\\stddev))/, /^(?:(\\variance))/, /^(?:((\\[a-zA-Z]+|[a-zA-Z])(_[a-zA-Z0-9]|_\{[a-zA-Z0-9]+\})?))/, /^(?:(###))/, /^(?:.)/];
        lexer.conditions = { "conditional": { "rules": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54], "inclusive": true }, "INITIAL": { "rules": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54], "inclusive": true } };
        return lexer;
    })()
    parser.lexer = lexer;
    return parser;
});
define('math/policy', ['require', 'graphing/graphmode'], function(require) {
    var GRAPHMODE = require('graphing/graphmode');

    var Policy = {
        assignmentForbidden: function(identifier) {
            return (
                identifier === 'x' ||
                identifier === 'y' ||
                identifier === 'theta' ||
                identifier.slice(0, 3) === 'tmp'
            );
        },

        validRegressionParameter: function(identifier) {
            return identifier !== 'x' && identifier !== 'y';
        },

        sliderVariables: function(identifiers) {
            if (identifiers.indexOf('theta') !== -1) {
                identifiers = identifiers.filter(function(s) { return s !== 'r'; });
            }
            var self = this;
            return identifiers.filter(function(s) { return !self.assignmentForbidden(s); });
        },

        validLHS: function(identifier) {
            return identifier !== 'theta';
        },

        unplottablePolarFunction: function(head, args) {
            if (head !== 'theta') return false;
            return args.indexOf('r') !== -1;
        },

        validDoubleInequalitySymbol: function(identifier) {
            return identifier === 'x' || identifier === 'y';
        },

        validDoubleInequalityVariables: function(identifiers) {
            if (identifiers.length > 2) return false;
            return identifiers.every(Policy.validDoubleInequalitySymbol);
        },

        validExpressionVariable: function(identifier) {
            return identifier === 'x';
        },

        validSolvedVariable: function(identifier) {
            return identifier === 'x' || identifier === 'y' || identifier === 'r';
        },

        validImplicitVariables: function(identifiers) {
            if (identifiers.length !== 2) return false;
            return (
                (identifiers[0] === 'x' && identifiers[1] === 'y') ||
                (identifiers[0] === 'y' && identifiers[1] === 'x') ||
                (identifiers[0] === 'r' && identifiers[1] === 'theta') ||
                (identifiers[0] === 'theta' && identifiers[1] === 'r')
            );
        },

        graphableListVariables: function(leftSymbol, rightSymbol) {
            return (
                leftSymbol === 'x' ||
                leftSymbol === 'y' ||
                leftSymbol === 'r' ||
                rightSymbol === 'x' ||
                rightSymbol === 'y'
            );
        },

        validParametricVariable: function(identifier) {
            return identifier === 't';
        },

        validParametricVariables: function(identifiers) {
            return identifiers.length === 1 && Policy.validParametricVariable(identifiers[0]);
        },

        validInequalityVariables: function(identifiers) {
            switch (identifiers.length) {
                case 1:
                    return identifiers[0] === 'x' || identifiers[0] === 'y' || identifiers[0] === 'r';
                case 2:
                    return Policy.validImplicitVariables(identifiers);
                default:
                    return false;
            }
        },

        validFirstColumnVariable: function(symbol) {
            return symbol !== 'y' && symbol !== 'r' && symbol !== 'theta' && !symbol.match(/y_(\d+)/);
        },

        complicatedPolarImplicit: function(identifier, order) {
            return identifier === 'theta' || (identifier === 'r' && order !== 1);
        },

        constantGraphMode: function(symbol) {
            if (symbol === 'x') return GRAPHMODE.X;
            if (symbol === 'r') return GRAPHMODE.POLAR;
            return GRAPHMODE.Y;
        },

        graphMode: function(independent, dependent) {
            if (dependent === 'y') return GRAPHMODE.X;
            if (independent === 'x') return GRAPHMODE.X;
            if (independent === 'r' && dependent === 'theta') return GRAPHMODE.POLAR;
            return GRAPHMODE.Y;
        },

        tableableAsConstant: function(identifier) {
            if (identifier === 'x') return false;
            if (identifier === 'r') return false;
            if (identifier === 'theta') return false;
            return true;
        },

        implicitIndependent: function(identifier) {
            return 'x';
        },

        implicitDependency: function(identifier) {
            if (identifier === 'y') return 'x';
            if (identifier === 'theta') return 'r';
            return 'y';
        },

        graphableAsConstant: function(identifier) {
            return identifier === 'y' || identifier === 'x' || identifier === 'r';
        },

        graphableAsBareIdentifier: function(identifier) {
            return identifier === 'x';
        }
    };

    return Policy;
});

var define_enum_constant;
var enum_strings = {};
var debuggable_enums = true;

if (debuggable_enums) {
    define_enum_constant = function(s) {
        this[s] = s;
    };
} else {
    var next_enum = 1000;
    define_enum_constant = function(s) {
        enum_strings[next_enum] = s;
        this[s] = next_enum++;
    };
}

//Statement types (determined entirely from the root element of the parse tree)
define_enum_constant("EXPRESSION"); //a+1 or 1+1
define_enum_constant("FUNCTION_DEFINITION"); //f(x)=???
define_enum_constant("VARIABLE_DEFINITION"); //a=???
define_enum_constant("ORDERED_PAIR_LIST"); // (?, ?), (?, ?).  Support lists of points, but only single parametrics
define_enum_constant("DOUBLE_INEQUALITY"); // expr < y < expr, shade-between
define_enum_constant("COMPARATOR"); // expr < expr - unsolved inequality
define_enum_constant("CHAINED_COMPARATOR"); // a < ??? - not a conditional as an expression
define_enum_constant("EQUATION"); // expr = expr
define_enum_constant("CONSTANT");
define_enum_constant("IDENTIFIER");
define_enum_constant("LIST");

define("math/enums", function() {});

define('math/parsenode/base', ['require', 'console', 'pjs', 'math/policy', 'math/functions', '../enums'], function(require) {
    //Parse-nodes are immutable objects
    //Built by the parse tree
    var console = require('console');
    var P = require('pjs');
    var Policy = require('math/policy');
    var Functions = require('math/functions');
    require('../enums');

    return P(function(node, _super, _class) {
        node.init = function() {
            this._dependencies = [];
            this._inputString = '';
            this._exports = [];
        };

        node.exportPenalty = 0;

        //Utility function for generating temporary variables
        var tmpVarCounter = 0; //Singleton used for generating tmp variables in compilation
        node.tmpVar = function() {
            return 'tmp' + tmpVarCounter++;
        };

        /* START OF ADAPTATION CODE */
        node.statementType = EXPRESSION; //TODO - remove this
        node.dependencies = function() { return this.getDependencies() };
        node.evaluateOnce = function(frame) {
            if (frame === undefined) frame = {};
            var concreteTree = this.getConcreteTree(frame);
            var evaluationInfo = concreteTree.getEvaluationInfo();
            if (evaluationInfo) return evaluationInfo[0].val;
            return NaN;
        };
        /*END OF ADAPTATION CODE */

        //Track input string (for error messages, etc.)
        node.setInputString = function(s) {
            this._inputString = s;
        };

        node.getInputString = function() {
            return this._inputString;
        };

        //Track dependencies and referenced variables
        //Anything that we need to be evaluated after
        //is a dependency (even things like "a" for "f(a) = a"
        //Don't track type of dependencies.  That will be checked dynamically
        //as the parse tree is rolled up
        node.addDependency = function(identifier) {
            if (this.dependsOn(identifier)) return;
            this._dependencies.push(identifier);
        };

        node.addDependencies = function(identifiers) {
            for (var i = 0; i < identifiers.length; i++) {
                this.addDependency(identifiers[i]);
            }
        };

        node.getDependencies = function() {
            return (this._dependencies);
        };

        node.removeDependency = function(identifier) {
            this._dependencies.splice(this._dependencies.indexOf(identifier), 1);
        };

        node.dependsOn = function(identifier) {
            return (this._dependencies.indexOf(identifier) > -1);
        };

        //Track which symbols we export definitions for
        node.getExports = function() {
            return this._exports;
        };

        node.exportsSymbol = function(symbol) {
            return this._exports.indexOf(symbol) > -1;
        };

        node.exportTo = function(concrete, frame) {
            var exports = this.getExports();
            if (exports.length === 0) return;
            if (exports.length > 1) {
                throw new Error("exportsTo unimplemented for nodes that define multiple symbols.");
            }

            var symbol = exports[0];
            if (Policy.assignmentForbidden(symbol)) return;
            if (frame[symbol]) return;

            // The concrete tree might be an error that blocks exporting the symbol.
            // In this case, export the error instead.
            frame[symbol] = concrete.blocksExport ? concrete : this;
        };

        node.getOperator = function() {
            return this.operator || '=';
        };

        node.isInequality = function() { return false; };

        node.isShadeBetween = function() {
            return false;
        };

        node.getAllIds = function() {
            return this.userData ? [this.userData.id] : [];
        };

        //Default to falsy evaluationInfo
        node.getEvaluationInfo = function() {
            return false;
        };

        //Default to falsy sliderInfo
        node.getSliderInfo = function() {
            return false;
        };

        node.getSliderVariables = function(concrete) {
            return Policy.sliderVariables(concrete.getDependencies());
        };

        //Default to not accepting in implicit function calls (e.g. "sin x")
        node.okForImplicitFunction = function() {
            return false;
        };

        node.getConcreteTree = function(frame) {
            console.log("Warning - default empty version of getConcreteTree being called");
            return this;
        };

        node.tryGetConcreteTree = function() {
            var concrete;
            try {
                concrete = this.getConcreteTree.apply(this, arguments);
            } catch (e) {
                if (e instanceof _class) { //only catch ErrorNodes
                    concrete = e;
                } else {
                    throw e; //Re-throw
                }
            }
            return concrete;
        };

        //Function compilation helpers
        //TODO - put this compilation functionality somewhere more general
        node.getCompiledFunctions = function(args) {
            var strings = this.getEvalStrings();
            var source = strings.statements.join(';') + ';return ' + strings.expression;

            if (args === undefined) {
                args = this.getDependencies();

                // By convention, 'x' always comes first in the argument list
                var i = args.indexOf('x');
                if (i !== -1) {
                    var tmp = args[0];
                    args[0] = args[i];
                    args[i] = tmp;
                }
            }

            return [{
                args: args,
                source: source,
                fn: Functions.closureFunctionWithBuiltIn(args, source)
            }];
        };

        node.getCompiledDerivatives = function() {
            var dependencies = this.getDependencies();
            var derivative = this.takeDerivative(dependencies[0] || 'x');
            return derivative.getCompiledFunctions();
        };
    });
});

define('lib/worker-i18n', ['require', 'underscore'], function(require) {
    var _ = require('underscore');
    //in the worker, we don't want the real i18n. But we do want:
    // * a familiar API
    // * for the i18n parser to be able to go through and find strings to push to crowdin
    //
    // this function only has the 't' method, and it just turns the whole ordeal into
    // a single JSON.stringified string that can be unpacked and translated outside of the worker.

    var packString = function(message, variables) {
        if (!variables || _.size(variables) === 0) return message;
        return JSON.stringify({
            msg: message,
            vars: variables
        });
    };

    return {
        t: packString
    };
});

define('math/parsenode/error', ['require', 'pjs', './base'], function(require) {
    var P = require('pjs');
    var ParseNode = require('./base');
    return P(ParseNode, function(node, _super) {
        node.init = function(msg) {
            _super.init.call(this);
            this._msg = msg;
            this._sliderVariables = [];
            this.blocksExport = true;
        };

        node.evaluateOnce = function(frame) {
            return this._msg;
        };

        node.getConcreteTree = function(frame, overrides) {
            if (overrides && overrides[this.type]) return overrides[this.type].call(this, frame, overrides);
            return this;
        };

        node.isError = true;

        node.getError = function() {
            return this._msg;
        };

        node.setDependencies = function(symbols) {
            this._dependencies = symbols;
            return this;
        };

        node.allowExport = function() {
            this.blocksExport = false;
            return this;
        };
    });
});

define('graphing/label', ['math/builtin'], function(BuiltIn) {
    // Returns a label for a point with an appropriate number of decimals for the
    // given scale. Scale is typically chosen to be the range of numbers displayed
    // in the current viewport. Rounds to pi fractions when the denominator is 24
    // or less, according to a tolerance that depends on x and scale.
    //
    // Label is returned as on object with the string representation given by
    // label.string, and represented value label.value, which is equal to x when
    // the string is a decimal representation, and equal to n*Math.PI/d for pi
    // fractions. This is used for checking if a labeled value is actually a hole
    // in the function.
    function value(x, scale) {

        if (isNaN(x)) return { string: 'undefined', value: x };

        if (x === 0) return { string: '0', value: x };

        if (!scale) scale = x;

        var piFraction = BuiltIn.toFraction(x / Math.PI, 24);
        var nString;
        var dString;

        if (
            fewDigits(scale) &&
            BuiltIn.approx(piFraction.n / piFraction.d * Math.PI, x, 3)
        ) {
            if (piFraction.n === 0) {
                nString = "0";
            } else if (piFraction.n === 1) {
                nString = "Ï€";
            } else if (piFraction.n === -1) {
                nString = "-Ï€";
            } else {
                nString = piFraction.n.toString() + "Ï€";
            }

            if (piFraction.d === 1) {
                dString = "";
            } else {
                dString = "/" + piFraction.d.toString();
            }

            return {
                string: nString + dString,
                value: piFraction.n / piFraction.d * Math.PI
            };
        }

        var mantissa, superscript, string;
        if (fewDigits(scale)) {
            string = stripZeros(x.toFixed(decimalsFromScale(scale)));
            superscript = null;
            mantissa = null;

        } else {
            var parts = stripExponentialZeros(x.toExponential(decimalsFromScale(scale / x))).split('e');
            mantissa = parts[0] + '\u00d7' + '10';
            superscript = parts[1].replace('+', '');
            string = stripExponentialZeros(x.toExponential(decimalsFromScale(scale / x))).replace('+', '');
        }

        return { string: string, mantissa: mantissa, superscript: superscript, value: x };
    }

    // x and f(value(x).value), returning the results as two strings. Useful
    // because the function may have a hole at value(x).value.
    function point(x, xscale, yscale, fn) {
        var xlabel = value(x, xscale);
        var ylabel = value(fn(xlabel.value), yscale);
        return [xlabel, ylabel];
    }

    // Strip trailing zeros from a string representation of a decimal.
    var trailingZerosRegex = /\.?0+$/;

    function stripZeros(string) {
        if (string.indexOf('.') === -1) return string;
        return string.replace(trailingZerosRegex, '');
    }

    var exponentialTrailingZerosRegex = /\.?0+e/;

    function stripExponentialZeros(string) {
        return string.replace(exponentialTrailingZerosRegex, 'e');
    }

    function fewDigits(x) {
        x = Math.abs(x);
        return 1e-4 < x && x < 1e7;
    }

    // Returns integer number of decimals to show given scale of numbers to be
    // represented.
    function decimalsFromScale(scale) {
        scale = Math.abs(scale);
        scale = Math.max(scale, 1e-16);
        return Math.max(0, Math.floor(4.5 - Math.log(scale) / Math.LN10));
    }

    function htmlSciNote(string) {
        string = stripExponentialZeros(string);
        return string.replace(/([\d\.\-]+)e\+?([\d\-]+)/, "$1<span class='dcg-cross'>Ã—</span>10<sup>$2</sup>");
    }

    function latexSciNote(string) {
        string = stripExponentialZeros(string);
        return string.replace(/([\d\.\-]+)e\+?([\d\-]+)/, "$1\\times10^{$2}");
    }

    var symbolTable = {
        'pi': 'Ï€',
        'tau': 'Ï„',
        'theta': 'Î¸'
    };

    function formatSymbol(symbol) {
        return symbolTable.hasOwnProperty(symbol) ? symbolTable[symbol] : symbol;
    }

    function identifierToLatex(symbol) {
        var pieces = symbol.split('_');
        var out = '';
        if (pieces[0].length > 1) out += '\\';
        out += pieces[0];
        if (pieces[1]) {
            if (pieces[1].length === 1) {
                out += '_' + pieces[1];
            } else {
                out += '_{' + pieces[1] + '}';
            }
        }
        return out;
    }

    function latexToIdentifier(symbol) {
        return symbol.replace(/[{}\\]/g, '');
    }

    return {
        stripZeros: stripZeros,
        htmlSciNote: htmlSciNote,
        latexSciNote: latexSciNote,
        value: value,
        point: point,
        formatSymbol: formatSymbol,
        identifierToLatex: identifierToLatex,
        latexToIdentifier: latexToIdentifier
    };

});

// NOTE, this file is an exception to our usual style guide.
//
// It uses double quoted strings to avoid escaping a lot of single quotes, and it uses long lines
// because our i18n parser requires translation strings to be literals that appear on the same line
// as the `i18n.t(` function invocation.
define('math/errormsg', ['require', 'lib/worker-i18n', 'math/parsenode/error', 'graphing/label', 'math/policy'], function(require) {
    /*jshint maxlen:200*/

    var i18n = require('lib/worker-i18n');
    var ErrorNode = require('math/parsenode/error');
    var Label = require('graphing/label');
    var Policy = require('math/policy');

    return {
        parseError: function() {
            return ErrorNode(i18n.t("Sorry, I don't understand this."));
        },

        deeplyNested: function() {
            return ErrorNode(i18n.t("Definitions are nested too deeply."));
        },

        wrongArity: function(symbol, arity, providedArity) {
            symbol = Label.formatSymbol(symbol);
            var msg, supplement;
            if (arity === 1) {

                supplement = i18n.t("For example, try typing: __dependency__(x).", {
                    dependency: symbol
                });

                if (providedArity > 1) { //requires 1 vs require an
                    msg = i18n.t("Function '__dependency__' requires only 1 argument. __supplement__", {
                        dependency: symbol,
                        supplement: supplement
                    });
                } else {
                    msg = i18n.t("Function '__dependency__' requires an argument. __supplement__", {
                        dependency: symbol,
                        supplement: supplement
                    });
                }
            } else {
                var args = [];
                //construct an example of using the function
                for (var j = 0; j < arity; j++) { args[j] = j + 1; }
                var recommendation = symbol + "(" + args.join(", ") + ")";

                supplement = i18n.t("For example, try typing: __recommendation__.", {
                    recommendation: recommendation
                });

                msg = i18n.t("Function '__dependency__' requires __assignment_arity__ arguments. __supplement__", {
                    dependency: symbol,
                    assignment_arity: arity,
                    supplement: supplement
                });
            }
            return ErrorNode(msg);
        },

        zeroArgReducer: function(symbol) {
            return ErrorNode(i18n.t("Function '__symbol__' requires at least one argument. For example, try typing: __symbol__(1, 2).", {
                symbol: Label.formatSymbol(symbol)
            }));
        },

        missingRHS: function(symbol) {
            symbol = Label.formatSymbol(symbol);
            return ErrorNode(i18n.t("What do you want '__symbol__' to equal?", {
                symbol: symbol
            }));
        },

        malformedPoint: function() {
            return ErrorNode(i18n.t("Points are written like this: (1, 2)."));
        },

        badTrigImplicitMultiply: function() {
            return ErrorNode(i18n.t("Too complicated. Use parens."));
        },

        badTrigExponent: function(prefix) {
            var form1 = prefix + '^2';
            var form2 = prefix + '^-1';
            return ErrorNode(i18n.t("Only __form1__ and __form2__ are supported. Otherwise, use parens.", {
                form1: form1,
                form2: form2
            }));
        },

        badLogImplicitMultiply: function() {
            return ErrorNode(i18n.t("Too complicated. Use parens."));
        },

        badLogExponent: function(prefix) {
            var form = prefix + '^2';
            return ErrorNode(i18n.t("Only __form__ is supported. Otherwise, use parens.", {
                form: form
            }));
        },

        blankExpression: function() {
            return ErrorNode(i18n.t("You haven't written anything yet."));
        },

        functionNotDefined: function(symbol) {
            symbol = Label.formatSymbol(symbol);
            return ErrorNode(i18n.t("Function '__dependency__' is not defined.", {
                dependency: symbol
            }));
        },

        parameterAlreadyDefined: function(symbol) {
            symbol = Label.formatSymbol(symbol);
            return ErrorNode(i18n.t("You can't use '__dependency__' as a parameter of this function because '__dependency__' is already defined.", {
                dependency: symbol
            }));
        },

        cannotRedefine: function(symbol) {
            symbol = Label.formatSymbol(symbol);
            return ErrorNode(i18n.t("You can't redefine '__symbol__' because it's already defined.", {
                symbol: symbol
            }));
        },

        multiplyDefined: function(symbol) {
            symbol = Label.formatSymbol(symbol);
            return ErrorNode(i18n.t("You've defined '__dependency__' in more than one place. Try picking a different variable, or deleting some of the definitions of '__dependency__'.", {
                dependency: symbol
            }));
        },

        shadowedIndex: function(symbol) {
            symbol = Label.formatSymbol(symbol);
            return ErrorNode(i18n.t("You can't use '__symbol__' as an index because it's already defined.", {
                symbol: symbol
            }));
        },

        cycle: function(symbols) {
            symbols = symbols.map(Label.formatSymbol);

            var lastSymbol = symbols.pop();

            return ErrorNode(i18n.t("'__symbols__' and '__lastSymbol__' can't be defined in terms of each other.", {
                symbols: symbols.join("', '"),
                lastSymbol: lastSymbol
            }));
        },

        tooManyVariables: function(symbols) {
            symbols = symbols.map(Label.formatSymbol);

            if (symbols.length === 0) {
                return ErrorNode(i18n.t("Too many variables, I don't know what to do with this."));
            }

            var lastSymbol = symbols.pop();

            return ErrorNode(i18n.t("Too many variables. Try defining '__variables__'.", {
                variables: (symbols.length ? symbols.join("', '") + "' or '" : "") + lastSymbol
            }));
        },

        addArgumentsToDefinition: function(symbols, head, args) {
            symbols = symbols.map(Label.formatSymbol);
            head = Label.formatSymbol(head);
            args = args.map(Label.formatSymbol);

            var newSignature = head + '(' + args.join(',') + ',' + symbols.join(',') + ')';
            var lastSymbol = symbols.pop();

            var interpolants = {
                symbols: symbols.join("', '"),
                lastSymbol: lastSymbol,
                newSignature: newSignature
            };

            if (symbols.length) {
                return ErrorNode(i18n.t("Try including '__symbols__' and '__lastSymbol__' as arguments by defining the function as '__newSignature__'.",
                    interpolants
                ));
            } else {
                return ErrorNode(i18n.t("Try including '__lastSymbol__' as an argument by defining the function as '__newSignature__'.",
                    interpolants
                ));
            }
        },

        invalidLHS: function(symbol) {
            symbol = Label.formatSymbol(symbol);
            return ErrorNode(i18n.t("Sorry, you can't graph __symbol__ as a function of anything yet.", {
                symbol: symbol
            }));
        },

        unplottablePolarFunction: function() {
            return ErrorNode(i18n.t("We can't plot Î¸ as a function of r. Try plotting r(Î¸) instead."));
        },

        invalidInequalityVariables: function() {
            return ErrorNode(i18n.t('We only plot inequalities of x and y, or r and Î¸.'));
        },

        invalidImplicitVariables: function() {
            return ErrorNode(i18n.t("We only support implicit equations of x and y."));
        },

        unsolvable: function() {
            return ErrorNode(i18n.t("We don't solve complicated single-variable equations yet."));
        },

        singleVariableListSolve: function() {
            return ErrorNode(i18n.t("We don't solve single-variable equations involving lists yet."));
        },

        complicatedImplicitInequality: function() {
            return ErrorNode(i18n.t("We can only plot inequalities when one variable is quadratic or linear."));
        },

        complicatedPolarImplicit: function() {
            return ErrorNode(i18n.t("Polar equations must be linear in r."));
        },

        invalidDoubleInequalityVariables: function() {
            return ErrorNode(i18n.t('We only plot double inequalities of x and y.'));
        },

        mismatchedDoubleInequality: function() {
            return ErrorNode(i18n.t("Double inequalities must both go the same way, e.g. 1 < y < 2."));
        },

        complicatedDoubleInequality: function() {
            return ErrorNode(i18n.t("We only support solved double inequalities. Try deleting one side of the inequality."));
        },

        equationRequired: function(symbol) {
            if (symbol) {
                return ErrorNode(i18n.t("Try adding '__lhs__' to the beginning of this equation.", {
                    lhs: Policy.implicitDependency(symbol) + "="
                }));
            } else {
                return ErrorNode(i18n.t("Try adding an equals sign to turn this into an equation."));
            }
        },

        variableAsFunction: function(symbol) {
            symbol = Label.formatSymbol(symbol);
            return ErrorNode(i18n.t("Variable '__dependency__' can't be used as a function.", {
                dependency: symbol
            }));
        },

        nestedList: function() {
            return ErrorNode(i18n.t("Nested lists are not allowed."));
        },

        invalidTableHeader: function(supplement) {
            return ErrorNode(i18n.t("Table headers must be simple expressions. __supplement__", {
                supplement: supplement
            }));
        },

        invalidTableEntry: function(supplement) {
            return ErrorNode(i18n.t("Table entries must be simple expressions. __supplement__", {
                supplement: supplement
            }));
        },

        invalidFirstTableColumn: function() {
            return ErrorNode(i18n.t("First column may not be __most__ or __last__.", {
                most: "'y', 'r',",
                last: "'Î¸'"
            }));
        },

        invalidDependentFirstTableColumn: function() {
            return ErrorNode(i18n.t("This column header can't be defined elsewhere in the calculator."));
        },

        invalidRegressionParameter: function(symbol) {
            return ErrorNode(i18n.t("'__symbol__' may not be used as a regression parameter.", {
                symbol: Label.formatSymbol(symbol)
            }));
        },

        optimizationError: function() {
            return ErrorNode(i18n.t("Failed to find regression coefficients."));
        },

        nonListRegression: function() {
            return ErrorNode(i18n.t("Regressions must contain at least one list of data."));
        },

        badListInReducer: function(symbol) {
            return ErrorNode(i18n.t("When __symbol__ is called with multiple arguments, no argument can be a list.", {
                symbol: Label.formatSymbol(symbol)
            }));
        },

        indexIntoNonList: function() {
            return ErrorNode(i18n.t("Cannot index into something that is not a list."));
        },

        listAsIndex: function() {
            return ErrorNode(i18n.t("List index must not be a list."));
        },

        variableRange: function(symbols) {
            return ErrorNode(i18n.t("Range cannot depend on free variable '__symbol__'.", {
                symbol: Label.formatSymbol(symbols[0])
            }));
        },

        nonArithmeticRange: function(symbols) {
            return ErrorNode(i18n.t("Ranges must be arithmetic sequences."));
        }
    };
});

define('math/parsenode/expression', ['require', 'pjs', './base', 'math/errormsg'], function(require) {
    //Expression parse-nodes have an output value
    //And can exist within an expression tree
    //This includes constants, variables, math operators, and functions
    //This does not include function calls, inequalities,
    //or variable definitions
    var P = require('pjs');
    var ParseNode = require('./base');
    var ErrorMsg = require('math/errormsg');

    return P(ParseNode, function(node, _super) {
        node.init = function(args) {
            if (!Array.isArray(args)) {
                throw new TypeError('Argument to expression constructor must be an Array.');
            }

            _super.init.call(this);
            this.args = args;
            this.registerDependencies();
            this.computeTreeSize();
        };

        //By default, we depend on all of our args
        node.registerDependencies = function() {
            for (var i = 0; i < this.args.length; i++) {
                this.addDependencies(this.args[i].getDependencies());
            }
        };

        node.computeTreeSize = function() {
            var treeSize = 0;
            for (var i = 0; i < this.args.length; i++) {
                if (this.args[i].treeSize) treeSize += this.args[i].treeSize;
            }
            this.treeSize = treeSize + 1;
            if (treeSize > 1e4) throw ErrorMsg.deeplyNested();
        };

        node.getConcreteTree = function(frame, overrides) {
            if (overrides && overrides[this.type]) return overrides[this.type].call(this, frame, overrides);
            var concreteArgs = [];
            for (var i = 0; i < this.args.length; i++) {
                concreteArgs.push(this.args[i].getConcreteTree(frame, overrides));
            }
            return this.copyWithArgs(concreteArgs);
        };

        //Default behavior.
        //Some nodes need to over-ride, since they have additional configuration beyond args
        node.copyWithArgs = function(args) {
            return new this.constructor(args);
        };

    });
});

define('math/parsenode/constant', ['require', 'pjs', './base'], function(require) {
    var P = require('pjs');
    var ParseNode = require('./base');

    return P(ParseNode, function(node, _super) {
        node.init = function(value) {
            _super.init.call(this, []);
            this.constantValue = value;
        };

        node.isConstant = true;

        node.getConcreteTree = function(frame, overrides) {
            if (overrides && overrides[this.type]) return overrides[this.type].call(this, frame, overrides);
            return this;
        };

        node.getEvalStrings = function() {
            return {
                statements: [],
                expression: this.scalarExprString()
            };
        };

        node.scalarExprString = function() {
            if (this.constantValue > 0) return String(this.constantValue);
            return '(' + String(this.constantValue) + ')';
        };

        node.getEvaluationInfo = function() {
            return [{ val: this.constantValue, operator: '=' }];
        };

        node.okForImplicitFunction = function() {
            return true;
        };
    });
});

define('math/parsenode/list', ['require', 'pjs', './expression', './constant', 'math/errormsg'], function(require) {
    var P = require('pjs');
    var Expression = require('./expression');
    var Constant = require('./constant');
    var ErrorMsg = require('math/errormsg');

    return P(Expression, function(node, _super, _class) {
        node.init = function(elements) {
            _super.init.call(this, elements);
            this.length = elements.length;
        };

        node.isList = true;

        node.elementAt = function(i) {
            i = Math.floor(i);
            if (i >= 0 && i < this.args.length) return this.args[i];
            return Constant(NaN);
        };

        node.getEvalStrings = function() {
            var retVal = [];
            for (var i = 0; i < this.args.length; i++) {
                retVal.push(this.args[i].getEvalStrings());
            }
            return retVal;
        };

        node.getConcreteTree = function(frame, overrides) {
            if (overrides && overrides[this.type]) return overrides[this.type].call(this, frame, overrides);
            var concreteElements = [];
            for (var i = 0; i < this.args.length; i++) {
                var concreteElement = this.args[i].getConcreteTree(frame, overrides);
                if (concreteElement.isList) throw ErrorMsg.nestedList();
                concreteElements.push(concreteElement);
            }
            return new this.constructor(concreteElements);
        };

        node.getEvaluationInfo = function() {
            /*If we're a list of constants, we're evaluable*/
            if (this.args.every(function(a) { return a.isConstant })) {
                return [{ val: this.args.map(function(a) { return a.constantValue }), operator: '=' }];
            }
        };

        node.getCompiledFunctions = function(args) {
            return this.args.map(function(a) { return a.getCompiledFunctions(args)[0]; });
        };

        // Length of longest list in args. Returns Infinity if there are no lists
        // in args.
        function _listLength(args) {
            var length = Infinity;
            for (var i = 0; i < args.length; i++) {
                if (args[i].isList) length = Math.min(length, args[i].length);
            }
            return length;
        }

        _class.eachArgs = function(args, fn) {
            var length = _listLength(args);

            if (!isFinite(length)) {
                fn(args);
                return;
            }

            for (var i = 0; i < length; i++) {
                var elts = [];
                for (var j = 0; j < args.length; j++) {
                    elts.push(args[j].isList ? args[j].elementAt(i) : args[j]);
                }
                fn(elts);
            }
        };

        _class.mapArgs = function(args, fn) {
            var length = _listLength(args);

            if (!isFinite(length)) return [fn(args)];

            var accum = [];
            for (var i = 0; i < length; i++) {
                var elts = [];
                for (var j = 0; j < args.length; j++) {
                    elts.push(args[j].isList ? args[j].elementAt(i) : args[j]);
                }
                accum.push(fn(elts));
            }
            return accum;
        };
    });
});

define('math/parsenode/scalarexpression', ['require', 'pjs', './expression', './constant', './list'], function(require) {
    var P = require('pjs');
    var ExpressionNode = require('./expression');
    var Constant = require('./constant');
    var List = require('./list');

    //This represents expressions which follow the standard broadcast pattern
    //for all of their arguments (scalar if all arguments are scalar, otherwise
    //a list with length equal to the minimum length of their list arguments).
    //
    //On getConcreteTree, this will bubble any list arguments up above itself,
    //to convert an operation on lists to a list of operations on scalars

    return P(ExpressionNode, function(node, _super) {
        node.init = function(args) {
            _super.init.call(this, args);
        };

        node.getConcreteTree = function(frame, overrides) {
            if (overrides && overrides[this.type]) return overrides[this.type].call(this, frame, overrides);
            //Return a tree which supports frame-based operations like
            //computing polynomialOrder, compiling, type checks, etc.
            //
            //This operation will descend into function calls,
            //substitute variables, and collapse constants
            //
            //This operation will also perform the broadcast logic
            //to map an operation over lists into a list of scalar
            //operation trees.
            //
            //Default operation is to ignore the frame, and generate
            //an identical node but with concrete children
            var i;

            var concreteArgs = [];
            var anyIsList = false;
            for (i = 0; i < this.args.length; i++) {
                var concreteArg = this.args[i].getConcreteTree(frame, overrides);
                if (concreteArg.isList) anyIsList = true;
                concreteArgs.push(concreteArg);
            }

            if (!anyIsList) return this._constantCollapsedCopy(concreteArgs, frame);

            var self = this;
            var elements = List.mapArgs(concreteArgs, function(args) {
                return self._constantCollapsedCopy(args, frame);
            });
            return List(elements);
        };

        node._constantCollapsedCopy = function(args) {
            var constantArgs = [];
            for (var i = 0; i < args.length; i++) {
                if (!args[i].isConstant) //Not constant - just copy
                    return this.copyWithArgs(args);
                constantArgs.push(args[i].constantValue);
            }
            return Constant(this.evaluate(constantArgs)); //Everything was a constant.  Evaluate and return
        };

        node.getEvalStrings = function() {
            //Only works when frame has been baked into the tree, so
            //that lists are guaranteed to be above us or below
            //reducers, and we don't have to deal with them
            //Default implementation:
            //Calls getEvalStrings on each argument
            //Prepends statements, and replaces expression
            //using scalarEvalExpression()
            var statements = [];
            var argExpressions = [];
            for (var i = 0; i < this.args.length; i++) {
                var evalStrings = this.args[i].getEvalStrings();
                statements = statements.concat(evalStrings.statements);
                argExpressions.push(evalStrings.expression);
            }
            return { statements: statements, expression: this.scalarEvalExpression(argExpressions) };
        };

    });
});

define('math/parsenode/expressionTypes', ['require', 'pjs', './scalarexpression'], function(require) {
    var P = require('pjs');
    var ScalarExpression = require('./scalarexpression');

    return {
        Add: P(ScalarExpression, {}),
        Subtract: P(ScalarExpression, {}),
        Multiply: P(ScalarExpression, {}),
        Divide: P(ScalarExpression, {}),
        Exponent: P(ScalarExpression, {}),
        Negative: P(ScalarExpression, {}),
        And: P(ScalarExpression, {
            isInequality: function() { return this.args[0].isInequality() && this.args[1].isInequality(); }
        })
    };
});

define('math/parsenode/freevariable', ['require', 'pjs', './scalarexpression'], function(require) {
    var P = require('pjs');
    var Parent = require('./scalarexpression');

    //Only meant to exist after a call to getConcreteTree
    //This is what an identifier that is not defined in the frame becomes

    return P(Parent, function(node, _super) {
        node.init = function(symbol) {
            _super.init.call(this, []);
            this.addDependency(symbol);
            this._symbol = symbol;
        };

        node.isFreeVariable = true;

        node.scalarEvalExpression = function(argExpressions) {
            return this._symbol;
        };

        node.copyWithArgs = function(args) {
            return this;
        };

        node._constantCollapsedCopy = function(args) {
            return this;
        };

        node.getConcreteTree = function(frame, overrides) {
            if (overrides && overrides[this.type]) return overrides[this.type].call(this, frame, overrides);
            return this;
        };

    });
});

define('math/parsenode/identifier', ['require', 'pjs', './expression', './freevariable', 'graphing/label'], function(require) {
    var P = require('pjs');
    var Parent = require('./expression');
    var FreeVariable = require('./freevariable');
    var Label = require('graphing/label');

    return P(Parent, function(node, _super, _class) {
        node.init = function(symbol) {
            _super.init.call(this, []);
            this._symbol = Label.latexToIdentifier(symbol);
            this.addDependency(this._symbol);
        };

        node.evaluate = function() { throw ("Cannot evaluate undefined variable " + this._symbol) };

        node.getConcreteTree = function(frame, overrides) {
            if (overrides && overrides[this.type]) return overrides[this.type].call(this, frame, overrides);
            //If tree is defined in frame, return concrete version of that
            var tree = frame[this._symbol];
            if (tree) {
                if (tree.isError) throw tree;
                if (tree.isFunction) return tree.getConcreteInvocationTree(frame, [], this._symbol, overrides);
                return tree.getConcreteTree(frame, overrides);
            }
            //Otherwise, we're a free variable
            return FreeVariable(this._symbol);
        };

        node.okForImplicitFunction = function() {
            return true;
        };
    });
});

define('math/parsenode/dummyindex', ['require', 'pjs', './freevariable'], function(require) {
    var P = require('pjs');
    var Parent = require('./freevariable');

    // Only meant to exist after a call to getConcreteTree
    // This is what the index symbol of a repeated operator becomes. It's main purpose
    // is to express the fact that the concrete tree no longer depends on external
    // values of that variable.

    return P(Parent, function(node, _super) {
        node.init = function() {
            _super.init.apply(this, arguments);
            this._dependencies = [];
        };
    });
});

define('math/parsenode/range', ['require', 'pjs', './expression', 'math/errormsg', './list', './constant', 'math/builtin'], function(require) {
    var P = require('pjs');
    var Parent = require('./expression');
    var ErrorMsg = require('math/errormsg');
    var List = require('./list');
    var Constant = require('./constant');
    var BuiltIn = require('math/builtin');

    return P(Parent, function(node, _super, _class) {
        node.init = function(args) {
            _super.init.call(this, args);
            this.beginning = args[0];
            this.end = args[1];
        };

        function _checkVal(concreteBeginning, concreteEnd, i, nsteps, val) {
            if (i < concreteBeginning.length) {
                if (!BuiltIn.approx(val, concreteBeginning.elementAt(i).constantValue, 10)) {
                    throw ErrorMsg.nonArithmeticRange();
                }
            }
            // Note, puprosely don't check actual end value
            if (nsteps - i <= concreteEnd.length && nsteps - i > 1) {
                if (!BuiltIn.approx(val, concreteEnd.elementAt(concreteEnd.length - nsteps + i).constantValue, 10)) {
                    throw ErrorMsg.nonArithmeticRange();
                }
            }
        }

        node.getConcreteTree = function(frame, overrides) {
            if (overrides && overrides[this.type]) return overrides[this.type].call(this, frame, overrides);
            var concreteBeginning = this.beginning.getConcreteTree(frame, overrides);
            var concreteEnd = this.end.getConcreteTree(frame, overrides);

            if (concreteBeginning.getDependencies().length) {
                throw ErrorMsg.variableRange(concreteBeginning.getDependencies());
            }
            if (concreteEnd.getDependencies().length) {
                throw ErrorMsg.variableRange(concreteEnd.getDependencies());
            }
            if (!concreteBeginning.isList || !concreteEnd.isList) {
                throw new Error("Programming Error: range bounds must be List nodes.");
            }

            var start = concreteBeginning.elementAt(0).constantValue;
            var end = concreteEnd.elementAt(concreteEnd.length - 1).constantValue;
            var diff = end - start;
            var step;
            if (concreteBeginning.length === 1) {
                step = diff >= 0 ? 1 : -1;
            } else {
                step = concreteBeginning.elementAt(1).constantValue - start;
            }
            var nsteps = Math.round(diff / step) + 1;
            if (!isFinite(nsteps) || nsteps < concreteBeginning.length || nsteps < concreteEnd.length) {
                throw ErrorMsg.nonArithmeticRange();
            }

            var accum = [Constant(start)];

            for (var i = 1; i < nsteps; i++) {
                // Barrycentric interpolation is the best way to
                // hit start and end exactly, and get good values
                // in the middle
                var val = start + i * step;
                _checkVal(concreteBeginning, concreteEnd, i, nsteps, val);
                accum.push(Constant(val));
            }

            return List(accum);
        };
    });
});

define('math/parsenode/listaccess', ['require', 'pjs', './expression', 'math/errormsg'], function(require) {
    var P = require('pjs');
    var Super = require('./expression');
    var ErrorMsg = require('math/errormsg');

    return P(Super, function(node, _super) {
        node.init = function(args) {
            _super.init.call(this, args);
            this.list = args[0];
            this.index = args[1];
        };

        node.getConcreteTree = function(frame, overrides) {
            if (overrides && overrides[this.type]) return overrides[this.type].call(this, frame, overrides);
            var concreteIndex = this.index.getConcreteTree(frame, overrides);
            if (concreteIndex.isList) throw ErrorMsg.listAsIndex();
            if (concreteIndex.isConstant) {
                //Convert from 1-index user-visible math to 0-indexed internal math
                //TODO - could be more efficient, and only make that list element concrete
                //but this is hard for examples where the list has to be evaluated or looked up
                var concreteList = this.list.getConcreteTree(frame, overrides);
                if (!concreteList.isList) throw ErrorMsg.indexIntoNonList();
                return concreteList.getConcreteTree(frame, overrides).elementAt(concreteIndex.constantValue - 1);
            }
            return new this.constructor([this.list.getConcreteTree(frame, overrides), concreteIndex]);
        };

        node.getEvalStrings = function() {
            var indexStrings = this.index.getEvalStrings();
            var listStrings = this.list.getEvalStrings();
            var statements = indexStrings.statements.slice(); //Statements required to compute index

            var tmp = this.tmpVar();
            statements.push('var ' + tmp);

            var caseStrings = [];
            for (var i = 0; i < listStrings.length; i++) {
                caseStrings.push('case ' + i + ':' +
                    listStrings[i].statements.join(';') + ';' +
                    tmp + '=' + listStrings[i].expression);
            }
            caseStrings.push('default:' + tmp + '=NaN');
            //Convert from 1-index user-visible math to 0-indexed internal math
            var switchStatement = 'switch(Math.floor(' + (indexStrings.expression) + ')-1){\n' +
                caseStrings.join(';break\n') +
                '\n}';

            statements.push(switchStatement);
            return { statements: statements, expression: tmp };
        };
    });
});

define('math/parsenode/orderedpair', ['require', 'pjs', './expression', './list', 'math/policy'], function(require) {
    var P = require('pjs');
    var Expression = require('./expression');
    var List = require('./list');
    var Policy = require('math/policy');

    return P(Expression, function(node, _super, _class) {
        node.getCompiledFunctions = function(args) {
            return [
                this.args[0].getCompiledFunctions(args)[0],
                this.args[1].getCompiledFunctions(args)[0]
            ];
        };

        node.getSliderVariables = function(concrete) {
            return Policy.sliderVariables(concrete.getDependencies()).filter(function(symbol) {
                return !Policy.validParametricVariable(symbol);
            });
        };

        node.getConcreteTree = function(frame, overrides) {
            var concreteArgs = [];
            for (var i = 0; i < this.args.length; i++) {
                concreteArgs.push(this.args[i].getConcreteTree(frame, overrides));
            }

            return this.copyWithArgs(concreteArgs);
        };

        // nonstandard constructor used by parser to desugar an ordered pair list
        // into a single ordered pair with lists of coordinates, i.e. to desugar
        // (1, 2), (3, 4) into ([1,3], [2,4])
        _class.fromList = function(list) {
            if (list.length === 1) return list[0];
            var xargs = [];
            var yargs = [];
            for (var i = 0; i < list.length; i++) {
                xargs.push(list[i].args[0]);
                yargs.push(list[i].args[1]);
            }
            return _class([List(xargs), List(yargs)]);
        };
    });
});

define('math/parsenode/movablepoint', ['require', 'pjs', './orderedpair'], function(require) {
    var P = require('pjs');
    var Parent = require('./orderedpair');

    return P(Parent, function(node, _super) {
        node.init = function(args, moveIds, moveMatrix) {
            _super.init.call(this, args);
            this._moveIds = moveIds;
            this._moveMatrix = moveMatrix;
        };

        node.isMovablePoint = true;
    });
});

//Use this table to get rid of all the string comparisons used to interpret comparators
define('math/comparators', ['require'], function(require) {

    var ComparatorTable = {
        '<': { inclusive: false, direction: -1 },
        '!=': { inclusive: false, direction: 0 },
        '>': { inclusive: false, direction: 1 },
        '<=': { inclusive: true, direction: -1 },
        '=': { inclusive: true, direction: 0 },
        '>=': { inclusive: true, direction: 1 }
    };

    var getComparator = function(inclusive, direction) {
        switch (direction) {
            case -1:
                return (inclusive ? '<=' : '<');
            case 0:
                return (inclusive ? '=' : '!=');
            case 1:
                return (inclusive ? '>=' : '>');
            default:
                throw "Programming error.  Comparators must have a direction of -1, 0, or 1";
        }
    };

    return {
        table: ComparatorTable,
        get: getComparator,
    };

});

define('math/parsenode/basecomparator', ['require', 'pjs', './scalarexpression', './expressionTypes', 'math/comparators', 'math/functions'], function(require) {
    var P = require('pjs');
    var ScalarExpression = require('./scalarexpression');
    var Subtract = require('./expressionTypes').Subtract;
    var comparatorTable = require('math/comparators').table;
    var Functions = require('math/functions');

    return P(ScalarExpression, function(node, _super, _class) {
        // Create concrete Comparator classes by calling BaseComparator.create(operator).
        // This happens in parsenode/comparator.js
        _class.create = function(operator, compiledOperator) {
            compiledOperator = compiledOperator || operator;
            return P(_class, function(node, _super) {
                node.operator = operator;
                node.isInequality = function() { return comparatorTable[operator].direction !== 0; };
                node.compiledOperator = compiledOperator || operator;
                node.scalarEvalExpression = function(args) { return args.join(compiledOperator); };

                node.evaluate = Functions.createEvaluateFunction(node.scalarEvalExpression, 2);
            });
        };

        node.init = function(args) {
            _super.init.call(this, args);

            this._difference = comparatorTable[this.operator].direction === -1 ?
                Subtract([args[1], args[0]]) :
                Subtract([args[0], args[1]]);
        };
    });
});

define('math/parsenode/comparator', ['require', 'math/parsenode/basecomparator'], function(require) {
    var BaseComparator = require('math/parsenode/basecomparator');

    return {
        '<': BaseComparator.create('<'),
        '>': BaseComparator.create('>'),
        '<=': BaseComparator.create('<='),
        '>=': BaseComparator.create('>='),
        '=': BaseComparator.create('=', '===')
    };
});

define('math/parsenode/piecewise', ['require', 'pjs', './scalarexpression', './constant'], function(require) {
    var P = require('pjs');
    var Parent = require('./scalarexpression');
    var Constant = require('./constant');

    var Piecewise = P(Parent, {});

    Piecewise.chain = function(args) {
        var next;
        var head = Constant(NaN); //Default if nothing matches
        while (args.length) {
            next = args.pop();
            head = Piecewise([next.condition, next.if_expr, head]);
        }
        return head;
    };

    return Piecewise;
});

define('math/parsenode/doubleinequality', ['require', 'pjs', './base', './identifier', './constant', './piecewise', 'math/comparators', './comparator'], function(require) {
    var P = require('pjs');
    var Parent = require('./base');
    var Identifier = require('./identifier');
    var Constant = require('./constant');
    var Piecewise = require('./piecewise');
    var Comparators = require('math/comparators');
    var Comparator = require('./comparator');

    return P(Parent, function(node, _super) {
        node.init = function(args) {
            _super.init.call(this);
            this._symbol = args[2]._symbol;
            this._operators = [args[1], args[3]];
            this._expressions = [args[0], args[4]];

            var indicatorComparator = Comparators.get(
                Comparators.table[args[1]].inclusive && Comparators.table[args[3]].inclusive,
                Comparators.table[args[1]].direction
            );

            this._indicator = Comparator[indicatorComparator]([args[0], args[4]]);
            this.addDependency(this._symbol);
            this.addDependencies(this._expressions[0].getDependencies());
            this.addDependencies(this._expressions[1].getDependencies());
        };

        node.isInequality = function() { return true; };

        node.isShadeBetween = function() { return true; };

        node.getConcreteTree = function(frame, overrides) {
            if (overrides && overrides[this.type]) return overrides[this.type].call(this, frame, overrides);
            return this.constructor.call(this, [
                Piecewise([this._indicator, this._expressions[0], Constant(NaN)]).getConcreteTree(frame, overrides),
                this._operators[0],
                Identifier(this._symbol), // TODO what if _symbol is in the frame?
                this._operators[1],
                Piecewise([this._indicator, this._expressions[1], Constant(NaN)]).getConcreteTree(frame, overrides)
            ]);
        };

        node.getCompiledFunctions = function(args) {
            return [
                this._expressions[0].getCompiledFunctions(args)[0], // TODO handle list expressions
                this._expressions[1].getCompiledFunctions(args)[0]
            ];
        };

        node.getCompiledDerivatives = function() {
            return [
                this._expressions[0].getCompiledDerivatives()[0],
                this._expressions[1].getCompiledDerivatives()[0]
            ];
        };
    });

});

define('math/parsenode/repeatedoperator', ['require', 'pjs', './scalarexpression', './dummyindex', './constant', 'math/errormsg'], function(require) {
    var P = require('pjs');
    var Parent = require('./scalarexpression');
    var DummyIndex = require('./dummyindex');
    var Constant = require('./constant');
    var ErrorMsg = require('math/errormsg');

    return P(Parent, function(node, _super) {
        node.init = function(args) {
            _super.init.call(this, args);
            this._index = args[0];
        };

        //Must define starting_value (e.g. 0)
        //Must define in_place_operator (e.g. "+=")
        //Must define evaluateConstant function

        //Always runs in a scalar environment, thanks to inheriting
        //from scalarexpression
        node.getEvalStrings = function() {
            var statements = [];

            var sum = this.tmpVar();
            var index = this._index._symbol;
            var lower_bound = this.tmpVar();
            var upper_bound = this.tmpVar();

            var lower_bound_strings = this.args[1].getEvalStrings();
            var upper_bound_strings = this.args[2].getEvalStrings();
            var summand_strings = this.args[3].getEvalStrings();

            Array.prototype.push.apply(statements, lower_bound_strings.statements);
            statements.push('var ' + lower_bound + ' = Math.round(' + lower_bound_strings.expression + ')');
            Array.prototype.push.apply(statements, upper_bound_strings.statements);
            statements.push('var ' + upper_bound + ' = Math.round(' + upper_bound_strings.expression + ')');
            statements.push('var ' + sum + '=' + this.starting_value);

            var loop = 'for (var ' + index + '=' + lower_bound + ';' + index + '<=' + upper_bound + ';' + index + '++) {' +
                summand_strings.statements.join(';') + ';' + sum + this.in_place_operator + summand_strings.expression + '};';

            var protected_loop = 'if(!isFinite(' + upper_bound + '-' + lower_bound + ')) {' +
                sum + '=(' + upper_bound + '<' + lower_bound + '?' + this.starting_value + ':NaN);}else{' + loop + '}';

            statements.push(protected_loop);

            return { statements: statements, expression: sum };
        };

        node.getConcreteTree = function(frame, overrides) {
            if (overrides && overrides[this.type]) return overrides[this.type].call(this, frame, overrides);
            if (frame[this._index._symbol]) throw ErrorMsg.shadowedIndex(this._index._symbol);
            var localFrame = Object.create(frame);
            localFrame[this._index._symbol] = DummyIndex(this._index._symbol);
            var concreteTree = _super.getConcreteTree.call(this, localFrame, overrides);
            return concreteTree;
        };

        node.evaluate = function(lowerBound, upperBound, summandExpression) {
            //Compile summand as function of loopVariable.
            //TODO - assert that it's not a list by this point
            var fn = summandExpression.getCompiledFunctions([this._index._symbol])[0].fn;
            //We know bounds are constant, otherwise we can't evaluate to a constant
            upperBound = Math.round(upperBound);
            lowerBound = Math.round(lowerBound);

            //Protect against NaNs and Infinities
            if (!isFinite(upperBound - lowerBound)) return (upperBound < lowerBound ? this.starting_value : NaN);

            //Run the loop
            var sum = this.starting_value;
            for (var index = lowerBound; index <= upperBound; index++) {
                sum = this.update(sum, fn(index));
            }
            return sum;
        };

        node._constantCollapsedCopy = function(args) {
            //Should collapse to constant if summand only depends on index variable
            if (args[1].isConstant && args[2].isConstant) {
                var lowerBound = args[1].constantValue;
                var upperBound = args[2].constantValue;
                var summand = args[3];
                if (summand.isConstant) {
                    //Constant loop can just be multiplied
                    return Constant(this.evaluateConstant([lowerBound, upperBound, summand.constantValue]));
                }
                if (summand.getDependencies().length === 0) {
                    //Compute, since we only depend on the loop variable
                    return Constant(this.evaluate(lowerBound, upperBound, summand));
                }
            }
            return this.copyWithArgs(args);
        };
    });
});

define('math/parsenode/sum', ['require', 'pjs', './repeatedoperator'], function(require) {
    var P = require('pjs');
    var Parent = require('./repeatedoperator');

    return P(Parent, function(node, _super) {
        node.in_place_operator = '+=';
        node.starting_value = 0;

        node.evaluateConstant = function(args) {
            var num_loops = 1 + Math.round(args[1]) - Math.round(args[0]);
            if (num_loops <= 0) return this.starting_value;
            return num_loops * args[3];
        };

        node.update = function(sum, value) {
            return sum + value;
        };
    });
});

define('math/parsenode/product', ['require', 'pjs', './repeatedoperator'], function(require) {
    var P = require('pjs');
    var Parent = require('./repeatedoperator');

    return P(Parent, function(node, _super) {
        node.in_place_operator = '*=';
        node.starting_value = 1;

        node.evaluateConstant = function(args) {
            var num_loops = 1 + Math.round(args[1]) - Math.round(args[0]);
            if (num_loops <= 0) return this.starting_value;
            return Math.pow(args[3], num_loops);
        };

        node.update = function(sum, value) {
            return sum * value;
        };
    });
});

define('math/parsenode/functioncall', ['require', 'pjs', './expression', 'math/errormsg', './identifier', './expressionTypes'], function(require) {
    var P = require('pjs');
    var Parent = require('./expression');
    var ErrorMsg = require('math/errormsg');
    var Identifier = require('./identifier');
    var Multiply = require('./expressionTypes').Multiply;

    return P(Parent, function(node, _super) {
        node.init = function(identifier, args) {
            if (typeof(identifier) === 'string') identifier = Identifier(identifier);
            this._symbol = identifier._symbol; //Relying on symbol rewrite logic in Identifier
            _super.init.call(this, args);
            this.addDependency(this._symbol);
        };

        node.copyWithArgs = function(args) {
            return new this.constructor(Identifier(this._symbol), args);
        };

        node.getConcreteTree = function(frame, overrides) {
            if (overrides && overrides[this.type]) return overrides[this.type].call(this, frame, overrides);
            var fn = frame[this._symbol];
            if (fn && fn.isError) throw fn;
            if (!fn || !fn.isFunction) {
                if (this.args.length == 1) {
                    var multiplyArgs = [Identifier(this._symbol), this.args[0]];
                    return Multiply(multiplyArgs).getConcreteTree(frame, overrides);
                }
                if (fn) {
                    throw ErrorMsg.variableAsFunction(this._symbol);
                }
                throw ErrorMsg.functionNotDefined(this._symbol);
            }

            var concreteArgs = [];
            for (var i = 0; i < this.args.length; i++) {
                var concreteArg = this.args[i].getConcreteTree(frame, overrides);
                concreteArgs.push(concreteArg);
            }

            return fn.getConcreteInvocationTree(frame, concreteArgs, this._symbol, overrides);
        };
    });
});

define('math/parsenode/functionexponent', ['require', 'pjs', './expression', './expressionTypes', './functioncall'], function(require) {
    var P = require('pjs');
    var Parent = require('./expression');
    var expressionTypes = require('./expressionTypes');
    var Multiply = expressionTypes.Multiply;
    var Exponent = expressionTypes.Exponent;
    var FunctionCall = require('./functioncall');
    //Ambiguous function call / exponent node
    //e.g. a(b)^c
    //could be function a(b) raised to the c,
    //or could be a * (b)^c

    return P(Parent, function(node, _super) {
        node.getConcreteTree = function(frame, overrides) {
            if (overrides && overrides[this.type]) return overrides[this.type].call(this, frame, overrides);
            var fn = this.args[0]._symbol;
            if (frame[fn] && frame[fn].isFunction) {
                return Exponent([FunctionCall(fn, [this.args[1]]), this.args[2]]).getConcreteTree(frame, overrides);
            } else {
                return Multiply([this.args[0], Exponent([this.args[1], this.args[2]])]).getConcreteTree(frame, overrides);
            }
        };
    });
});

define('math/parsenode/nativefunction', ['require', 'pjs', './scalarexpression', 'math/errormsg', 'math/functions'], function(require) {
    //This is the default definition of a built-in function, which can be expressed
    //as a string (e.g. "Math.sin")
    //This can be expanded to cover functions with unique signatures (like reducers),
    //Functions on BuiltIn instead of on Math, etc.
    var P = require('pjs');
    var ScalarExpression = require('./scalarexpression');
    var ErrorMsg = require('math/errormsg');
    var Functions = require('math/functions');

    var Invocation = P(ScalarExpression, function(node, _super) {
        node.init = function(fn, args) {
            _super.init.call(this, args);
            this._fn = fn;
            this.scalarEvalExpression = this._fn.scalarEvalExpression;
            this.evaluate = this._fn.evaluate;
        };

        node.copyWithArgs = function(args) {
            return new this.constructor(this._fn, args);
        };

        node.polynomialOrder = function(symbol) {
            return this.dependsOn(symbol) ? Infinity : 0;
        };
    });

    //This thing lives in the BuiltIn frame, but there's no way for a user to declare it,
    //or for it to actually exist as a term in an expression.
    //
    //It's not clear that it should actually be parsenode, since it's not parsed.
    //
    //It would be the thing that a user declared if we allowed them to pass
    //in arbitrary javascript for us to evaluate, e.g. via the API
    return P(function(node, _super, _class) {

        //Sample call is NativeFunction('Math.sin', 1)
        node.init = function(head, arity) {
            this._arity = arity; //TODO - verify this
            this.head = head;
            // create here to clouse in head
            this.scalarEvalExpression = function(argExpressions) {
                return head + '(' + argExpressions.join(',') + ')';
            };
            this.evaluate = Functions.createEvaluateFunction(this.scalarEvalExpression, arity);
        };

        node.isFunction = true;

        node.getConcreteInvocationTree = function(frame, args, symbol, overrides) {
            if (args.length !== this._arity) throw ErrorMsg.wrongArity(symbol, this._arity, args.length);
            return this._getInvocationTree(args).getConcreteTree(frame, overrides);
        };

        node._getInvocationTree = function(args) {
            return Invocation(this, args);
        };

        _class.Invocation = Invocation;
    });
});

define('math/parsenode/trigfunction', ['require', 'pjs', './nativefunction', './expressionTypes', './identifier'], function(require) {
    //For functions like sin(x) which depend on the angleMultiplier
    //to switch between radians and degrees

    var P = require('pjs');
    var NativeFunction = require('./nativefunction');
    var Multiply = require('./expressionTypes').Multiply;
    var Identifier = require('./identifier');

    return P(NativeFunction, function(node, _super) {
        node.init = function(head) {
            _super.init.call(this, head, 1);
        };

        node.getConcreteInvocationTree = function(frame, args, symbol, overrides) {
            if (frame.trigAngleMultiplier) {
                var scaledArgs = [Multiply([args[0], Identifier('trigAngleMultiplier')])];
                return _super.getConcreteInvocationTree.call(this, frame, scaledArgs, symbol, overrides);
            } else {
                return _super.getConcreteInvocationTree.call(this, frame, args, symbol, overrides);
            }
        };
    });
});

define('math/parsenode/inversetrigfunction', ['require', 'pjs', './nativefunction', './expressionTypes', './identifier'], function(require) {
    //For functions like arcsin(x) which depend on the angleMultiplier
    //to switch between radians and degrees

    var P = require('pjs');
    var NativeFunction = require('./nativefunction');
    var Divide = require('./expressionTypes').Divide;
    var Identifier = require('./identifier');

    return P(NativeFunction, function(node, _super) {
        node.init = function(head) {
            _super.init.call(this, head, 1);
        };

        node.getConcreteInvocationTree = function(frame, args, symbol, overrides) {
            if (frame.trigAngleMultiplier) {
                var tree = this._getInvocationTree(args);
                return Divide([tree, Identifier('trigAngleMultiplier')]).getConcreteTree(frame);
            } else {
                return _super.getConcreteInvocationTree.call(this, frame, args, symbol, overrides);
            }
        };
    });
});

define('math/parsenode/reducerfunction', ['require', 'pjs', './expression', './list', './constant', 'math/functions', 'math/errormsg'], function(require) {
    //This is the definition of a built-in function which maps a single
    //list to a single scalar

    var P = require('pjs');
    var Expression = require('./expression');
    var List = require('./list');
    var Constant = require('./constant');
    var Functions = require('math/functions');
    var ErrorMsg = require('math/errormsg');

    var Invocation = P(Expression, function(node, _super) {
        node.init = function(symbol, fn, args) {
            _super.init.call(this, args);
            this._symbol = symbol;
            this._fn = fn;
            this.evalExpression = this._fn.evalExpression;
            this.evaluate = this._fn.evaluate;
        };

        node.copyWithArgs = function(args) {
            return new this.constructor(this._symbol, this._fn, args);
        };

        node.getEvalStrings = function() {
            var list = this.args[0];
            var statements = [];
            var elementExpressions = [];
            for (var i = 0; i < list.length; i++) {
                var elementStrings = list.elementAt(i).getEvalStrings();
                statements = statements.concat(elementStrings.statements);
                elementExpressions.push(elementStrings.expression);
            }
            var argExpressions = ['[' + elementExpressions.join(',') + ']'];
            return { statements: statements, expression: this.evalExpression(argExpressions) };
        };

        node.getConcreteTree = function(frame, overrides) {
            if (overrides && overrides[this.type]) return overrides[this.type].call(this, frame, overrides);

            var i;
            var args = this.args;

            var list;
            var collect;
            if (args.length === 0) throw ErrorMsg.zeroArgReducer(this._symbol);

            if (args.length === 1) {
                list = args[0].getConcreteTree(frame, overrides);
                collect = !list.isList;
            } else if (args.length === 2 && (args[0].isList || args[1].isList)) {
                var self = this;
                return List(List.mapArgs(this.args, function(args) {
                    return self.copyWithArgs(args).getConcreteTree(frame, overrides);
                }));
            } else {
                collect = true;
            }

            var concreteArgs = [];
            if (collect) {
                for (i = 0; i < args.length; i++) {
                    if (args[i].isList) throw ErrorMsg.badListInReducer(this._symbol);
                    concreteArgs.push(args[i].getConcreteTree(frame, overrides));
                }
                list = List(args);
            }

            //If list elements are all constant, we can constant collapse
            var constantElements = [];
            for (i = 0; i < list.length; i++) {
                var element = list.elementAt(i);
                if (!element.isConstant) {
                    return this.copyWithArgs([list]);
                }
                constantElements.push(element.constantValue);
            }
            return Constant(this.evaluate([constantElements]));
        };
    });

    return P(function(node, _super, _class) {
        //Sample call is ReducerFunction('Reducers.mean', 1)
        node.init = function(head, arity) {
            this.head = head;
            if (arity !== 1) throw new Error("Higher arity reduces not yet implemented");
            this._arity = arity;
            // create here to clouse in head
            this.evalExpression = function(argExpressions) {
                return head + '(' + argExpressions.join(',') + ')';
            };
            this.evaluate = Functions.createEvaluateFunction(this.evalExpression, arity);
        };

        node.isFunction = true;
        node.isReducer = true;

        node.getConcreteInvocationTree = function(frame, args, symbol, overrides) {
            return Invocation(symbol, this, args).getConcreteTree(frame, overrides);
        };

        _class.Invocation = Invocation;
    });
});

//Definition of built-in functions and variables

define('math/builtinframe', ['require', 'math/parsenode/constant', 'math/parsenode/nativefunction', 'math/parsenode/trigfunction', 'math/parsenode/inversetrigfunction', 'math/parsenode/reducerfunction'], function(require) {
    //Defining with short names
    var Constant = require('math/parsenode/constant');
    var F = require('math/parsenode/nativefunction');
    var Trig = require('math/parsenode/trigfunction');
    var ITrig = require('math/parsenode/inversetrigfunction');
    var Reducer = require('math/parsenode/reducerfunction');

    return {
        pi: Constant(Math.PI),
        tau: Constant(2 * Math.PI),
        e: Constant(Math.E),
        trigAngleMultiplier: Constant(1),

        //Trig functions
        sin: Trig('BuiltIn.sin'),
        cos: Trig('BuiltIn.cos'),
        tan: Trig('BuiltIn.tan'),
        cot: Trig('BuiltIn.cot'),
        sec: Trig('BuiltIn.sec'),
        csc: Trig('BuiltIn.csc'),
        //Inverse trig function
        arcsin: ITrig('Math.asin'),
        arccos: ITrig('Math.acos'),
        arctan: ITrig('Math.atan'),
        arccot: ITrig('BuiltIn.acot'),
        arcsec: ITrig('BuiltIn.asec'),
        arccsc: ITrig('BuiltIn.acsc'),

        //Hyperbolic trig functions
        sinh: F('BuiltIn.sinh', 1),
        cosh: F('BuiltIn.cosh', 1),
        tanh: F('BuiltIn.tanh', 1),
        coth: F('BuiltIn.coth', 1),
        sech: F('BuiltIn.sech', 1),
        csch: F('BuiltIn.csch', 1),
        arcsinh: F('BuiltIn.asinh', 1),
        arccosh: F('BuiltIn.acosh', 1),
        arctanh: F('BuiltIn.atanh', 1),
        arccoth: F('BuiltIn.acoth', 1),
        arcsech: F('BuiltIn.asech', 1),
        arccsch: F('BuiltIn.acsch', 1),

        //Power functions
        pow: F('BuiltIn.pow', 2),
        sqrt: F('Math.sqrt', 1),
        nthroot: F('BuiltIn.nthroot', 2),
        log: F('BuiltIn.log_base', 2),
        ln: F('Math.log', 1),
        exp: F('Math.exp', 1),

        //Integer functions
        floor: F('Math.floor', 1),
        ceil: F('Math.ceil', 1),
        round: F('Math.round', 1),
        abs: F('Math.abs', 1),
        sign: F('BuiltIn.sign', 1),
        mod: F('BuiltIn.mod', 2),

        lcm: F('BuiltIn.lcm', 2),
        gcd: F('BuiltIn.gcd', 2),
        nCr: F('BuiltIn.nCr', 2),
        nPr: F('BuiltIn.nPr', 2),
        factorial: F('BuiltIn.factorial', 1),
        polyGamma: F('BuiltIn.polyGamma', 2),

        //Stats
        mean: Reducer('BuiltIn.mean', 1),
        total: Reducer('BuiltIn.total', 1),
        'var': Reducer('BuiltIn.var', 1),
        stdev: Reducer('BuiltIn.stdev', 1),
        stdevp: Reducer('BuiltIn.stdevp', 1),
        length: Reducer('BuiltIn.length', 1),
        min: Reducer('BuiltIn.listMin', 1),
        max: Reducer('BuiltIn.listMax', 1),
        argmin: Reducer('BuiltIn.argMin', 1),
        argmax: Reducer('BuiltIn.argMax', 1)
    };
});

define('math/parsenode/derivative', ['require', 'pjs', './scalarexpression', './freevariable', './identifier', 'math/builtinframe'], function(require) {
    var P = require('pjs');
    var Parent = require('./scalarexpression');
    var FreeVariable = require('./freevariable');
    var Identifier = require('./identifier');
    var BuiltInFrame = require('math/builtinframe');

    return P(Parent, function(node, _super) {
        node.init = function(symbol, args) {
            this._symbol = Identifier(symbol)._symbol; // Use identifier normalization for symbol
            _super.init.call(this, args);
        };

        node.getConcreteTree = function(frame, overrides) {
            if (overrides && overrides[this.type]) return overrides[this.type].call(this, frame, overrides);
            if (frame[this._symbol]) {
                var childFrame = Object.create(frame);
                childFrame[this._symbol] = FreeVariable(this._symbol);
                var substitution = {};
                substitution[this._symbol] = frame[this._symbol];
                return _super.getConcreteTree.call(this, childFrame, overrides)
                    .substitute(substitution)
                    .getConcreteTree(frame, overrides);
            }
            return _super.getConcreteTree.call(this, frame, overrides);
        };

        //Not really a great name for derivatives, since they think about constants differently
        //More like getScalarConcreteTree...
        node._constantCollapsedCopy = function(concreteArgs) {
            return concreteArgs[0].takeDerivative(this._symbol).getConcreteTree(BuiltInFrame);
        };
    });
});

define('math/parsenode/equation', ['require', './base', 'pjs', './expressionTypes', 'math/parsenode/comparator'], function(require) {
    var Parent = require('./base');
    var P = require('pjs');
    var Subtract = require('./expressionTypes').Subtract;
    var Comparator = require('math/parsenode/comparator');

    return P(Parent, function(node, _super) {
        node.init = function(lhs, rhs) {
            _super.init.call(this);
            this.addDependencies(lhs.getDependencies());
            this.addDependencies(rhs.getDependencies());
            this._lhs = lhs;
            this._rhs = rhs;
            this._difference = Subtract([this._lhs, this._rhs]);
        };

        node.asComparator = function() {
            return Comparator['=']([this._lhs, this._rhs]);
        };

        node.getConcreteTree = function(frame, overrides) {
            if (overrides && overrides[this.type]) return overrides[this.type].call(this, frame, overrides);
            return this.asComparator().getConcreteTree(frame, overrides);
        };
    });
});

define('math/parsenode/assignment', ['require', './base', 'math/policy', './equation', './identifier', 'pjs'], function(require) {
    var Parent = require('./base');
    var Policy = require('math/policy');
    var Equation = require('./equation');
    var Identifier = require('./identifier');
    var P = require('pjs');

    return P(Parent, function(node, _super) {
        node.init = function(symbol, expression) {
            _super.init.call(this);
            symbol = symbol._symbol; //TODO - normalize symbol processing.
            //Would like to always pass around strings, but sometimes we pass around Identifiers instead
            //due to the way the parser works.
            this.addDependencies(expression.getDependencies());
            this._expression = expression;
            this._symbol = symbol;
            this._exports = Policy.assignmentForbidden(symbol) ? [] : [symbol];
        };

        node.getConcreteTree = function(frame, overrides) {
            if (overrides && overrides[this.type]) return overrides[this.type].call(this, frame, overrides);
            return this._expression.getConcreteTree(frame, overrides);
        };

        node.asEquation = function() {
            var eqn = Equation(Identifier(this._symbol), this._expression);
            // TODO was hard to predict by reading that this would be necessary. API smell.
            eqn.userData = this.userData;
            return eqn;
        };

        node.getSliderInfo = function() {
            if (this._expression.isConstant) return { value: this._expression.constantValue };
        };

    });
});

define('math/parsenode/functiondefinition', ['require', 'pjs', './base', 'math/errormsg', 'math/policy'], function(require) {
    var P = require('pjs');
    var ParseNode = require('./base');
    var ErrorMsg = require('math/errormsg');
    var Policy = require('math/policy');

    return P(ParseNode, function(node, _super) {

        node.init = function(symbol, args, expression) {
            _super.init.call(this);

            symbol = symbol._symbol; //TODO - normalize symbol processing.
            // Currently using Identifer constructor to normalize symbols

            this._argSymbols = args.map(function(identifier) { return identifier._symbol; });
            this._symbol = symbol;
            this._exports = Policy.assignmentForbidden(symbol) ? [] : [symbol];
            this._expression = expression;
            this.addDependencies(this._argSymbols);
            this.addDependencies(this._expression.getDependencies()); //Will depend on formal arguments
        };

        node.isFunction = true;

        node.getConcreteInvocationTree = function(frame, args, symbol, overrides) {
            if (args.length !== this._argSymbols.length) {
                throw ErrorMsg.wrongArity(this._symbol, this._argSymbols.length, args.length);
            }
            var localFrame = Object.create(frame);

            for (var i = 0; i < this._argSymbols.length; i++) {
                localFrame[this._argSymbols[i]] = args[i];
            }

            return this._expression.getConcreteTree(localFrame, overrides);
        };

        node.getConcreteTree = function(frame, overrides) {
            if (overrides && overrides[this.type]) return overrides[this.type].call(this, frame, overrides);
            for (var i = 0; i < this._argSymbols.length; i++) {
                if (frame[this._argSymbols[i]]) throw ErrorMsg.parameterAlreadyDefined(this._argSymbols[i]);
                if (this._argSymbols[i] === this._symbol) throw ErrorMsg.parameterAlreadyDefined(this._argSymbols[i]);
            }
            return this._expression.getConcreteTree(frame, overrides);
        };

        node.getArgs = function() {
            return this._args;
        };

        node.getSliderVariables = function(concrete) {
            var argSymbols = this._argSymbols;
            return Policy.sliderVariables(concrete.getDependencies()).filter(function(symbol) {
                return argSymbols.indexOf(symbol) === -1;
            });
        };
    });
});

define('math/parsenode/optimizedregression', ['require', 'pjs', './base'], function(require) {
    var P = require('pjs');
    var Parent = require('./base');

    return P(Parent, function(node, _super) {
        node.init = function(parameters, residuals, statistics, model, opts) {
            _super.init.call(this);
            this.parameters = parameters;
            this.residuals = residuals;
            this.statistics = statistics;
            this.model = model;

            this.isModelValid = opts.isModelValid;
            this.residualVariable = opts.residualVariable;
            this.residualSuggestionId = opts.residualSuggestionId;

            // An optimized regression exports its residual variable and all of its
            // parameters
            this._exports = [this.residualVariable];
            for (var p in parameters) {
                if (parameters.hasOwnProperty(p)) this._exports.push(p);
            }
            // TODO this is a little sketchy, since these dependencies are just a bunch
            // of tmpVars used for plotting.
            this.addDependencies(model.getDependencies());
        };

        // Forward getCompiledFunctions calls to model
        node.getCompiledFunctions = function() {
            return this.model.getCompiledFunctions.apply(this.model, arguments);
        };
        node.evaluate = function() {
            return this.model.evaluate.apply(this.model, arguments);
        };
    });
});

define('math/parsenode/regression', ['require', 'pjs', './base', 'numeric', 'math/builtin', 'math/policy', 'graphing/label', 'math/errormsg', './optimizedregression', './list', './identifier', './constant', './freevariable', './expressionTypes', 'console'], function(require) {
    var P = require('pjs');
    var Parent = require('./base');
    var Numeric = require('numeric');
    var BuiltIn = require('math/builtin');
    var Policy = require('math/policy');
    var Label = require('graphing/label');
    var ErrorMsg = require('math/errormsg');
    var OptimizedRegression = require('./optimizedregression');
    var List = require('./list');
    var Identifier = require('./identifier');
    var Constant = require('./constant');
    var FreeVariable = require('./freevariable');
    var expressionTypes = require('./expressionTypes');
    var console = require('console');

    var Subtract = expressionTypes.Subtract;

    return P(Parent, function(node, _super) {
        node.init = function(lhs, rhs) {
            _super.init.call(this);
            this._lhs = lhs;
            this._rhs = rhs;
            this._difference = Subtract([lhs, rhs]);
            this.addDependencies(lhs.getDependencies());
            this.addDependencies(rhs.getDependencies());
        };

        node.isRegression = true;

        node.chooseResidualVariable = function(exportFrame) {
            if (this.userData && this.userData.residualVariable) {
                var stripped = Label.latexToIdentifier(this.userData.residualVariable);
                if (!exportFrame[stripped]) return stripped;
            }
            var dependencies = this.getDependencies();
            var candidate;
            for (var i = 0; i < dependencies.length; i++) {
                var match = dependencies[i].match(/_(.*)/);
                if (!match) continue;
                candidate = 'e_' + match[1];
                if (!exportFrame[candidate]) return candidate;
            }
            var n = 1;
            while (true) {
                candidate = 'e_' + n;
                if (!exportFrame[candidate]) return candidate;
                n++;
            }
        };

        function canCorrelate(modelNode, replacedNodes) {
            // Check if the model is of the form y = f(u, v)*x + g(u, v). Where f and g are
            // linearly independent linear (well, actually affine) functions of u and v.
            //
            // The point of this is to be sure that we actually can find the best linear fit
            // to the data by adjusting the model parameters.
            if (replacedNodes.length !== 1) return false;
            var dependencies = modelNode.getDependencies();
            if (dependencies.length !== 3) return false;
            var replacedSymbol = replacedNodes[0].symbol;

            if (!modelNode.isLinear(dependencies[0])) return false;
            if (!modelNode.isLinear(dependencies[1])) return false;
            if (!modelNode.isLinear(dependencies[2])) return false;

            // Check the slope and intercept of f(u, v)*x + g(u, v), for different values of
            // u and v to make sure that f(u, v) and g(u, v) are linearly independent.
            var i = dependencies.indexOf(replacedSymbol);
            if (i === -1) return false;
            var orderedDependencies = [dependencies[i]];
            i = (i + 1) % 3;
            orderedDependencies.push(dependencies[i]);
            i = (i + 1) % 3;
            orderedDependencies.push(dependencies[i]);

            // Because of the dependency ordering above, fn is a function fn(x, u, v).
            var fn = modelNode.getCompiledFunctions(orderedDependencies)[0].fn;

            var b0 = fn(0, 0, 0);
            var m0 = fn(1, 0, 0) - b0;

            var bu = fn(0, 1, 0);
            var mu = fn(1, 1, 0) - bu;

            var bv = fn(0, 0, 1);
            var mv = fn(1, 0, 1) - bv;

            // Check that [mu - m0, bu - b0] and [mv - m0, bv - b0] are linearly independent
            // vectors by making sure that the area of the parallelogram that they span is not
            // 0.
            return !BuiltIn.approx((mu - m0) * (bv - b0), (mv - m0) * (bu - b0));
        }

        node.getRHSModel = function(frame) {
            // Store a map of lists that have been replaced by temporary variables.
            // Have to linear search on this because JS doesn't have object hashes.
            var replacedNodes = [];
            var isValid = true;

            function _replaceWithFreeVariable(frame, overrides) {
                for (var i = 0; i < replacedNodes.length; i++) {
                    if (replacedNodes[i].node === this) return replacedNodes[i].tmpVar;
                }
                var tmpVar = FreeVariable(this.tmpVar());
                var concrete = this.getConcreteTree(frame);
                if (concrete.getDependencies().length) isValid = false;
                replacedNodes.push({
                    node: this,
                    tmpVar: tmpVar,
                    symbol: tmpVar._symbol,
                    concrete: concrete
                });
                return tmpVar;
            }

            var overrides = {
                List: _replaceWithFreeVariable,
                TableColumn: _replaceWithFreeVariable,
                Range: _replaceWithFreeVariable
            };

            var node = this._rhs.tryGetConcreteTree(frame, overrides); // Actual work happens here

            return {
                node: node,
                replacedNodes: replacedNodes,
                canCorrelate: isValid && canCorrelate(node, replacedNodes),
                isValid: isValid
            };

        };

        function _mse(compiledDifference, solution) {
            var sse = 0;
            for (var j = 0; j < compiledDifference.length; j++) {
                var d = compiledDifference[j].fn.apply(undefined, solution);
                sse += d * d;
            }
            return sse / compiledDifference.length;
        }

        function _evaluateDifference(compiledDifference, solution) {
            var dy = [];
            for (var j = 0; j < compiledDifference.length; j++) {
                dy.push(compiledDifference[j].fn.apply(undefined, solution));
            }
            return dy;
        }

        function _evaluateJacobian(compiledJacobian, solution) {
            var JT = [];
            for (var i = 0; i < compiledJacobian.length; i++) {
                var Jj = [];
                for (var j = 0; j < compiledJacobian[i].length; j++) {
                    Jj.push(compiledJacobian[i][j].fn.apply(undefined, solution));
                }
                JT.push(Jj);
            }
            return JT;
        }

        // Gauss-Newton iteration: steps parameters by solving JT*J*dx=-JT*dy
        // where dy is vector that we're minimizing the squares of, evaluated at the current
        // parameters, dx is the update to the parameters on the next step, and J and JT are
        // the Jacobian and its transpose.
        //
        // It would be better to solve the linear system using a QR decomposition instead of
        // an LUP decomposition, but Numeric.js doesn't support QR solves (yet...).
        function optimizeLinear(compiledDifference, compiledJacobian) {
            var solution = [];

            for (var i = 0; i < compiledJacobian.length; i++) { solution.push(0); }

            var JT = _evaluateJacobian(compiledJacobian, solution);

            var LUJTJ = Numeric.LU(Numeric.dot(JT, Numeric.transpose(JT)), true);

            // In principle, only need one iteration in linear cases, but additional steps help us
            // clean up rounding errors. Don't need to update jacobian because in a linear problem,
            // it is independent of the parameters.
            var lastSolution = solution;
            var converged = false;
            for (var m = 0; m < 5; m++) {
                var dy = _evaluateDifference(compiledDifference, solution);
                var dx = Numeric.neg(Numeric.LUsolve(LUJTJ, Numeric.dot(JT, dy)));
                if (!Numeric.all(Numeric.isFinite(dx))) break;
                solution = Numeric.add(lastSolution, dx);
                converged = Numeric.all(Numeric.eq(lastSolution, solution));
                if (converged) break;
                lastSolution = solution;
            }

            return {
                solution: solution,
                f: _mse(compiledDifference, solution),
                converged: converged
            };
        }

        // Modified Levenberg-Marquardt algorithm, based on
        //
        // Transtrum, Machta, and Sethna, Phys. Rev. E 83, 036701 (2011)
        // http://dx.doi.org/10.1103/PhysRevE.83.036701
        // http://link.aps.org/accepted/10.1103/PhysRevE.83.036701 [PDF]
        //
        // This is currently their "delayed gratification algorithm," but I intend to add
        // the geodesic acceleration term to implement the full "Algorithm 2" from appendix
        // B.
        //
        // The full algorithm iterates by solving
        //
        // (JT*J + lambda*I)*v=JT*dy
        // JT*J*a=JT*(dvdvdy)
        //
        // for v and a, where J and JT are the jacobian and its transpose, I is an identity
        // matrix, dy is the vector of differences that is being minimized, dvdvdy is the
        // directional second derivative of the difference vector, evaluated in the v direction,
        // and lambda is a dynamically adjusted parameter that controls step size
        //
        // The parameters are then updated according to
        // solution = solution + v + 1/2*a
        //
        // If the new solution is worse than the old solution, lambda is increased, producing
        // a smaller step. If the new solution is better, it is accepted, and lambda is decreased.
        function _optimizeNonLinear(compiledDifference, compiledJacobian, p0, maxIterations) {
            var solution = p0;
            var f = _mse(compiledDifference, solution);

            var lambda = 0.001;
            var lambdaUp = 2;
            var lambdaDown = 0.1;

            var ones = [];
            for (var j = 0; j < compiledJacobian.length; j++) { ones.push(1); }

            var it = 0;

            var converged = false;
            var JT = _evaluateJacobian(compiledJacobian, solution);
            var lastSolution = solution;
            var lastF = f;
            while (it < maxIterations && !converged) {
                var dy = _evaluateDifference(compiledDifference, solution);
                var J = Numeric.transpose(JT);
                var JTJ = Numeric.dot(JT, J);

                if (!Numeric.all(Numeric.isFinite(dy))) break;
                if (!Numeric.all(Numeric.isFinite(JTJ))) break;

                var decreased = false;

                while (it < maxIterations && !converged && !decreased) {
                    it += 1;

                    // metric = JT*J + lambda*I
                    var LUmetric = Numeric.LU(
                        Numeric.add(JTJ, Numeric.diag(Numeric.mul(lambda, ones))),
                        true);

                    var v = Numeric.neg(Numeric.LUsolve(LUmetric, Numeric.dot(JT, dy)));

                    //TODO calculate geodesic acceleration here and add it to v.
                    var dx = v;

                    solution = Numeric.add(lastSolution, dx);
                    f = _mse(compiledDifference, solution);

                    converged = Numeric.all(Numeric.eq(solution, lastSolution));

                    if (converged) {
                        lastSolution = solution;
                        lastF = f;
                        break;
                    }

                    var tmpJT;
                    if (isFinite(f) && f <= lastF) {
                        tmpJT = _evaluateJacobian(compiledJacobian, solution);
                        decreased = Numeric.all(Numeric.isFinite(tmpJT));
                    }

                    if (decreased) {
                        JT = tmpJT;
                        lastSolution = solution;
                        lastF = f;
                        lambda *= lambdaDown;
                        // Don't let lambda underflow
                        lambda = Math.max(1e-64, lambda);
                        break;
                    } else {
                        lambda *= lambdaUp;
                    }
                }
            }

            return {
                solution: lastSolution,
                f: lastF,
                converged: converged
            };
        }

        //goal of these:
        // 1/4 are negative (8), 3/4 (24) are positive
        // approximately log-normal, w/ variance of 3
        // generated on: https://www.desmos.com/calculator/1xxlt84tvo
        //plus some from Eli thrown in (1, -1, 120, 1500, -.3)
        var pseudoRandoms = [
            18.9, 0.105, 0.0113, 0.089,
            4.414, 34.32, 8.61, 0.373,
            0.06, 0.149, 1.84, 9.26,
            5, 0.7, 0.2, 1.13,
            2.61, 1.89, 1, 0.007, 30,
            120, 1500, 0.0004, 7.23, -1, -0.0081, -0.03, -28.6, -1.71, -0.4, -6.94, -0.777
        ];


        var pseudoRandom = function(seed) {
            //503 is prime. That's all it's got going for it
            var index = (seed * 503) % (pseudoRandoms.length);
            return pseudoRandoms[index];
        };

        var generateStartingValues = function(numVals, args) {
            var startingVals = [],
                newStartingVals, nargs = args.length;
            for (var i = 0; i < numVals; i++) {
                newStartingVals = [];
                for (var j = 0; j < nargs; j++) {
                    //prepopulate with a few stock starting values:
                    //  * all 0, which helps with y1 ~ e^(a*x1+b)
                    //  * all 1, which helps with y1 ~ a*b^x1
                    //then use pseudo-randomly generated parameters for the rest
                    if (i === 0) {
                        newStartingVals[j] = 0;
                    } else if (i === 1) {
                        newStartingVals[j] = 1;
                    } else {
                        newStartingVals[j] = pseudoRandom(i * nargs + j);
                    }
                }
                startingVals.push(newStartingVals);
            }
            return startingVals;
        };

        //
        // goal of this is to try a bunch of random starting values, and only explore the ones that are closest
        // niterations is the depth to search each option
        // nreturn is the number to return
        //
        var filterStartingValues = function(compiledDifference, compiledJacobian, startingVals, niterations, nreturn) {
            var scores = [];

            for (var j = 0; j < startingVals.length; j++) {
                scores.push({
                    soln: _optimizeNonLinear(compiledDifference, compiledJacobian, startingVals[j], niterations),
                    startingVals: startingVals[j]
                });
            }

            scores.sort(function(el1, el2) {
                if (isNaN(el1.soln.f)) return 1;
                if (isNaN(el2.soln.f)) return -1;
                return el1.soln.f - el2.soln.f;
            });

            var toReturn = [];
            for (var i = 0; i < nreturn; i++) {
                toReturn.push(scores[i].startingVals);
            }
            return toReturn;
        };

        function optimizeNonLinear(compiledDifference, compiledJacobian, args, userParams, lastExportFrame) {
            /* jshint maxcomplexity: 11 */
            var i;
            var xlast = [];
            if (!userParams) userParams = {};
            if (!lastExportFrame) lastExportFrame = {};
            for (i = 0; i < args.length; i++) {
                var symbol = args[i];
                if (lastExportFrame[symbol] && isFinite(lastExportFrame[symbol].constantValue)) {
                    xlast.push(+lastExportFrame[symbol].constantValue);
                } else if (userParams.hasOwnProperty(symbol) && isFinite(userParams[symbol])) {
                    xlast.push(+userParams[symbol]);
                } else {
                    xlast.push(1);
                }
            }

            //generate some random starting points
            var startingVals = generateStartingValues(30, args);
            //filter these down, first by finding 5 promising starting points, and then filtering down to 1 deeply
            var firstPass = filterStartingValues(compiledDifference, compiledJacobian, startingVals, 3, 5);
            var secondPass = filterStartingValues(compiledDifference, compiledJacobian, firstPass, 60, 1);

            var solnrestart = _optimizeNonLinear(compiledDifference, compiledJacobian, secondPass[0], 250);
            var solnlast = _optimizeNonLinear(compiledDifference, compiledJacobian, xlast, 100);

            if (!isFinite(solnlast.f)) return solnrestart;
            if (solnlast.f < solnrestart.f) return solnlast;
            return BuiltIn.approx(solnlast.f, solnrestart.f, 8) ? solnlast : solnrestart;
        }

        function getCorrelation(concreteIndependent, concreteDependent) {
            var l1 = [];
            var l2 = [];
            List.eachArgs([concreteIndependent, concreteDependent], function(elts) {
                l1.push(+elts[0].constantValue);
                l2.push(+elts[1].constantValue);
            });
            return BuiltIn.corr(l1, l2);
        }

        node.getResidualSuggestionId = function(residualVariable, priorAnalysis) {
            // Search for a table who's first column is in the regressions rhs.
            // If any table that the regression depends on already has a column
            // that depends on the regression's residual variable, return undefined.
            var rhsDependencies = this._rhs.getDependencies();
            var candidateId;
            for (var id in priorAnalysis) {
                if (!priorAnalysis.hasOwnProperty(id)) continue;
                if (!priorAnalysis[id].concreteTree.isTable) continue;
                if (!priorAnalysis[id].concreteTree.columns[0]) continue;
                var rawColumns = priorAnalysis[id].rawTree.columns;
                if (!rawColumns || !rawColumns.length) continue;
                var exports = rawColumns[0].getExports();
                if (exports.length !== 1) continue;
                if (rhsDependencies.indexOf(exports[0]) === -1) continue;

                for (var i = 1; i < rawColumns.length; i++) {
                    if (rawColumns[i].getDependencies().indexOf(residualVariable) !== -1) return undefined;
                }
                candidateId = candidateId ? candidateId : id;
            }

            return candidateId ? candidateId : undefined;
        };

        node.optimize = function(frame, exportFrame, lastExportFrame, priorAnalysis) {
            /* jshint maxcomplexity: 15*/
            var concreteLHS = this._lhs.tryGetConcreteTree(frame);
            var concreteRHS = this._rhs.tryGetConcreteTree(frame);
            if (concreteLHS.isError) return concreteLHS;
            if (concreteRHS.isError) return concreteRHS;

            var concreteDifference = this._difference.tryGetConcreteTree(frame);
            if (concreteDifference.isError) return concreteDifference;
            if (!concreteDifference.isList) return ErrorMsg.nonListRegression();

            var soln, i;
            var args = concreteDifference.getDependencies();

            for (i = 0; i < args.length; i++) {
                if (!Policy.validRegressionParameter(args[i])) {
                    return ErrorMsg.invalidRegressionParameter(args[i]);
                }
            }

            var compiledDifference = concreteDifference.getCompiledFunctions(args);
            if (!args.length) {
                soln = {
                    f: _mse(compiledDifference, []),
                    solution: []
                };
            } else {

                // Since this is a multivariate function in general, we have to be careful with our
                // isLinear check. Can't check each arg separately, because (1+x)*(1+y) is linear in
                // x and y separately, but is not linear overall (where by linear, we actually mean
                // affine, here and in many places).
                var argmap = {};
                for (i = 1; i < args.length; i++) {
                    argmap[args[i]] = FreeVariable(args[0]);
                }

                var isLinear = concreteDifference.substitute(argmap).isLinear(args[0]);
                // This block can fail because takeDerivative can produce too many nodes, or possibly
                // inside calls to Numeric
                try {
                    var compiledJacobian = [];
                    for (i = 0; i < args.length; i++) {
                        compiledJacobian.push(concreteDifference.takeDerivative(args[i]).getCompiledFunctions(args));
                    }
                    if (isLinear) {
                        soln = optimizeLinear(compiledDifference, compiledJacobian);
                    } else {
                        soln = optimizeNonLinear(compiledDifference, compiledJacobian,
                            args, this.userData.regressionParameters, lastExportFrame
                        );
                    }
                } catch (e) {
                    console.log(e);
                    return ErrorMsg.optimizationError();
                }
            }
            var localFrame = Object.create(frame, parameters);
            var parameters = {};
            for (i = 0; i < args.length; i++) {
                localFrame[args[i]] = parameters[args[i]] = Constant(soln.solution[i]);
            }

            var model = this.getRHSModel(frame);
            var residuals = this._difference.getConcreteTree(localFrame);

            // If the lhs depends on parameters, return the RMS of the residuals instead of Rsquared.
            var statistics;
            var msqres = soln.f;
            var lhsVariance = concreteLHS.isList ?
                BuiltIn.var(concreteLHS.args.map(function(c) { return +c.constantValue })) :
                0;
            if (
                concreteLHS.getDependencies().length ||
                !isFinite(lhsVariance) ||
                lhsVariance <= 0 ||
                !(this._lhs instanceof Identifier || this._lhs instanceof List)
            ) {
                statistics = {
                    'RMSE': Math.sqrt(msqres)
                };
            } else if (model.canCorrelate) {
                statistics = {
                    'r': getCorrelation(concreteLHS, model.replacedNodes[0].concrete)
                };
            } else {
                statistics = {
                    'Rsquared': 1 - msqres / lhsVariance
                };
            }

            var substitutedModel = model.node.isError ? model.node : model.node.substitute(parameters);

            var residualVariable = this.chooseResidualVariable(exportFrame);
            var residualSuggestionId = this.getResidualSuggestionId(residualVariable, priorAnalysis);
            // Update userData here because there is no guarantee that the new value has to
            // to come back from the frontend.
            this.userData.residualVariable = Label.identifierToLatex(residualVariable);

            return OptimizedRegression(parameters, residuals, statistics, substitutedModel, {
                isModelValid: model.isValid,
                residualVariable: residualVariable,
                residualSuggestionId: residualSuggestionId
            });
        };

        node.exportTo = function(concrete, frame) {
            if (concrete.isError) return;
            for (var symbol in concrete.parameters) {
                if (!concrete.parameters.hasOwnProperty(symbol)) continue;
                if (Policy.assignmentForbidden(symbol)) continue;
                frame[symbol] = frame[symbol] ? ErrorMsg.multiplyDefined(symbol) : concrete.parameters[symbol];
            }

            // Never expect this to happen, but just to be safe...
            if (Policy.assignmentForbidden(concrete.residualVariable)) return;
            // Shouldn't have to worry about residualVariable being in the frame, since we chose it not to be.
            frame[concrete.residualVariable] = concrete.residuals;
        };

        // Regressions should never suggest sliders
        node.getSliderVariables = function() { return []; };
    });
});

define('math/parsenode/table', ['require', 'pjs', './base', 'math/policy', './constant', './list'], function(require) {
    var P = require('pjs');
    var Parent = require('./base');
    var Policy = require('math/policy');
    var Constant = require('./constant');
    var List = require('./list');

    return P(Parent, function(node, _super) {
        node.init = function(columns) {
            _super.init.call(this);
            this.columns = columns;
            this._exports = [];
            for (var i = 0; i < columns.length; i++) {
                this.addDependencies(columns[i].getDependencies());
                Array.prototype.push.apply(this._exports, columns[i].getExports());
            }
        };

        node.exportPenalty = 1;

        node.isTable = true;

        node.canAutoRegress = function(concrete) {
            /* jshint maxcomplexity: 11 */
            if (concrete.isError) return false;
            if (this.columns.length > 2) return false;

            for (var i = 0; i < this.columns.length; i++) {
                var symbols = this.columns[i].getExports();
                if (symbols.length !== 1) return false;
                if (Policy.assignmentForbidden(symbols[0])) return false;
                if (concrete.columns[i].isError) return false;
                if (!concrete.columns[i].isIndependent) return false;
                var columnLength = concrete.columns[i].values.args.length;
                if (columnLength < 2) return false;
                for (var j = 0; j < columnLength; j++) {
                    if (isNaN(+concrete.columns[i].values.args[j].constantValue)) return false;
                }
            }

            return true;
        };

        function _replaceErrorWithNaN(arg) {
            return (arg.isError) ? Constant(NaN) : arg;
        }

        // Note, only exports table column values. Will need to modify this if we allow,
        // e.g., assignments in headers.
        node.exportTo = function(concrete, frame) {
            for (var i = 0; i < this.columns.length; i++) {
                var symbols = this.columns[i].getExports();
                if (!symbols.length) continue;
                var symbol = symbols[0];
                if (Policy.assignmentForbidden(symbol)) continue;
                if (frame[symbol]) continue;
                // Replace errors with NaN's for export
                if (concrete.isError) {
                    frame[symbol] = concrete;
                } else if (concrete.columns[i].isError) {
                    frame[symbol] = concrete.columns[i];
                } else {
                    frame[symbol] = List(concrete.columns[i].values.args.map(_replaceErrorWithNaN));
                }
            }
        };

        node.getConcreteTree = function(frame, overrides) {
            if (overrides && overrides[this.type]) return overrides[this.type].call(this, frame, overrides);
            var concreteColumns = [];
            var localFrame = Object.create(frame);
            for (var i = 0; i < this.columns.length; i++) {
                var concreteColumn = this.columns[i].getConcreteTree(localFrame, frame, overrides);
                if (concreteColumn.isIndependent) {
                    localFrame[concreteColumn.header._symbol] = concreteColumn.values;
                }
                concreteColumns.push(concreteColumn);
            }
            return this.constructor(concreteColumns);
        };

        // TODO shim
        node.getAllIds = function() {
            return this.columns.map(function(c) { return c.header.userData.id; });
        };
    });
});
define('math/parsenode/tablecolumn', ['require', 'pjs', './base', './list', './identifier', 'math/policy'], function(require) {
    var P = require('pjs');
    var Parent = require('./base');
    var List = require('./list');
    var Identifier = require('./identifier');
    var Policy = require('math/policy');

    return P(Parent, function(node, _super) {
        node.init = function(header, length, values) {
            _super.init.call(this);
            this.header = header;
            this.length = length;
            this.values = values;
            this.isIndependent = false; // May be changed to true in a concrete tree
            this.addDependencies(header.getDependencies());
            this.addDependencies(values.getDependencies());
            this._exports = this._computeExports();
        };

        node._computeExports = function() {
            if (!(this.header instanceof Identifier)) return [];
            var symbol = this.header._symbol;
            return Policy.assignmentForbidden(symbol) ? [] : [symbol];
        };

        // Override getConcreteTree to allow storing errors in individual elements
        // instead of propagating errors to the top of the column.
        node.getConcreteTree = function(frame, parentFrame) {
            var concreteHeader = this.header.getConcreteTree(frame);
            var concreteElements;
            var concrete;
            if (concreteHeader.isFreeVariable) {
                concreteElements = [];
                for (var i = 0; i < this.values.args.length; i++) {
                    var concreteElement = this.values.args[i].tryGetConcreteTree(frame);
                    concreteElements.push(concreteElement);
                }
                concrete = this.constructor(concreteHeader, this.length, List(concreteElements));
                concrete.isIndependent = true;
                concrete.isDiscrete = true;
                return concrete;
            } else {
                if (concreteHeader.isConstant) {
                    var values = [];
                    for (var n = 0; n < this.length; n++) values.push(concreteHeader);
                    concreteElements = List(values);
                } else {
                    concreteElements = concreteHeader;
                }
                concreteHeader = this.header.getConcreteTree(parentFrame);
                concrete = this.constructor(concreteHeader, this.length, concreteElements);
                concrete.isDiscrete = !!(concreteHeader.isList || concreteHeader.isConstant);
                return concrete;
            }
        };
    });
});

define('math/parsenode/solvedequation', ['require', 'pjs', './base'], function(require) {

    var P = require('pjs');
    var ParseNode = require('./base');

    return P(ParseNode, function(node, _super) {
        node.init = function(symbol, expression) {
            _super.init.call(this);
            this._symbol = symbol; // The symbol that was solved for.
            this._expression = expression;
            this.addDependencies(expression.getDependencies());
        };

        node.getConcreteTree = function(frame, overrides) {
            if (overrides && overrides[this.type]) return overrides[this.type].call(this, frame, overrides);
            return this.constructor(this._symbol, this._expression.getConcreteTree(frame, overrides));
        };

        node.getEvaluationInfo = function() {
            if (this._expression.isList) {
                return this._expression.args.map(function(a) {
                    return { val: a.constantValue, operator: '=' };
                });
            }
            return this._expression.getEvaluationInfo();
        };

        // Delegate to _expression
        node.getCompiledFunctions = function() {
            return this._expression.getCompiledFunctions.apply(this._expression, arguments);
        };
        node.evaluate = function() {
            return this._expression.evaluate.apply(this._expression, arguments);
        };
    });
});

define('parsenodes', ['require', 'math/parsenode/expressionTypes', 'math/parsenode/base', 'math/parsenode/expression', 'math/parsenode/scalarexpression', 'math/parsenode/error', 'math/parsenode/constant', 'math/parsenode/identifier', 'math/parsenode/freevariable', 'math/parsenode/dummyindex', 'math/parsenode/list', 'math/parsenode/range', 'math/parsenode/listaccess', 'math/parsenode/orderedpair', 'math/parsenode/movablepoint', 'math/parsenode/basecomparator', 'math/parsenode/comparator', 'math/parsenode/doubleinequality', 'math/parsenode/repeatedoperator', 'math/parsenode/sum', 'math/parsenode/product', 'math/parsenode/functioncall', 'math/parsenode/functionexponent', 'math/parsenode/piecewise', 'math/parsenode/derivative', 'math/parsenode/assignment', 'math/parsenode/functiondefinition', 'math/parsenode/equation', 'math/parsenode/regression', 'math/parsenode/table', 'math/parsenode/tablecolumn', 'math/parsenode/nativefunction', 'math/parsenode/reducerfunction', 'math/parsenode/solvedequation', 'math/parsenode/optimizedregression'], function(require) {
    var expressionParseNodes = require('math/parsenode/expressionTypes'); //Require expressionsTypes

    var nodes = {
        //Base Types
        Base: require('math/parsenode/base'),
        Expression: require('math/parsenode/expression'),
        ScalarExpression: require('math/parsenode/scalarexpression'),

        //Primitive Types
        Error: require('math/parsenode/error'),
        Constant: require('math/parsenode/constant'),
        Identifier: require('math/parsenode/identifier'),
        FreeVariable: require('math/parsenode/freevariable'),
        DummyIndex: require('math/parsenode/dummyindex'),

        //List types
        List: require('math/parsenode/list'),
        Range: require('math/parsenode/range'),
        ListAccess: require('math/parsenode/listaccess'),

        // Points and point lists
        OrderedPair: require('math/parsenode/orderedpair'),
        MovablePoint: require('math/parsenode/movablepoint'),

        //Expressions and operators
        BaseComparator: require('math/parsenode/basecomparator'),
        Comparator: require('math/parsenode/comparator'),
        DoubleInequality: require('math/parsenode/doubleinequality'),
        RepeatedOperator: require('math/parsenode/repeatedoperator'),
        Sum: require('math/parsenode/sum'),
        Product: require('math/parsenode/product'),
        FunctionCall: require('math/parsenode/functioncall'),
        FunctionExponent: require('math/parsenode/functionexponent'),
        Piecewise: require('math/parsenode/piecewise'),
        Derivative: require('math/parsenode/derivative'),

        //Exports and definitions
        Assignment: require('math/parsenode/assignment'),
        FunctionDefinition: require('math/parsenode/functiondefinition'),
        Equation: require('math/parsenode/equation'),
        Regression: require('math/parsenode/regression'),

        // Tables
        Table: require('math/parsenode/table'),
        TableColumn: require('math/parsenode/tablecolumn'),

        // Concrete function call nodes
        NativeFunction: require('math/parsenode/nativefunction'),
        ReducerFunction: require('math/parsenode/reducerfunction'),

        // Concrete solved equation
        SolvedEquation: require('math/parsenode/solvedequation'),
        OptimizedRegression: require('math/parsenode/optimizedregression')

    };

    //Each of the simple expression types
    for (var nodeType in expressionParseNodes) {
        nodes[nodeType] = expressionParseNodes[nodeType];
    }

    for (var t in nodes) {
        if (!nodes.hasOwnProperty(t)) continue;
        if (t === 'Comparator') continue;
        nodes[t].prototype.type = t;
    }

    for (var op in nodes.Comparator) {
        if (!nodes.Comparator.hasOwnProperty(op)) continue;
        nodes.Comparator[op].prototype.type = 'Comparator[\'' + op + '\']';
    }

    return nodes;
});

define('math/inverses', [], function() {
    var inverses = {};

    // Functions with an inverse spelled arcname
    var arcNames = [
        'sin',
        'cos',
        'tan',
        'cot',
        'sec',
        'csc',
        'sinh',
        'cosh',
        'tanh',
        'coth',
        'sech',
        'csch'
    ];

    arcNames.forEach(function(name) {
        inverses[name] = 'arc' + name;
        inverses['arc' + name] = name;
    });

    return inverses;
});
/*
 * baseparser is separated from parser so that it can be used inside
 * features without creating a circular dependency. Outside users
 * should include parser, which adds features to the baseparse.
 */
define('math/baseparser', ['require', 'jison', 'parsenodes', 'math/inverses', 'math/errormsg'], function(require) {
    var jison = require('jison');
    var yy = jison.yy;
    var ParseNodes = require('parsenodes');
    var inverses = require('math/inverses');
    var ErrorMsg = require('math/errormsg');

    var exports = {};

    //Public parsing API
    exports.parse = function(input) {
        try {
            return jison.parse('###' + input);
        } catch (e) {
            if (e instanceof ParseNodes.Error) return e;
            return ErrorMsg.parseError();
        }
    };

    yy.ErrorMsg = ErrorMsg;

    yy.setInput = function(node, range) {
        //Don't ever show the '###' mark we insert to mark the start of the string
        node.setInputString(yy.lexer.matched.slice(Math.max(3, range.first_column), range.last_column));
    };

    //Make all ParseNodes available on yy object for jison
    for (var nodeType in ParseNodes) {
        yy[nodeType] = ParseNodes[nodeType];
    }

    //Register known inverses
    yy.inverses = inverses;

    /* This function takes the entire function declaration as a single lexed token and parses with a regexp,
     * to keep the overall grammar context-free and LALR(1)-parseable.
     * TODO - generate this once, not every time we parse a function declaration */
    yy.parseFunctionDeclaration = function(declaration_string) {
        declaration_string = declaration_string.replace('###', ''); //Strip off start-of-line marker
        var whitespace_pattern = //Non-capturing latex whitespace pattern
            "(?:\\s|\\\\space|\\\\\\:)*";
        //   \s   \\space  \\ \ :
        var id_body_pattern = //Non-capturing latex identifier pattern
            "(?:[a-zA-Z]|\\\\[a-zA-Z]+)";
        var id_subscript_pattern = //Non-capturing latex subscript pattern
            "(?:_[a-zA-Z0-9]|_{[a-zA-Z0-9]+})?";
        var id_pattern = id_body_pattern + id_subscript_pattern;

        var arglist_pattern = //Non-capturing comma-separated list of identifiers in whitespace-free string
            "(?:" + id_pattern + "(?:\\," + id_pattern + ")*)";

        var declaration_pattern = //Captures function name as first group, and arglist as second group
            "(" + id_pattern + ")" + "(?:\\\\left)?\\((" + arglist_pattern + ")(?:\\\\right)?\\)=";

        var declaration_regexp = new RegExp(declaration_pattern);
        var whitespace_regexp = new RegExp(whitespace_pattern, "g");
        //Want "g" flag to ensure global capturing of whitespace
        declaration_string = declaration_string.replace(whitespace_regexp, '');
        var match = declaration_regexp.exec(declaration_string);

        return {
            identifier: ParseNodes.Identifier(match[1]), //match[1] is the function symbol.
            //match[2] is the argument list.  Split it on commas.
            args: match[2].split(',').map(function(symbol) { return ParseNodes.Identifier(symbol); }),
        };
    };

    return exports;
});

// String representation of parse nodes that should return the same parse tree when executed.
// Intended to be used for debugging and experiments, not for implementing other features.
define('math/features/repr', ['require', 'parsenodes'], function(require) {
    var nodes = require('parsenodes');

    var reprArgs = function(args, prefix, level) {
        level = level || 0;
        var lastIndent = Array(level + 1).join('  ');
        var indent = lastIndent + '  ';
        return '[' + '\n' +
            indent + args.map(function(arg) {
                return arg.repr(prefix, level + 1);
            }).join(',\n' + indent) + '\n' +
            lastIndent + ']';
    };

    var reprHead = function(head, prefix) {
        prefix = prefix || '';
        return '' + prefix + '' + head;
    };

    nodes.DoubleInequality.prototype.repr =
        nodes.Expression.prototype.repr = function(prefix, level) {
            return reprHead(this.type, prefix) + '(' + reprArgs(this.args, prefix, level) + ')';
        };

    nodes.Identifier.prototype.repr =
        nodes.FreeVariable.prototype.repr = function(prefix) {
            return reprHead(this.type, prefix) + '(\'' + this._symbol + '\')';
        };

    nodes.Constant.prototype.repr = function(prefix) {
        return reprHead(this.type, prefix) + '(' + this.constantValue + ')';
    };

    nodes.FunctionCall.prototype.repr = function(prefix, level) {
        return reprHead(this.type, prefix) + '(' +
            '\'' + this._symbol + '\'' + ', ' + reprArgs(this.args, prefix, level) +
            ')';
    };

    nodes.Assignment.prototype.repr = function(prefix, level) {
        return reprHead(this.type, prefix) + '(' +
            nodes.Identifier(this._symbol).repr(prefix, level) + ', ' +
            this._expression.repr(prefix, level) +
            ')';
    };

    nodes.Regression.prototype.repr =
        nodes.Equation.prototype.repr = function(prefix, level) {
            return reprHead(this.type, prefix) + '(' +
                this._lhs.repr(prefix, level) + ', ' +
                this._rhs.repr(prefix, level) +
                ')';
        };

    nodes.FunctionDefinition.prototype.repr = function(prefix, level) {
        return reprHead(this.type, prefix) + '(' +
            nodes.Identifier(this._symbol).repr(prefix, level) + ', ' +
            reprArgs(this._argSymbols.map(function(s) { return nodes.Identifier(s); }), prefix, level) + ', ' +
            this._expression.repr(prefix, level) +
            ')';
    };

    nodes.Error.prototype.repr = function(prefix, level) {
        return reprHead(this.type, prefix) + '(\'' + this._msg + '\')';
    };

    nodes.Derivative.prototype.repr = function(prefix, level) {
        return reprHead(this.type, prefix) + '(' +
            '\'' + this._symbol + '\'' + ', ' + reprArgs(this.args, prefix, level) +
            ')';
    };

    nodes.SolvedEquation.prototype.repr = function(prefix, level) {
        return reprHead(this.type, prefix) + '(' +
            '\'' + this._symbol + '\'' + ', ' + this._expression.repr(prefix, level) +
            ')';
    };

    nodes.OptimizedRegression.prototype.repr = function(prefix, level) {
        return reprHead(this.type, prefix) + '(' +
            JSON.stringify(this.parameters) + ', ' +
            JSON.stringify(this.residuals) + ', ' +
            JSON.stringify(this.statistics) + ', ' +
            this.model.repr(prefix, level + 1) + ', ' +
            JSON.stringify({
                isModelValid: this.isModelValid,
                residualVariable: this.residualVariable,
                residualSuggestionId: this.residualSuggestionId
            }) +
            ')';
    };

    // TODO, Table could be an expression
    nodes.Table.prototype.repr = function(prefix, level) {
        return reprHead(this.type, prefix) + '(' + reprArgs(this.columns, prefix, level) + ')';
    };

    nodes.TableColumn.prototype.repr = function(prefix, level) {
        return reprHead(this.type, prefix) + '(' +
            this.header.repr(prefix, level) + ', ' + this.length + ', ' +
            reprArgs(this.values, prefix, level) +
            ')';
    };


});

define('math/features/scalarEvalExpression', ['require', 'parsenodes', 'math/functions'], function(require) {
    var nodes = require('parsenodes');
    var Functions = require('math/functions');

    var expressions = {
        Add: function(args) {
            return '(' + args.join('+') + ')';
        },
        Multiply: function(args) {
            return '(' + args.join('*') + ')';
        },
        Divide: function(args) {
            return '(' + args.join('/') + ')';
        },
        Subtract: function(args) {
            return '(' + args.join('-') + ')';
        },
        Exponent: function(args) {
            return 'BuiltIn.pow(' + args.join(',') + ')';
        },
        Negative: function(args) {
            return '(-' + args[0] + ')';
        },
        And: function(args) {
            //Used for Chained Comparators (a<b<c becomes a<b && b<c)
            //TODO - this naively re-evaluates middle terms
            //TODO - this doesn't check that directions agree
            return args.join('&&');
        },
        Piecewise: function(args) {
            //TODO - this will naively evaluate statements
            //for all branches.
            //This will produce correct output, but performance
            //will be better if we only evaluate needed statements
            return '(' + args[0] + '?' + args[1] + ':' + args[2] + ')';
        }
    };

    var arities = {
        Add: 2,
        Multiply: 2,
        Divide: 2,
        Subtract: 2,
        Exponent: 2,
        Negative: 1,
        And: 2,
        Piecewise: 3
    };

    for (var nodeType in expressions) {
        var p = nodes[nodeType].prototype;
        p.scalarEvalExpression = expressions[nodeType];
        p.evaluate = Functions.createEvaluateFunction(p.scalarEvalExpression, arities[nodeType]);
    }

});

define('math/features/okForImplicitFunction', ['require', 'parsenodes'], function(require) {
    var nodes = require('parsenodes');

    nodes.Add.prototype.okForImplicitFunction =
        nodes.Subtract.prototype.okForImplicitFunction =
        nodes.Add.prototype.okForImplicitFunction =
        nodes.Multiply.prototype.okForImplicitFunction =
        nodes.Divide.prototype.okForImplicitFunction =
        nodes.Exponent.prototype.okForImplicitFunction = function() {
            for (var i = 0; i < this.args.length; i++) {
                if (!this.args[i].okForImplicitFunction()) return false;
            }
            return true;
        };
});

define('math/features/constantcollapsedcopy', ['require', 'parsenodes'], function(require) {
    var nodes = require('parsenodes');
    var Constant = nodes.Constant;

    var defs = {
        Add: function(args) {
            if (args[0].isConstant && args[1].isConstant) {
                return Constant(this.evaluate([args[0].constantValue, args[1].constantValue]));
            }
            if (args[0].constantValue === 0) return args[1];
            if (args[1].constantValue === 0) return args[0];
            return this.copyWithArgs(args);
        },
        Multiply: function(args) {
            if (args[0].isConstant && args[1].isConstant) {
                return Constant(this.evaluate([args[0].constantValue, args[1].constantValue]));
            }
            if (args[0].constantValue === 1) return args[1];
            if (args[1].constantValue === 1) return args[0];
            return this.copyWithArgs(args);
        },
        Subtract: function(args) {
            if (args[0].isConstant && args[1].isConstant) {
                return Constant(this.evaluate([args[0].constantValue, args[1].constantValue]));
            }
            if (args[0].constantValue === 0) return nodes.Negative([args[1]]);
            if (args[1].constantValue === 0) return args[0];
            return this.copyWithArgs(args);
        },
        Divide: function(args) {
            if (args[0].isConstant && args[1].isConstant) {
                return Constant(this.evaluate([args[0].constantValue, args[1].constantValue]));
            }
            if (args[1].constantValue === 1) return args[0];
            return this.copyWithArgs(args);
        },
        Exponent: function(args) {
            if (args[0].isConstant && args[1].isConstant) {
                return Constant(this.evaluate([args[0].constantValue, args[1].constantValue]));
            }
            if (args[1].constantValue === 1) return args[0];
            return this.copyWithArgs(args);
        },
        Negative: function(args) {
            if (args[0].isConstant) return Constant(-args[0].constantValue);
            if (args[0] instanceof nodes.Negative) return args[0].args[0];
            return this.copyWithArgs(args);
        },
        And: function(args) {
            if (args[0].isConstant && args[1].isConstant) {
                return Constant(args[0].constantValue && args[1].constantValue);
            }
            if (args[0].isConstant && args[0] === true) return args[1];
            if (args[0].isConstant && args[0] === false) return Constant(false);
            if (args[1].isConstant && args[1] === true) return args[0];
            if (args[1].isConstant && args[1] === false) return Constant(false);
            return this.copyWithArgs(args);
        },
        Piecewise: function(args) {
            if (args[0].isConstant && args[0].constantValue === true) return args[1];
            if (args[0].isConstant && args[0].constantValue === false) return args[2];
            return this.copyWithArgs(args);
        }
    };

    for (var k in defs) {
        nodes[k].prototype._constantCollapsedCopy = defs[k];
    }

});
define('math/features/polynomialorder', ['require', 'parsenodes'], function(require) {
    var nodes = require('parsenodes');

    var polynomialOrders = {
        Expression: "this.dependsOn(symbol) ? Infinity : 0",
        FreeVariable: "(symbol === this._symbol ? 1 : 0)",
        Constant: "0",
        Add: "Math.max(order0, order1)",
        Subtract: "Math.max(order0, order1)",
        Multiply: "order0 + order1",
        Negative: "order0",
        Divide: "order1 > 0 ? Infinity : order0"
    };

    //Convert data above into proper member functions
    var wrap = function(expr) {
        /*jshint evil: true */
        expr = expr.replace("order0", "this.args[0].polynomialOrder(symbol)");
        expr = expr.replace("order1", "this.args[1].polynomialOrder(symbol)");
        return new Function(['symbol'], 'return ' + expr);
    };

    for (var nodeType in polynomialOrders) {
        var order = polynomialOrders[nodeType];
        nodes[nodeType].prototype.polynomialOrder = wrap(order);
    }

    nodes.Exponent.prototype.polynomialOrder = function(symbol) {
        var baseOrder = this.args[0].polynomialOrder(symbol);
        var exponentOrder = this.args[1].polynomialOrder(symbol);
        if (baseOrder === 0 && exponentOrder === 0) return 0;
        var exponent = this.args[1];
        if (exponent.isConstant &&
            exponent.constantValue === Math.round(exponent.constantValue) &&
            exponent.constantValue > 0) {
            return baseOrder * exponent.constantValue;
        }
        return Infinity;
    };

    // Allow piecewise expressions of the form {f(x):5} where f(x) is a boolean
    // expression in symbol
    nodes.Piecewise.prototype.polynomialOrder = function(symbol) {
        if (!this.dependsOn(symbol)) return 0;
        if (!this.args[2].isConstant || !isNaN(this.args[2].constantValue)) return Infinity;
        if (this.args[1].dependsOn(symbol)) return Infinity;
        return 0;
    };

    nodes.List.prototype.polynomialOrder = function(symbol) {
        var order = 0;
        for (var i = 0; i < this.args.length; i++) {
            order = Math.max(order, this.args[i].polynomialOrder(symbol));
        }
        return order;
    };
});

define('math/features/polynomialcoefficients', ['require', 'parsenodes'], function(require) {
    var nodes = require('parsenodes');
    var zero = nodes.Constant(0);
    var one = nodes.Constant(1);

    nodes.FreeVariable.prototype.getPolynomialCoefficients = function(symbol) {
        if (symbol === this._symbol) return [zero, one];
        return [this];
    };

    nodes.Constant.prototype.getPolynomialCoefficients = function(symbol) {
        return [this];
    };

    nodes.Add.prototype.getPolynomialCoefficients = function(symbol) {
        var coeffs0 = this.args[0].getPolynomialCoefficients(symbol);
        var coeffs1 = this.args[1].getPolynomialCoefficients(symbol);
        var order0 = coeffs0.length - 1;
        var order1 = coeffs1.length - 1;
        var coeffs = [];
        for (var i = 0; i <= Math.max(order0, order1); i++) {
            if (order0 >= i && order1 >= i) {
                coeffs.push(nodes.Add([coeffs0[i], coeffs1[i]]));
            } else {
                coeffs.push(order0 > order1 ? coeffs0[i] : coeffs1[i]);
            }
        }
        return coeffs;
    };

    nodes.Subtract.prototype.getPolynomialCoefficients = function(symbol) {
        var coeffs0 = this.args[0].getPolynomialCoefficients(symbol);
        var coeffs1 = this.args[1].getPolynomialCoefficients(symbol);
        var order0 = coeffs0.length - 1;
        var order1 = coeffs1.length - 1;
        var coeffs = [];
        for (var i = 0; i <= Math.max(order0, order1); i++) {
            if (order0 >= i && order1 >= i) {
                coeffs.push(nodes.Subtract([coeffs0[i], coeffs1[i]]));
            } else {
                coeffs.push(order0 > order1 ? coeffs0[i] : nodes.Negative([coeffs1[i]]));
            }
        }
        return coeffs;
    };

    nodes.Negative.prototype.getPolynomialCoefficients = function(symbol) {
        var coeffs0 = this.args[0].getPolynomialCoefficients(symbol);
        var coeffs = [];
        for (var i = 0; i < coeffs0.length; i++) {
            coeffs.push(nodes.Negative([coeffs0[i]]));
        }
        return coeffs;
    };

    nodes.Exponent.prototype.getPolynomialCoefficients = function(symbol) {
        var coeffs0 = this.args[0].getPolynomialCoefficients(symbol);
        var coeffs1 = this.args[1].getPolynomialCoefficients(symbol);
        var order0 = coeffs0.length - 1;
        var order1 = coeffs1.length - 1;
        if (order1 > 0) throw "can't solve for variable in exponent";
        if (order0 === 0) return [nodes.Exponent([coeffs0[0], coeffs1[0]])];
        if (this.args[1].isConstant) {
            var exponent = this.args[1].constantValue;
            switch (exponent) {
                case 0:
                    return [zero];
                case 1:
                    return coeffs0;
                case 2:
                    return nodes.Multiply([this.args[0], this.args[0]]).getPolynomialCoefficients(symbol);
            }
        }
        throw "Unable to compile polynomial representation";
    };

    nodes.Multiply.prototype.getPolynomialCoefficients = function(symbol) {
        var coeffs0 = this.args[0].getPolynomialCoefficients(symbol);
        var coeffs1 = this.args[1].getPolynomialCoefficients(symbol);
        var order0 = coeffs0.length - 1;
        var order1 = coeffs1.length - 1;
        var coeffs = [];
        for (var i = 0; i <= order0; i++) {
            for (var j = 0; j <= order1; j++) {
                var newTerm = nodes.Multiply([coeffs0[i], coeffs1[j]]);
                var currentTerm = coeffs[i + j];
                if (currentTerm === undefined) {
                    coeffs[i + j] = newTerm;
                } else {
                    coeffs[i + j] = nodes.Add([currentTerm, newTerm]);
                }
            }
        }
        return coeffs;
    };

    nodes.Divide.prototype.getPolynomialCoefficients = function(symbol) {
        var coeffs0 = this.args[0].getPolynomialCoefficients(symbol);
        var coeffs1 = this.args[1].getPolynomialCoefficients(symbol);
        var order1 = coeffs1.length - 1;
        var coeffs = [];
        if (order1 > 0) throw "Can't solve for variable in denominator";
        for (var i = 0; i < coeffs0.length; i++) {
            coeffs.push(nodes.Divide([coeffs0[i], coeffs1[0]]));
        }
        return coeffs;
    };

    nodes.Expression.prototype.getPolynomialCoefficients = function(symbol) {
        if (this.dependsOn(symbol)) throw "Unimplemented polynomialCoefficient call";
        return [this];
    };

    // Only treating special case of expressions like {f(x):2} where f(x) is a boolean
    // expression in symbol. Everything else is screened out by polynomialOrder.
    //
    // In this case, behave as if condition is satisfied. Later, we use node.extractConditions
    // to reapply the original conditions to the solution.
    nodes.Piecewise.prototype.getPolynomialCoefficients = function(symbol) {
        if (!this.dependsOn(symbol)) return [this];
        var ifExprCoeffs = this.args[1].getPolynomialCoefficients(symbol);
        if (this.args[0].dependsOn(symbol)) return ifExprCoeffs;
        return [nodes.Piecewise(this.args[0], ifExprCoeffs[0], this.args[2])];
    };

});

// node.extractConditions(symbol, replacement) applies conditions in
// expression given by node to expression given by replacement, replacing
// instances of symbol in the conditions with replacement.
//
// The rationale for this is to allow solving expressions like
// y=sin(x){0<y<2}. Our solver first solves this to y=sin(x),
// and then extractConditions wraps the solution to be y={0<sin(x)<2:sin(x)}
define('math/features/extractconditions', ['require', 'parsenodes'], function(require) {
    var nodes = require('parsenodes');

    nodes.Expression.prototype.extractConditions = function(symbol, replacement) {
        for (var i = 0; i < this.args.length; i++) {
            var arg = this.args[i];
            replacement = arg.extractConditions(symbol, replacement);
        }
        return replacement;
    };

    nodes.Constant.prototype.extractConditions = function(symbol, replacement) {
        return replacement;
    };

    nodes.Piecewise.prototype.extractConditions = function(symbol, replacement) {
        if (!this.dependsOn(symbol)) return replacement;
        if (!this.args[0].dependsOn(symbol)) {
            replacement = this.args[1].extractConditions(symbol, replacement);
            replacement = this.args[2].extractConditions(symbol, replacement);
            return replacement;
        }
        var substitution = {};
        substitution[symbol] = replacement;
        return nodes.Piecewise([
            this.args[0].substitute(substitution),
            replacement,
            nodes.Constant(NaN)
        ]);
    };
});

// node.boundDomain(symbol) returns an upper bound on the domain of symbol for
// which the expression given by node is defined.
//
//
// Returns false if we cannot bound the domain, or a domain in the form
// [xmin, xmax], in which case it should be valid for the plotter to plot the
// function only from xmin to xmax,.
//
// Ignores the distinction between strict and non-strict inequalities. This is
// important because the function may return NaN when evaluated exactly at the
// domain bounds, so the plotter needs to know how to deal with that.
// Otherwise, the domain bound should be "nearly tight" in the sense that it is
// tight up to floating point rounding.
//
// May return false when we don't know how to supply a "nearly tight" domain.
define('math/features/bounddomain', ['require', 'parsenodes', 'math/builtinframe'], function(require) {
    var nodes = require('parsenodes');
    var BuiltInFrame = require('math/builtinframe');

    var zero = nodes.Constant(0);

    nodes.Base.prototype.boundDomain = function(symbol) {
        return false;
    };

    // Bail on lists for now. Cound bound each term separately, but
    // can't just take intersection of term bounds.
    nodes.List.prototype.boundDomain = function(symbol) {
        return false;
    };

    // The domain of an expression is the intersection of the domains of
    // its arguments.
    nodes.Expression.prototype.boundDomain = function(symbol) {
        var out = [-Infinity, Infinity];
        for (var i = 0; i < this.args.length; i++) {
            var arg = this.args[i];
            var domain = arg.boundDomain(symbol);
            if (!domain) return false;
            out = [Math.max(out[0], domain[0]), Math.min(out[1], domain[1])];
        }
        return out;
    };

    nodes.Constant.prototype.boundDomain = function(symbol) {
        return [-Infinity, Infinity];
    };

    // Tighten domain for piecewise functions with a linear inequality condition
    // and a NaN else_expr.
    nodes.Piecewise.prototype.boundDomain = function(symbol) {
        if (!this.args[2].isConstant || !isNaN(this.args[2].constantValue)) return false;
        var condDomain = this.args[0].boundDomain(symbol);
        var ifExprDomain = this.args[1].boundDomain(symbol);
        if (!condDomain || !ifExprDomain) return false;
        return [Math.max(condDomain[0], ifExprDomain[0]), Math.min(condDomain[1], ifExprDomain[1])];
    };

    nodes.BaseComparator.prototype.boundDomain = function(symbol) {
        if (this.operator === '=') return false; // Just bail on equality case
        var differenceTree = this._difference;
        var polynomialOrder = differenceTree.polynomialOrder(symbol);
        if (polynomialOrder > 1) return false;
        // Should strictly check sign of 0 order term, and return either complete or empty
        // set accordingly, but for plotting, this isn't relevant.
        if (polynomialOrder < 1) return [-Infinity, Infinity];

        var coeffTrees = differenceTree.getPolynomialCoefficients(symbol);
        var b = coeffTrees[1] ? coeffTrees[1].getConcreteTree(BuiltInFrame) : zero;
        var c = coeffTrees[0] ? coeffTrees[0].getConcreteTree(BuiltInFrame) : zero;

        // Only handle cases that constant collapse to finite constants.
        if (!b.isConstant || !c.isConstant) return false;
        if (!isFinite(b.constantValue) || !isFinite(c.constantValue)) return false;

        // Same note as polynomialOrder < 1 above.
        if (b.constantValue === 0) return [-Infinity, Infinity];

        var soln = -c.constantValue / b.constantValue;
        return (b.constantValue < 0) ? [-Infinity, soln] : [soln, Infinity];
    };
});
define('math/features/derivative', ['require', 'parsenodes', 'math/baseparser', 'math/builtinframe'], function(require) {
    var Nodes = require('parsenodes');
    var Parser = require('math/baseparser');
    var BuiltInFrame = require('math/builtinframe');

    var zero = Nodes.Constant(0);
    var one = Nodes.Constant(1);
    var two = Nodes.Constant(2);

    var derivatives = {
        FreeVariable: function(symbol) { return symbol === this._symbol ? one : zero },
        Constant: function(symbol) {
            return isFinite(this.constantValue) ? zero : Nodes.Constant(this.constantValue);
        },
        Negative: function(symbol) { return Nodes.Negative([this.args[0].takeDerivative(symbol)]) },
        // ['x_1', 'y_1']
        Add: function(symbol) {
            return Nodes.Add([
                this.args[0].takeDerivative(symbol),
                this.args[1].takeDerivative(symbol)
            ]);
        },
        // Subtract: ['x_1', '-y_1'],
        Subtract: function(symbol) {
            return Nodes.Subtract([
                this.args[0].takeDerivative(symbol),
                this.args[1].takeDerivative(symbol)
            ]);
        },
        // Multiply: ['x*y_1', 'x_1*y'],
        Multiply: function(symbol) {
            return Nodes.Add([
                checkDependence(symbol, this.args[0], Nodes.Multiply([this.args[0].takeDerivative(symbol), this.args[1]])),
                checkDependence(symbol, this.args[1], Nodes.Multiply([this.args[0], this.args[1].takeDerivative(symbol)])),
            ]);
        },
        // ['x_1/y, -(x*y_1)/y^2']
        Divide: function(symbol) {
            return Nodes.Subtract([
                checkDependence(symbol, this.args[0], Nodes.Divide([this.args[0].takeDerivative(symbol), this.args[1]])),
                checkDependence(symbol, this.args[1], Nodes.Divide([
                    Nodes.Multiply([this.args[0], this.args[1].takeDerivative(symbol)]),
                    Nodes.Exponent([this.args[1], two])
                ]))
            ]);
        },
        // ['y*x^y*x_1', '\\ln(x)*x^y*y_1']
        Exponent: function(symbol) {
            return Nodes.Add([
                checkDependence(symbol, this.args[0], Nodes.Multiply([
                    Nodes.Multiply([
                        this.args[1],
                        Nodes.Exponent([this.args[0], Nodes.Subtract([this.args[1], one])])
                    ]),
                    this.args[0].takeDerivative(symbol)
                ])),
                checkDependence(symbol, this.args[1], Nodes.Multiply([
                    Nodes.Multiply([
                        Nodes.FunctionCall('\\ln', [this.args[0]]),
                        Nodes.Exponent([this.args[0], this.args[1]])
                    ]),
                    this.args[1].takeDerivative(symbol)
                ]))
            ]).getConcreteTree(BuiltInFrame);
        },
        Sum: function(symbol) {
            return this.copyWithArgs([
                this.args[0],
                this.args[1],
                this.args[2],
                this.args[3].takeDerivative(symbol)
            ]);
        },
        Product: function(symbol) {
            // If product has no zero terms, use (sum_i fi'/fi)(product_i fi)
            // If product has exactly 1 zero at ith term, use f1*f2*...*fi'*...*fn
            // If product has more than 1 non-zero term, then its derivative is 0.

            var nzeros = Nodes.Sum([
                this.args[0],
                this.args[1],
                this.args[2],
                Nodes.Piecewise([
                    Nodes.Comparator['=']([zero, this.args[3]]),
                    one,
                    zero
                ])
            ]);

            var noZeros = Nodes.Multiply([
                Nodes.Sum([
                    this.args[0],
                    this.args[1],
                    this.args[2],
                    Nodes.Divide([
                        this.args[3].takeDerivative(symbol),
                        this.args[3]
                    ])
                ]),
                Nodes.Product(this.args)
            ]);

            var oneZero = Nodes.Product([
                this.args[0],
                this.args[1],
                this.args[2],
                Nodes.Piecewise([
                    Nodes.Comparator['=']([zero, this.args[3]]),
                    this.args[3].takeDerivative(symbol),
                    this.args[3]
                ])
            ]);

            return Nodes.Piecewise([
                Nodes.Comparator['=']([zero, nzeros]),
                noZeros,
                Nodes.Piecewise([
                    Nodes.Comparator['=']([one, nzeros]),
                    oneZero,
                    zero
                ])
            ]);
        },
        Piecewise: function(symbol) {
            // TODO incorrect at condition boundaries
            if (this.args.length === 2) {
                return Nodes.Piecewise([
                    this.args[0],
                    this.args[1].takeDerivative(symbol)
                ]);
            } else if (this.args.length === 3) {
                return Nodes.Piecewise([
                    this.args[0],
                    this.args[1].takeDerivative(symbol),
                    this.args[2].takeDerivative(symbol)
                ]);
            }
        },
        List: function(symbol) {
            return Nodes.List(this.args.map(function(arg) {
                return arg.takeDerivative(symbol);
            }));
        },
        ListAccess: function(symbol) {
            return this.constructor([this.args[0].takeDerivative(symbol), this.args[1]]);
        },
        SolvedEquation: function(symbol) {
            return this._expression.takeDerivative(symbol);
        },
        OptimizedRegression: function(symbol) {
            return this.model.takeDerivative(symbol);
        }
    };

    Nodes.NativeFunction.Invocation.prototype.takeDerivative = function(symbol) {
        return this._fn.takeDerivative(symbol, this.args);
    };

    Nodes.ReducerFunction.Invocation.prototype.takeDerivative = function(symbol) {
        return this._fn.takeDerivative(symbol, this.args);
    };

    // TODO restrict domain on derivatives of inverse functions
    var oneArgFunctionDerivatives = {
        exp: '\\exp(x)*x_1',
        ln: '\\{x >= 0: x_1/x \\}',
        sqrt: 'x_1/(2*\\sqrt{x})',
        sin: '\\cos(x)*x_1',
        cos: '-\\sin(x)*x_1',
        tan: '\\sec(x)^2*x_1',
        arcsin: 'x_1/\\sqrt{1 - x^2}',
        arccos: '-x_1/\\sqrt{1 - x^2}',
        arctan: 'x_1/(1+x^2)',
        sinh: '\\cosh(x)*x_1',
        cosh: '\\sinh(x)*x_1',
        tanh: '(\\sech(x))^2*x_1',
        arcsinh: 'x_1/\\sqrt{x^2 + 1}',
        arccosh: '\\{ x > 0: x_1/\\sqrt{x^2 - 1} \\}',
        arctanh: '\\{ \\abs(x) < 1: x_1/(1 - x^2) \\}',
        csc: '-\\cot(x)*\\csc(x)*x_1',
        sec: '\\tan(x)*\\sec(x)*x_1',
        cot: '-\\csc(x)^2*x_1',
        arccsc: '-x_1/(x\\sqrt{x^2 - 1})',
        arcsec: 'x_1/(x\\sqrt{x^2 - 1})',
        arccot: '-x_1/(1+x^2)',
        csch: '-\\coth(x)*\\csch(x)*x_1',
        sech: '-\\tanh(x)*\\sech(x)*x_1',
        coth: '-(\\csch(x))^2*x_1',
        arccsch: '-x_1/(x*\\sqrt{1 + x^2})',
        arcsech: '\\{ x >= 0: -x_1/(x*\\sqrt{1 - x^2}) \\}',
        arccoth: '\\{ \\abs(x) > 1 : x_1/(1 - x^2) \\}',
        factorial: '(x)!*\\polyGamma(0, x + 1)*x_1',
        floor: '\\{ \\mod(x, 1) > 0: 0*x_1 \\}',
        ceil: '\\{ \\mod(x, 1) > 0: 0*x_1 \\}',
        round: '\\{ \\abs(\\mod(x, 1) - 0.5) > 0: 0*x_1 \\}',
        abs: '\\{ \\abs(x) > 0: \\sign(x)*x_1 \\}',
        sign: '\\{ \\abs(x) > 0: 0*x_1 \\}',
        mean: '\\mean(x_1)',
        total: '\\total(x_1)',
        length: '0',
        'var': '2\\mean((x-\\mean(x))*(x_1-\\mean(x_1)))',
        stdev: '\\length(x)/(\\length(x) - 1)*\\mean((x-\\mean(x))*(x_1-\\mean(x_1)))/\\stdev(x)',
        stdevp: '\\mean((x-\\mean(x))*(x_1-\\mean(x_1)))/\\stdevp(x)',
        // TODO: ignores the case that the supremum/infimum of x contains more than 1 element.
        // In that case, the result should be NaN unless the derivative of all of the elements
        // of the supremum/infimum are equal.
        min: 'x_1[\\argmin(x)]',
        max: 'x_1[\\argmax(x)]',
        // zero would be an okay answer here too, but this usually isn't relevant
        argmin: '0/0',
        argmax: '0/0'
    };

    var twoArgFunctionDerivatives = {
        log: [
            // d/dx ln(x) is actually real for negative x, too, but showing the
            // derivative in places where we don't show the function is confusing,
            // so restrict to x > 0.
            '\\{x > 0: \\frac{x_1}{x*\\ln(y)}\\}',
            '\\frac{-\\log_{y}(x)*y_1}{y*\\ln(y)}'
        ],
        pow: [
            'y*x^{y - 1}*x_1',
            'x^{y}*\\ln(x)*y_1'
        ],
        nthroot: [
            'x^{1/y - 1}/y*x_1',
            '-\\frac{x^{1/y}*\\ln(x)*y_1}{y^2}'
        ],
        polyGamma: [
            '0/0',
            '\\polyGamma(1 + x, y)*y_1'
        ],
        mod: [
            '\\{ \\abs(\\mod(x, y)) > 0: x_1 \\}',
            // Check whether division results in an integer directly instead
            // of computing mod of the args because division sometimes results
            // in an integer when modulus does not result in 0, e.g.
            //
            // 3.8 % -0.7599999999999999 -> 3.3306690738754696e-16, but
            // 3.8 / -0.7599999999999999 -> -5
            //
            // This can confuse the jump detector, resulting in spurious
            // connections.
            //
            //TODO still have some spurious connections near 0 in d/dx mod(3,x).
            // Why?
            '\\{ \\mod(x/y, 1) > 0: -\\floor(x/y)*y_1 \\}'
        ],
        // We actually round arguments for these functions, so to be consistent,
        // these could be defined as 0 except at integers where they're undefined,
        // but that is not a standard definition.
        //
        // Can also define continuous nCr and nPr using gamma function.
        lcm: ['0/0', '0/0'],
        gcd: ['0/0', '0/0'],
        nCr: ['0/0', '0/0'],
        nPr: ['0/0', '0/0']
    };

    var oneArgDerivativeFunction = function(derivativeTree) {
        return function(symbol, args) {
            var substitutions = {
                x: args[0],
                x_1: args[0].takeDerivative(symbol)
            };
            return checkDependence(symbol, args[0], derivativeTree.substitute(substitutions)).getConcreteTree(BuiltInFrame);
        };
    };

    var twoArgDerivativeFunction = function(derivativeTree1, derivativeTree2) {
        return function(symbol, args) {
            var substitutions = {
                x: args[0],
                x_1: args[0].takeDerivative(symbol),
                y: args[1],
                y_1: args[1].takeDerivative(symbol)
            };

            return Nodes.Add([
                checkDependence(symbol, args[0], derivativeTree1.substitute(substitutions)),
                checkDependence(symbol, args[1], derivativeTree2.substitute(substitutions))
            ]).getConcreteTree(BuiltInFrame);
        };
    };

    for (var k in oneArgFunctionDerivatives) {
        BuiltInFrame[k].takeDerivative = oneArgDerivativeFunction(
            Parser.parse(oneArgFunctionDerivatives[k])
        );
    }

    for (k in twoArgFunctionDerivatives) {
        BuiltInFrame[k].takeDerivative = twoArgDerivativeFunction(
            Parser.parse(twoArgFunctionDerivatives[k][0]),
            Parser.parse(twoArgFunctionDerivatives[k][1])
        );
    }

    var checkDependence = function(symbol, arg, tree) {
        return arg.dependsOn(symbol) ? tree : zero;
    };

    for (var nodeType in derivatives) {
        var derivative = derivatives[nodeType];
        Nodes[nodeType].prototype.takeDerivative = derivative;
    }
});

// substitute does non-recursive replacement of identifiers specified in a frame.
// It differs from getConcreteTree by being non-recursive. Currently, this feature
// is used only in the derivative system to substitute arguments into derivative
// definitions.
define('math/features/substitute', ['require', 'parsenodes'], function(require) {
    var Nodes = require('parsenodes');

    var substitutions = {
        Identifier: function(frame) { return frame[this._symbol] ? frame[this._symbol] : this; },
        FreeVariable: function(frame) { return frame[this._symbol] ? frame[this._symbol] : this; },
        Constant: function(frame) { return this; },
        Expression: function(frame) {
            return this.copyWithArgs(this.args.map(function(arg) {
                return arg.substitute(frame);
            }));
        },
        List: function(frame) {
            return Nodes.List(this.args.map(function(arg) {
                return arg.substitute(frame);
            }));
        },
        SolvedEquation: function(symbol) {
            return this.constructor(this._symbol, this._expression.substitute(symbol));
        },
        OptimizedRegression: function(symbol) {
            return this.constructor(
                this.model.substitute(symbol),
                this.parameters,
                this.residualVariables,
                this.residuals,
                this.statistics
            );
        }
    };

    for (var key in substitutions) {
        Nodes[key].prototype.substitute = substitutions[key];
    }
});

// Only defines a function on basecomparator, but making this a feature because
// it needs to use baseparser.
define('math/features/solve', ['require', 'math/baseparser', 'math/parsenode/constant', 'math/parsenode/equation', 'math/parsenode/solvedequation', 'math/parsenode/basecomparator', 'math/parsenode/list', 'math/errormsg', 'math/builtinframe', 'math/policy'], function(require) {
    var Parser = require('math/baseparser');
    var Constant = require('math/parsenode/constant');
    var Equation = require('math/parsenode/equation');
    var SolvedEquation = require('math/parsenode/solvedequation');
    var BaseComparator = require('math/parsenode/basecomparator');
    var List = require('math/parsenode/list');
    var ErrorMsg = require('math/errormsg');
    var BuiltInFrame = require('math/builtinframe');
    var Policy = require('math/policy');

    var zero = Constant(0);

    // Can't easily write this as a single calculator expression because the length
    // of the result depends on values.
    var linearSolutionTree = Parser.parse('[-c/b]');
    var degenerateSolutionTree = Parser.parse('[-b/(2*a)]');
    var generalSolutionTree = Parser.parse('[\\{a>0:q,p\\},\\{a>0:p,q\\}]');

    function _solveSingleVariableEquation(localFrame) {
        _populateFrame(localFrame);
        if (localFrame.a.constantValue === 0) {
            if (localFrame.b.constantValue === 0) {
                return Constant(localFrame.c.constantValue === 0);
            }
            return linearSolutionTree.getConcreteTree(localFrame);
        }
        // f - g is the discriminant. If it's negative, there are no solutions
        // If it's 0, there is only one solution (with multiplicity 2)
        if (localFrame.f.constantValue - localFrame.g.constantValue < 0) {
            return List([Constant(false)]);
        }
        if (localFrame.f.constantValue - localFrame.g.constantValue === 0) {
            return degenerateSolutionTree.getConcreteTree(localFrame);
        }
        return generalSolutionTree.getConcreteTree(localFrame);
    }


    function _populateABC(coeffTrees) {
        var localFrame = Object.create(BuiltInFrame);
        // Set up a frame with variables relevant to the solution of a quadratic inequality
        // or equation: ax^2+bx+c=0
        localFrame.a = coeffTrees[2] ? coeffTrees[2].tryGetConcreteTree(BuiltInFrame) : zero;
        localFrame.b = coeffTrees[1] ? coeffTrees[1].tryGetConcreteTree(BuiltInFrame) : zero;
        localFrame.c = coeffTrees[0] ? coeffTrees[0].tryGetConcreteTree(BuiltInFrame) : zero;
        return localFrame;
    }

    var fTree = Parser.parse('b*b');
    var gTree = Parser.parse('4*a*c');
    // p and q are the two solutions to the quadratic equation.
    var pTree = Parser.parse('(-b+\\sqrt{b*b-4*a*c})/(2*a)');
    var qTree = Parser.parse('(-b-\\sqrt{b*b-4*a*c})/(2*a)');
    var eqnSolutionTree = Parser.parse('[' +
        '\\{a=0:\\{b<0:-c/b\\},q\\},' +
        '\\{a=0:\\{b>=0:-c/b\\},p\\}' +
        ']');
    var inequalitySolutionTree = Parser.parse('[' +
        '\\{a=0:\\{b<0:-c/b\\},a>0:q\\},' +
        '\\{a=0:\\{b=0:\\{c>0:-m\\}\\},a>0:\\{f<g:-m\\},p\\},' +
        '\\{a=0:\\{b=0:\\{c>0:m\\}\\},a>0:\\{f<g:m\\},q\\},' +
        '\\{a=0:\\{b>0:-c/b\\},a>0:p\\}' +
        ']');

    function _effectiveOrder(localFrame) {
        if (localFrame.a.constantValue === 0) {
            if (localFrame.b.constantValue === 0) return 0;
            return 1;
        }
        return 2;
    }

    function _chooseVariable(concreteDifference, dependencies, isInequality) {
        //ask for trees to represent the coefficients

        var variableOfInterest;
        var effectiveOrders = [];
        var localFrames = [];
        var localFrame;
        for (var i = 0; i < dependencies.length; i++) {
            var dependency = dependencies[i];
            var order = concreteDifference.polynomialOrder(dependency);
            var orderTooHigh = order > 2;
            var invalidVariable = dependencies.length > 1 && !Policy.validSolvedVariable(dependency);
            // piecewiseIneqality check is a little bit subtle. Relies on the fact that extractConditions
            // returns the original expression iff it finds no piecewise expressions that depend on
            // dependency.
            var piecewiseInequality = isInequality && concreteDifference.extractConditions(dependency, zero) !== zero;

            if (orderTooHigh || invalidVariable || piecewiseInequality) {
                localFrames[i] = {};
                effectiveOrders[i] = Infinity;
                continue;
            }

            localFrames[i] = [];
            effectiveOrders[i] = 0;
            for (var j = 0; j < concreteDifference.args.length; j++) {
                localFrame = _populateABC(concreteDifference.args[j].getPolynomialCoefficients(dependency));
                localFrames[i][j] = localFrame;
                effectiveOrders[i] = Math.max(effectiveOrders[i], _effectiveOrder(localFrame));
            }
        }

        var effectiveOrder;
        if (dependencies.length === 1) {
            localFrame = localFrames[0];
            variableOfInterest = dependencies[0];
            effectiveOrder = effectiveOrders[0];
        } else { // dependencies.length === 2
            var index;
            if (effectiveOrders[0] === 0) {
                index = 1;
            } else if (effectiveOrders[1] === 0) {
                index = 0;
            } else {
                index = effectiveOrders[0] < effectiveOrders[1] ? 0 : 1;
            }
            localFrame = localFrames[index];
            variableOfInterest = dependencies[index];
            effectiveOrder = effectiveOrders[index];
        }

        return {
            localFrame: localFrame,
            variableOfInterest: variableOfInterest,
            effectiveOrder: effectiveOrder
        };
    }

    var solvers = {
        singleVariable: _solveSingleVariableEquation,
        inequality: function(localFrame) {
            _populateFrame(localFrame);
            return inequalitySolutionTree.getConcreteTree(localFrame);
        },
        generalEquation: function(localFrame) {
            _populateFrame(localFrame);
            return eqnSolutionTree.getConcreteTree(localFrame);
        }
    };

    function _chooseSolver(dependencies, isInequality) {
        if (isInequality) return solvers.inequality;
        if (dependencies.length === 1) return solvers.singleVariable;
        return solvers.generalEquation;
    }

    function _populateFrame(localFrame) {
        // f - g is the discriminant
        localFrame.f = fTree.getConcreteTree(localFrame);
        localFrame.g = gTree.getConcreteTree(localFrame);
        // p and q are the two solutions to the quadratic equation.
        localFrame.p = pTree.getConcreteTree(localFrame);
        localFrame.q = qTree.getConcreteTree(localFrame);
        // m is a standin for Infinity. This is kind of a hack to help us shade from a
        // solution to "infinity," working around the fact that the rest of the pipeline
        // doesn't always handle infinity well.
        localFrame.m = Constant(1e305);
    }

    Equation.prototype.solve = function(frame) {
        return this.asComparator().solve(frame);
    };

    BaseComparator.prototype.solve = function(frame) {
        /* jshint maxcomplexity:18 */
        var concrete = this.tryGetConcreteTree(frame);
        if (concrete.isError) return concrete;
        if (concrete.isConstant) return concrete;

        var isInequality = this.getOperator() !== '=';

        //get concrete tree for the difference
        var concreteDifference = this._difference.tryGetConcreteTree(frame);

        var dependencies = concreteDifference.getDependencies();

        if (dependencies.length === 0) {
            if (concreteDifference.isList) return List(concreteDifference.args.map(function(arg) {
                return Constant(arg.constantValue === 0);
            }));
            return Constant(concreteDifference.constantValue === 0);
        }

        if (dependencies.length === 1 && concreteDifference.isList && !isInequality) {
            return ErrorMsg.singleVariableListSolve();
        }

        // After this point, it's easier if we can just assume everything is a list.
        var concreteDifferences = concreteDifference.isList ? concreteDifference : List([concreteDifference]);

        if (dependencies.length > 2) {
            return ErrorMsg.tooManyVariables(this.getSliderVariables(concrete)).setDependencies(dependencies);
        }

        if (isInequality && !Policy.validInequalityVariables(dependencies)) {
            return ErrorMsg.invalidInequalityVariables().setDependencies(dependencies);
        }

        if (dependencies.length === 2 && !Policy.validImplicitVariables(dependencies)) {
            return ErrorMsg.invalidImplicitVariables().setDependencies(dependencies);
        }

        var result = _chooseVariable(concreteDifferences, dependencies, isInequality);
        var localFrame = result.localFrame;
        var effectiveOrder = result.effectiveOrder;
        var variableOfInterest = result.variableOfInterest;

        if (Policy.complicatedPolarImplicit(variableOfInterest, effectiveOrder)) {
            if (isInequality || dependencies.length > 1) {
                return ErrorMsg.complicatedPolarImplicit().setDependencies(dependencies);
            }
        }

        if (effectiveOrder > 2) {
            if (dependencies.length === 1) return ErrorMsg.unsolvable().setDependencies(dependencies);
            if (isInequality) return ErrorMsg.complicatedImplicitInequality().setDependencies(dependencies);
            return concreteDifference;
        }

        var solveScalar = _chooseSolver(dependencies, isInequality);

        var allBranches = [];
        for (var i = 0; i < localFrame.length; i++) {
            var branches = solveScalar(localFrame[i]);
            if (branches.isError) return branches;
            if (branches.isConstant) {
                allBranches.push(branches);
                continue;
            }
            for (var j = 0; j < branches.args.length; j++) {
                var branch = branches.args[j];
                var restricted = concreteDifferences.args[i]
                    .extractConditions(variableOfInterest, branch)
                    .getConcreteTree(frame);
                allBranches.push(restricted);
            }
        }

        return SolvedEquation(variableOfInterest, List(allBranches));
    };
});
// Basically temporary shim to support the API of the current formula object and allow integration into the rest of the
// system. API here is just a direct copy, funny naming and all.

define('math/evaluationstate', ['require', 'graphing/graphmode', 'parsenodes', 'graphing/label'], function(require) {
    var GRAPHMODE = require('graphing/graphmode');
    var nodes = require('parsenodes');
    var Label = require('graphing/label');

    function _tableCellValue(concrete) {
        if (concrete.isError) return concrete.getError();
        if (concrete.constantValue === undefined) return '';
        return +concrete.constantValue;
    }

    function _tableState(raw, concrete) {
        var columnData = [];
        for (var i = 0; i < raw.columns.length; i++) {
            var column = concrete.columns[i];
            var state = {
                dependent: !column.isIndependent,
                discrete: column.isIndependent
            };
            if (column.isError) {
                state.error = column.getError();
                state.values = [];
            } else {
                state.values = column.values.args.map(_tableCellValue);
            }
            columnData.push(state);
        }
        return {
            can_auto_regress: raw.canAutoRegress(concrete),
            column_data: columnData
        };
    }

    var _defaultEvaluationState = function() {
        return {
            operator: '=',
            variables: []
        };
    };

    var EvaluationState = function(raw, concrete) {
        /* jshint maxcomplexity:20 */
        //Compute serializable evaluation state from raw and concrete parseTrees

        // Tables follow a completely different format for their
        // evaluation state.
        if (raw.isTable) return _tableState(raw, concrete);

        //Reasonable defaults
        var state = _defaultEvaluationState();

        //What errors should it return? (if any)
        if (concrete.isError) {
            state.error = concrete.getError();
            state.variables = raw.getSliderVariables(concrete);
            return state;
        }

        if (concrete.isMovablePoint) {
            state.move_ids = concrete._moveIds;
            state.move_matrix = concrete._moveMatrix;
        }

        if (raw.isInequality()) state.is_inequality = true;
        state.operator = raw.getOperator();

        //Does it assign anything
        if (concrete instanceof nodes.SolvedEquation) {
            // Set assignment for things like x=3, but not for equations
            // that are satisfied everywhere or nowhere
            if (
                concrete._expression.constantValue !== true &&
                concrete._expression.constantValue !== false
            ) {
                state.assignment = concrete._symbol;
            }
        } else if (raw instanceof nodes.Assignment) {
            // Cover assignments that don't need to be solved, like b=1+2
            state.assignment = raw._symbol;
        }

        //How should it be graphed? (if at all)
        var graphMode = raw.getGraphMode(concrete);
        if (graphMode !== GRAPHMODE.NONE) {
            state.is_graphable = true;

            if (graphMode === GRAPHMODE.XYPOINT) state.is_point_list = true;
            if (graphMode === GRAPHMODE.XYPOINT_MOVABLE) state.is_point_list = true;
            if (graphMode === GRAPHMODE.PARAMETRIC) state.is_parametric = true;
            if (concrete.isShadeBetween()) state.is_shade_between = true;

            var table_info = raw.tableInfo(concrete);
            if (table_info) {
                state.is_tableable = true;
                state.table_info = table_info;
            }
        }

        //What sliders should it prompt for? (none if graphable)
        state.variables = state.is_graphable ? [] : raw.getSliderVariables(concrete);

        var sliderInfo = raw.getSliderInfo();
        if (sliderInfo) {
            state.is_slidable = true;
            state.is_animatable = !state.is_graphable; //Don't animate graphed sliders
            state.constant_value = sliderInfo.value;
        } else if (concrete.isConstant) {
            state.constant_value = concrete.constantValue;
        }

        //How should it be evaluated? (if at all)
        var values = concrete.getEvaluationInfo();
        if (values && !raw.isConstant && !raw.isFunction && !state.is_graphable && !state.is_slidable) {
            state.is_evaluable = true;
            state.zero_values = values;
        }

        if (concrete instanceof nodes.OptimizedRegression) {
            var parameterValues = {};
            for (var p in concrete.parameters) {
                if (!concrete.parameters.hasOwnProperty(p)) continue;
                parameterValues[Label.identifierToLatex(p)] = +concrete.parameters[p].constantValue;
            }

            state.is_regression = true;
            state.regression = {
                parameters: parameterValues,
                residualVariable: Label.identifierToLatex(concrete.residualVariable),
                residualSuggestionId: concrete.residualSuggestionId,
                statistics: concrete.statistics
            };
        }

        return state;
    };

    EvaluationState.default = _defaultEvaluationState;

    return EvaluationState;
});

define('math/statementanalysis', ['require', 'math/evaluationstate', 'pjs', 'graphing/graphmode'], function(require) {
    var getEvaluationState = require('math/evaluationstate');
    var P = require('pjs');
    var GRAPHMODE = require('graphing/graphmode');

    return P(function(analysis) {
        analysis.init = function(raw, concrete) {
            this.rawTree = raw;
            this.concreteTree = concrete;
            this.evaluationState = getEvaluationState(raw, concrete);
        };

        analysis.exportTo = function(frame) {
            this.rawTree.exportTo(this.concreteTree, frame);
        };

        analysis.graph = function(viewState) {
            return this.rawTree.graph(this.concreteTree, viewState);
        };

        analysis.getGraphMode = function() {
            return this.rawTree.getGraphMode(this.concreteTree);
        };

        analysis.getGraphInfo = function() {
            return this.rawTree.getGraphInfo(this.concreteTree);
        };

        analysis.shouldIntersect = function() {
            if (!this.evaluationState.is_graphable) return false;
            if (!this.rawTree.userData.shouldGraph) return false;
            var graphMode = this.getGraphMode();
            return graphMode === GRAPHMODE.X || graphMode === GRAPHMODE.Y;
        };
    });
});

define('math/features/analyze', ['require', 'parsenodes', 'math/statementanalysis', 'math/builtinframe', 'math/policy', 'math/errormsg', 'math/comparators'], function(require) {
    var nodes = require('parsenodes');
    var StatementAnalysis = require('math/statementanalysis');
    var BuiltInFrame = require('math/builtinframe');
    var Policy = require('math/policy');
    var Constant = nodes.Constant;
    var ErrorMsg = require('math/errormsg');
    var Comparators = require('math/comparators');
    var FreeVariable = nodes.FreeVariable;

    var zero = Constant(0);

    nodes.Base.prototype.analyze = function(frame) {
        return StatementAnalysis(this, this.tryGetConcreteTree(frame));
    };

    nodes.Expression.prototype.analyze = function(frame) {
        var concrete = this.tryGetConcreteTree(frame);
        if (concrete.isError) return StatementAnalysis(this, concrete);
        var dependencies = concrete.getDependencies();
        if (dependencies.length > 1) {
            if (Policy.validImplicitVariables(dependencies)) {
                return StatementAnalysis(this, ErrorMsg.equationRequired().setDependencies(dependencies));
            } else {
                return StatementAnalysis(
                    this,
                    ErrorMsg.tooManyVariables(this.getSliderVariables(concrete)).setDependencies(dependencies)
                );
            }
        } else if (dependencies.length === 1 && !Policy.validExpressionVariable(dependencies[0])) {
            return StatementAnalysis(
                this,
                ErrorMsg.equationRequired(dependencies[0]).setDependencies(dependencies)
            );
        } else {
            return StatementAnalysis(this, concrete);
        }
    };

    nodes.Identifier.prototype.analyze = function(frame) {
        return StatementAnalysis(this, this.tryGetConcreteTree(frame));
    };

    nodes.FunctionDefinition.prototype.analyze = function(frame) {
        if (BuiltInFrame[this._symbol]) {
            return StatementAnalysis(this, ErrorMsg.cannotRedefine(this._symbol));
        }

        //Make sure free variables are all arguments
        var concrete = this.tryGetConcreteTree(frame);
        if (concrete.isError) return StatementAnalysis(this, concrete);
        var argSymbols = this._argSymbols;

        var dependencies = concrete.getDependencies();

        var freeVariables = dependencies.filter(function(symbol) {
            return argSymbols.indexOf(symbol) === -1;
        });

        if (Policy.unplottablePolarFunction(this._symbol, dependencies)) {
            return StatementAnalysis(this, ErrorMsg.unplottablePolarFunction());
        }

        if (freeVariables.some(Policy.assignmentForbidden)) {
            return StatementAnalysis(
                this,
                ErrorMsg.addArgumentsToDefinition(freeVariables, this._symbol, argSymbols).setDependencies(dependencies)
            );
        } else if (freeVariables.length) {
            return StatementAnalysis(
                this,
                ErrorMsg.tooManyVariables(this.getSliderVariables(concrete)).setDependencies(dependencies)
            );
        } else {
            return StatementAnalysis(this, concrete);
        }
    };

    nodes.Assignment.prototype.analyze = function(frame) {
        var lhs = this._symbol;
        if (!Policy.validLHS(lhs)) return StatementAnalysis(this, ErrorMsg.invalidLHS(lhs));
        if (BuiltInFrame[lhs]) return StatementAnalysis(this, ErrorMsg.cannotRedefine(lhs));

        var concrete = this.tryGetConcreteTree(frame);
        if (concrete.isError) return StatementAnalysis(this, concrete);
        var dependencies = concrete.getDependencies();

        // If the assigned symbol appears on the RHS, analyze as an equation
        if (dependencies.indexOf(this._symbol) !== -1) {
            var eqnAnalysis = this.asEquation().analyze(frame);
            return StatementAnalysis(this, eqnAnalysis.concreteTree);
        }

        if (dependencies.length > 1) {
            return StatementAnalysis(
                this,
                ErrorMsg.tooManyVariables(this.getSliderVariables(concrete)).allowExport().setDependencies(dependencies)
            );
        }

        return StatementAnalysis(this, concrete);
    };

    nodes.Regression.prototype.analyze = function(frame, exportFrame, lastExportFrame, priorAnalysis) {
        return StatementAnalysis(this, this.optimize(frame, exportFrame, lastExportFrame, priorAnalysis));
    };

    nodes.Equation.prototype.analyze =
        nodes.BaseComparator.prototype.analyze = function(frame) {
            return StatementAnalysis(this, this.solve(frame));
        };

    nodes.DoubleInequality.prototype.analyze = function(frame) {
        var concrete = this.tryGetConcreteTree(frame);
        if (concrete.isError) return StatementAnalysis(this, concrete);

        var dependencies = concrete.getDependencies();

        if (Comparators.table[this._operators[0]].direction !== Comparators.table[this._operators[1]].direction) {
            return StatementAnalysis(this, ErrorMsg.mismatchedDoubleInequality());
        }

        if (!Policy.validDoubleInequalitySymbol(concrete._symbol)) {
            return StatementAnalysis(
                this,
                ErrorMsg.invalidDoubleInequalityVariables().setDependencies(dependencies)
            );
        }

        if (!Policy.validDoubleInequalityVariables(dependencies)) {
            return StatementAnalysis(
                this,
                ErrorMsg.invalidDoubleInequalityVariables().setDependencies(dependencies)
            );
        }

        if (dependencies.length > 2) {
            return StatementAnalysis(
                this,
                ErrorMsg.tooManyVariables(this.getSliderVariables(concrete)).setDependencies(dependencies)
            );
        }

        if (
            concrete._expressions[0].getDependencies().indexOf(concrete._symbol) !== -1 ||
            concrete._expressions[1].getDependencies().indexOf(concrete._symbol) !== -1
        ) {
            return StatementAnalysis(this, ErrorMsg.complicatedDoubleInequality().setDependencies(dependencies));
        }

        return StatementAnalysis(this, concrete);
    };

    // Complicated double inequalities like x < y^2 < z compile to And comparators.
    nodes.And.prototype.analyze = function(frame) {
        var concrete = this.tryGetConcreteTree(frame);
        if (concrete.isError) return StatementAnalysis(this, concrete);

        var dependencies = concrete.getDependencies();
        if (dependencies.length) {
            if (Policy.validDoubleInequalityVariables(dependencies)) {
                return StatementAnalysis(
                    this,
                    ErrorMsg.complicatedDoubleInequality().setDependencies(dependencies)
                );
            }
            return StatementAnalysis(
                this,
                ErrorMsg.tooManyVariables(this.getSliderVariables(concrete)).setDependencies(dependencies)
            );
        }

        return StatementAnalysis(this, concrete);
    };

    nodes.OrderedPair.prototype.analyze = function(frame, priorAnalysis) {
        //movable points rely on prior analysis to find moveIds
        var concrete = this.tryGetConcreteTree(frame);
        if (concrete.isError) return StatementAnalysis(this, concrete);
        var analysis = StatementAnalysis(this, concrete);

        //Check for free variables that aren't t
        var dependencies = concrete.getDependencies();

        if (dependencies.length) {
            if (Policy.validParametricVariables(dependencies)) return analysis;
            return StatementAnalysis(
                this,
                ErrorMsg.tooManyVariables(this.getSliderVariables(concrete)).setDependencies(dependencies)
            );
        }

        //Check preconditions for being a movable point
        if (!analysis.evaluationState.is_graphable) return analysis;
        if (analysis.evaluationState.variables.length !== 0) return analysis;
        if (this.args[0].isList || this.args[1].isList) return analysis; //We only move single points

        var movable;
        var coupled;
        var moveIds = [undefined, undefined];
        var moveMatrix = [
            [1, 0, 0],
            [0, 1, 0]
        ];

        var coordTrees = this.args; //Each coordinate of the point
        coordTrees.forEach(function(tree, index) {
            /* jshint maxcomplexity:14 */
            if (coupled) return;
            var symbols = tree.getDependencies();
            var otherTree = coordTrees[index === 0 ? 1 : 0];
            var definitionId;

            // Symbols are stored in order of lexical first appearance in _referencedSymbols.
            // Traversing the array in reverse order means we will move the slider variable that
            // has the last first occurance.
            for (var i = symbols.length - 1; i >= 0; i--) {
                definitionId = undefined;
                var symbol = symbols[i];
                //Make sure the variable is defined by a slider
                //TODO - find statement ID from symbol var definitionId = frame.getDefinitionId(symbol);
                for (var id in priorAnalysis) {
                    //Find id of slider defining symbol if there is one
                    if (priorAnalysis[id].evaluationState.assignment === symbol &&
                        priorAnalysis[id].evaluationState.is_slidable) {
                        definitionId = id;
                        break;
                    }
                }
                //Make sure we found a slider
                if (definitionId === undefined) continue;

                //Make sure we are linear in the variable

                //Create a frame that shadows the definition of our symbol of interest
                //So that we can ask for the polynomialOrder, etc.
                var localFrame = Object.create(frame);
                localFrame[symbol] = FreeVariable(symbol);
                var concreteTree = tree.tryGetConcreteTree(localFrame);
                if (concreteTree.isError) continue;
                var order = concreteTree.polynomialOrder(symbol);
                if (order !== 1) continue;

                //Find the parameters
                var coeffs = concreteTree.getPolynomialCoefficients(symbol);
                var b = coeffs[1] ? coeffs[1].getConcreteTree(localFrame) : zero;
                var c = coeffs[0] ? coeffs[0].getConcreteTree(localFrame) : zero;
                if (!c.isConstant || !b.isConstant) continue;
                if (b.constantValue === 0) continue;

                // Don't handle coupled variables (yet...)
                //var otherOrder = otherTree.polynomialOrder(frame, symbol);
                var otherConcreteTree = otherTree.tryGetConcreteTree(localFrame);
                if (otherConcreteTree.isError) continue;
                var otherOrder = otherConcreteTree.polynomialOrder(symbol);
                if (otherOrder > 0) {
                    //if other moveID exists, continue
                    if (moveIds[0]) continue;
                    //set coupled = true to prevent future links
                    if (otherOrder !== 0) coupled = true;
                }

                moveMatrix[index][index] = 1 / b.constantValue; //Linear term
                moveMatrix[index][2] = -c.constantValue / b.constantValue; //Constant term

                movable = true;
                moveIds[index] = definitionId;

                break;
            }

        });

        if (movable) {
            // Avoid double updating in case of [ 'a = 1', '(a, a)' ]
            // TODO - may be able to avoid this check with coupling check above
            if (moveIds[1] === moveIds[0]) moveIds[1] = undefined;
            return StatementAnalysis(this, nodes.MovablePoint(concrete.args, moveIds, moveMatrix));
        } else {
            return analysis;
        }
    };

    function _removeLocals(symbols, localFrame) {
        return symbols.filter(function(symbol) { return !localFrame[symbol]; });
    }

    nodes.Table.prototype.analyze = function(frame) {
        var localFrame = Object.create(frame);

        // Note, currently process column definitions left to right.
        // Could switch to running dependency ordering first.
        var concreteColumns = [];
        var firstColumnSymbol;
        for (var i = 0; i < this.columns.length; i++) {
            var columnAnalysis = this.columns[i].analyze(localFrame, frame);
            if (i === 0) {
                // First column must be an independent variable. Check with Policy
                // that that variable is valid.
                if (!columnAnalysis.concreteTree.isIndependent) {
                    columnAnalysis = StatementAnalysis(this.columns[i], ErrorMsg.invalidDependentFirstTableColumn());
                } else if (!Policy.validFirstColumnVariable(columnAnalysis.concreteTree.header._symbol)) {
                    columnAnalysis = StatementAnalysis(this.columns[i], ErrorMsg.invalidFirstTableColumn());
                } else {
                    firstColumnSymbol = columnAnalysis.concreteTree.header._symbol;
                }
            }
            if (columnAnalysis.concreteTree.isIndependent) {
                localFrame[columnAnalysis.concreteTree.header._symbol] = columnAnalysis.concreteTree.values;
            } else if (!columnAnalysis.concreteTree.isError) {
                // Dependent columns must have no dependencies, or depend only on the
                // first column variable
                var dependencies = columnAnalysis.concreteTree.header.getDependencies();
                var freeDependencies = _removeLocals(dependencies, localFrame);
                if (freeDependencies.length) {
                    columnAnalysis = StatementAnalysis(
                        this.columns[i],
                        ErrorMsg.tooManyVariables(freeDependencies).setDependencies(freeDependencies)
                    );
                }
            }
            concreteColumns.push(columnAnalysis.concreteTree);
        }
        var concreteTable = nodes.Table(concreteColumns);
        var analysis = StatementAnalysis(this, concreteTable);
        analysis.evaluationState.is_graphable = true; // TODO wrong place for this
        return analysis;
    };

    nodes.TableColumn.prototype.analyze = function(frame, parentFrame) {
        var headerError = this.header.tableError();
        if (headerError) return StatementAnalysis(this, ErrorMsg.invalidTableHeader(headerError));

        var concrete = this.tryGetConcreteTree(frame, parentFrame);
        if (concrete.isError) return StatementAnalysis(this, concrete);
        // TODO following error checking lines should not be necessary, because an error in
        // the header should throw
        if (concrete.header.isError) return StatementAnalysis(this, concrete.header);
        if (concrete.values.isError) return StatementAnalysis(this, concrete.values);
        for (var i = 0; i < concrete.values.args.length; i++) {
            if (concrete.values.args[i].isError) continue;
            var entryError = this.values.args[i] && this.values.args[i].tableError();
            if (entryError) {
                concrete.values.args[i] = ErrorMsg.invalidTableEntry(entryError);
                continue;
            }
            var dependencies = concrete.values.args[i].getDependencies();
            if (dependencies.length) {
                concrete.values.args[i] = ErrorMsg.tooManyVariables(dependencies).setDependencies(dependencies);
            }
        }

        return StatementAnalysis(this, concrete);
    };
});

define('math/features/getgraphmode', ['require', 'parsenodes', 'math/policy', 'graphing/graphmode'], function(require) {
    var nodes = require('parsenodes');
    var Policy = require('math/policy');
    var GRAPHMODE = require('graphing/graphmode');

    // Default to graphing nothing.
    nodes.Base.prototype.getGraphMode = function(concrete) {
        return GRAPHMODE.NONE;
    };

    nodes.Identifier.prototype.getGraphMode = function(concrete) {
        if (Policy.graphableAsBareIdentifier(this._symbol)) return GRAPHMODE.Y;
        return GRAPHMODE.NONE;
    };

    nodes.Expression.prototype.getGraphMode = function(concrete) {
        var dependencies = concrete.getDependencies();
        if (dependencies.length !== 1) return GRAPHMODE.NONE;
        return GRAPHMODE.Y;
    };

    // Helper for solved assignments and equations
    function _solvedEquationGraphInfo(concrete) {
        var dependencies = concrete._expression.getDependencies();
        if (dependencies.length !== 1) return GRAPHMODE.NONE;
        var independent = concrete._symbol;
        var dependent = dependencies[0];
        return Policy.graphMode(independent, dependent);
    }

    nodes.BaseComparator.prototype.getGraphMode = function(concrete) {
        // concrete is either
        // 1. a constant Boolean
        // 2. a SolvedEquation
        // 3. an Expression representing a multivariate implicit inequality
        var dependencies = concrete.getDependencies();
        if (concrete.isConstant) return GRAPHMODE.NONE;
        if (concrete instanceof nodes.SolvedEquation) {
            if (dependencies.length === 0) {
                if (Policy.graphableAsConstant(concrete._symbol)) return Policy.constantGraphMode(concrete._symbol);
                return GRAPHMODE.NONE;
            }
            return _solvedEquationGraphInfo(concrete);
        }
        return GRAPHMODE.NONE;
    };

    nodes.DoubleInequality.prototype.getGraphMode = function(concrete) {
        return Policy.constantGraphMode(concrete._symbol);
    };

    nodes.Equation.prototype.getGraphMode = function(concrete) {
        // concrete is either
        // 1. a constant Boolean
        // 2. a SolvedEquation
        // 3. an Expression representing a multivariate implicit function
        if (concrete.isConstant) return GRAPHMODE.NONE;
        if (concrete instanceof nodes.SolvedEquation) return _solvedEquationGraphInfo(concrete);

        if (concrete.getDependencies().length !== 2) return GRAPHMODE.NONE;
        return GRAPHMODE.IMPLICIT;
    };

    nodes.Assignment.prototype.getGraphMode = function(concrete) {
        // concrete is either a SolvedEquation or an Expression.
        if (concrete instanceof nodes.SolvedEquation) return _solvedEquationGraphInfo(concrete);

        var dependencies = concrete.getDependencies();

        switch (dependencies.length) {
            case 0:
                if (!Policy.graphableAsConstant(this._symbol)) return GRAPHMODE.NONE;
                return Policy.constantGraphMode(this._symbol);
            case 1:
                if (concrete.isList && !Policy.graphableListVariables(this._symbol, dependencies[0])) {
                    return GRAPHMODE.NONE;
                }
                return Policy.graphMode(this._symbol, dependencies[0]);
            case 2:
                return GRAPHMODE.IMPLICIT;
            default:
                return GRAPHMODE.NONE;
        }
    };

    nodes.FunctionDefinition.prototype.getGraphMode = function(concrete) {
        if (this._argSymbols.length !== 1) return GRAPHMODE.NONE;

        var graphMode = Policy.graphMode(this._symbol, this._argSymbols[0]);
        var dependencies = concrete.getDependencies();
        switch (dependencies.length) {
            case 0:
                return graphMode;
            case 1:
                if (dependencies[0] !== this._argSymbols[0]) return GRAPHMODE.NONE;
                return graphMode;
            default:
                return GRAPHMODE.NONE;
        }
    };

    nodes.OrderedPair.prototype.getGraphMode = function(concrete) {
        if (concrete.isMovablePoint) return GRAPHMODE.XYPOINT_MOVABLE;
        var dependencies = concrete.getDependencies();
        if (dependencies.length === 0) return GRAPHMODE.XYPOINT;
        return Policy.validParametricVariables(dependencies) ? GRAPHMODE.PARAMETRIC : GRAPHMODE.NONE;
    };

    nodes.List.prototype.getGraphMode = function(concrete) {
        /*If we have one free variable, we're graphable*/
        if (concrete.getDependencies().length !== 1) return GRAPHMODE.NONE;
        return GRAPHMODE.Y;
    };

    nodes.Regression.prototype.getGraphMode = function(concrete) {
        if (!(this._lhs instanceof nodes.Identifier) && !(this._lhs instanceof nodes.List)) return GRAPHMODE.NONE;
        if (!concrete.isModelValid) return GRAPHMODE.NONE;
        if (concrete.model.getDependencies().length !== 1) return GRAPHMODE.NONE;
        return GRAPHMODE.Y;
    };

});
define('math/features/getgraphinfo', ['require', 'parsenodes', 'math/builtinframe'], function(require) {
    var nodes = require('parsenodes');
    var BuiltInFrame = require('math/builtinframe');

    // Needs to be a feature because it relies on BuiltInFrame.

    nodes.Base.prototype.getGraphInfo = function(concrete) {
        var dependencies = concrete.getDependencies();

        var isLinear, domainBound;
        var linearCoefficients = [NaN, NaN];

        switch (dependencies.length) {
            case 0:
                isLinear = true;
                linearCoefficients = [+concrete.constantValue, 0];
                domainBound = [-Infinity, Infinity];
                break;
            case 1:
                domainBound = concrete.boundDomain(dependencies[0]);
                if (!domainBound) {
                    domainBound = [-Infinity, Infinity];
                    isLinear = false;
                } else {
                    isLinear = concrete.isLinear(dependencies[0]);
                }
                if (isLinear) {
                    var cs = concrete.getPolynomialCoefficients(dependencies[0]);
                    linearCoefficients[0] = cs[0] ? +cs[0].getConcreteTree(BuiltInFrame).constantValue : 0;
                    linearCoefficients[1] = cs[1] ? +cs[1].getConcreteTree(BuiltInFrame).constantValue : 0;
                }
                break;
            case 2:
                isLinear = false;
                domainBound = [-Infinity, Infinity];
                break;
        }

        return {
            graphMode: this.getGraphMode(concrete),
            color: this.userData.color,
            style: this.userData.style,
            operator: this.getOperator(),
            isLinear: isLinear,
            linearCoefficients: linearCoefficients,
            domainBound: domainBound
        };
    };
});

// node.tableInfo returns either
// 1. false if the node cannot be converted to a table
// 2 {
//     independent_variable: 'symbol',
//     dependent_column: 'latex',
//     values: [[x1, y1], [x2, y2], ...], // (optional),
//     by_reference: t/f // Whether the table should replace or reference the statement
//   }
define('math/features/tableinfo', ['require', 'parsenodes', 'math/policy'], function(require) {
    var nodes = require('parsenodes');
    var Policy = require('math/policy');

    var latexTrim = function(str) {
        return str.replace(/^( |\\space)+/, '').replace(/( |\\space)+$/, '');
    };

    // Default to graphing nothing.
    nodes.Base.prototype.tableInfo = function(concrete) {
        return false;
    };

    nodes.Identifier.prototype.tableInfo = function(concrete) {
        if (!Policy.graphableAsBareIdentifier(this._symbol)) return false;
        if (!Policy.validFirstColumnVariable(this._symbol)) return false;
        return {
            independent_variable: this._symbol,
            dependent_column: this._inputString,
            by_reference: false
        };
    };

    nodes.Expression.prototype.tableInfo = function(concrete) {
        var dependencies = concrete.getDependencies();

        if (dependencies.length !== 1) return false;
        var independent = dependencies[0];
        if (!Policy.validFirstColumnVariable(independent)) return false;

        return {
            independent_variable: independent,
            dependent_column: this._inputString,
            by_reference: false
        };
    };

    nodes.Assignment.prototype.tableInfo = function(concrete) {
        // concrete is either a SolvedEquation or an Expression.
        if (concrete instanceof nodes.SolvedEquation) return false;
        // Comes up in the case of generated expressions. We won't need to table those anyway.
        if (!this._inputString.length) return false;

        var dependencies = concrete.getDependencies();

        if (dependencies.length > 1) return false;
        var independent;
        if (dependencies.length === 0) {
            if (!Policy.tableableAsConstant(this._symbol)) return false;
            independent = Policy.implicitIndependent(this._symbol);
        } else {
            independent = dependencies[0];
        }

        if (!Policy.validFirstColumnVariable(independent)) return false;

        var dependent = Policy.assignmentForbidden(this._symbol) ?
            latexTrim(this._inputString.replace(/[^=]*=/, '')) :
            latexTrim(this._inputString.split('=')[0]);

        return {
            independent_variable: independent,
            dependent_column: dependent,
            by_reference: !Policy.assignmentForbidden(this._symbol)
        };
    };

    nodes.FunctionDefinition.prototype.tableInfo = function(concrete) {
        if (this._argSymbols.length !== 1) return false;
        // Comes up in the case of generated expressions. We won't need to table those anyway.
        if (!this._inputString.length) return false;

        var dependencies = concrete.getDependencies();

        if (dependencies.length > 1) return false;
        var independent = this._argSymbols[0];
        if (!Policy.validFirstColumnVariable(independent)) return false;

        var assignmentForbidden = Policy.assignmentForbidden(this._symbol);
        var dependent = assignmentForbidden ?
            latexTrim(this._inputString.replace(/[^=]*=/, '')) :
            latexTrim(this._inputString.split('=')[0]);

        return {
            independent_variable: independent,
            // Close to this._symbol, but we want to preserve, e.g., curly brackets in
            // a_{ro}.
            dependent_column: dependent,
            by_reference: !assignmentForbidden
        };
    };

    nodes.BaseComparator.prototype.tableInfo = function(concrete) {
        return false;
    };

    nodes.DoubleInequality.prototype.tableInfo = function(concrete) {
        return false;
    };

    nodes.Equation.prototype.tableInfo = function(concrete) {
        return false;
    };

    nodes.OrderedPair.prototype.tableInfo = function(concrete) {
        var dependencies = concrete.getDependencies();
        if (dependencies.length !== 0) return false;
        if (concrete.isMovablePoint) return false;
        return {
            independent_variable: 'x',
            dependent_column: 'y',
            by_reference: false,
            // TODO, would like to be able to pass full expressions to tables,
            // not just numbers
            values: nodes.List.mapArgs(concrete.args, function(pair) {
                return [+pair[0].constantValue, +pair[1].constantValue];
            })
        };
    };

    nodes.List.prototype.tableInfo = function(concrete) {
        return false;
    };
});
define('math/features/tableerror', ['require', 'parsenodes', 'lib/worker-i18n'], function(require) {
    var nodes = require('parsenodes');
    var i18n = require('lib/worker-i18n');

    nodes.Base.prototype.tableError = function() {
        if (this.isInequality()) return i18n.t("Inequalities are not allowed.");
        return false;
    };
    nodes.List.prototype.tableError = function() {
        return i18n.t("Lists are not allowed.");
    };
    nodes.OrderedPair.prototype.tableError = function() {
        return i18n.t("Points are not allowed.");
    };
    nodes.Equation.prototype.tableError =
        nodes.Assignment.prototype.tableError = function() {
            return i18n.t("Equations are not allowed.");
        };
    nodes.FunctionDefinition.prototype.tableError = function() {
        return i18n.t("Function definitions are not allowed.");
    };
});
define('math/features/islinear', ['require', 'parsenodes'], function(require) {
    var nodes = require('parsenodes');

    nodes.Base.prototype.isLinear = function(symbol) {
        return false;
    };

    nodes.Expression.prototype.isLinear = function(symbol) {
        return this.polynomialOrder(symbol) <= 1;
    };

    nodes.SolvedEquation.prototype.isLinear = function(symbol) {
        return this._expression.isLinear(symbol);
    };

    nodes.OptimizedRegression.prototype.isLinear = function(symbol) {
        return this.model.isLinear(symbol);
    };

});
define('graphing/columnmode', {
    POINTS: 'POINTS',
    LINES: 'LINES',
    POINTS_AND_LINES: 'POINTS_AND_LINES'
});

define('math/features/graph', ['require', 'parsenodes', 'math/plotter', 'graphing/graphmode', 'math/comparators', 'graphing/columnmode'], function(require) {
    var nodes = require('parsenodes');
    var Plotter = require('math/plotter');
    var GRAPHMODE = require('graphing/graphmode');
    var Comparators = require('math/comparators');
    var COLUMNMODE = require('graphing/columnmode');
    var List = nodes.List;

    function copyDefinedPOIs(points) {
        var xs = [];
        var ys = [];

        var len = points.length;
        for (var i = 0; i < len; i++) {
            xs.push(points[i][0]);
            ys.push(points[i][1]);
        }

        return {
            defined: { x: xs, y: ys }
        };
    }

    nodes.Base.prototype._graph = function(concrete, viewState, graphInfo) {
        if (graphInfo.graphMode === GRAPHMODE.NONE) return false;

        //Compile, pass to plotter, and return
        var fns = concrete.getCompiledFunctions();
        var derivatives;

        // TODO, taking derivatives can throw an error if the nodecount of the
        // tree gets to large. Can just plot without derivatives if we can't
        // compute them. Would be nice to clean this up.
        try {
            derivatives = concrete.getCompiledDerivatives();
        } catch (e) {
            // do nothing
        }

        var branches = [];
        for (var i = 0; i < fns.length; i++) {
            var localGraphInfo;
            if (concrete.isList) {
                localGraphInfo = this.getGraphInfo(concrete.args[i]);
                localGraphInfo.graphMode = graphInfo.graphMode;
            } else {
                localGraphInfo = graphInfo;
            }

            var branch = derivatives ?
                Plotter.computeGraphData(viewState, localGraphInfo, fns[i].fn, derivatives[i].fn) :
                Plotter.computeGraphData(viewState, localGraphInfo, fns[i].fn);
            branch.compiled = fns[i];
            branches.push(branch);
        }

        return branches;
    };

    nodes.Base.prototype.graph = function(concrete, viewState) {
        var graphInfo = this.getGraphInfo(concrete);
        return this._graph(concrete, viewState, graphInfo);
    };

    nodes.BaseComparator.prototype.graph = function(concrete, viewState) {
        var graphMode = this.getGraphInfo(concrete).graphMode;
        if (graphMode === GRAPHMODE.NONE) return false;
        if (!concrete instanceof nodes.SolvedEquation) return false;

        var operator = this.getOperator();
        //Compile, pass to plotter, and return
        var fns = concrete.getCompiledFunctions();

        var derivatives;
        try {
            derivatives = concrete.getCompiledDerivatives();
        } catch (e) {
            // do nothing
        }

        var branch, i;
        var branches = [];
        var polarities = [-1, 0, 0, 1];

        var nbranches = fns.length;
        for (i = 0; i < nbranches; i++) {
            var graphInfo = this.getGraphInfo(concrete._expression.args[i]);
            graphInfo.graphMode = graphMode;
            branch = derivatives ?
                Plotter.computeGraphData(viewState, graphInfo, fns[i].fn, derivatives[i].fn) :
                Plotter.computeGraphData(viewState, graphInfo, fns[i].fn);
            branch.compiled = fns[i];
            branch.operator = Comparators.get(
                Comparators.table[operator].inclusive,
                polarities[i % 4]
            );
            branches.push(branch);
        }

        for (i = 0; i < nbranches; i += 4) {
            var polygons = Plotter.polygonsFromSegments(
                branches[i + 1].segments,
                branches[i + 2].segments,
                graphMode
            );
            branches.push({
                graphMode: GRAPHMODE.POLYGONFILL,
                segments: polygons,
                poi: {}
            });
        }

        return branches;
    };

    nodes.DoubleInequality.prototype.graph = function(concrete, viewState) {
        var graphInfo = this.getGraphInfo(concrete);
        if (graphInfo.graphMode === GRAPHMODE.NONE) return false;

        var branches = [];
        var op0 = Comparators.get(Comparators.table[this._operators[0]].inclusive, 0);
        var op1 = Comparators.get(Comparators.table[this._operators[1]].inclusive, 0);

        var userData = this.userData;

        var self = this;
        List.eachArgs(concrete._expressions, function(args) {
            var branch0, branch1;
            args[0].userData = args[1].userData = userData; // TODO ick, prefer nodes to be immutable
            branch0 = self._graph(args[0], viewState, graphInfo)[0];
            branch0.operator = op0;
            branches.push(branch0);
            branch1 = self._graph(args[1], viewState, graphInfo)[0];
            branch1.operator = op1;
            branches.push(branch1);

            var polygons = Plotter.polygonsFromSegments(branch0.segments, branch1.segments, branch0.graphMode);
            branches.push({
                graphMode: GRAPHMODE.POLYGONFILL,
                segments: polygons,
                poi: {}
            });
        });

        return branches;
    };

    nodes.OrderedPair.prototype.graph = function(concrete, viewState) {
        var graphInfo = this.getGraphInfo(concrete);
        var points;
        switch (graphInfo.graphMode) {
            case GRAPHMODE.XYPOINT_MOVABLE:
                points = [
                    [concrete.args[0].constantValue, concrete.args[1].constantValue]
                ];

                return [{
                    segments: [points],
                    graphMode: graphInfo.graphMode,
                    color: this.userData.color,
                    style: this.userData.style,
                    poi: copyDefinedPOIs(points)
                }];
            case GRAPHMODE.XYPOINT:
                points = [];
                List.eachArgs(concrete.args, function(args) {
                    if (isFinite(args[0].constantValue) && isFinite(args[1].constantValue)) {
                        points.push([args[0].constantValue, args[1].constantValue]);
                    }
                });

                return [{
                    segments: [points],
                    graphMode: graphInfo.graphMode,
                    color: this.userData.color,
                    style: this.userData.style,
                    poi: copyDefinedPOIs(points)
                }];
            case GRAPHMODE.PARAMETRIC:
                var userData = this.userData;
                var branches = List.mapArgs(concrete.args, function(args) {
                    // Handle case that args don't actually depend on t. This can
                    // happen for some elements in a parametric with list coordinates,
                    // e.g. (1, [t, 2]) has one curve and one point.
                    if (args[0].isConstant && args[1].isConstant) {
                        var points = [
                            [args[0].constantValue, args[1].constantValue]
                        ];
                        return {
                            segments: [points],
                            graphMode: GRAPHMODE.XYPOINT,
                            color: userData.color,
                            style: userData.style,
                            poi: copyDefinedPOIs(points)
                        };
                    } else {
                        var fn1 = args[0].getCompiledFunctions()[0].fn;
                        var fn2 = args[1].getCompiledFunctions()[0].fn;
                        // TODO modify parametric plotter to work with array of fns instead
                        // of an fn that returns an array
                        var fn = function(t) { return [fn1(t), fn2(t)]; };
                        graphInfo.domain = userData.domain;
                        return Plotter.computeGraphData(viewState, graphInfo, fn);
                    }
                });

                return branches;
            default:
                return false;
        }
    };

    nodes.Regression.prototype.graph = function(concrete, viewState) {
        var graphInfo = this.getGraphInfo(concrete);
        return this._graph(concrete.model, viewState, graphInfo);
    };

    function _flatten(arr) { return Array.prototype.concat.apply([], arr); }

    nodes.Table.prototype.graph = function(concrete, viewState) {
        /* jshint maxcomplexity:13 */
        var graphs = [];

        if (concrete.columns[0].isError) return graphs;
        var firstColumnValues = concrete.columns[0].values;

        for (var i = 1; i < this.columns.length; i++) {
            var column = concrete.columns[i];
            if (column.isError) continue;
            var userData = this.columns[i].header.userData;
            if (userData.hidden) continue;
            var columnMode = userData.columnMode;
            var showPoints = columnMode === COLUMNMODE.POINTS || columnMode === COLUMNMODE.POINTS_AND_LINES;
            var showLine = columnMode === COLUMNMODE.LINES || columnMode === COLUMNMODE.POINTS_AND_LINES;
            //Connect the dots if we're independent numbers, or an externally defined list
            //Draw a smooth line if it's a defined function
            var showDiscreteLine = showLine && column.isDiscrete;
            var showContinuousLine = showLine && !column.isDiscrete;

            var branches = [];
            if (showPoints || showDiscreteLine) {
                var segments = [];
                var thisSegment = [];
                var columnValues = column.values;
                /* jshint loopfunc: true */
                List.eachArgs([firstColumnValues, columnValues], function(args) {
                    if (isFinite(args[0].constantValue) && isFinite(args[1].constantValue)) {
                        thisSegment.push([args[0].constantValue, args[1].constantValue]);
                    } else {
                        segments.push(thisSegment);
                        thisSegment = [];
                    }
                });
                segments.push(thisSegment);
                if (showPoints) {
                    branches.push({
                        segments: segments,
                        graphMode: GRAPHMODE.XYPOINT,
                        poi: copyDefinedPOIs(segments),
                        color: userData.color,
                        style: userData.style
                    });
                }
                if (showDiscreteLine) {
                    branches.push({
                        // flatten segments into format expected by line plotter
                        segments: segments.map(_flatten),
                        // Using PARAMETRIC instead of Y here is a bit of a hack
                        // to keep graph controller from trying to trace, etc.
                        graphMode: GRAPHMODE.PARAMETRIC,
                        poi: [],
                        color: userData.color,
                        style: userData.style
                    });
                }
            }
            if (showContinuousLine) {
                var continuousBranches = this.columns[i].header.graph(concrete.columns[i].header, viewState);
                if (continuousBranches.length) Array.prototype.push.apply(branches, continuousBranches);
            }

            if (branches.length) graphs[userData.id] = branches;
        }
        return graphs;
    };
});

define('parser', ['require', 'math/baseparser', 'math/features/repr', 'math/features/scalarEvalExpression', 'math/features/okForImplicitFunction', 'math/features/constantcollapsedcopy', 'math/features/polynomialorder', 'math/features/polynomialcoefficients', 'math/features/extractconditions', 'math/features/bounddomain', 'math/features/derivative', 'math/features/substitute', 'math/features/solve', 'math/features/analyze', 'math/features/getgraphmode', 'math/features/getgraphinfo', 'math/features/tableinfo', 'math/features/tableerror', 'math/features/islinear', 'math/features/graph'], function(require) {
    var Parser = require('math/baseparser');

    //Append each types of node with additional features
    require('math/features/repr');
    require('math/features/scalarEvalExpression');
    require('math/features/okForImplicitFunction');
    require('math/features/constantcollapsedcopy');
    require('math/features/polynomialorder');
    require('math/features/polynomialcoefficients');
    require('math/features/extractconditions');
    require('math/features/bounddomain');
    require('math/features/derivative');
    require('math/features/substitute');
    require('math/features/solve');
    require('math/features/analyze');
    require('math/features/getgraphmode');
    require('math/features/getgraphinfo');
    require('math/features/tableinfo');
    require('math/features/tableerror');
    require('math/features/islinear');
    require('math/features/graph');

    return Parser;
});

define('math/finddependencyorder', ['require', 'math/builtinframe', 'underscore'], function(require) {
    var BuiltInFrame = require('math/builtinframe');
    var _ = require('underscore');
    // Order statements according to their dependencies.
    //
    // Optional 2nd arguments is a list of ids giving the roots to start searching
    // for dependencies from. This is used by the regression pass to only traverse
    // statements that regressions depend on, and to preserve order in case of ties
    // for the purpose of picking good residual variables.
    //
    // Implements Tarjan's algorithm
    //
    // https://en.wikipedia.org/wiki/Tarjan's_strongly_connected_components_algorithm
    //
    // to topologically sort DAG of strongly connected components of dependency graph.
    // A strongly connected component is a subgraph for which every node can be
    // reached by following directed edges from every other node. Any time we find a
    // strongly connected component with more than one statement in it, that's a
    // cyclic dependency error.
    function findDependencyOrder(statements, roots) {
        /* jshint maxcomplexity:16 */
        var exportLevels = [];
        var assignments = {}; // symbol => [id] of assigners
        var multiplyDefined = {}; // symbol => sentinal
        var cyclicallyDefined = {}; // symbol => [symbols]
        var nodes = {}; // id => { id: #, index: #, lowval: #, error: {}, instack: t/f }
        var index = 0; // Number of nodes reached so far in DFS
        var stack = []; // [node]
        var resolved = []; // [id]
        var id, i, j, symbol, penalty;

        if (!roots) {
            roots = [];
            for (id in statements) {
                if (statements.hasOwnProperty(id)) roots.push(id);
            }
        }

        // Separate statements by export penalty
        for (id in statements) {
            if (!statements.hasOwnProperty(id)) continue;
            penalty = statements[id].exportPenalty || 0;
            while (exportLevels.length < penalty + 1) exportLevels.push([]);
            exportLevels[penalty].push(id);
        }

        for (penalty = 0; penalty < exportLevels.length; penalty++) {
            var levelAssignments = {};
            for (i = 0; i < exportLevels[penalty].length; i++) {
                id = exportLevels[penalty][i];
                var exports = statements[id].getExports();

                // Fill in dictionary of assignments at the current level, skipping
                // symbols that have already been assigned at a lower penalty
                for (j = 0; j < exports.length; j++) {
                    symbol = exports[j];
                    if (BuiltInFrame[symbol]) continue;
                    if (assignments[symbol]) continue;
                    levelAssignments[symbol] = levelAssignments[symbol] || [];
                    levelAssignments[symbol].push(id);
                    if (levelAssignments[symbol].length > 1) multiplyDefined[symbol] = true;
                }
            }
            // Commit assignments from this level to the accumulated assignments
            // dictionary
            for (symbol in levelAssignments) {
                assignments[symbol] = levelAssignments[symbol];
            }
        }

        // Traverse all nodes, finding their strongly connected components.
        // Note that strongConnect calls itself recursively.
        for (i = 0; i < roots.length; i++) {
            if (!nodes.hasOwnProperty(roots[i])) strongConnect(roots[i]);
        }

        function strongConnect(id) {
            nodes[id] = nodes[id] || {};
            var v = nodes[id];
            var w;
            v.id = id;
            v.index = index;
            v.lowlink = index;
            stack.push(v);
            v.instack = true;
            index++;

            var dependencies = statements[id].getDependencies();
            for (var i = 0; i < dependencies.length; i++) {
                var symbol = dependencies[i];
                if (!assignments.hasOwnProperty(symbol)) continue;
                var assigners = assignments[symbol];

                // Visit the dependencies w of v
                for (var j = 0; j < assigners.length; j++) {
                    var assigner = assigners[j];
                    if (!nodes.hasOwnProperty(assigner)) {
                        // assigner has not yet been visited; recurse on it
                        strongConnect(assigner);
                        w = nodes[assigner];
                        v.lowlink = Math.min(v.lowlink, w.lowlink);
                    } else {
                        w = nodes[assigner];
                        // If w is already in the stack, it is part of the SCC of v
                        if (w.instack) v.lowlink = Math.min(v.lowlink, w.index);
                    }
                }
            }

            // If v is a root node, the current stack is a strongly connected component
            if (v.lowlink === v.index) {
                w = stack.pop();
                w.instack = false;

                if (w === v) {
                    markSingle(v);
                } else {
                    var scc = [w];
                    while (true) {
                        w = stack.pop();
                        w.instack = false;
                        scc.push(w);
                        if (w === v) break;
                    }
                    markCycle(scc);
                }
            }
        }

        function markSingle(v) {
            resolved.push(v.id);
        }

        function markCycle(scc) {
            var cycleSymbols = [];
            var v;
            var i;

            for (i = scc.length - 1; i >= 0; i--) {
                v = scc[i];
                var exports = statements[v.id].getExports();

                // TODO for expressions with multiple exports, does not distinguish between
                // symbols that are and are not involved in the cycle.
                Array.prototype.push.apply(cycleSymbols, exports);

                cycleSymbols.push(exports[0]);
                resolved.push(v.id);
            }

            cycleSymbols = _.unique(cycleSymbols);
            cycleSymbols.sort();

            for (i = 0; i < cycleSymbols.length; i++) {
                cyclicallyDefined[cycleSymbols[i]] = cycleSymbols;
            }
        }

        return {
            resolved: resolved,
            multiplyDefined: multiplyDefined,
            cyclicallyDefined: cyclicallyDefined
        };
    }

    return findDependencyOrder;
});
define('math/context', ['require', 'console', 'pjs', 'underscore', './plotter', './poi', 'parser', 'math/builtinframe', 'math/parsenode/constant', 'math/parsenode/table', 'math/parsenode/tablecolumn', 'math/parsenode/freevariable', 'math/parsenode/list', 'math/finddependencyorder', 'math/errormsg', 'graphing/graphmode'], function(require) {
    var console = require('console');
    var P = require('pjs');
    var _ = require('underscore');
    var Plotter = require('./plotter');
    var POI = require('./poi');
    var Parser = require('parser');
    var BuiltInFrame = require('math/builtinframe');
    var Constant = require('math/parsenode/constant');
    var Table = require('math/parsenode/table');
    var TableColumn = require('math/parsenode/tablecolumn');
    var FreeVariable = require('math/parsenode/freevariable');
    var List = require('math/parsenode/list');
    var findDependencyOrder = require('math/finddependencyorder');
    var ErrorMsg = require('math/errormsg');
    var GRAPHMODE = require('graphing/graphmode');

    return P(function(context) {

        // callback noop
        context.triggerGraphComputed = function() {};
        context.triggerStatusChange = function() {};
        context.triggerRemoveGraph = function() {};
        context.triggerRender = function() {};
        context.triggerRenderSlowly = function() {};
        context.triggerDidAddStatement = function() {};
        context.triggerDidRemoveStatement = function() {};
        context.triggerDidSetCompleteState = function() {};
        context.triggerDidUpdateIntersections = function() {};

        context.init = function(frame) {
            if (!frame) frame = BuiltInFrame;
            // Only trigAngleMultiplier is ever updated in parent_frame
            this.parent_frame = Object.create(frame);
            // statements export definitions to this.frame
            this.frame = Object.create(this.parent_frame);
            this.lastFrame = Object.create(this.parent_frame);
            this.regressionFrame = Object.create(this.parent_frame);
            this.statements = {}; //Each statement should be immutable
            this.analysis = {}; //This can be cleaned out at re-derived each round
            this.currentStatus = {}; //Remember last sent message, so that we only update when necessary
            this.unanalyzedIds = {};
            this.unpublishedIds = {};
            this.intersectIds = {};
        };

        context.processChangeSet = function(changeSet) {
            /* jshint maxcomplexity:44 */
            var ids, triggerRender;

            if (changeSet.isCompleteState) {
                this.invalidate();
                this.statements = {};
            }

            // update the viewport
            if (changeSet.viewState) {
                this.setViewState(changeSet.viewState);
            }

            // update degree mode
            if (changeSet.hasOwnProperty('degreeMode')) {
                this.setDegreeMode(changeSet.degreeMode);
            }

            // change which expressions 'intersectId' attempts to intersect with
            if (changeSet.hasOwnProperty('intersectIds')) {
                this.intersectIds = changeSet.intersectIds;
            }

            if (changeSet.statements) {
                for (var id in changeSet.statements) {
                    var statement = changeSet.statements[id];

                    // remove the statement if it is null
                    if (statement === null) {
                        if (!changeSet.isCompleteState && this.statements.hasOwnProperty(id)) {
                            ids = this.statements[id].getAllIds();
                        }

                        this.removeStatement(id);

                        if (!changeSet.isCompleteState && ids) {
                            for (var i = 0; i < ids.length; i++) {
                                this.triggerRemoveGraph(ids[i]);
                            }
                            this.triggerDidRemoveStatement(id);
                        }
                    } else {
                        this.addStatement(statement);

                        if (!changeSet.isCompleteState) {
                            this.triggerDidAddStatement(statement);
                        }
                    }
                }
            }

            if (changeSet.isCompleteState) {
                this.triggerDidSetCompleteState(changeSet.statements);

                //Temporarily use slow rendering callback
                //TODO - handle renderSlowly via some other mechanism.
                triggerRender = this.triggerRender;
                this.triggerRender = this.triggerRenderSlowly;
            }

            this.updateAnalysis();

            if (changeSet.hasOwnProperty('intersectId')) this._updateIntersections(changeSet.intersectId);

            this.publishChanges();

            if (changeSet.isCompleteState) {
                this.triggerRender = triggerRender;
            }
        };

        context.setViewState = function(viewState) {
            if (_.isEqual(viewState, this.viewState)) return;
            this.viewState = viewState;
            for (var id in this.statements) {
                if (!this.statements.hasOwnProperty(id)) continue;
                this.unpublishedIds[id] = true;
            }
        };

        context.getViewState = function() {
            if (!this.viewState) return;
            // Hack to smuggle trigAngleMultiplier into viewState while allowing these to be
            // set separately by external calls.
            var localViewState = Object.create(this.viewState);
            if (this.parent_frame && this.parent_frame.trigAngleMultiplier) {
                localViewState.trigAngleMultiplier = this.parent_frame.trigAngleMultiplier.constantValue;
            } else {
                localViewState.trigAngleMultiplier = 1.0;
            }
            return localViewState;
        };

        context.setDegreeMode = function(use_degrees) {
            this.parent_frame.trigAngleMultiplier = Constant(use_degrees ? Math.PI / 180 : 1);
            this.invalidate();
        };

        context.publishChanges = function() {
            this.updateAnalysis();
            this._publishAllStatuses();
            this._graphAllChanged();
            this.unpublishedIds = {};
        };

        // `_publishAllStatuses`, `_graphAllChanged`, and `_updateIntersections`
        // use `this.analysis`, and so expect it to be up to date, i.e. no statements
        // should have been added or removed since `this.updateAnalysis()` was called.
        //
        context._publishAllStatuses = function() {
            //Compute new states, but only send them out if they're different from what we sent last time
            var changes = {};
            var lastStatus = this.currentStatus;
            this.currentStatus = {};

            for (var id in this.unpublishedIds) {
                if (!this.analysis.hasOwnProperty(id)) continue;
                var newState = this.analysis[id].evaluationState;
                if (JSON.stringify(newState) !== JSON.stringify(lastStatus[id])) {
                    changes[id] = newState;
                }
                this.currentStatus[id] = newState;
            }

            this.triggerStatusChange(changes);
        };

        context._graphAllChanged = function() {
            /* jshint maxcomplexity:13 */
            var viewState = this.getViewState();
            if (!Plotter.validateViewState(viewState)) return;

            for (var id in this.unpublishedIds) {
                if (!this.analysis.hasOwnProperty(id)) continue;
                var analysis = this.analysis[id];
                if (analysis.rawTree.isTable) {
                    var graphs = analysis.graph(viewState);
                    var columnIds = analysis.rawTree.getAllIds();
                    for (var i = 0; i < columnIds.length; i++) {
                        if (graphs[columnIds[i]]) {
                            this.triggerGraphComputed(columnIds[i], graphs[columnIds[i]]);
                        } else {
                            this.triggerRemoveGraph(columnIds[i]);
                        }
                    }
                } else if (analysis.evaluationState.is_graphable && analysis.rawTree.userData.shouldGraph) {
                    this.triggerGraphComputed(id, analysis.graph(viewState));
                    if (this.intersectIds.hasOwnProperty(id)) this._updateIntersections(id);
                } else {
                    this.triggerRemoveGraph(id); //TODO - removing evaluable things every cycle
                }
            }

            // Recompute all visible intersections for curves that weren't regraphed.
            // Curves that were regraphed already had their intersections updated in
            // the graph routine. Need to do this because we're only keeping track of
            // one partner in an intersection, and the other partner might have
            // changed.
            if (_.keys(this.unpublishedIds).length) {
                for (var intersectId in this.intersectIds) {
                    if (this.unpublishedIds.hasOwnProperty(intersectId)) continue;
                    if (this.intersectIds.hasOwnProperty(intersectId)) this._updateIntersections(intersectId);
                }
            }

            this.triggerRender();
        };

        // Find all intersections between a curve with the given id and other
        // curves.
        context._updateIntersections = function(id) {
            if (!this.viewState) return;
            var analysis = this.analysis[id];

            if (!analysis || !analysis.shouldIntersect()) {
                this.triggerDidUpdateIntersections(id, []);
                return;
            }

            this.findSomeIntersectionsWith(id).streamRest();
        };

        // context.findSomeIntersectionsWith computes as many intersections with the
        // curve with given id as it can in 20 ms and then returns an object:
        // {
        //   intersections: // Intersections found so far
        //   streamRest: // Function that will stream the rest of the intersections
        //               // back to the grapher.
        // }
        //
        // We run a different timeout for every curve id that is having
        // having intersections computed on it so that we can start computing
        // intersections with a few curves at once without having them cancel
        // eachother. This will happen if you open intersections on a few different
        // curves and then change something that triggers a graphAll.
        //
        // Note that we typically only stick the intersection POI on one of the two
        // curves that is involved in an intersection (the one that was selected
        // when the intersection was computed).
        var streamIntersectionsTimeouts = {};
        context.findSomeIntersectionsWith = function(id1) {
            this.cancelIntersectionStreaming(id1);
            var runFor = 20; // ms
            var waitFor = 60; // ms
            var self = this;
            var push = Array.prototype.push;
            var viewState = this.getViewState();
            var analysis1 = self.analysis[id1];
            var graphInfo = analysis1.getGraphInfo();
            var graphMode = graphInfo.graphMode;
            var compiled1 = analysis1.concreteTree.getCompiledFunctions();

            var otherAnalyses = [];
            for (var id2 in self.analysis) {
                if (!self.analysis.hasOwnProperty(id2)) continue;
                if (String(id2) === String(id1)) continue;
                if (!self.analysis[id2].shouldIntersect()) continue;
                otherAnalyses.push(self.analysis[id2]);
            }

            // intersections accumulator and iterator i are modified during successive
            // calls to computeSome()
            var intersections = [];
            for (var branch = 0; branch < compiled1.length; branch++) {
                intersections[branch] = { x: [], y: [], intersects: [] };
            }
            var i = otherAnalyses.length - 1;
            var stream = false;
            var computeSome = function() {
                /* jshint maxcomplexity:14 */
                /* jshint loopfunc: true */
                var now = new Date();
                var updated = false;
                var fn1;
                var fn2;
                var newIntersections;
                var analysis2, graphMode2, compiled2;
                var swap;
                var indicatorSamples;
                var domain;
                for (i; i >= 0; i--) {
                    if (new Date() - now > runFor) {
                        if (!stream) return;
                        streamIntersectionsTimeouts[id1] = setTimeout(computeSome, waitFor);
                        if (!updated) return;
                        self.triggerDidUpdateIntersections(id1, intersections);
                        return;
                    }
                    analysis2 = otherAnalyses[i];
                    graphMode2 = analysis2.getGraphInfo().graphMode;

                    var modesxx = graphMode === GRAPHMODE.X && graphMode2 === GRAPHMODE.X;
                    var modesyy = graphMode === GRAPHMODE.Y && graphMode2 === GRAPHMODE.Y;
                    var modesxy = graphMode === GRAPHMODE.X && graphMode2 === GRAPHMODE.Y;
                    var modesyx = graphMode === GRAPHMODE.Y && graphMode2 === GRAPHMODE.X;
                    // Currently only intersect x and y graphs
                    if (!(modesxx || modesyy || modesxy || modesyx)) continue;

                    compiled2 = analysis2.concreteTree.getCompiledFunctions();

                    for (var branch1 = 0; branch1 < compiled1.length; branch1++) {
                        fn1 = compiled1[branch1].fn;
                        domain = Plotter.computeDomain(viewState, graphInfo, fn1);
                        for (var branch2 = 0; branch2 < compiled2.length; branch2++) {
                            fn2 = compiled2[branch2].fn;

                            var indicatorFn;
                            if (modesxx || modesyy) {
                                indicatorFn = function(x) { return fn2(x) - fn1(x); };
                            } else if (modesxy || modesyx) {
                                indicatorFn = function(x) { return x - fn2(fn1(x)); };
                            } else {
                                continue;
                            }
                            indicatorSamples = Plotter.sampleXY(indicatorFn, domain).segments;
                            newIntersections = POI.findIntersections(
                                indicatorSamples,
                                fn1,
                                indicatorFn
                            );
                            if (newIntersections.x.length) updated = true;
                            newIntersections.intersects = Array(newIntersections.x.length);
                            for (var j = 0, jlen = newIntersections.x.length; j < jlen; j++) {
                                newIntersections.intersects[j] = analysis2.id;
                            }
                            // Need to swap x and y if graphmode is GRAPHMODE.X
                            if (graphMode === GRAPHMODE.X) {
                                swap = newIntersections.y;
                                newIntersections.y = newIntersections.x;
                                newIntersections.x = swap;
                            }
                            push.apply(intersections[branch1].x, newIntersections.x);
                            push.apply(intersections[branch1].y, newIntersections.y);
                            push.apply(intersections[branch1].intersects, newIntersections.intersects);
                        }
                    }
                }

                if (!stream || !updated) return;
                self.triggerDidUpdateIntersections(id1, intersections);
                self.cancelIntersectionStreaming(id1);
            };

            computeSome();

            return {
                intersections: intersections,
                streamRest: function() {
                    // Slightly wasteful, but handy for clearing old intersections early.
                    self.triggerDidUpdateIntersections(id1, intersections);
                    stream = true;
                    computeSome();
                }
            };
        };

        context.cancelIntersectionStreaming = function(id) {
            clearTimeout(streamIntersectionsTimeouts[id]);
            delete streamIntersectionsTimeouts[id];
        };

        //Takes a object representing a statement
        //Expects statement to have properties:
        // * id (integer)
        // * latex (string)
        // * shouldGraph (boolean)
        // * color (string)
        context.addStatement = function(statement) {
            if (!statement) return;
            var id = statement.id;
            this.markDirty(id); // Mark existing dependencies as dirty

            if (statement.type === 'table') {
                var previousIds = []; //Used to tell tables to ungraph old columns

                if (this.statements.hasOwnProperty(id)) previousIds = this.statements[id].getAllIds();

                statement.shouldGraph = true; // TODO hack

                var columns = statement.columns;
                var parsedColumns = [];
                var header, values, parsedColumn;

                var maxLength = 0;
                for (var n = 0; n < columns.length; n++) {
                    maxLength = Math.max(columns[n].values.length, maxLength);
                }

                for (var i = 0; i < columns.length; i++) {
                    header = Parser.parse(columns[i].latex);
                    values = [];
                    var lastNonEmptyIndex = 0;
                    for (var j = 0; j < columns[i].values.length; j++) {
                        if (columns[i].values[j].replace(/\\space/g, '').match(/\S/)) {
                            values.push(Parser.parse(columns[i].values[j]));
                            lastNonEmptyIndex = j;
                        } else {
                            // Parse blank entries as NaN
                            values.push(Constant(NaN));
                        }
                    }
                    values.splice(lastNonEmptyIndex + 1);
                    parsedColumn = TableColumn(header, maxLength, List(values));
                    parsedColumn.id = columns[i].id;
                    // Hang onto things like color, style, and columnMode
                    if (parsedColumn.header) parsedColumn.header.userData = columns[i];
                    parsedColumns.push(parsedColumn);
                }

                this.statements[id] = Table(parsedColumns);

                // NOTE: quadratic algorithm; assuming you can't have that many table columns
                var self = this;
                var currentIds = this.statements[id].getAllIds();
                previousIds.forEach(function(id) {
                    if (currentIds.indexOf(id) === -1) self.triggerRemoveGraph(id);
                });
            } else {
                this.statements[id] = Parser.parse(statement.latex);
            }

            this.statements[id].userData = statement; //Hold on to domain, color, etc.

            // Need to mark clean before marking dirty again because otherwise we'll
            // hit an early return and fail to mark new dependencies dirty.
            this.markClean(statement.id);
            this.markDirty(statement.id); // Mark any new dependencies as dirty
        };

        context.removeStatement = function(id) {
            if (!this.statements.hasOwnProperty(id)) return;
            // Looks like it was already deleted.
            // This happens when a table is deleted, and then each column is deleted.
            var statement = this.statements[id];

            this.markDirty(id); //Mark dirty before deletion
            if (statement.isTable) {
                var self = this;
                statement.getAllIds().forEach(function(id) { self.triggerRemoveGraph(id); });
            } else {
                this.triggerRemoveGraph(id); //TODO - removes even if it wasn't graphed
            }

            delete this.statements[id];
        };

        context.invalidate = function() {
            for (var id in this.statements) {
                if (this.statements.hasOwnProperty(id)) this.markDirty(id);
            }
            this.currentStatus = {};
            // TODO too conservative.
            this.frame = Object.create(this.parent_frame);
            this.regressionFrame = Object.create(this.parent_frame);
        };

        context.markDirty = function(id) {
            if (!this.statements[id]) return;
            if (this.unanalyzedIds[id]) return;

            this.unanalyzedIds[id] = true;
            this.unpublishedIds[id] = true;
            delete this.analysis[id];

            var statement = this.statements[id];

            var symbols = statement.getExports();
            for (var i = 0; i < symbols.length; i++) {
                this.markSymbolDirty(symbols[i]);
            }

            if (statement.isRegression) {
                // TODO too conservative. Problem with regressions is that we need to
                // mark their (recursive) dependencies dirty as well as their exports,
                // since they might export any of their recursive dependencies.
                //
                // Note, when this is fixed, don't forget to mark residualVariable dirty
                // too.
                this.invalidate();
            }

            this.cancelIntersectionStreaming(id);
        };

        context.markSymbolDirty = function(symbol) {
            delete this.frame[symbol];
            delete this.regressionFrame[symbol];
            for (var id in this.statements) {
                if (!this.statements.hasOwnProperty(id)) continue;
                if (this.statements[id].dependsOn(symbol)) this.markDirty(id);
                if (this.statements[id].exportsSymbol(symbol)) this.markDirty(id);
            }
        };

        context.markClean = function(id) {
            delete this.unanalyzedIds[id];
        };

        context.getFrame = function() {
            this.updateAnalysis();
            return this.frame;
        };

        context.getAnalysis = function() {
            this.updateAnalysis();
            return this.analysis;
        };

        context.getStatus = function(id) {
            this.updateAnalysis();
            if (!this.analysis[id]) return undefined;
            return this.analysis[id].status;
        };

        //Returns an object that mirrors the API of Formula
        context.getEvaluationState = function(id) {
            this.updateAnalysis();
            if (!this.analysis[id]) return undefined;
            return this.analysis[id].evaluationState;
        };

        function exportErrors(dependencyOrder, frame) {
            var multiplyDefined = dependencyOrder.multiplyDefined;
            var cyclicallyDefined = dependencyOrder.cyclicallyDefined;

            var symbol;
            for (symbol in multiplyDefined) {
                if (!multiplyDefined.hasOwnProperty(symbol)) continue;
                frame[symbol] = ErrorMsg.multiplyDefined(symbol);
            }
            for (symbol in cyclicallyDefined) {
                if (!cyclicallyDefined.hasOwnProperty(symbol)) continue;
                frame[symbol] = ErrorMsg.cycle(cyclicallyDefined[symbol]);
            }
        }

        context._updateRegressions = function(dirtyStatements) {
            var frame = this.frame;
            var lastFrame = this.lastFrame;
            var regressionFrame = this.regressionFrame;

            var id;

            // In this pass, we are only interested in statements that dirty regressions
            // depend on.
            var roots = [];
            for (id in dirtyStatements) {
                if (!dirtyStatements.hasOwnProperty(id)) continue;
                if (dirtyStatements[id].isRegression) roots.push(id);
            }

            // Prefer to process regressions that already have a residualVariable first.
            var self = this;
            roots.sort(function(a, b) {
                var aHasResidual = self.statements[a].userData && self.statements[a].userData.residualVariable;
                var bHasResidual = self.statements[b].userData && self.statements[b].userData.residualVariable;

                if (aHasResidual && !bHasResidual) return -1;
                if (bHasResidual && !aHasResidual) return 1;
                return 0;
            });

            // Walk through statements in dependencyOrder populating the regression frame, and then
            // run the regressions.
            var dependencyOrder = findDependencyOrder(dirtyStatements, roots);
            exportErrors(dependencyOrder, regressionFrame);
            var resolved = dependencyOrder.resolved;
            // TODO this is needed for determining whether we can add a regression plot suggestion,
            // but it isn't a full "analysis" because its members don't have evaluation states.
            var regressionAnalysis = {};

            for (var i = 0; i < resolved.length; i++) {
                id = resolved[i];

                if (this.statements[id].isRegression) {
                    // Also pass frame to allow regression to pick a residual variable
                    this.analysis[id] = dirtyStatements[id].analyze(
                        regressionFrame,
                        frame,
                        lastFrame,
                        regressionAnalysis
                    );
                    this.analysis[id].exportTo(frame);
                    delete dirtyStatements[id];
                } else {
                    // TODO not clear if it is sound to just call getConcreteTree here, or if
                    // we need to run more of analyze. Only expect to run into assignments,
                    // function definitions, and tables/table columns here. Don't want to throw
                    // tooManyVariable errors here like we normally would in analyze.
                    //
                    //  Definitely not working on tables right now because they don't implement
                    //  getConcreteTree yet. They probably should.
                    var concrete = dirtyStatements[id].tryGetConcreteTree(regressionFrame);
                    dirtyStatements[id].exportTo(concrete, regressionFrame);
                    regressionAnalysis[id] = { rawTree: dirtyStatements[id], concreteTree: concrete };
                }
            }
        };

        context.updateAnalysis = function() {
            var id;
            var dirtyStatements = {};
            for (id in this.unanalyzedIds) {
                if (this.unanalyzedIds.hasOwnProperty(id) && this.statements[id]) {
                    dirtyStatements[id] = this.statements[id];
                }
            }

            // Note: mutates dirtyStatements to remove regressions
            this._updateRegressions(dirtyStatements);

            var analysis = this.analysis;
            var frame = this.frame;

            // _updateRegressions has already taken care of analyzing regressions and
            // exporting regressed parameters to the frame. Now analyze all other
            // statements.
            var dependencyOrder = findDependencyOrder(dirtyStatements);
            exportErrors(dependencyOrder, frame);
            var resolved = dependencyOrder.resolved;

            for (var i = 0; i < resolved.length; i++) {
                id = resolved[i];

                // Special handling when 'r' is in the frame. First, check if the statement
                // is graphable as a polar equation with r removed from the frame. If not,
                // use the full frame.
                if (frame.r) {
                    var localFrame = Object.create(frame, { r: FreeVariable('r') });
                    analysis[id] = this.statements[id].analyze(localFrame, analysis);
                    if (analysis[id].getGraphMode() === GRAPHMODE.POLAR) {
                        analysis[id].exportTo(frame);
                        continue;
                    }
                }

                //Pass in previous analysis to allow populating movable points
                analysis[id] = this.statements[id].analyze(frame, analysis);
                analysis[id].exportTo(frame, dependencyOrder);
            }

            this.unanalyzedIds = {};
            this.lastFrame = Object.create(this.parent_frame);
            for (var symbol in frame) {
                if (frame.hasOwnProperty(symbol)) this.lastFrame[symbol] = frame[symbol];
            }
        };

        //Below this point, these are shims for compatibility with existing tests
        //TODO - remove these and re-factor tests
        context.evaluateOnce = function(id) {
            console.log("Deprecated console.evaluateOnce - this should not run in production code");
            return this.analysis[id].concreteTree.constantValue;
        };

        context.compile = function(id) {
            console.log("Deprecated console.compile - this should not run in production code");
            var compiled = this.analysis[id].concreteTree.getCompiledFunctions();
            if (compiled.length === 1) return compiled[0];
            return compiled;
        };

        context.evalStrings = function(id) {
            console.log("Deprecated console.evalStrings - this should not run in production code");
            return this.analysis[id].concreteTree.getEvalStrings();
        };
    });
});

define('worker/workercore', ['require', 'math/context', 'math/functions'], function(require) {
    var EvaluatorContext = require('math/context');
    var Functions = require('math/functions');

    return function(sendMessage) {

        //Initialize environment
        var context = EvaluatorContext(); //TODO - pass in frame

        //Functions to send data back to main thread
        context.triggerGraphComputed = function(id, data) {
            Functions.dehydrateGraphData(data);
            sendMessage('graphComputed', { id: id, graphData: data });
        };

        context.triggerDidUpdateIntersections = function(id, intersections) {
            sendMessage('updateIntersections', { id: id, intersections: intersections });
        };

        context.triggerRender = function() {
            sendMessage('render');
        };

        context.triggerRenderSlowly = function() {
            sendMessage('renderSlowly');
        };

        context.triggerRemoveGraph = function(id) {
            sendMessage('removeGraph', id);
        };

        context.triggerStatusChange = function(data) {
            sendMessage('statusChange', data);
        };

        return {
            processChangeSet: function(changeSet) {
                context.processChangeSet(changeSet);

                sendMessage('processChangeSet', changeSet);
            }
        };

    };

});

define('worker/fakeworker', ['require', 'worker/workercore'], function(require) {
    var WorkerCore = require('worker/workercore');

    return function(messageListener) {
        var fakeWorker = {};
        var workerCore = WorkerCore(sendMessage);

        //Handle message from worker to UI thread
        function sendMessage(type, payload) {
            messageListener({ type: type, payload: payload });
        }

        //Handle messages from UI thread to worker
        fakeWorker.postMessage = function(e) {
            setTimeout(function() {
                workerCore.processChangeSet(e);
            }, 0);
        };

        return fakeWorker;
    };
});

define('worker/workerpool', ['require', 'console', 'api/cross_origin_worker', 'pjs', 'underscore_model', './fakeworker', 'underscore'], function(require) {
    var console = require('console');
    var CrossOriginWorkerURL = require('api/cross_origin_worker');
    var P = require('pjs');
    var UnderscoreModel = require('underscore_model');
    var FakeWorker = require('./fakeworker');
    var _ = require('underscore');

    var WorkerPool = P(UnderscoreModel, function(pool, _super) {
        pool.init = function(workerPath, maxWorkers) {
            _super.init.call(this);

            this.workers = [];
            this.maxWorkers = maxWorkers;
            this.workerPath = workerPath;

            this.crossOriginWorkerURL = CrossOriginWorkerURL(this.workerPath);

            if (this.allowedToSpawnWorker()) {
                console.log('WorkerPool: allowed to use ' + this.maxWorkers + ' workers.');
            } else {
                console.log('WorkerPool: will not try to use workers');
            }
        };

        pool.allowedToSpawnWorker = function() {
            return this.crossOriginWorkerURL && this.workers.length < this.maxWorkers;
        };

        pool.killWorker = function(worker) {
            var workerIndex = _.indexOf(this.workers, worker);
            if (workerIndex !== -1) {
                console.log("terminated worker " + (workerIndex + 1) + " of " + this.workers.length);
                worker.terminate();
                this.workers = _.without(this.workers, worker);

                // the evaluators respond to onWorkerKilled() by resending the last unfinished job
                // back into the worker pool. Sending the jobs back in the same order
                // will starve any jobs after the long-running one. We randomize the order we
                // tell the evaluators to prevent starvation.
                _.shuffle(_.values(worker.__connections)).forEach(function(connection) {
                    if (connection && connection.onWorkerKilled) {
                        connection.onWorkerKilled();
                    }
                });
            }
        };

        pool.spawnWorker = function() {
            try {
                var worker = new Worker(this.crossOriginWorkerURL);
                worker.__connections = {};
                worker.__isFake = false;
                worker.onerror = function(evt) { console.log(evt) };
                worker.addEventListener('message', function(e) {
                    var data = e.data;
                    if (data && data.log) {
                        console.log('worker log: ', JSON.parse(data.log));
                        return;
                    }
                    if (data && data.connectionId) {
                        var connection = worker.__connections[data.connectionId];
                        if (connection) {
                            connection.onResponse(data.originalMessage);
                        }
                    }
                });

                this.workers.push(worker);
                console.log('spawned worker ' + this.workers.length + " of " + this.workers.length);
                return worker;
            } catch (e) {
                // Fallback when we can't support real workers. Can happen if
                // 1. window.Worker does not exist (IE < 10)
                // 2. We're working cross domain and the browser can't build Blobs.
                //    (for the API; all versions of IE I've been able to test)
                console.log(e.message);
                console.log('failed to spawn worker ' + (this.workers.length + 1) + " of " + (this.workers.length + 1));
                return null;
            }
        };

        pool.spawnFakeWorker = function() {
            console.log("spawning fake worker");
            var worker = FakeWorker(function(data) {
                // a FakeWorker will only have a single connection. Send the message there.
                _.values(worker.__connections)[0].onResponse(data);
            });
            worker.__isFake = true;
            worker.__connections = {};
            return worker;
        };

        pool.findLeastUsedWorker = function() {
            var countConnectionsToWorker = function(worker) {
                return _.size(worker.__connections);
            };

            var worker = _.sortBy(this.workers, countConnectionsToWorker)[0];
            if (worker) {
                console.log('reusing worker ' + (_.indexOf(this.workers, worker) + 1) + ' of ' + this.workers.length);
            }
            return worker;
        };

        // pick the worker with the fewest connections.
        pool.allocateWorker = function() {
            var worker = null;

            // try to spawn a worker if we're allowed to. The spawn may fail, but we'll
            // recover by either reusing an existing worker or by resorting to a fake worker.
            if (this.allowedToSpawnWorker()) {
                worker = this.spawnWorker();
            }

            // we didn't create a worker last step. So let's find the least used worker.
            if (!worker) {
                worker = this.findLeastUsedWorker();
            }

            // we can't re-use an already created worker. Let's spawn a fake worker.
            if (!worker) {
                worker = this.spawnFakeWorker();
            }
            return worker;
        };

    });

    return WorkerPool;
});

define('worker/workerpoolconnection', ['require', 'pjs', 'underscore_model'], function(require) {
    var P = require('pjs');
    var UnderscoreModel = require('underscore_model');

    var WorkerPoolConnection = P(UnderscoreModel, function(connection, _super) {
        connection.init = function(workerPool) {
            _super.init.call(this);

            this.workerPool = workerPool;

            // get a worker and allow the worker to lookup this connection
            this.worker = workerPool.allocateWorker();
            this.worker.__connections[this.guid] = this;
        };

        connection.killWorker = function() {
            if (!this.worker.__isFake) {
                this.workerPool.killWorker(this.worker);
            }
        };

        // to be overriden by the owner of the connection
        connection.onWorkerKilled = function() {};

        // to be overriden by the owner of the connection
        connection.onResponse = function(data) {};

        connection.sendMessage = function(data) {
            if (this.worker.__isFake) {
                this.worker.postMessage(data);
            } else {
                this.worker.postMessage({ connectionId: this.guid, originalMessage: data });
            }
        };
    });

    return WorkerPoolConnection;
});
define('main/evaluator', ['require', 'pjs', 'math/functions', 'worker/workerpool', 'worker/workerpoolconnection'], function(require) {
    var P = require('pjs');
    //var BuiltInFrame = require('math/builtinframe');
    var Functions = require('math/functions');
    var WorkerPool = require('worker/workerpool');
    var WorkerPoolConnection = require('worker/workerpoolconnection');

    var cloneJSON = function(json) {
        if (json === undefined) return undefined;
        return JSON.parse(JSON.stringify(json));
    };

    var KILL_WORKER_TIME = 4000;

    var Evaluator = P(function(evaluator) {

        // Overwritten in calc.js
        evaluator.triggerStatusChange = function(changes) {};
        evaluator.triggerRemove = function(id) {};
        evaluator.triggerGraphComputed = function(id, graphData) {};
        evaluator.triggerUpdateIntersections = function(id, intersections) {};
        evaluator.triggerRender = function() {};
        evaluator.triggerRenderSlowly = function() {};

        evaluator.init = function(workerPool) {
            this.__state = {};
            this.changeSet = null;
            this.cumulativeChangeSet = {};
            this.clearJobTimer();
            this.syncId = 1;
            this.processingDisabled = false;

            if (!workerPool) {
                workerPool = WorkerPool();
            }

            this.workerPool = workerPool;
            this.createWorkerPoolConnection();

            this.syncRequests = [];
        };

        evaluator.createWorkerPoolConnection = function() {
            if (this.workerPoolConnection) {
                this.workerPoolConnection.onResponse = function() {};
                this.workerPoolConnection.onWorkerKilled = function() {};
            }

            this.workerPoolConnection = WorkerPoolConnection(this.workerPool);

            var self = this;
            this.workerPoolConnection.onResponse = function(data) {
                self.listeners[data.type].call(self, data.payload);
            };

            this.workerPoolConnection.onWorkerKilled = function() {
                // create another connection
                self.createWorkerPoolConnection();

                // we were trying to do a job and the worker was killed.
                // Send the job back in.
                if (self.hasJobInWorker()) {
                    self.changeSet = cloneJSON(self.cumulativeChangeSet);
                    self.__state.changed = true;
                    self.__state.droppedMessage = true;
                    self.clearJobTimer(); // we had a job in there, but it's wiped out
                }

                // we did not have a job in the worker, but the worker has lost all
                // of our state. We must send our entire state back in the next time
                // that we add a change to the changeSet. Wait for a change.
                else {
                    self.changeSet = cloneJSON(self.cumulativeChangeSet);
                    self.__state.changed = false;
                }

                self.processChangeSet();
            };
        };

        evaluator.listeners = {};

        evaluator.listeners.processChangeSet = function(changeSet) {
            var syncId = changeSet.syncId;

            // find all waiting sync ids <= syncId and call callback
            while (this.syncRequests.length && this.syncRequests[0].id <= syncId) {
                var syncRequest = this.syncRequests.shift();
                syncRequest.callback();
            }

            this.__state.droppedMessage = false;

            // try to send another job in
            this.clearJobTimer();
            this.processChangeSet();
        };

        evaluator.listeners.removeGraph = function(id) {
            this.triggerRemove(id);
        };

        evaluator.listeners.graphComputed = function(payload) {
            Functions.rehydrateGraphData(payload.graphData);
            this.triggerGraphComputed(payload.id, payload.graphData);
        };

        evaluator.listeners.updateIntersections = function(payload) {
            this.triggerUpdateIntersections(payload.id, payload.intersections);
        };

        evaluator.listeners.statusChange = function(changes) {
            //Updates to status of expression-list items
            this.triggerStatusChange(changes);
        };

        evaluator.listeners.render = function() {
            this.triggerRender();
        };

        evaluator.listeners.renderSlowly = function() {
            this.triggerRenderSlowly();
        };

        evaluator._disableProcessing = function() {
            this.processingDisabled = true;
        };

        evaluator._enableProcessing = function() {
            this.processingDisabled = false;
            this.processChangeSet();
        };

        // Allows multiple messages to be pushed onto a changeset without
        // intermediate processing.
        evaluator.batch = function(fn) {
            var alreadyDisabled = this.processingDisabled;
            this._disableProcessing();
            try {
                fn();
            } finally {
                // Want to make sure that if calls to evaluator.batch are nested, only the
                // outermost call reenables processing.
                if (!alreadyDisabled) this._enableProcessing();
            }
        };

        evaluator.clearJobTimer = function() {
            this.__jobStartTime = -1;
        };

        evaluator.startJobTimer = function() {
            this.__jobStartTime = new Date().getTime();
        };

        evaluator.hasJobInWorker = function() {
            return this.__jobStartTime !== -1;
        };

        evaluator.getJobElapsedTime = function() {
            if (this.hasJobInWorker()) {
                return new Date().getTime() - this.__jobStartTime;
            } else {
                return NaN;
            }
        };

        //Set up outgoing communication to worker
        evaluator.processChangeSet = function() {
            if (this.processingDisabled) return;
            var previousJobIsLongRunning = this.getJobElapsedTime() >= KILL_WORKER_TIME;

            // after dropping a message don't wait forever for your job to finish. Kill the
            // worker again to get the job attempted again.
            if (this.__state.droppedMessage && previousJobIsLongRunning) {
                this.workerPoolConnection.killWorker();
                return;
            }

            if (this.__state.changed && this.changeSet) {
                if (this.changeSet.isCompleteState && previousJobIsLongRunning) {
                    this.workerPoolConnection.killWorker();
                } else if (!this.hasJobInWorker()) {
                    var changeSet = this.changeSet;
                    this.changeSet = null;
                    this.__state.changed = false;
                    this.startJobTimer();
                    this.workerPoolConnection.sendMessage(changeSet);
                } else {
                    // there is a job in the worker. Don't send another job in.
                }
            }

        };

        // Utility for applying changes to both the current change set and the cumulative
        // change set.
        //
        // Calls the passed function with this.changeSet, then this.cumulativeChangeSet, then
        // calls processChangeSet.
        evaluator.applyToChangeSets = function(fn) {
            this.__state.changed = true;
            if (!this.changeSet) this.changeSet = {};
            if (!this.cumulativeChangeSet) this.cumulativeChangeSet = {};
            var self = this;
            this.batch(function() {
                fn(self.changeSet);
                fn(self.cumulativeChangeSet);
                self.processChangeSet();
            });
        };

        evaluator.setViewState = function(viewState) {
            this.applyToChangeSets(function(changeSet) {
                changeSet.viewState = cloneJSON(viewState);
            });
        };

        // the evaluator has no way of telling the difference between a completely new
        // state and a state where a bunch of stuff was both deleted and added. We explicitly
        // tell it here. The only reason it matters is that if we're doing a completely new state
        // we're free to kill the worker and start fresh. That can get us out of a long running computation
        // or an errored worker that stops responding.
        evaluator.markAsCompleteState = function() {
            this.applyToChangeSets(function(changeSet) {
                changeSet.isCompleteState = true;
            });
        };

        //Takes a object representing an "expression" (TODO - rename this concept)
        //Expects expr to have properties:
        // * id (integer)
        // * latex (string)
        // * shouldGraph (boolean)
        // * color (string)
        evaluator.addStatement = function(statement) {
            this.applyToChangeSets(function(changeSet) {
                if (!changeSet.statements) changeSet.statements = {};
                changeSet.statements[statement.id] = cloneJSON(statement);
            });
        };

        evaluator.addStatements = function(statements) {
            var self = this;
            this.batch(function() {
                for (var i = 0; i < statements.length; i++) {
                    self.addStatement(statements[i]);
                }
            });
        };

        evaluator.removeStatement = function(id) {
            this.applyToChangeSets(function(changeSet) {
                if (!changeSet.statements) changeSet.statements = {};
                // Use _ = null instead of delete _ because we need to communicate
                // to the worker that if the statement was present before, it
                // should be removed.
                changeSet.statements[id] = null;
            });
        };

        evaluator.removeStatements = function(ids) {
            var self = this;
            this.batch(function() {
                for (var i = 0; i < ids.length; i++) {
                    self.removeStatement(ids[i]);
                }
            });
        };

        // TODO - rename setIntersectIds and updateIntersections. They trip
        // me up every time.
        evaluator.setIntersectIds = function(intersectIds) {
            this.applyToChangeSets(function(changeSet) {
                changeSet.intersectIds = cloneJSON(intersectIds);
            });
        };

        evaluator.updateIntersections = function(id) {
            this.applyToChangeSets(function(changeSet) {
                changeSet.intersectId = id;
            });
        };

        evaluator.setDegreeMode = function(use_degrees) {
            this.applyToChangeSets(function(changeSet) {
                changeSet.degreeMode = use_degrees;
            });
        };

        evaluator.notifyWhenSynced = function(callback) {
            this.syncId++;

            //Put the request in a list
            this.syncRequests.push({ id: this.syncId, callback: callback });

            // send sync request to worker. when it comes back, we'll call the
            // callback
            var self = this;
            this.applyToChangeSets(function(changeSet) {
                changeSet.syncId = self.syncId;
            });
        };

    });

    return Evaluator;
});

define('lib/rounding', ['require', 'math/distance'], function(require) {
    var Distance = require('math/distance');

    var Rounding = {
        // Returns the shortest decimal between two numbers according to the following rules
        //
        // 1. 0 is the shortest decimal in any range that contains it.
        // 2. Decimals with a larger exponent are shorter than decimals with a smaller exponent
        // 3. Of decimals with the same exponent, 1 is the shortest
        // 4. When there are multiple decimals in the range that are equally sort, the closest to
        //    the mean of x1 and x2 is chosen.
        shortestDecimalBetween: function(x1, x2) {
            var mean = Distance.mean(x1, x2);

            if (x1 > 0 !== x2 > 0) return 0;
            if (x1 === 0 || x2 === 0) return 0;

            // Already know x1 and x2 have the same sign, so make them positive
            // to avoid complication of leading '-' sign.
            var sign = x1 > 0 ? 1 : -1;
            var u1 = (Math.abs(x1)).toExponential().split('e');
            var u2 = (Math.abs(x2)).toExponential().split('e');

            var m1 = u1[0];
            var m2 = u2[0];

            var e1 = u1[1];
            var e2 = u2[1];

            if (e2 !== e1) {
                return sign * Math.pow(10, Math.max(parseFloat(e1), parseFloat(e2)));
            }

            if (m1[0] !== m2[0]) return parseFloat(mean.toPrecision(1));

            var precision = 1;

            // Start at 2 to skip the decimal point. We've already examined
            // the leading digit.
            for (var i = 2; i < Math.min(m1.length, m2.length); i++) {
                precision++;
                if (m1[i] !== m2[i]) break;
            }

            return parseFloat(mean.toPrecision(precision));

        }
    };

    return Rounding;
});

define('graphing/viewport', ['require', 'lib/rounding'], function(require) {
    var Rounding = require('lib/rounding');

    function Viewport(xmin, xmax, ymin, ymax) {
        this.xmin = xmin !== undefined ? xmin : -10;
        this.xmax = xmax !== undefined ? xmax : 10;
        this.ymin = ymin !== undefined ? ymin : -10;
        this.ymax = ymax !== undefined ? ymax : 10;
    }

    Viewport.prototype.toObject = function() {
        return {
            xmin: this.xmin,
            ymin: this.ymin,
            xmax: this.xmax,
            ymax: this.ymax
        };
    };

    Viewport.fromObject = function(obj) {
        return new Viewport(obj.xmin, obj.xmax, obj.ymin, obj.ymax);
    };

    Viewport.prototype.equals = function(viewport) {
        if (this.xmin !== viewport.xmin) return false;
        if (this.ymin !== viewport.ymin) return false;
        if (this.xmax !== viewport.xmax) return false;
        if (this.ymax !== viewport.ymax) return false;

        return true;
    };

    Viewport.prototype.isXValid = function() {
        return (this.xmax - this.xmin > 0);
    };

    Viewport.prototype.isYValid = function() {
        return (this.ymax - this.ymin > 0);
    };

    Viewport.prototype.isValid = function() {
        return this.isXValid() && this.isYValid();
    };

    Viewport.prototype.isSquare = function(screen) {
        return Math.abs(screen.height - screen.width * this.aspectRatio()) < 1;
    };

    Viewport.prototype.aspectRatio = function() {
        return (this.ymax - this.ymin) / (this.xmax - this.xmin);
    };

    Viewport.prototype.squareXAxis = function(screen) {
        var xrange = this.xmax - this.xmin;
        var yrange = this.ymax - this.ymin;
        var xcenter = this.xmin + xrange / 2;
        var new_xrange = yrange / screen.height * screen.width;

        this.xmin = xcenter - new_xrange / 2;
        this.xmax = xcenter + new_xrange / 2;
    };

    Viewport.prototype.squareYAxis = function(screen) {
        if (screen.width === 0 || screen.height === 0) return;
        var xrange = this.xmax - this.xmin;
        var yrange = this.ymax - this.ymin;
        var ycenter = this.ymin + yrange / 2;
        var new_yrange = xrange / screen.width * screen.height;

        this.ymin = ycenter - new_yrange / 2;
        this.ymax = ycenter + new_yrange / 2;
    };

    Viewport.prototype.squareCrop = function(screen) {
        // Square axes in a way that is guaranteed to reduce the viewport
        if (this.aspectRatio() > screen.height / screen.width) {
            this.squareYAxis(screen);
        } else {
            this.squareXAxis(screen);
        }
    };

    // rounds the viewport so that it's not more precise than a pixel
    Viewport.prototype.round = function(screen) {
        if (screen.height === 0 || screen.width === 0) return;
        var xrange = this.xmax - this.xmin;
        var yrange = this.ymax - this.ymin;

        var x_pixel_units = xrange / screen.width;
        var y_pixel_units = yrange / screen.height;

        // Do things this way to try to maintain xrange and yrange when panning.
        this.xmin = Rounding.shortestDecimalBetween(
            this.xmin - x_pixel_units / 10,
            this.xmin + x_pixel_units / 10
        );
        this.xmax = Rounding.shortestDecimalBetween(
            this.xmin + xrange - x_pixel_units / 10,
            this.xmin + xrange + x_pixel_units / 10
        );
        this.ymin = Rounding.shortestDecimalBetween(
            this.ymin + y_pixel_units / 10,
            this.ymin - y_pixel_units / 10
        );
        this.ymax = Rounding.shortestDecimalBetween(
            this.ymin + yrange + y_pixel_units / 10,
            this.ymin + yrange - y_pixel_units / 10
        );
    };

    Viewport.prototype.clone = function() {
        return new Viewport(this.xmin, this.xmax, this.ymin, this.ymax);
    };

    // calculates a distance from the origin that is guaranteed to reach out past
    // the edge of the viewport for all values of theta. The actual value doesn't
    // matter much. This is used for clipping and the value will get truncated
    // during the clipping routine. In theory could use a really big number but
    // it's possible that we won't pick a big enough number.
    Viewport.prototype.polarDiameter = function() {
        var d1 = Math.abs(this.xmax),
            d2 = Math.abs(this.xmin);
        var d3 = Math.abs(this.ymax),
            d4 = Math.abs(this.ymin);

        // Distance can be at most sqrt(2)*magnitude of largest limit.
        // the 1.5 gives a little padding
        return 1.5 * Math.max(d1, d2, d3, d4);
    };

    //the largest visible radius. Note: this should always be strictly smaller than polarDiameter
    Viewport.prototype.largestR = function() {
        //if xmin is positive, then xmax is bigger than abs(xmin)
        //if xmax is negative, then -xmin is bigger than abs(xmax)
        return Math.sqrt(
            Math.pow(Math.max(-this.xmin, this.xmax), 2) +
            Math.pow(Math.max(-this.ymin, this.ymax), 2)
        );
    };

    //the smallest visible radius on the screen
    Viewport.prototype.smallestR = function() {
        //origin is visible
        if (this.xmin <= 0 && this.xmax >= 0 && this.ymin <= 0 && this.ymax >= 0) return 0;
        //y-axis is visible: return wherever on that's smallest
        if (this.xmin <= 0 && this.xmax >= 0) return Math.min(Math.abs(this.ymin), Math.abs(this.ymax));
        //x-axis is visible: return wherever on that's smallest
        if (this.ymin <= 0 && this.ymax >= 0) return Math.min(Math.abs(this.xmin), Math.abs(this.xmax));

        // both x & y axes are offscreen. one of the corners is the min.
        // If both negative, then -xmax is positive and smaller.
        // If both positive, then xmin positive and smaller
        return Math.sqrt(
            Math.pow(Math.max(this.xmin, -this.xmax), 2) +
            Math.pow(Math.max(this.ymin, -this.ymax), 2)
        );
    };

    return Viewport;
});

define('graphing/projection', ['require', './viewport'], function(require) {
    var Viewport = require('./viewport');

    // A single object that contains all the information to map from
    // the theoretical space to the canvas space.
    var Projection = function(screen, viewport, settings) {
        this.screen = screen;
        this.viewport = viewport;
        this.settings = settings;
    };

    Projection.prototype.calculateViewportForScreen = function(newScreen) {
        var vp = this.viewport;
        var dw = (newScreen.width / this.screen.width - 1) * (vp.xmax - vp.xmin);
        var dh = (newScreen.height / this.screen.height - 1) * (vp.ymax - vp.ymin);

        var newViewport = new Viewport(vp.xmin - dw / 2, vp.xmax + dw / 2, vp.ymin - dh / 2, vp.ymax + dh / 2);
        newViewport.round(newScreen);

        return newViewport;
    };

    Projection.prototype.mapx = function(x) {
        return (x - this.viewport.xmin) * this.screen.width / (this.viewport.xmax - this.viewport.xmin);
    };

    Projection.prototype.mapy = function(y) {
        return this.screen.height - (y - this.viewport.ymin) * this.screen.height / (this.viewport.ymax - this.viewport.ymin);
    };

    Projection.prototype.map_pt = function(pt) {
        return { x: this.mapx(pt.x), y: this.mapy(pt.y) };
    };

    Projection.prototype.reverse_mapx = function(mapped_x) {
        return mapped_x * (this.viewport.xmax - this.viewport.xmin) / this.screen.width + this.viewport.xmin;
    };

    Projection.prototype.reverse_mapy = function(mapped_y) {
        return (-(mapped_y - this.screen.height) * (this.viewport.ymax - this.viewport.ymin) / this.screen.height + this.viewport.ymin);
    };

    Projection.prototype.reverse_map_pt = function(mapped_pt) {
        return { x: this.reverse_mapx(mapped_pt.x), y: this.reverse_mapy(mapped_pt.y) };
    };

    return Projection;
});

define('graphing/viewporttransformation', ['require', 'pjs', './viewport', './projection'], function(require) {
    var P = require('pjs');
    var Viewport = require('./viewport');
    var Projection = require('./projection');

    var ViewportTransformation = P(function(proto) {
        // Constructor can take 2 arguments for a translation only, 3 arguments
        // for a uniform scaling, or 4 arguments for different scalings along x
        // and y.
        proto.init = function(xOffset, yOffset, xScale, yScale) {
            this.xOffset = xOffset !== undefined ? xOffset : 0;
            this.yOffset = yOffset !== undefined ? yOffset : 0;
            this.xScale = xScale !== undefined ? xScale : 1;
            this.yScale = yScale !== undefined ? yScale : this.xScale;
        };

        proto.compose = function(transformation) {
            return new ViewportTransformation(
                transformation.xScale * this.xOffset + transformation.xOffset,
                transformation.yScale * this.yOffset + transformation.yOffset,
                transformation.xScale * this.xScale,
                transformation.yScale * this.yScale
            );
        };

        proto.lerp = function(transformation, ratio) {
            return new ViewportTransformation(
                (1 - ratio) * this.xOffset + ratio * transformation.xOffset,
                (1 - ratio) * this.yOffset + ratio * transformation.yOffset,
                (1 - ratio) * this.xScale + ratio * transformation.xScale,
                (1 - ratio) * this.yScale + ratio * transformation.yScale
            );
        };

        proto.transformProjection = function(projection) {
            var viewport = projection.viewport;
            var screen = projection.screen;

            var vmidx = (viewport.xmin + viewport.xmax) / 2;
            var vmidy = (viewport.ymin + viewport.ymax) / 2;
            var vminx = vmidx + (viewport.xmin - vmidx) / this.xScale;
            var vmaxx = vmidx + (viewport.xmax - vmidx) / this.xScale;
            var vminy = vmidy + (viewport.ymin - vmidy) / this.yScale;
            var vmaxy = vmidy + (viewport.ymax - vmidy) / this.yScale;

            // Pixel coord vs cartesian coord flip means that voffset_y needs to be flipped.
            var vox = this.xOffset * (vmaxx - vminx) / screen.width;
            var voy = -this.yOffset * (vmaxy - vminy) / screen.height;

            return new Projection(
                projection.screen,
                new Viewport(vminx - vox, vmaxx - vox, vminy - voy, vmaxy - voy),
                projection.settings
            );
        };
    });

    return ViewportTransformation;
});

define('graphing/screen', ['require'], function(require) {
    function Screen(width, height) {
        this.width = width;
        this.height = height;

        return this;
    }

    return Screen;
});

define('loadcss!css/poi', function() {});
// Disable text selection

/* global jQuery */
;
(function($) {

    $.fn.disableTextSelection = function(removeFocus) {

        if (removeFocus) {
            this.each(function() {
                $(this).bind("mousedown touchstart", function() {
                    $(document.activeElement).focusout();
                });
            });
        }

        return this.each(function() {
            $(this).attr('unselectable', 'on').css({
                    '-moz-user-select': 'none',
                    '-webkit-user-select': 'none',
                    'user-select': 'none'
                })
                .each(function() {
                    this.onselectstart = function() { return false; };
                });
        });
    };

})(jQuery);


define("jquery.disabletextselection", function() {});

define('graphing/canvaslayer', ['require', 'jquery', 'pjs', 'browser', 'jquery.disabletextselection'], function(require) {
    var $ = require('jquery');
    var P = require('pjs');
    var Browser = require('browser');
    require('jquery.disabletextselection');

    var CanvasLayer = P(function(layer) {

        layer.init = function() {
            this.$ = $("<div class='dcg-graph-outer'></div>")
                .css('position', 'absolute')
                .css('overflow', 'hidden')
                .disableTextSelection(Browser.IS_IE);

            this.canvas_node = $("<canvas class='dcg-graph-inner'></canvas>")
                .css('position', 'relative')
                .css('display', 'block')
                .disableTextSelection(Browser.IS_IE);

            this.devicePixelRatio = (window.devicePixelRatio || 1);
            this.ctx = this.canvas_node[0].getContext('2d');

            // Canvas used to hold an image of the graph when we're panning/scaling.
            this.unscaledCanvas = document.createElement('canvas');

            // Flag for whether we're in the middle of a pan/scale
            this.transforming = false;

            this.$.append(this.canvas_node);
        };

        layer.resize = function(width, height) {
            // concession to retina iPads, where there is a horrendous performance
            // drop between 1023 pixels, and its full width, 1024 pixels. This
            // problem also occurs on desktop Safari as of version 6, so full screen
            // safari on a retina laptop will still be a bad experience.
            //
            // see minimal examlpe at http://jsbin.com/ulobuh/4
            if (width === 1024 && this.devicePixelRatio === 2) width = 1023;

            // early trap if not changing size
            if (width === this.width && height === this.height) return;

            this.width = width;
            this.height = height;

            this.$.css('width', width + "px")
                .css('height', height + "px");

            this.canvas_node.css('width', width + "px")
                .css('height', height + "px")
                .attr('width', width * this.devicePixelRatio)
                .attr('height', height * this.devicePixelRatio);

            if (this.unscaledCanvas) {
                this.unscaledCanvas.width = width;
                this.unscaledCanvas.height = height;
            }

            this.ctx.scale(this.devicePixelRatio, this.devicePixelRatio);
        };

        // should get overridden by subclass
        layer.redraw = function() {};

        layer.saveUnscaledCanvas = function(projection) {

            // if we've already saved it, don't want to overwrite it. You must release
            // it if you want to resave it.
            if (this.transforming) return;
            this.transforming = true;

            var ctx = this.unscaledCanvas.getContext('2d');
            var width = this.unscaledCanvas.width;
            var height = this.unscaledCanvas.height;
            ctx.clearRect(0, 0, width, height);
            ctx.drawImage(this.canvas_node[0], 0, 0, width, height);
        };

        layer.releaseUnscaledCanvas = function() {
            this.transforming = false;
        };

        layer.paintScaledCanvas = function(transformation) {
            // can't do this if we don't have an unscaledCanvas to scale
            if (!this.unscaledCanvas) return;

            var t = transformation;

            var width = this.ctx.canvas.width;
            var height = this.ctx.canvas.height;

            this.ctx.save();
            this.ctx.clearRect(0, 0, width, height);

            this.ctx.setTransform(
                t.xScale, 0,
                0, t.yScale,
                t.xOffset * this.devicePixelRatio - 0.5 * (t.xScale - 1) * width,
                t.yOffset * this.devicePixelRatio - 0.5 * (t.yScale - 1) * height
            );
            this.ctx.drawImage(this.unscaledCanvas, 0, 0, width, height);
            this.ctx.restore();
        };
    });

    return CanvasLayer;
});

define('graphing/clipping', [], function() {

    var Clipping = {

        TOP: 1,
        BOTTOM: 2,
        LEFT: 4,
        RIGHT: 8,
        ALL: 15,
        X: 12,
        Y: 3,

        POLAR_RADIAN_EQUALITY: 1,
        POLAR_RADIAN_INEQUALITY: 2,
        POLAR_DEGREE_EQUALITY: 3,
        POLAR_DEGREE_INEQUALITY: 4,
        Y_EQUALS: 5,
        X_EQUALS: 6,

        mapSegmentToCanvas: function(segment, viewport, screen, graphType) {
            /* jshint maxcomplexity:15 */
            var output = [];
            var xmin = viewport.xmin;
            var ymin = viewport.ymin;
            var xrange = viewport.xmax - viewport.xmin;
            var yrange = viewport.ymax - viewport.ymin;
            var width = screen.width;
            var height = screen.height;
            var xscale = width / xrange;
            var yscale = -height / yrange;
            var len = segment.length;
            var i, x, y, theta, r;

            if (graphType === Clipping.Y_EQUALS) {

                for (i = 0; i < len; i += 2) {
                    x = (segment[i] - xmin) * xscale - 0.5;
                    y = (segment[i + 1] - ymin) * yscale + height - 0.5;
                    output.push(x, y);
                }

            } else if (graphType === Clipping.X_EQUALS) {

                for (i = 0; i < len; i += 2) {
                    x = (segment[i + 1] - xmin) * xscale - 0.5;
                    y = (segment[i] - ymin) * yscale + height - 0.5;
                    output.push(x, y);
                }

            } else if (graphType === Clipping.POLAR_RADIAN_EQUALITY) {

                for (i = 0; i < segment.length; i += 2) {
                    theta = segment[i];
                    r = segment[i + 1];
                    x = (r * Math.cos(theta) - xmin) * xscale - 0.5;
                    y = (r * Math.sin(theta) - ymin) * yscale + height - 0.5;
                    output.push(x, y);
                }

            } else if (graphType === Clipping.POLAR_RADIAN_INEQUALITY) {

                for (i = 0; i < segment.length; i += 2) {
                    theta = segment[i];
                    r = segment[i + 1];
                    if (r < 0) r = 0;
                    x = (r * Math.cos(theta) - xmin) * xscale - 0.5;
                    y = (r * Math.sin(theta) - ymin) * yscale + height - 0.5;
                    output.push(x, y);
                }

            } else if (graphType === Clipping.POLAR_DEGREE_EQUALITY) {

                for (i = 0; i < segment.length; i += 2) {
                    theta = segment[i] * Math.PI / 180;
                    r = segment[i + 1];
                    x = (r * Math.cos(theta) - xmin) * xscale - 0.5;
                    y = (r * Math.sin(theta) - ymin) * yscale + height - 0.5;
                    output.push(x, y);
                }

            } else if (graphType === Clipping.POLAR_DEGREE_INEQUALITY) {

                for (i = 0; i < segment.length; i += 2) {
                    theta = segment[i] * Math.PI / 180;
                    r = segment[i + 1];
                    if (r < 0) r = 0;
                    x = (r * Math.cos(theta) - xmin) * xscale - 0.5;
                    y = (r * Math.sin(theta) - ymin) * yscale + height - 0.5;
                    output.push(x, y);
                }

            }

            return output;
        },

        clipStrokeEdges: function(segment, viewport) {
            return Clipping.clipFillEdges(segment, viewport, Clipping.ALL, true);
        },

        clipFillEdge: function(input, inside_test, exit_point, is_open) {
            var output = [];
            var push = [].push;
            var start_index;

            if (is_open) { //stroke
                x = input[0];
                y = input[1];
                start_index = 2;
                inside = inside_test(x, y);
                if (inside) output.push(x, y);
            } else { //fill
                x = input[input.length - 2];
                y = input[input.length - 1];
                start_index = 0;
                inside = inside_test(x, y);
            }

            for (var i = start_index; i < input.length; i += 2) {
                var x_prev = x;
                var y_prev = y;
                var inside_prev = inside;

                var x = input[i];
                var y = input[i + 1];
                var inside = inside_test(x, y);

                if (!inside && !inside_prev) {
                    continue;
                }
                if (inside && inside_prev) {
                    output.push(x, y);
                }
                if (inside && !inside_prev) {
                    push.apply(output, exit_point(x, y, x_prev, y_prev));
                    output.push(x, y);
                }
                if (!inside && inside_prev) {
                    push.apply(output, exit_point(x_prev, y_prev, x, y));
                }
            }
            return output;
        },

        clipFillEdges: function(input, viewport, edges, is_open) {
            /* jshint bitwise: false */
            var xmin = viewport.xmin;
            var xmax = viewport.xmax;
            var ymin = viewport.ymin;
            var ymax = viewport.ymax;

            var test_xmin = function(x, y) {
                return x >= xmin;
            };
            var test_xmax = function(x, y) {
                return x <= xmax;
            };
            var test_ymin = function(x, y) {
                return y >= ymin;
            };
            var test_ymax = function(x, y) {
                return y <= ymax;
            };

            var entry_xmin = function(x, y, x2, y2) {
                var dy = y2 - y;
                return [xmin, y + dy * (xmin - x) / (x2 - x)];
            };
            var entry_xmax = function(x, y, x2, y2) {
                var dy = y2 - y;
                return [xmax, y + dy * (xmax - x) / (x2 - x)];
            };
            var entry_ymin = function(x, y, x2, y2) {
                var dx = x2 - x;
                return [x + dx * (ymin - y) / (y2 - y), ymin];
            };
            var entry_ymax = function(x, y, x2, y2) {
                var dx = x2 - x;
                return [x + dx * (ymax - y) / (y2 - y), ymax];
            };

            var output = input;

            if (edges & Clipping.LEFT) {
                output = Clipping.clipFillEdge(input, test_xmin, entry_xmin, is_open);
            }

            if (edges & Clipping.BOTTOM) {
                output = Clipping.clipFillEdge(output, test_ymin, entry_ymin, is_open);
            }

            if (edges & Clipping.RIGHT) {
                output = Clipping.clipFillEdge(output, test_xmax, entry_xmax, is_open);
            }

            if (edges & Clipping.TOP) {
                output = Clipping.clipFillEdge(output, test_ymax, entry_ymax, is_open);
            }

            return output;
        },

        clipAllFillEdges: function(input, viewport) {
            return Clipping.clipFillEdges(input, viewport, Clipping.ALL, false);
        },

        computePolarFill: function(segment, fillTowards, polarInterval) {

            var all_segments = [];

            var theta;
            var start_theta = segment[0];
            var end_theta = start_theta + polarInterval;
            var limited_segment = [];
            all_segments.push(limited_segment);

            // detect 2pi intervals and split into separate segments
            for (var i = 0; i < segment.length; i += 2) {
                theta = segment[i];
                var r = segment[i + 1];
                if (r < 0) r = 0;

                if (theta >= end_theta) {

                    limited_segment = [];
                    all_segments.push(limited_segment);
                    start_theta = segment[i - 2]; //previous theta
                    end_theta = start_theta;
                    // Make sure that end_theta always increases. Adding polarInterval
                    // only once isn't enough because theta might change by more than
                    // polarInterval between two samples.
                    while (theta >= end_theta) end_theta += polarInterval;
                    i -= 4; //go back 1 theta (for loop will +2)

                } else {
                    limited_segment.push(theta, r);
                }

            }

            if (fillTowards === 0) {
                // just fill towards the origin
                for (i = 0; i < all_segments.length; i++) {
                    all_segments[i].push(0, 0);
                }

            } else {

                // shade toward outside. trace around counter clockwise, jump to the
                // outside, and trace around clockwise again at pi/8 intervals. Then
                // go to the starting theta with very large radius.
                var clockwise_step = polarInterval / 16;
                var radius = fillTowards;
                for (i = 0; i < all_segments.length; i++) {
                    var seg = all_segments[i];
                    start_theta = seg[0];
                    end_theta = seg[seg.length - 2];
                    for (theta = end_theta; theta > start_theta; theta -= clockwise_step) {
                        seg.push(theta, radius);
                    }
                    seg.push(start_theta, radius);
                }

            }

            return all_segments;
        },

        computeCartesianFill: function(segment, fillTowards) {
            // copy the incoming segment and push it to the list
            segment = segment.slice();

            // add a couple points that decide which direction we fill
            segment.push(segment[segment.length - 2], fillTowards);
            segment.push(segment[0], fillTowards);

            return [segment];
        }
    };

    return Clipping;
});

define('graphing/constants', [], function() {
    return {
        ANIMATE_ZOOM_DURATION: 500,
        DOUBLETAP_ZOOM: 2.0,
        ZOOM_FACTOR: 1.125,

        MAX_DOTTED_SEGMENTS: 1000,
        STROKE_ALPHA: 0.7,
        HIGHLIGHTED_STROKE_ALPHA: 1,
        FILL_ALPHA: 0.4,
        POINT_ALPHA: 0.9,
        HIGHLIGHTED_POINT_ALPHA: 0.6,
        POLAR_ALPHA: 0.2,
        POI_ALPHA: 0.01
    };
});

//TODO - something is slow about this when zoomed way out.
//       could be subpixel rendering.
define('graphing/dasheddrawer', ['require', './constants', 'math/distance'], function(require) {
    var constants = require('./constants');
    var Distance = require('math/distance');

    function DashedDrawer(ctx, seglen) {
        this.pattern = [11, 7];
        this.replen = this.pattern[0] + this.pattern[1];

        if (seglen !== null && seglen / this.replen > constants.MAX_DOTTED_SEGMENTS) {
            this.pattern[0] = seglen * this.pattern[0] / this.replen / constants.MAX_DOTTED_SEGMENTS;
            this.pattern[1] = seglen * this.pattern[1] / this.replen / constants.MAX_DOTTED_SEGMENTS;
        }

        this.pstate = 0; // 0 being "draw a line"
        this.dstaccum = 0.0;
        this.px = null;
        this.py = null;
        this.ctx = ctx;

        return this;
    }

    DashedDrawer.getTotalSegmentLength = function(segment) {
        if (segment.length < 4) return 0;

        var len = 0;
        var x = segment[0];
        var y = segment[1];

        for (var i = 2; i < segment.length; i += 2) {
            var nx = segment[i];
            var ny = segment[i + 1];

            len += Distance.hypot(nx - x, ny - y);

            x = nx;
            y = ny;
        }

        return len;
    };

    DashedDrawer.prototype.start = function(x, y) {
        if (!this.ctx.desmos_batching) this.ctx.beginPath();
        this.px = x;
        this.py = y;
    };

    DashedDrawer.prototype.next = function(x, y) {
        var dstlimit = this.pattern[this.pstate];
        var dstincr = Math.sqrt(Math.pow(x - this.px, 2) + Math.pow(y - this.py, 2));

        if (dstincr > 0.00001) {
            while (dstincr + this.dstaccum >= dstlimit) {
                // Draw up to the phase change, change phase.
                // compute actual line-to point
                var incrx = x - this.px;
                var incry = y - this.py;

                // Scaling factor
                var linedst = dstlimit - this.dstaccum;
                incrx *= linedst / dstincr;
                incry *= linedst / dstincr;

                // Draw if in the draw state
                if (this.pstate === 0) {
                    this.ctx.moveTo(this.px, this.py);
                    this.ctx.lineTo(this.px + incrx, this.py + incry);
                }

                // Reset the accumulator
                this.dstaccum = 0.0;
                this.px += incrx;
                this.py += incry;
                // Flip the pattern state
                this.pstate = 1 - this.pstate;
                dstlimit = this.pattern[this.pstate];
                dstincr -= linedst;
            }

            // Draw up to the target point.
            if (this.pstate === 0) {
                this.ctx.moveTo(this.px, this.py);
                this.ctx.lineTo(x, y);
            }
        }
        this.px = x;
        this.py = y;
        this.dstaccum += dstincr;
    };

    DashedDrawer.prototype.skip = function(x, y) {
        this.px = x;
        this.py = y;
    };

    DashedDrawer.prototype.close = function() {
        if (!this.ctx.desmos_batching) this.ctx.stroke();

        this.pstate = 0; // 0 being "draw a line"
        this.dstaccum = 0.0;
        this.px = null;
        this.py = null;
    };

    return DashedDrawer;
});

define('graphing/graphslayer', ['require', 'pjs', 'underscore', './canvaslayer', './clipping', './dasheddrawer', './constants', './viewport', 'graphing/graphmode'], function(require) {
    var P = require('pjs');
    var _ = require('underscore');
    var CanvasLayer = require('./canvaslayer');
    var Clipping = require('./clipping');
    var DashedDrawer = require('./dasheddrawer');
    var constants = require('./constants');
    var Viewport = require('./viewport');
    var GRAPHMODE = require('graphing/graphmode');

    var screenToClippingViewport = function(screen) {
        return new Viewport(-3, screen.width + 3, -3, screen.height + 3);
    };

    var GraphsLayer = P(CanvasLayer, function(layer) {

        layer.redraw = function(projection, graphSketches, drawOrder) {
            var screen = projection.screen;

            // make sure that this is the correct size
            this.resize(screen.width, screen.height);
            // Clear out the drawing area
            this.ctx.clearRect(0, 0, screen.width, screen.height);
            this.redrawToCtx(this.ctx, projection, graphSketches, drawOrder);

        };

        layer.redrawToCtx = function(ctx, projection, graphSketches, drawOrder) {
            // Do the drawing of the segments
            if (drawOrder === undefined || drawOrder.length < _.size(graphSketches)) {
                // If we don't have a drawOrder, or it doesn't include all of our graphSketches then make a new order.
                drawOrder = _.keys(graphSketches);
            }
            drawOrder.forEach(function(id) {
                var sketch = graphSketches[id];
                if (sketch !== undefined) {
                    if (sketch.visible) {
                        GraphsLayer.drawSketchToCtx(graphSketches[id], ctx, projection);
                    }
                }
            });
        };

    });

    GraphsLayer.eachSegment = function(sketch, fn) {
        for (var i = 0; i < sketch.branches.length; i++) {
            var branch = sketch.branches[i];
            for (var j = 0; j < branch.segments.length; j++) {
                var segment = branch.segments[j];
                fn(branch, segment);
            }
        }
    };

    GraphsLayer.drawSketchToCtx = function(sketch, ctx, projection) {
        if (!sketch.branches || !sketch.branches.length) return;
        ctx.lineWidth = projection.settings.graphLineWidth;
        ctx.strokeStyle = sketch.color;
        ctx.fillStyle = sketch.color;
        ctx.lineJoin = "round";
        ctx.lineCap = "round";

        //If we're drawing points, draw points and return
        var allowMovable = !!projection.settings.takingScreenshot;
        ctx.desmos_batching = true;
        ctx.beginPath();
        ctx.save();
        GraphsLayer.eachSegment(sketch, function(branch, segment) {
            if (branch.graphMode === GRAPHMODE.XYPOINT ||
                (branch.graphMode === GRAPHMODE.XYPOINT_MOVABLE && allowMovable)) {
                GraphsLayer.drawPointsToCtx(ctx, projection, segment, branch.style);
            }
        });

        ctx.globalAlpha = constants.POINT_ALPHA;
        ctx.stroke();
        ctx.restore();
        ctx.desmos_batching = false;

        //If we're filling, fill.  No batching, because we want polar to shade deeper in overlaps
        GraphsLayer.eachSegment(sketch, function(branch, segment) {
            if (branch.graphMode === GRAPHMODE.XYPOINT || branch.graphMode === GRAPHMODE.XYPOINT_MOVABLE) return;
            var graphMode = GRAPHMODE.Y;
            if (branch.flip) graphMode = GRAPHMODE.X;
            if (branch.graphMode) graphMode = branch.graphMode;

            if (graphMode === GRAPHMODE.POLYGONFILL) {
                GraphsLayer.fillPolygonToCtx(ctx, projection, segment);
            } else {
                var op = branch.operator;
                var fill = (
                    op == "<" || op == ">" || op == "<=" || op == ">=" ||
                    op == "\\leq" || op == "\\le" || op == "\\geq" || op == "\\ge"
                );
                var fill_d = (op == "<=" || op == "<" || op == "\\leq" || op == "\\le");

                if (fill) GraphsLayer.fillGraphStrokeToCtx(ctx, projection, segment, fill_d, graphMode);
            }
        });

        //If we're drawing segments, draw them
        ctx.desmos_batching = true;
        ctx.beginPath();
        GraphsLayer.eachSegment(sketch, function(branch, segment) {
            if (branch.graphMode === GRAPHMODE.XYPOINT || branch.graphMode === GRAPHMODE.XYPOINT_MOVABLE) return;
            var graphMode = GRAPHMODE.Y;
            if (branch.flip) graphMode = GRAPHMODE.X;
            if (branch.graphMode) graphMode = branch.graphMode;

            var op = branch.operator;
            // != is used for shade-between lines which should be dashed but not filled
            var dotted = (op == "<" || op == ">" || op == '!=' || sketch.style === 'dashed');

            GraphsLayer.drawGraphStrokeToCtx(ctx, projection, segment, dotted, graphMode, op);
        });
        ctx.globalAlpha = constants.STROKE_ALPHA;
        ctx.stroke();
        ctx.globalAlpha = 1.0;
        ctx.desmos_batching = false;
    };

    GraphsLayer.drawGraphStrokeToCtx = function(ctx, projection, segment, dotted, graphMode, op) {
        ctx.globalAlpha = projection.settings.highlight ?
            constants.HIGHLIGHTED_STROKE_ALPHA : constants.STROKE_ALPHA;

        // takes the raw array of numbers and maps it to the canvas. Then it clips.
        var graphType = GraphsLayer.getClippingGraphType(graphMode, op !== "=", projection.settings);
        var scaled = Clipping.mapSegmentToCanvas(segment, projection.viewport, projection.screen, graphType);
        var clipped = Clipping.clipStrokeEdges(scaled, screenToClippingViewport(projection.screen));
        var i;

        // draws the clipped segment as a solid curve
        if (!dotted) {

            if (!ctx.desmos_batching) ctx.beginPath();
            ctx.moveTo(clipped[0], clipped[1]);
            for (i = 0; i < clipped.length; i += 2) {
                ctx.lineTo(clipped[i], clipped[i + 1]);
            }
            if (!ctx.desmos_batching) ctx.stroke();

            // draws the clipped segment as a dashed curve
        } else {

            var buf = new DashedDrawer(ctx, DashedDrawer.getTotalSegmentLength(clipped));
            buf.start(clipped[0], clipped[1]);
            for (i = 2; i < clipped.length; i += 2) {
                buf.next(clipped[i], clipped[i + 1]);
            }
            buf.close();

        }

        ctx.globalAlpha = 1.0;
    };

    GraphsLayer.mapPointToScreen = function(projection, x, y) {
        // if the point is more than 20px off the screen in any direction, we just
        // don't draw it.
        var padding = 20;
        var mx = projection.mapx(x) - 0.5;
        if (mx < -padding || mx > projection.screen.width + padding) return null;

        var my = projection.mapy(y) - 0.5;
        if (my < -padding || my > projection.screen.height + padding) return null;

        return { x: mx, y: my };
    };

    GraphsLayer.drawPointToCtx = function(ctx, projection, x, y, alpha, style) {

        var pt = GraphsLayer.mapPointToScreen(projection, x, y);
        var size;
        if (!pt) return false;

        ctx.globalAlpha = projection.settings.highlight ?
            constants.HIGHLIGHTED_POINT_ALPHA : constants.POINT_ALPHA;
        if (alpha) ctx.globalAlpha = alpha;
        ctx.globalAlpha = constants.POINT_ALPHA;
        if (!ctx.desmos_batching) ctx.beginPath();
        // For some reason we need a full polygon, but a small one.

        if (style === 'cross') {
            // The values for this and the open style are largely eyeballed so they
            // seem cohesize when mixed. They may change based on other peoples eyeballs
            size = projection.settings.pointLineWidth * 0.4;
            ctx.moveTo(pt.x - size, pt.y - size);
            ctx.lineTo(pt.x + size, pt.y + size);
            ctx.moveTo(pt.x + size, pt.y - size);
            ctx.lineTo(pt.x - size, pt.y + size);
            ctx.lineWidth = projection.settings.pointLineWidth * 0.3;
        } else if (style === 'open') {
            size = projection.settings.pointLineWidth * 0.5;
            ctx.moveTo(pt.x + size, pt.y);
            ctx.arc(pt.x, pt.y, size, 0, Math.PI * 2, true);
            ctx.closePath();
            ctx.fillStyle = "white";
            ctx.lineWidth = projection.settings.pointLineWidth * 0.25;
            ctx.fill();
        } else {
            ctx.moveTo(pt.x - 0.1, pt.y - 0.1);
            ctx.lineTo(pt.x - 0.1, pt.y + 0.1);
            ctx.lineTo(pt.x + 0.1, pt.y + 0.1);
            ctx.lineTo(pt.x + 0.1, pt.y - 0.1);
        }
        if (!ctx.desmos_batching) ctx.stroke();

        ctx.globalAlpha = 1.0;

        return true;
    };

    GraphsLayer.drawPointsToCtx = function(ctx, projection, segment, style) {
        ctx.lineWidth = projection.settings.pointLineWidth;
        for (var i = 0; i < segment.length; i++) {
            GraphsLayer.drawPointToCtx(ctx, projection, segment[i][0], segment[i][1], false, style);
        }
    };

    GraphsLayer.fillGraphStrokeToCtx = function(ctx, projection, segment, fillDown, graphMode) {
        ctx.globalAlpha = (graphMode === GRAPHMODE.POLAR) ? constants.POLAR_ALPHA : constants.FILL_ALPHA;

        var fill_paths = null;
        var clipped_edges = null;
        var fillTowards;

        if (graphMode === GRAPHMODE.POLAR) {

            clipped_edges = Clipping.ALL;
            var radius = fillDown ? 0 : projection.viewport.polarDiameter();
            var interval = projection.settings.degreeMode ? 180.0 : 2 * Math.PI;
            fill_paths = Clipping.computePolarFill(segment, radius, interval);

        } else if (graphMode === GRAPHMODE.Y) {

            clipped_edges = Clipping.Y;
            fillTowards = fillDown ? projection.viewport.ymin : projection.viewport.ymax;
            fill_paths = Clipping.computeCartesianFill(segment, fillTowards);

        } else if (graphMode === GRAPHMODE.X) {

            clipped_edges = Clipping.X;
            fillTowards = fillDown ? projection.viewport.xmin : projection.viewport.xmax;
            fill_paths = Clipping.computeCartesianFill(segment, fillTowards);

        }

        // scale, clip, and then draw each fill path
        var clipped_viewport = screenToClippingViewport(projection.screen);
        for (var i = 0; i < fill_paths.length; i++) {

            // scale the segment
            var map_graphType = GraphsLayer.getClippingGraphType(graphMode, true, projection.settings);
            var scaled = Clipping.mapSegmentToCanvas(fill_paths[i], projection.viewport, projection.screen, map_graphType);

            // clip the segment
            var clipped = Clipping.clipFillEdges(scaled, clipped_viewport, clipped_edges);

            // draw the segment
            if (clipped.length >= 6) {
                ctx.beginPath();

                ctx.moveTo(clipped[0], clipped[1]);
                for (var j = 2; j < clipped.length; j += 2) {
                    ctx.lineTo(clipped[j], clipped[j + 1]);
                }

                ctx.closePath();
                ctx.fill();
            }
        }

        ctx.globalAlpha = 1.0;
    };

    GraphsLayer.fillPolygonToCtx = function(ctx, projection, segment) {
        ctx.globalAlpha = constants.FILL_ALPHA;

        var clipped_viewport = screenToClippingViewport(projection.screen);

        var scaled = Clipping.mapSegmentToCanvas(segment, projection.viewport, projection.screen, Clipping.Y_EQUALS);

        // clip the segment
        var clipped = Clipping.clipFillEdges(scaled, clipped_viewport, Clipping.ALL);

        // draw the segment
        if (clipped.length >= 6) {
            ctx.beginPath();

            ctx.moveTo(clipped[0], clipped[1]);
            for (var j = 2; j < clipped.length; j += 2) {
                ctx.lineTo(clipped[j], clipped[j + 1]);
            }

            ctx.closePath();
            ctx.fill();
        }

        ctx.globalAlpha = 1.0;
    };

    GraphsLayer.getClippingGraphType = function(graphMode, isInequality, settings) {
        switch (graphMode) {

            case GRAPHMODE.X:
                return Clipping.X_EQUALS;

            case GRAPHMODE.IMPLICIT:
            case GRAPHMODE.PARAMETRIC:
            case GRAPHMODE.Y:
                return Clipping.Y_EQUALS;

            case GRAPHMODE.POLAR:
                if (settings.degreeMode) {
                    return isInequality ? Clipping.POLAR_DEGREE_INEQUALITY : Clipping.POLAR_DEGREE_EQUALITY;
                } else {
                    return isInequality ? Clipping.POLAR_RADIAN_INEQUALITY : Clipping.POLAR_RADIAN_EQUALITY;
                }

        }
    };

    return GraphsLayer;
});

define('graphing/poidotslayer', ['require', 'loadcss!css/poi', 'pjs', './graphslayer', './canvaslayer', 'math/poi', './constants'], function(require) {

    // TODO - we have both a poidots layer and poilabels layer. This is including the css for both layers. Either
    // split the css into two separate files or combine the two layers into a single file
    require('loadcss!css/poi');

    var P = require('pjs');
    var GraphsLayer = require('./graphslayer');
    var CanvasLayer = require('./canvaslayer');
    var POITYPE = require('math/poi');
    var constants = require('./constants');

    // TODO - rename from 'POIDotsLayer to something like SketchStyleLayer.
    var POIDotsLayer = P(CanvasLayer, function(layer, _super) {

        layer.init = function() {
            _super.init.apply(this, arguments);
            this.$.addClass('dcg-poi-dots-layer');
        };

        layer.redraw = function(projection, graphSketches) {

            // make sure that this is the correct size
            this.resize(projection.screen.width, projection.screen.height);

            // Clear out the drawing area
            this.ctx.clearRect(0, 0, projection.screen.width, projection.screen.height);

            // Iterate through each graphSketch, find the ones that should showPOI
            // and draw the poi dots. Also, we save the dots we drew.
            var savedPOI = [];
            for (var id in graphSketches) {
                var sketch = graphSketches[id];

                if (sketch.visible) {

                    if (sketch.showHighlight) {
                        POIDotsLayer.drawSketchHighlight(sketch, this.ctx, projection);
                    }

                    var pois = sketch.getPOI();
                    if (
                        sketch.showPOI ||
                        // Always run this routine on defined POI. They aren't drawn to the screen, but they
                        // need to be available to be opened. This is easier in the current system
                        // than ensuring that showPOI is always set to true for these sketches.
                        (pois.length && pois[0].type === POITYPE.DEFINITION)
                    ) {
                        savedPOI.push.apply(savedPOI, POIDotsLayer.drawPOIs(pois, this.ctx, "#AAAAAA", projection));
                    }
                }
            }
            this.savedPOI = savedPOI;
        };

        layer.getDrawnPOI = function() {
            return this.savedPOI || [];
        };
    });

    POIDotsLayer.drawSketchHighlight = function(sketch, ctx, projection) {
        projection.settings.setProperty('highlight', true);
        GraphsLayer.drawSketchToCtx(sketch, ctx, projection);
        projection.settings.setProperty('highlight', false);
    };

    POIDotsLayer.drawPOIs = function(pois, ctx, color, projection) {

        ctx.lineWidth = projection.settings.pointLineWidth;
        ctx.strokeStyle = color || "#AAAAAA";
        ctx.fillStyle = color || "#AAAAAA";
        ctx.lineJoin = "round";
        ctx.lineCap = "round";

        var oldGlobalAlpha = ctx.globalAlpha;
        ctx.globalAlpha = constants.POI_ALPHA;

        var poiOnScreen = [];

        var i, plen = pois.length;
        var poi;

        // we don't draw dots for POI that are defined. There is already a dot
        // for the point on the screen. But, we want there to be a POI registered
        // still, so we add it to the list of poiOnScreen
        if (plen && pois[0].type === POITYPE.DEFINITION) {
            for (i = 0; i < plen; i++) {
                poi = pois[i];
                if (GraphsLayer.mapPointToScreen(projection, poi.x, poi.y)) {
                    poiOnScreen.push(poi);
                }
            }
        }

        // actually draw them on screen
        else {
            for (i = 0; i < plen; i++) {
                poi = pois[i];
                if (GraphsLayer.drawPointToCtx(ctx, projection, poi.x, poi.y, constants.POI_ALPHA)) {
                    poiOnScreen.push(poi);
                }
            }
        }

        ctx.globalAlpha = oldGlobalAlpha;
        return poiOnScreen;
    };

    return POIDotsLayer;
});

define('graphing/domlayer', ['require', 'pjs', 'jquery', 'browser', 'jquery.disabletextselection'], function(require) {
    var P = require('pjs');
    var $ = require('jquery');
    var Browser = require('browser');
    require('jquery.disabletextselection');

    var DOMLayer = P(function(layer) {

        layer.init = function($root) {
            this.$ = $("<div class='dcg-graph-outer'></div>")
                .css('position', 'absolute')
                .css('overflow', 'hidden')
                .disableTextSelection(Browser.IS_IE);

            this.dom_node = $("<div></div>")
                .css('position', 'relative')
                .css('display', 'block')
                .disableTextSelection(Browser.IS_IE);

            this.$root = $root;
            this.$.append(this.dom_node);
        };

        // can't use jquery addClass and removeClass because they are slow on ipad.
        // the problem appears to be that jquery implementation keeps setting the
        // className property of the element even if nothing has changed. In turn,
        // ios appears to rerender everything since .className was set. So we only
        // add/remove the class if it'll change the className of the body.
        layer.addGlobalClass = function(className) {
            if (!this.$root.hasClass(className)) {
                this.$root.addClass(className);
            }
        };
        layer.removeGlobalClass = function(className) {
            if (this.$root.hasClass(className)) {
                this.$root.removeClass(className);
            }
        };

        layer.resize = function(width, height) {

            // early trap if not changing size
            if (width === this.width && height === this.height) return;

            this.width = width;
            this.height = height;

            this.$.css('width', width + "px")
                .css('height', height + "px");

            this.dom_node.css('width', width + "px")
                .css('height', height + "px");
        };

        // should get overridden by subclass
        layer.redraw = function() {};
    });

    return DOMLayer;
});

define('graphing/poilabelslayer', ['require', 'pjs', 'jquery', './domlayer', './label', 'graphing/graphmode', 'math/poi'], function(require) {
    var P = require('pjs');
    var $ = require('jquery');
    var DOMLayer = require('./domlayer');
    var Label = require('./label');
    var GRAPHMODE = require('graphing/graphmode');
    var POITYPE = require('math/poi');

    var POILabelsLayer = P(DOMLayer, function(layer, _super) {

        layer.init = function(width, height, $root) {
            _super.init.call(this, width, height, $root);
            this.$.addClass('dcg-poi-labels-layer');
        };

        layer.redraw = function(projection, graphSketches) {

            // make sure that this is the correct size
            this.resize(projection.screen.width, projection.screen.height);

            // Clear out the drawing area
            this.dom_node.find('.dcg-poi').remove();

            // check if an old hoveredPOI was set and clear it out if so
            var hoveredPOI = this.hoveredPOI;
            var hoveredSketch = hoveredPOI ? hoveredPOI.sketch : null;
            var foundHoveredSketch = false;

            // Iterate through each graphSketch, find the opened poi and draw them
            // also saves which ones were drawn.
            var savedPOI = [];
            for (var id in graphSketches) {
                var sketch = graphSketches[id];
                if (sketch === hoveredSketch) foundHoveredSketch = true;
                if (!sketch.visible) continue;

                var pois = POILabelsLayer.drawOpenPOI(sketch, this.dom_node, projection);
                if (pois.length) {
                    savedPOI.push.apply(savedPOI, pois);
                }
            }

            // we had a hoveredPOI set but the sketch isn't there any more. clear out
            // the hoverdPOI property.
            if (!foundHoveredSketch) {
                hoveredPOI = this.hoveredPOI = null;
            }

            if (hoveredPOI && hoveredPOI.sketch.visible) {

                if (!hoveredPOI.isOpen()) {
                    POILabelsLayer.drawHoveredPOI(this.dom_node, hoveredPOI, projection);
                    this.addGlobalClass('dcg-mouse-over-closed-poi');
                } else {
                    this.addGlobalClass('dcg-mouse-over-opened-poi');
                }

            } else {

                this.removeGlobalClass('dcg-mouse-over-closed-poi');
                this.removeGlobalClass('dcg-mouse-over-opened-poi');

            }

            this.savedPOI = savedPOI;
        };

        layer.getDrawnPOI = function() {
            return this.savedPOI || [];
        };

    });

    POILabelsLayer.getPointLabel = function(poi_in, viewport) {
        var xscale = viewport.xmax - viewport.xmin;
        var yscale = viewport.ymax - viewport.ymin;
        var labels;
        var graphMode = poi_in.getGraphMode();

        if (graphMode === GRAPHMODE.XYPOINT || graphMode === GRAPHMODE.XYPOINT_MOVABLE) {

            labels = [
                Label.value(poi_in.x, xscale),
                Label.value(poi_in.y, yscale)
            ];

        } else {

            var flip = graphMode === GRAPHMODE.X;
            var independent = (flip) ? poi_in.y : poi_in.x;
            var fn = poi_in.getCompiledFunction();
            labels = Label.point(independent, xscale, yscale, fn);

            if (flip) {
                var tmp = labels[0];
                labels[0] = labels[1];
                labels[1] = tmp;
            }

        }
        var x_label = (
            labels[0].superscript ? labels[0].mantissa + '<sup>' + labels[0].superscript + '</sup>' : labels[0].string
        );
        var y_label = (
            labels[1].superscript ? labels[1].mantissa + '<sup>' + labels[1].superscript + '</sup>' : labels[1].string
        );
        return {
            x: labels[0].value,
            x_label: x_label,
            y: labels[1].value,
            y_label: y_label,
            is_hole: !isFinite(labels[1].value)
        };
    };

    // TODO - cleanup. Copied and modified from main/grapher.js
    POILabelsLayer.createSinglePOI = function(poi_in, viewport) {

        var pt = POILabelsLayer.getPointLabel(poi_in, viewport);
        var hole = pt.is_hole ? ' dcg-hole' : '';
        var real = poi_in.type === POITYPE.DEFINITION ? ' dcg-real' : '';

        var x_label = pt.x_label.replace("Ï€", "<span class='dcg-pi'>Ï€</span>");
        var y_label = pt.y_label.replace("Ï€", "<span class='dcg-pi'>Ï€</span>");

        return $(
            '<div class="dcg-tracept dcg-poi' + hole + real + '">' +
            '  <div class="dcg-pt"></div>' +
            '  <div class="dcg-label">' + x_label + ', ' + y_label + '</div>' +
            '  <div class="dcg-arrow""></div>' +
            '</div>'
        );
    };

    POILabelsLayer.drawHoveredPOI = function(dom, poi, projection) {
        var screen_x = projection.mapx(poi.x);
        var screen_y = projection.mapy(poi.y);

        // ensure is on screen. TODO - duplicate of code elsewhere. Might want to centralize that.
        if (
            screen_x > -20 && screen_y > -20 &&
            screen_x < projection.screen.width + 20 && screen_y < projection.screen.height + 20
        ) {
            var dom_poi = POILabelsLayer.createSinglePOI(poi, projection.viewport);
            dom_poi.css({
                left: screen_x + "px",
                top: screen_y + "px"
            });
            dom_poi.addClass('dcg-mouseover');
            dom.append(dom_poi);
        }

    };

    POILabelsLayer.drawOpenPOI = function(sketch, dom, projection) {

        var pois = sketch.openPOI;
        if (!pois.length) return [];

        var poiOnScreen = [];
        for (var i = 0; i < pois.length; i++) {
            var poi = pois[i];
            var screen_x = projection.mapx(poi.x);
            var screen_y = projection.mapy(poi.y);

            // ensure is on screen. TODO - duplicate of code elsewhere. Might want to centralize that.
            if (
                screen_x > -20 && screen_y > -20 &&
                screen_x < projection.screen.width + 20 && screen_y < projection.screen.height + 20
            ) {
                var dom_poi = POILabelsLayer.createSinglePOI(poi, projection.viewport);
                dom_poi.css({
                    left: screen_x + "px",
                    top: screen_y + "px"
                });
                dom_poi.addClass('dcg-opened');

                dom.append(dom_poi);
                poiOnScreen.push(poi);
            }
        }

        return poiOnScreen;
    };

    return POILabelsLayer;
});

define('graphing/stepnumber', ['require', 'pjs'], function(require) {
    var P = require('pjs');

    // a reference to a ctx to do measurements on. Shared between
    // all instances of StepNumber
    var STATIC_CTX = document.createElement('canvas').getContext('2d');

    var StepNumber = P(function(proto) {

        proto.init = function(label, fontSize) {
            this._label = label;
            this._fontSize = fontSize;
            this._layout = this._computeLayout(label, fontSize);
        };

        // TODO - memoize
        // the layout assumes text is centered both vertically and horizontall when drawn on the ctx.
        // That's why width/2 and height/2 is used so often.
        proto._computeLayout = function(label, fontSize) {
            var layout = {};

            if (label.superscript) {

                layout.mantissa_height = fontSize;
                StepNumber.setCtxFontSize(STATIC_CTX, layout.mantissa_height);
                layout.mantissa_width = STATIC_CTX.measureText(label.mantissa).width;

                layout.superscript_height = Math.round(0.8 * fontSize);
                StepNumber.setCtxFontSize(STATIC_CTX, layout.superscript_height);
                layout.superscript_width = STATIC_CTX.measureText(label.superscript).width;

                layout.mantissa_x = 0;
                layout.mantissa_y = fontSize / 5;
                layout.superscript_x = layout.mantissa_width / 2 + layout.superscript_width / 2;
                layout.superscript_y = -fontSize / 4;

                layout.top = layout.superscript_y - layout.superscript_height / 2;
                layout.bottom = layout.mantissa_y + layout.mantissa_height / 2;
                layout.left = layout.mantissa_x - layout.mantissa_width / 2;
                layout.right = layout.superscript_x + layout.superscript_width / 2;

            } else {

                layout.mantissa_height = fontSize;
                StepNumber.setCtxFontSize(STATIC_CTX, fontSize);
                layout.mantissa_width = STATIC_CTX.measureText(label.string).width;

                layout.mantissa_x = 0;
                layout.mantissa_y = 0;

                layout.top = layout.mantissa_y - layout.mantissa_height / 2;
                layout.bottom = layout.mantissa_y + layout.mantissa_height / 2;
                layout.left = layout.mantissa_x - layout.mantissa_width / 2;
                layout.right = layout.mantissa_x + layout.mantissa_width / 2;

            }

            return layout;
        };

        proto.getRect = function() {
            return this.getRectWhenCenteredAt({ x: 0, y: 0 });
        };

        proto.getRectWhenCenteredAt = function(centerPt) {
            return {
                left: this._layout.left + centerPt.x,
                right: this._layout.right + centerPt.x,
                top: this._layout.top + centerPt.y,
                bottom: this._layout.bottom + centerPt.y
            };
        };

        proto.getWidth = function() {
            return this._layout.right - this._layout.left;
        };

        proto.getHeight = function() {
            return this._layout.bottom - this._layout.top;
        };

        proto.clampBoundsWithinRect = function(centerPt, rect) {
            var clampedCenterPt = {};

            if (centerPt.x + this._layout.left < rect.left) {
                clampedCenterPt.x = rect.left - this._layout.left;
            } else if (centerPt.x + this._layout.right > rect.right) {
                clampedCenterPt.x = rect.right - this._layout.right;
            } else {
                clampedCenterPt.x = centerPt.x;
            }

            if (centerPt.y + this._layout.top < rect.top) {
                clampedCenterPt.y = rect.top - this._layout.top;
            } else if (centerPt.y + this._layout.bottom > rect.bottom) {
                clampedCenterPt.y = rect.bottom - this._layout.bottom;
            } else {
                clampedCenterPt.y = centerPt.y;
            }

            return clampedCenterPt;
        };

        proto.getValue = function() {
            return this._label.value;
        };

        // TODO - memioze
        proto.getMinusWidth = function() {
            if (this.getValue() < 0) {
                StepNumber.setCtxFontSize(STATIC_CTX, this._fontSize);
                return STATIC_CTX.measureText("-1").width - STATIC_CTX.measureText("1").width;
            } else {
                return 0;
            }
        };

        proto.getString = function() {
            if (this._label.superscript) {
                return this._label.mantissa + '^' + this._label.superscript;
            } else {
                return this._label.string;
            }
        };

        proto.drawCenteredAt = function(ctx, centerPt) {
            var x = centerPt.x;
            var y = centerPt.y;

            ctx.save();
            StepNumber.setCtxFontSize(ctx, this._fontSize);

            if (this._label.superscript) {
                ctx.fillText(this._label.mantissa, this._layout.mantissa_x + x, this._layout.mantissa_y + y);
                ctx.fillText(this._label.superscript, this._layout.superscript_x + x, this._layout.superscript_y + y);
            } else {
                ctx.fillText(this._label.string, this._layout.mantissa_x + x, this._layout.mantissa_y + y);
            }

            ctx.restore();
        };

    });

    StepNumber.setCtxFontSize = function(ctx, fontSize) {
        ctx.font = fontSize + "px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
    };

    return StepNumber;
});

define('graphing/computestepsizes', ['require', './stepnumber', './label'], function(require) {
    var StepNumber = require('./stepnumber');
    var Label = require('./label');

    var ComputeStepSizes = {};

    var eachStep = function(min, max, step, func) {
        var nmin = Math.ceil(min / step);
        var nmax = Math.floor(max / step);
        var invstep = 1 / step;
        if (nmin > nmax) return;
        // If step===0, this would loop forever. This is designed for drawing
        // gridlines to a screen, so it shouldn't need to use more steps than
        // there are pixels.
        if (nmax - nmin > 10000) return;
        for (var n = nmin; n <= nmax; n++) func(n / invstep);
    };

    ComputeStepSizes.RATIONAL_STEPS = {
        base: 10,
        major: [1, 2, 5],
        minor: [4, 4, 5]
    };

    ComputeStepSizes.PI_STEPS = {
        base: 10,
        major: [Math.PI, 2 * Math.PI, 5 * Math.PI],
        minor: [4, 4, 5]
    };

    ComputeStepSizes.PI_FRAC_STEPS = {
        base: 2,
        major: [Math.PI / 3],
        minor: [3]
    };

    function generateSteps(step) {
        if (!step) return ComputeStepSizes.RATIONAL_STEPS;

        return {
            base: 10,
            major: [step, 2 * step, 5 * step],
            minor: [4, 4, 5]
        };
    }

    // TODO - test
    ComputeStepSizes.bestStep = function(exact, steps) {

        // JM: What does this mean...

        /* 1 + xrange/bestMultiple <= expectedX
         * xrange/(expectedX-1) <= bestMultiple
         * xrange/(expectedX-1) <= mult*base^exp
         * (xrange/expectedX-1) / mult <= base^exp
         * ceil(log((range/expectedX-1)/mult)/log(base)) = exp
         */
        var major, bestMajor = Infinity,
            bestMinor, exp, num;
        for (var i = 0; i < steps.major.length; i++) {
            major = steps.major[i];
            exp = Math.ceil(Math.log(exact / major) / Math.log(steps.base));
            num = major * Math.pow(steps.base, exp);

            if (num < bestMajor) {
                bestMajor = num;
                bestMinor = bestMajor / steps.minor[i];
            }
        }

        return { major: bestMajor, minor: bestMinor };
    };

    // simply generate the labels and make sure there is space between them.
    // TODO - test
    ComputeStepSizes.countStepsInRange = function(min, max, step) {
        return 1 + (max - min) / step;
    };

    ComputeStepSizes.calculateSpaceBetweenRects = function(rect1, rect2) {
        var vertSpace;
        var horizSpace;

        if (rect1.right < rect2.left) {
            horizSpace = rect2.left - rect1.right;
        } else if (rect2.right < rect1.left) {
            horizSpace = rect1.left - rect2.right;
        } else {
            horizSpace = 0;
        }

        if (rect1.bottom < rect2.top) {
            vertSpace = rect2.top - rect1.bottom;
        } else if (rect2.bottom < rect1.top) {
            vertSpace = rect1.top - rect2.bottom;
        } else {
            vertSpace = 0;
        }

        return Math.max(vertSpace, horizSpace);
    };

    // assumes that each label takes up projection.settings.pixelsPerLabel
    // in order to get a rough step size to start working with
    ComputeStepSizes.estimateMajors = function(projection) {
        var width = projection.screen.width;
        var height = projection.screen.height;
        var xRange = projection.viewport.xmax - projection.viewport.xmin;
        var yRange = projection.viewport.ymax - projection.viewport.ymin;
        var pixelsPerLabel = projection.settings.pixelsPerLabel;

        return {
            majorStepX: pixelsPerLabel / width * xRange,
            majorStepY: pixelsPerLabel / height * yRange,
        };
    };

    // TODO - test
    ComputeStepSizes.cartesian = function(projection) {
        /* jshint maxcomplexity:16 */
        var cartesianSteps = {};

        var xStep = Math.abs(projection.settings.xAxisStep);
        var yStep = Math.abs(projection.settings.yAxisStep);
        var xRange = projection.viewport.xmax - projection.viewport.xmin;
        var yRange = projection.viewport.ymax - projection.viewport.ymin;
        var xIsMultipleOfPi = Label.value(xStep, xRange).string.indexOf('Ï€') >= 0;
        var yIsMultipleOfPi = Label.value(yStep, yRange).string.indexOf('Ï€') >= 0;
        var numXLabels = ComputeStepSizes.countStepsInRange(projection.viewport.xmin, projection.viewport.xmax, xStep);
        var numYLabels = ComputeStepSizes.countStepsInRange(projection.viewport.ymin, projection.viewport.ymax, yStep);
        var estimatedMajors = ComputeStepSizes.estimateMajors(projection);
        var fontSize = projection.settings.labelSize;

        // if the step is exactly pi we want to fall through to legacy pi labels at the end
        if (xStep && xStep !== Math.PI) {
            if (numXLabels >= 3 && numXLabels < 100) {
                var maxWidth = 0;
                eachStep(projection.viewport.xmin, projection.viewport.xmax, xStep, function(step) {
                    var stepNumber = StepNumber(Label.value(step, xRange), fontSize);
                    maxWidth = Math.max(stepNumber.getWidth(), maxWidth);
                });

                // check if there's enough room to fit this many labels with a little padding
                if (numXLabels * (maxWidth + 10) <= projection.screen.width) {
                    cartesianSteps.majorStepX = xStep;
                    cartesianSteps.minorStepX = xStep / 4;
                }
            }
        }

        // if the step is exactly pi we want to fall through to legacy pi labels at the end
        if (yStep && yStep !== Math.PI) {
            if (numYLabels >= 3 && numYLabels < 100) {
                var maxHeight = 0;
                eachStep(projection.viewport.ymin, projection.viewport.ymax, yStep, function(step) {
                    var stepNumber = StepNumber(Label.value(step, yRange), fontSize);
                    maxHeight = Math.max(stepNumber.getHeight(), maxHeight);
                });

                // check if there's enough room to fit this many labels with a little padding
                if (numYLabels * (maxHeight + 10) <= projection.screen.height) {
                    cartesianSteps.majorStepY = yStep;
                    cartesianSteps.minorStepY = yStep / 4;
                }
            }
        }

        // either the user didn't define an xstep or the user defined an inappropriate xstep.
        if (!cartesianSteps.majorStepX) {
            var defaultXSteps;
            if (xIsMultipleOfPi) {
                if (estimatedMajors.majorStepX >= 1) {
                    defaultXSteps = ComputeStepSizes.PI_STEPS;
                } else {
                    defaultXSteps = ComputeStepSizes.PI_FRAC_STEPS;
                }
            } else {
                defaultXSteps = generateSteps(xStep);
            }

            var defaultXLabels = ComputeStepSizes.bestStep(estimatedMajors.majorStepX, defaultXSteps);
            cartesianSteps.majorStepX = defaultXLabels.major;
            cartesianSteps.minorStepX = defaultXLabels.minor;
        }

        // either the user didn't define an ystep or the user defined an inappropriate ystep.
        if (!cartesianSteps.majorStepY) {
            var defaultYSteps;
            if (yIsMultipleOfPi) {
                if (estimatedMajors.majorStepY >= 1) {
                    defaultYSteps = ComputeStepSizes.PI_STEPS;
                } else {
                    defaultYSteps = ComputeStepSizes.PI_FRAC_STEPS;
                }
            } else {
                defaultYSteps = generateSteps(yStep);
            }

            var defaultYLabels = ComputeStepSizes.bestStep(estimatedMajors.majorStepY, defaultYSteps);
            cartesianSteps.majorStepY = defaultYLabels.major;
            cartesianSteps.minorStepY = defaultYLabels.minor;
        }

        // If the axes have similar extents, prefer to choose the same steps for
        // x and y. Could both be undefined or defined to same number
        if (xStep === yStep) {
            var maxRatio = 2;
            var pixel_scale_ratio = (projection.screen.width / xRange) / (projection.screen.height / yRange);
            if (pixel_scale_ratio >= 1 && pixel_scale_ratio <= maxRatio) {
                cartesianSteps.majorStepX = cartesianSteps.majorStepY;
                cartesianSteps.minorStepX = cartesianSteps.minorStepY;
            } else if (pixel_scale_ratio <= 1 && pixel_scale_ratio >= 1 / maxRatio) {
                cartesianSteps.majorStepY = cartesianSteps.majorStepX;
                cartesianSteps.minorStepY = cartesianSteps.minorStepX;
            }
        }

        return cartesianSteps;
    };

    ComputeStepSizes.polar = function(projection) {
        var estimatedStepSizes = ComputeStepSizes.estimateMajors(projection);
        var bestX = ComputeStepSizes.bestStep(estimatedStepSizes.majorStepX, ComputeStepSizes.RATIONAL_STEPS);
        var bestY = ComputeStepSizes.bestStep(estimatedStepSizes.majorStepY, ComputeStepSizes.RATIONAL_STEPS);
        var bestR = bestX.major > bestY.major ? bestX : bestY;

        return {
            majorStepR: bestR.major,
            minorStepR: bestR.minor
        };
    };

    return ComputeStepSizes;
});

define('graphing/gridlayer', ['require', 'pjs', './canvaslayer', './stepnumber', './label', './computestepsizes'], function(require) {
    var P = require('pjs');
    var CanvasLayer = require('./canvaslayer');
    var StepNumber = require('./stepnumber');
    var Label = require('./label');
    var ComputeStepSizes = require('./computestepsizes');

    var GridLayer = P(CanvasLayer, function(layer) {

        layer.redraw = function(projection, scaleAxis) {
            var screen = projection.screen;
            // make sure that this is the correct size
            this.resize(screen.width, screen.height);
            // Clear out the drawing area
            this.ctx.clearRect(0, 0, screen.width, screen.height);
            this.redrawToCtx(this.ctx, projection, scaleAxis);
        };

        layer.redrawToCtx = function(ctx, projection, scaleAxis) {

            if (projection.settings.polarMode) {
                projection.settings.setProperty('computedStepSizes', ComputeStepSizes.polar(projection));
            } else {
                projection.settings.setProperty('computedStepSizes', ComputeStepSizes.cartesian(projection));
            }

            if (projection.settings.showGrid) {
                if (projection.settings.polarMode) {
                    this.drawPolarGrid(ctx, projection);
                } else {
                    this.drawCartesianGrid(ctx, projection);
                }
            }

            this.drawAxes(ctx, projection, scaleAxis);

            var numberBounds;
            if (projection.settings.polarMode) {
                numberBounds = this.drawPolarStepNumbers(ctx, projection);
                this.drawLabels(ctx, projection, numberBounds);
            } else {
                numberBounds = this.drawCartesianStepNumbers(ctx, projection);
                this.drawLabels(ctx, projection, numberBounds);
            }
        };

        layer.addTextShadow = function(ctx) {
            ctx.shadowBlur = 4;
            ctx.shadowColor = "white";
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
        };

        layer.drawPolarGrid = function(ctx, projection) {
            var stepSizes = projection.settings.computedStepSizes;
            var minorOpacity = projection.settings.minorAxisOpacity;
            var majorOpacity = projection.settings.majorAxisOpacity;
            var adjustedMajorOpacity = 1 - (1 - majorOpacity) / (1 - minorOpacity);

            var x = Math.round(projection.mapx(0)) - 0.5;
            var y = Math.round(projection.mapy(0)) - 0.5;
            var rh = projection.screen.height / (projection.viewport.ymax - projection.viewport.ymin);
            var rw = projection.screen.width / (projection.viewport.xmax - projection.viewport.xmin);
            var scale = rh / rw;
            var y_scaled = y / scale;
            var rmin = projection.viewport.smallestR();
            var rmax = projection.viewport.largestR();

            // we don't want to draw from stepSizes.minorStepR if the origin is way off
            // the screen. We figure out the first multiples of minorStepR and
            // majorStepR that are visible (or nearly visible).
            var firstMinorStepR = stepSizes.minorStepR * Math.max(1, Math.floor(rmin / stepSizes.minorStepR));
            var firstMajorStepR = stepSizes.majorStepR * Math.max(1, Math.floor(rmin / stepSizes.majorStepR));

            // minor circles
            ctx.save();
            ctx.scale(1, scale);
            ctx.beginPath();
            eachStep(firstMinorStepR, rmax, stepSizes.minorStepR, function(value) {
                var r = projection.mapx(value) - x;
                ctx.moveTo(x + r, y_scaled);
                ctx.arc(x, y_scaled, r, 0, 2 * Math.PI);
            });
            ctx.restore();
            ctx.lineWidth = 1;
            ctx.strokeStyle = "rgba(0, 0 , 0, " + minorOpacity + ")";
            ctx.stroke();

            // minor radial lines
            ctx.beginPath();
            //if rmin > 0, the origin is offscreen. tacky, but use this as the cue to double-up the lines
            var rInterval = (rmin > 0 ? 5 : 15);
            eachStep(0, 359, rInterval, function(degrees) {
                ctx.moveTo(x, y);
                var x_px = projection.mapx(rmax * Math.cos(degrees * Math.PI / 180));
                var y_px = projection.mapy(rmax * Math.sin(degrees * Math.PI / 180));
                ctx.lineTo(Math.round(x_px) - 0.5, Math.round(y_px) - 0.5);
            });
            ctx.stroke();

            // major circles
            ctx.save();
            ctx.scale(1, scale);
            ctx.beginPath();
            eachStep(firstMajorStepR, rmax, stepSizes.majorStepR, function(value) {
                var r = projection.mapx(value) - x;
                ctx.moveTo(x + r, y_scaled);
                ctx.arc(x, y_scaled, r, 0, 2 * Math.PI);
            });
            ctx.restore();
            ctx.lineWidth = 1;
            ctx.strokeStyle = "rgba(0, 0 , 0, " + adjustedMajorOpacity + ")";
            ctx.stroke();

            // major radial lines
            ctx.beginPath();
            eachStep(0, 360 - 15, 90, function(degrees) {
                ctx.moveTo(x, y);
                var x_px = projection.mapx(rmax * Math.cos(degrees * Math.PI / 180));
                var y_px = projection.mapy(rmax * Math.sin(degrees * Math.PI / 180));
                ctx.lineTo(Math.round(x_px) - 0.5, Math.round(y_px) - 0.5);
            });
            ctx.stroke();

        };

        layer.drawCartesianGrid = function(ctx, projection) {
            var stepSizes = projection.settings.computedStepSizes;

            var xmin = projection.viewport.xmin,
                ymin = projection.viewport.ymin;
            var xmax = projection.viewport.xmax,
                ymax = projection.viewport.ymax;

            var width = projection.screen.width;
            var height = projection.screen.height;

            var minorOpacity = projection.settings.minorAxisOpacity;
            var majorOpacity = projection.settings.majorAxisOpacity;

            ctx.lineWidth = 1;

            // Minor gridlines

            ctx.beginPath();

            ctx.strokeStyle = "rgba(0, 0 , 0, " + minorOpacity + ")";

            eachStep(xmin, xmax, stepSizes.minorStepX, function(value) {
                var pixelValue = Math.round(projection.mapx(value));
                if (pixelValue === width) return;
                ctx.moveTo(pixelValue - 0.5, 0);
                ctx.lineTo(pixelValue - 0.5, height);
            });

            eachStep(ymin, ymax, stepSizes.minorStepY, function(value) {
                var pixelValue = Math.round(projection.mapy(value));
                if (pixelValue === height) return;
                ctx.moveTo(0, pixelValue - 0.5);
                ctx.lineTo(width, pixelValue - 0.5);
            });

            ctx.stroke();

            // Major gridlines

            ctx.beginPath();
            // Compensate for double stroking major gridlines. Strokes opacities
            // compose as o3 = 1 - (1 - o1)(1 - o2). We know what we've stroked so
            // far (o1), and what final stroke we'd like (o3), so solve for o2:
            // o2 = 1 - (1 - o3)/(1 - o1).
            var adjustedMajorOpacity = 1 - (1 - majorOpacity) / (1 - minorOpacity);
            ctx.strokeStyle = "rgba(0, 0 , 0, " + adjustedMajorOpacity + ")";

            eachStep(xmin, xmax, stepSizes.majorStepX, function(value) {
                var pixelValue = Math.round(projection.mapx(value));
                if (pixelValue === width) return;
                ctx.moveTo(pixelValue - 0.5, 0);
                ctx.lineTo(pixelValue - 0.5, height);
            });

            eachStep(ymin, ymax, stepSizes.majorStepY, function(value) {
                var pixelValue = Math.round(projection.mapy(value));
                if (pixelValue === height) return;
                ctx.moveTo(0, pixelValue - 0.5);
                ctx.lineTo(width, pixelValue - 0.5);
            });

            ctx.stroke();

        };

        layer.drawAxes = function(ctx, projection, scaleAxis) {
            var lineOffset = projection.settings.axisLineOffset;
            var axisOpacity = projection.settings.axisOpacity.toString();

            var scaleAxisStyle = "rgba(127,205,230," + axisOpacity + ")";
            var normalAxisStyle = "rgba(0,0,0," + axisOpacity + ")";
            var xAxisArrows = projection.settings.xAxisArrows;
            var yAxisArrows = projection.settings.yAxisArrows;
            var showXAxis = projection.settings.showXAxis;
            var showYAxis = projection.settings.showYAxis;

            var scaleAxisMultiplier = 3;

            var pixelX = Math.round(projection.mapx(0)) - lineOffset;
            var pixelY = Math.round(projection.mapy(0)) - lineOffset;
            var height = projection.screen.height;
            var width = projection.screen.width;

            function drawArrow(x, y, angle) {
                var angleOffset = Math.PI / 6;
                var hyp = 8 * ctx.lineWidth;
                ctx.moveTo(x + Math.cos(angle - angleOffset) * hyp, y + Math.sin(angle - angleOffset) * hyp);
                ctx.lineTo(x, y);
                ctx.lineTo(x + Math.cos(angle + angleOffset) * hyp, y + Math.sin(angle + angleOffset) * hyp);
            }

            if (showYAxis) {
                ctx.lineWidth = projection.settings.axisLineWidth * (scaleAxis === 'y' ? scaleAxisMultiplier : 1);
                ctx.strokeStyle = scaleAxis === 'y' ? scaleAxisStyle : normalAxisStyle;
                ctx.beginPath();
                ctx.moveTo(pixelX, 0);
                ctx.lineTo(pixelX, height);
                if (yAxisArrows === 'both') {
                    drawArrow(pixelX, height, 3 * Math.PI / 2);
                    drawArrow(pixelX, 0, Math.PI / 2);
                } else if (yAxisArrows === 'positive') {
                    drawArrow(pixelX, 0, Math.PI / 2);
                }
                ctx.stroke();
            }

            if (showXAxis) {
                ctx.lineWidth = projection.settings.axisLineWidth * (scaleAxis === 'x' ? scaleAxisMultiplier : 1);
                ctx.strokeStyle = scaleAxis === 'x' ? scaleAxisStyle : normalAxisStyle;
                ctx.beginPath();
                ctx.moveTo(0, pixelY);
                ctx.lineTo(width, pixelY);
                if (xAxisArrows === 'both') {
                    drawArrow(0, pixelY, 0);
                    drawArrow(width, pixelY, Math.PI);
                } else if (xAxisArrows === 'positive') {
                    drawArrow(width, pixelY, Math.PI);
                }
                ctx.stroke();
            }

        };


        layer.drawPolarStepNumbers = function(ctx, projection) {
            ctx.save();
            var showGrid = projection.settings.showGrid;
            var showXNumbers = projection.settings.xAxisNumbers && projection.settings.showXAxis;
            var showYNumbers = projection.settings.yAxisNumbers && projection.settings.showYAxis;
            var showPolarNumbers = showGrid && projection.settings.polarNumbers;
            var stepSizes = projection.settings.computedStepSizes;

            var rmax = projection.viewport.largestR();
            var rmin = projection.viewport.smallestR();
            var xmin = projection.viewport.xmin,
                xmax = projection.viewport.xmax;
            var ymin = projection.viewport.ymin,
                ymax = projection.viewport.ymax;
            var width = projection.screen.width;
            var height = projection.screen.height;
            var screenRect = { left: 3, right: width - 3, top: 3, bottom: height - 3 };

            var hangingColor = projection.settings.labelHangingColor;
            var normalColor = projection.settings.labelNormalColor;

            var fontSize = projection.settings.labelSize;
            var textHeight = fontSize;

            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            this.addTextShadow(ctx);
            ctx.font = fontSize.toString() + "px Arial";
            ctx.fillStyle = normalColor;

            function intersectX(r, bounds, numbers) {
                var y = Math.sqrt(r * r - bounds * bounds);
                if (ymin <= y && y <= ymax) {
                    numbers.push({ x: projection.mapx(bounds), y: projection.mapy(y) });
                }
                if (ymin <= -y && -y <= ymax) {
                    numbers.push({ x: projection.mapx(bounds), y: projection.mapy(-y) });
                }
            }

            function intersectY(r, bounds, numbers) {
                var x = Math.sqrt(r * r - bounds * bounds);
                if (xmin <= x && x <= xmax) {
                    numbers.push({ x: projection.mapx(x), y: projection.mapy(bounds) });
                }
                if (xmin <= -x && -x <= xmax) {
                    numbers.push({ x: projection.mapx(-x), y: projection.mapy(bounds) });
                }
            }

            var xAxis = projection.mapx(0);
            var yAxis = projection.mapy(0);

            // if the axis is on screen add labels for it
            var xAxisIsWithinViewport = ymin <= 0 && 0 <= ymax;
            var yAxisIsWithinViewport = xmin <= 0 && 0 <= xmax;
            var addXNumbers = xAxisIsWithinViewport && showXNumbers;
            var addYNumbers = yAxisIsWithinViewport && showYNumbers;
            var addEdgeNumbers = '';

            // neither axis is on the screen
            if (!addXNumbers && !addYNumbers && showGrid) {

                // figure out which edge is closest to an axis
                var leftDistance = Math.abs(xAxis);
                var rightDistance = Math.abs(xAxis - width);
                var topDistance = Math.abs(yAxis);
                var bottomDistance = Math.abs(yAxis - height);

                var leftRightWinner, topBottomWinner, leftRightDis, topBottomDis;

                if (leftDistance <= rightDistance) {
                    leftRightWinner = 'left';
                    leftRightDis = leftDistance;
                } else {
                    leftRightWinner = 'right';
                    leftRightDis = rightDistance;
                }

                if (topDistance <= bottomDistance) {
                    topBottomWinner = 'top';
                    topBottomDis = topDistance;
                } else {
                    topBottomWinner = 'bottom';
                    topBottomDis = bottomDistance;
                }

                if (showXNumbers && showYNumbers) {
                    addEdgeNumbers = leftRightDis <= topBottomDis ? leftRightWinner : topBottomWinner;
                } else if (showYNumbers) {
                    addEdgeNumbers = leftRightWinner;
                } else if (showXNumbers) {
                    addEdgeNumbers = topBottomWinner;
                }
            }

            // the space taken up by the numbers. the axis labels will use this stepSizesrmation
            // to figure out where to jump to.
            var xBounds = { left: 0, right: width, top: yAxis - 1, bottom: yAxis + 1 };
            var yBounds = { left: xAxis - 1, right: xAxis + 1, top: 0, bottom: height };

            // label each circle where it crosses the x axis, the y axis, and
            // whenever it leaves or enters the viewport.
            eachStep(0, rmax, stepSizes.majorStepR, function(r) {
                /* jshint maxcomplexity:12 */
                var xNumbers = [];
                var yNumbers = [];
                var edgeNumbers = [];

                var stepNumber = StepNumber(Label.value(r, rmax), fontSize);
                var rect = stepNumber.getRect();

                if (r > 0) {
                    // check if circle intersects positive y axis
                    if (addYNumbers && ymin <= r && r <= ymax) {
                        yNumbers.push({ x: xAxis - rect.right - 5, y: projection.mapy(r) });
                    }

                    // check if circle intersects negative y axis
                    if (addYNumbers && ymin <= -r && -r <= ymax) {
                        yNumbers.push({ x: xAxis - rect.right - 5, y: projection.mapy(-r) });
                    }

                    // check if circle intersects positive x axis
                    if (addXNumbers && xmin <= r && r <= xmax) {
                        xNumbers.push({ x: projection.mapx(r), y: yAxis - rect.top + 3 });
                    }

                    // check if circle intersects negative x axis
                    if (addXNumbers && xmin <= -r && -r <= xmax) {
                        xNumbers.push({ x: projection.mapx(-r), y: yAxis - rect.top + 3 });
                    }
                }

                // only show 0 if one of the axes are turned off
                else {
                    if (addYNumbers && !showXNumbers && ymin <= r && r <= ymax) {
                        yNumbers.push({ x: xAxis - rect.right - 5, y: projection.mapy(r) });
                    } else if (addXNumbers && !showYNumbers && xmin <= r && r <= xmax) {
                        xNumbers.push({ x: projection.mapx(r), y: yAxis - rect.top + 3 });
                    }
                }

                // if we're supposed to add numbers to an edge, do it
                switch (addEdgeNumbers) {
                    case "top":
                        intersectY(r, ymax, edgeNumbers);
                        break;

                    case "bottom":
                        intersectY(r, ymin, edgeNumbers);
                        break;

                    case "left":
                        intersectX(r, xmin, edgeNumbers);
                        break;

                    case "right":
                        intersectX(r, xmax, edgeNumbers);
                        break;
                }

                xNumbers.forEach(function(centerPt) {
                    centerPt = stepNumber.clampBoundsWithinRect(centerPt, screenRect);
                    stepNumber.drawCenteredAt(ctx, centerPt);
                    expandBounds(xBounds, stepNumber.getRectWhenCenteredAt(centerPt));
                });

                yNumbers.forEach(function(centerPt) {
                    centerPt = stepNumber.clampBoundsWithinRect(centerPt, screenRect);
                    stepNumber.drawCenteredAt(ctx, centerPt);
                    expandBounds(yBounds, stepNumber.getRectWhenCenteredAt(centerPt));
                });

                edgeNumbers.forEach(function(centerPt) {
                    centerPt = stepNumber.clampBoundsWithinRect(centerPt, screenRect);
                    stepNumber.drawCenteredAt(ctx, centerPt);
                });
            });

            if (showPolarNumbers) {
                // figure out which circle to label radial lines along.
                // Rule here: halfway between the largest and smallest r (rmin and rmax).
                // not scientific. Round up. Let's see how it feels

                // 0 => 0th circle. 1 => first circle, etc;
                var minRadNum = Math.ceil(rmin / stepSizes.majorStepR);
                var maxRadNum = Math.floor(rmax / stepSizes.majorStepR);
                var radiusNum = Math.ceil((minRadNum + maxRadNum) / 2);
                var radial_label_radius = radiusNum * stepSizes.majorStepR;


                //if rmin > 0, the origin is offscreen. tacky, but use this as the cue to double-up the lines
                var rInterval = (rmin > 0 ? 15 : 30);

                // label radial lines
                eachStep(0, 359, rInterval, function(degrees) {
                    var string;
                    if (projection.settings.degreeMode) {
                        string = degrees.toString() + "Â°";
                    } else {
                        string = Label.value(degrees * Math.PI / 180, 2 * Math.PI).string;
                    }

                    var textHalfWidth = ctx.measureText(string).width / 2;
                    var r = radial_label_radius / 1.05;

                    var x = r * Math.cos(degrees * Math.PI / 180);
                    var y = r * Math.sin(degrees * Math.PI / 180);

                    // only draw numbers that are on the screen
                    if (x < xmin || x > xmax || y < ymin || y > ymax) return;

                    var pixelX = projection.mapx(x);
                    var pixelY = projection.mapy(y);

                    // some adjustments to the numbers along the axes
                    if (degrees === 0 || degrees === 180) {
                        pixelY -= textHeight;
                    } else if (degrees === 90 || degrees === 270) {
                        pixelX += textHalfWidth + 3;
                    }

                    var clampedPixelX = clamp(pixelX, 3 + textHalfWidth, width - 3 - textHalfWidth);
                    var clampedPixelY = clamp(pixelY, 3 + textHeight, height - 3 - textHeight);

                    ctx.fillStyle = hangingColor;
                    ctx.fillText(string, clampedPixelX, clampedPixelY);
                });
            }
            ctx.restore();
            return {
                x: xBounds,
                y: yBounds
            };
        };

        layer.drawLabels = function(ctx, projection, numberBounds) {
            /* jshint maxcomplexity:11 */
            var xmin = projection.viewport.xmin,
                xmax = projection.viewport.xmax;
            var ymin = projection.viewport.ymin,
                ymax = projection.viewport.ymax;
            var width = projection.screen.width;
            var height = projection.screen.height;
            var xscale = (xmax - xmin) / width;
            var yscale = (ymax - ymin) / height;
            var normalColor = projection.settings.labelNormalColor;
            var xAxis = projection.mapx(0);
            var yAxis = projection.mapy(0);
            var fontSize = projection.settings.labelSize;

            //labelEdgePadding is the distance from the edge of the viewport along the label
            var labelEdgePadding = 15;

            var labelFontSize = Math.round(fontSize * 1.25);
            var xLabel = projection.settings.showXAxis && projection.settings.xAxisLabel;
            var yLabel = projection.settings.showYAxis && projection.settings.yAxisLabel;
            var xBounds = numberBounds.x;
            var yBounds = numberBounds.y;

            if (xLabel && xBounds) {
                ctx.save();
                ctx.font = labelFontSize.toString() + "px Arial";

                this.addTextShadow(ctx);
                ctx.fillStyle = normalColor;
                var xLabelPosition;

                if (ctx.__xLabelOffset && projection.settings.isViewportTransient) {
                    if (approxEqual(ctx.__xLabelOffset.xscale, xscale) && approxEqual(ctx.__xLabelOffset.yscale, yscale)) {
                        xLabelPosition = { x: ctx.__xLabelOffset.x + xAxis, y: ctx.__xLabelOffset.y + yAxis };
                    }
                }

                if (!xLabelPosition) {
                    var xWidth = ctx.measureText(xLabel).width;
                    var xLeft = width - xWidth - labelEdgePadding;
                    var xHeight = labelFontSize;

                    // there is space below the numbers, draw the label there
                    if (xBounds.bottom + xHeight < height) {
                        xLabelPosition = { x: xLeft, y: xBounds.bottom + xHeight };
                    }
                    // there isn't space below the numbers, so draw above them
                    else {
                        //I don't know why we want xHeight/2 here. It fixes
                        //behavior in projector & regular mode though. Otherwise,
                        //when floated on top of the x-axis, the label was too far away
                        xLabelPosition = { x: xLeft, y: xBounds.top - xHeight / 2 };
                    }

                    ctx.__xLabelOffset = {
                        x: xLabelPosition.x - xAxis,
                        y: xLabelPosition.y - yAxis,
                        xscale: xscale,
                        yscale: yscale
                    };
                }
                ctx.fillText(xLabel, xLabelPosition.x, xLabelPosition.y);
                ctx.restore();
            } else {
                ctx.__xLabelPosition = null;
            }

            if (yLabel && yBounds) {
                ctx.save();

                this.addTextShadow(ctx);
                ctx.font = labelFontSize.toString() + "px Arial";
                ctx.fillStyle = normalColor;
                var yLabelPosition;

                if (ctx.__yLabelOffset && projection.settings.isViewportTransient) {
                    if (approxEqual(ctx.__yLabelOffset.xscale, xscale) && approxEqual(ctx.__yLabelOffset.yscale, yscale)) {
                        yLabelPosition = { x: ctx.__yLabelOffset.x + xAxis, y: ctx.__yLabelOffset.y + yAxis };
                    }
                }

                if (!yLabelPosition) {
                    var yHeight = ctx.measureText(yLabel).width;
                    var yTop = 0 + labelEdgePadding + yHeight;
                    var yWidth = labelFontSize;

                    // there is space to the left of the numbers, draw the label there
                    if (yBounds.left - yWidth > 0) {
                        //I don't know why we want yWidth/2 here. It fixes
                        //behavior in projector & regular mode though. Otherwise,
                        //when floated on the left of the y-axis, it was too far away
                        yLabelPosition = { x: yBounds.left - yWidth / 2, y: yTop };
                    }

                    // there isn't space to the left of the numbers, so draw the label to the right of them
                    else {
                        yLabelPosition = { x: yBounds.right + yWidth, y: yTop };
                    }

                    ctx.__yLabelOffset = {
                        x: yLabelPosition.x - xAxis,
                        y: yLabelPosition.y - yAxis,
                        xscale: xscale,
                        yscale: yscale
                    };
                }

                ctx.translate(yLabelPosition.x, yLabelPosition.y);
                ctx.rotate(-Math.PI / 2);
                ctx.fillText(yLabel, 0, 0);
                ctx.restore();
            } else {
                ctx.__yLabelPosition = null;
            }
        };

        layer.drawCartesianStepNumbers = function(ctx, projection) {
            ctx.save();

            var stepSizes = projection.settings.computedStepSizes;

            var showXAxis = projection.settings.showXAxis;
            var showYAxis = projection.settings.showYAxis;
            var drawXNumbers = showXAxis && projection.settings.xAxisNumbers;
            var drawYNumbers = showYAxis && projection.settings.yAxisNumbers;

            var xmin = projection.viewport.xmin,
                xmax = projection.viewport.xmax;
            var ymin = projection.viewport.ymin,
                ymax = projection.viewport.ymax;
            var width = projection.screen.width;
            var height = projection.screen.height;
            var screenRect = { left: 3, top: 3, right: width - 3, bottom: height - 3 };

            var hangingColor = projection.settings.labelHangingColor;
            var normalColor = projection.settings.labelNormalColor;

            var xAxis = projection.mapx(0);
            var yAxis = projection.mapy(0);

            var fontSize = projection.settings.labelSize;
            this.addTextShadow(ctx);

            // the space taken up by the numbers. the axis labels will use this stepSizesrmation
            // to figure out where to jump to
            var xBounds = { left: 0, right: width, top: yAxis - 1, bottom: yAxis + 1 };
            var yBounds = { left: xAxis - 1, right: xAxis + 1, top: 0, bottom: height };

            var zeroDrawn = false;
            if (showXAxis && showYAxis && (drawXNumbers || drawYNumbers)) {
                zeroDrawn = true;
                ctx.fillStyle = normalColor;

                var zeroStepNumber = StepNumber(Label.value(0, 1), fontSize);

                zeroStepNumber.drawCenteredAt(ctx, {
                    x: xAxis - zeroStepNumber.getRect().right - 5,
                    y: yAxis - zeroStepNumber.getRect().top + 3
                });
            }

            if (drawXNumbers) {
                eachStep(xmin, xmax, stepSizes.majorStepX, function(step) {
                    var stepNumber = StepNumber(Label.value(step, xmax - xmin), fontSize);
                    var centerPt = {
                        x: projection.mapx(stepNumber.getValue()) - stepNumber.getMinusWidth(),
                        y: yAxis - stepNumber.getRect().top + 3
                    };
                    var clampedCenterPt = stepNumber.clampBoundsWithinRect(centerPt, screenRect);

                    ctx.fillStyle = (centerPt.y === clampedCenterPt.y) ? normalColor : hangingColor;

                    if (stepNumber.getString() === '0' && zeroDrawn) {
                        return;
                    }

                    stepNumber.drawCenteredAt(ctx, clampedCenterPt);
                    expandBounds(xBounds, stepNumber.getRectWhenCenteredAt(clampedCenterPt));
                });
            }

            if (drawYNumbers) {

                eachStep(ymin, ymax, stepSizes.majorStepY, function(step) {
                    var stepNumber = StepNumber(Label.value(step, ymax - ymin), fontSize);
                    var centerPt = {
                        x: xAxis - 5 - stepNumber.getRect().right,
                        y: projection.mapy(stepNumber.getValue())
                    };
                    var clampedCenterPt = stepNumber.clampBoundsWithinRect(centerPt, screenRect);

                    ctx.fillStyle = (centerPt.x === clampedCenterPt.x) ? normalColor : hangingColor;

                    if (stepNumber.getString() === '0' && zeroDrawn) {
                        return;
                    }

                    stepNumber.drawCenteredAt(ctx, clampedCenterPt);
                    expandBounds(yBounds, stepNumber.getRectWhenCenteredAt(clampedCenterPt));
                });
            }

            ctx.restore();

            return {
                x: xBounds,
                y: yBounds
            };
        };

    });

    var eachStep = function(min, max, step, func) {
        var nmin = Math.ceil(min / step);
        var nmax = Math.floor(max / step);
        var invstep = 1 / step;
        if (nmin > nmax) return;
        // If step===0, this would loop forever. This is designed for drawing
        // gridlines to a screen, so it shouldn't need to use more steps than
        // there are pixels.
        if (nmax - nmin > 10000) return;
        for (var n = nmin; n <= nmax; n++) func(n / invstep);
    };

    var clamp = function(value, min, max) {
        if (value < min) return min;
        if (value > max) return max;
        return value;
    };

    var expandBounds = function(cumBounds, numBounds) {
        if (numBounds.left < cumBounds.left) cumBounds.left = numBounds.left;
        if (numBounds.right > cumBounds.right) cumBounds.right = numBounds.right;
        if (numBounds.top < cumBounds.top) cumBounds.top = numBounds.top;
        if (numBounds.bottom > cumBounds.bottom) cumBounds.bottom = numBounds.bottom;
    };

    var approxEqual = function(num1, num2) {
        var A = Math.abs(num1),
            B = Math.abs(num2),
            epsilon = 0.0001;
        return Math.abs(A - B) <= (A < B ? B : A) * epsilon;
    };

    return GridLayer;
});

define('graphing/poi', [], function() {

    // This is a very coupled class. It should be used along side GraphSketch.
    function POI(x, y, type, sketch, branch) {
        this.x = x;
        this.y = y;
        this.type = type;
        this.sketch = sketch;
        this.branch = branch;
    }

    POI.prototype.getGraphMode = function() {
        return this.sketch.branches[this.branch].graphMode;
    };

    POI.prototype.getCompiledFunction = function() {
        return this.sketch.branches[this.branch].compiled.fn;
    };

    POI.prototype.isOpen = function() {
        return this.sketch.openPOI.indexOf(this) >= 0;
    };

    POI.prototype.close = function() {
        var index = this.sketch.openPOI.indexOf(this);
        if (index === -1) return false;

        this.sketch.openPOI.splice(index, 1);
        return true;
    };

    POI.prototype.open = function() {
        if (this.isOpen()) return false;

        this.sketch.openPOI.push(this);
        return true;
    };

    return POI;
});

define('graphing/graphsketch', ['require', 'math/poi', './poi', 'math/distance', 'graphing/graphmode'], function(require) {
    var POITYPE = require('math/poi');
    var POI = require('./poi');
    var Distance = require('math/distance');
    var GRAPHMODE = require('graphing/graphmode');

    function GraphSketch(id, branches) {
        // mutable properties
        this.color = '#000000';
        this.style = 'normal';
        this.visible = true;
        this.showPOI = false;
        this.showHighlight = false;
        this.selected = false;
        this.openPOI = []; // the points that are opened and visible
        this.hiddenOpenPOI = []; // the points that were opened previously,
        // but not mapped to screen any longer.
        // immutable properties
        this.id = id;
        this.branches = branches !== undefined ? branches : [];
    }

    // looks inside the branches and finds POI. Only needs to do this
    // once because branches are immutable. This caches the results. Also
    // note that this implementation postpones the conversion from one
    // large array of numbers to array of objects until someone actually
    // cares about this graphsketch's poi.
    GraphSketch.prototype.getPOI = function() {

        if (this.__cachedPOI) return this.__cachedPOI;

        var branch, graphMode;
        this.__cachedPOI = [];
        for (var i = 0; i < this.branches.length; i++) {
            branch = this.branches[i];
            graphMode = branch.graphMode;

            var pois = branch.poi;
            if (graphMode === GRAPHMODE.X || graphMode === GRAPHMODE.Y) {
                this._pushPOI(pois.zeros, i, POITYPE.ZERO);
                this._pushPOI(pois.intercept, i, POITYPE.INTERCEPT);
                this._pushPOI(pois.extrema, i, POITYPE.EXTREMUM);
                this._pushPOI(pois.intersections, i, POITYPE.INTERSECTION);
            } else if (graphMode === GRAPHMODE.XYPOINT || graphMode === GRAPHMODE.XYPOINT_MOVABLE) {
                this._pushPOI(pois.defined, i, POITYPE.DEFINITION);
            }
        }

        return this.__cachedPOI;
    };

    GraphSketch.prototype._pushPOI = function(pois, i, type) {
        if (!pois) return;

        for (var j = 0, plen = pois.x.length; j < plen; j++) {

            var poi = new POI();
            poi.type = type;
            poi.x = pois.x[j];
            poi.y = pois.y[j];
            poi.branch = i;
            poi.sketch = this;
            if (pois.intersects) poi.intersects = pois.intersects[j];

            this.__cachedPOI.push(poi);
        }
    };

    GraphSketch.prototype.updateIntersections = function(intersections) {
        for (var i = 0, ilen = this.branches.length; i < ilen; i++) {
            this.branches[i].poi.intersections = intersections[i];
        }
        this.__cachedPOI = undefined;
        this.getPOI();
        this.reopenPOIFrom(this);
    };

    GraphSketch.prototype.updateFrom = function(sketch) {
        if (!sketch) return;

        this.visible = true;

        if (sketch.openPOI.length || sketch.hiddenOpenPOI.length) {
            this.reopenPOIFrom(sketch);
        }

        this.showPOI = sketch.showPOI;
        this.showHighlight = sketch.showHighlight;
        this.selected = sketch.selected;
    };

    // TODO - change all the cryptic variable names to meaningful names
    GraphSketch.prototype.reopenPOIFrom = function(sketch) {
        /* jshint maxcomplexity:12 */
        var openPOI = [];
        var hiddenOpenPOI = [];
        var pois, n_pts, min, n_j, o_pt, n_pt;
        var t_poi, poi, poi_type;
        var i, j;

        var newPoints = {};
        var oldPoints = {};

        // categorize all new poi
        pois = this.getPOI();

        for (i = 0; i < pois.length; i++) {
            poi = pois[i];
            poi_type = poi.type;

            if (!newPoints[poi_type]) {
                newPoints[poi_type] = [poi];
            } else {
                newPoints[poi_type].push(poi);
            }

        }

        // categorize all old poi
        pois = sketch.openPOI.concat(sketch.hiddenOpenPOI);
        for (i = 0; i < pois.length; i++) {
            poi = pois[i];
            poi_type = poi.type;

            if (!oldPoints[poi_type]) {
                oldPoints[poi_type] = [poi];
            } else {
                oldPoints[poi_type].push(poi);
            }

        }

        // reopen the new points that were closest to the old opened points
        for (var type in oldPoints) {
            t_poi = oldPoints[type];
            n_pts = newPoints[type] || [];

            for (i = t_poi.length - 1; i >= 0; i--) {
                o_pt = t_poi[i];
                min = Infinity;
                n_j = -1;

                for (j = n_pts.length - 1; j >= 0; j--) {
                    n_pt = n_pts[j];
                    if (!n_pt) continue;
                    // Don't allow intersections to jump between functions.
                    if (n_pt.intersects !== o_pt.intersects) continue;

                    var dis = Distance.hypot(o_pt.x - n_pt.x, o_pt.y - n_pt.y);
                    if (dis < min) {
                        n_j = j;
                        min = dis;
                    }
                }

                if (n_j != -1) {
                    openPOI.push(n_pts[n_j]); // open the poi again
                    n_pts[n_j] = null;
                } else {
                    hiddenOpenPOI.push(o_pt); // mark point as opened but not mapped to screen
                }
            }
        }

        this.openPOI = openPOI;
        this.hiddenOpenPOI = hiddenOpenPOI;
    };

    return GraphSketch;
});

define('graphing/imagelayer', ['require', 'pjs', './canvaslayer', 'underscore'], function(require) {
    var P = require('pjs');
    var CanvasLayer = require('./canvaslayer');
    var _ = require('underscore');

    var ImageLayer = P(CanvasLayer, function(layer) {

        layer.redraw = function(projection, graphImages, drawOrder) {
            // Optimization for case when there are no images.
            var isEmpty = !_.size(graphImages);
            if (this.isEmpty && isEmpty) return;
            this.isEmpty = isEmpty;

            var screen = projection.screen;
            this.resize(screen.width, screen.height);
            this.ctx.save();
            this.ctx.clearRect(0, 0, screen.width, screen.height);
            this.ctx.strokeStyle = '#6993C7';
            this.ctx.lineWidth = 2;
            this.redrawToCtx(this.ctx, projection, graphImages, drawOrder);

            this.ctx.restore();
        };

        layer.redrawToCtx = function(ctx, projection, graphImages, drawOrder) {
            // Do the drawing of the segments
            if (drawOrder === undefined || drawOrder.length < _.size(graphImages)) {
                // If we don't have a drawOrder, or it doesn't include all of our graphSketches then make a new order.
                drawOrder = _.keys(graphImages);
            }

            // draw images in correct order
            var self = this;
            for (var i = 0; i < drawOrder.length; i++) {
                var image = graphImages[drawOrder[i]];
                if (image && image.shouldGraph) {
                    self.drawImageToCtx(image, ctx, projection);
                }
            }
        };

        layer.drawImageToCtx = function(image, ctx, projection) {
            var img_x = image.computed_x;
            var img_y = image.computed_y;
            var img_width = image.computed_width;
            var img_height = image.computed_height;

            // check if values are all numbers
            if (!isFinite(img_x) || !isFinite(img_y) || !isFinite(img_width) || !isFinite(img_height)) {
                return;
            }

            ctx.globalAlpha = image.opacity;

            var height = projection.mapy(img_height) - projection.mapy(0);
            var width = projection.mapx(img_width) - projection.mapx(0);

            // calculate the topLeft given the center as input
            var x = projection.mapx(img_x) - width / 2;
            var y = projection.mapy(img_y) + height / 2;

            // We want to correctly invert any images with negative dimensions.
            // This means flipping the context, dimension and associated positioning.
            var yflip = (img_height < 0) ? -1 : 1;
            var xflip = (img_width < 0) ? -1 : 1;
            ctx.save();
            ctx.scale(xflip, yflip);

            var canvasX = x * xflip;
            var canvasY = y * yflip;
            var canvasW = Math.abs(width);
            var canvasH = Math.abs(height);

            ctx.drawImage(image.imageObj, canvasX, canvasY, canvasW, canvasH);
            if (image.selected) {
                ctx.beginPath();
                ctx.rect(canvasX, canvasY, canvasW, canvasH);
                ctx.stroke();
            }

            ctx.restore();
        };

    });

    return ImageLayer;
});

define('graphing/tracelayer', ['require', 'pjs', './domlayer', './poi', './poilabelslayer'], function(require) {
    var P = require('pjs');
    var DOMLayer = require('./domlayer');
    var POI = require('./poi');
    var POILabelsLayer = require('./poilabelslayer');

    var TraceLayer = P(DOMLayer, function(layer, _super) {
        layer.init = function() {
            _super.init.apply(this, arguments);
            this.$.addClass('dcg-trace-layer');
        };

        layer.redraw = function(projection) {

            // make sure that this is the correct size
            this.resize(projection.screen.width, projection.screen.height);

            // Clear out the drawing area
            this.dom_node.find('.dcg-tracept').remove();

            var poi = this.traceInfo ? this.traceInfo.pt : null;
            if (!poi) return;

            var screen_x = projection.mapx(poi.x);
            var screen_y = projection.mapy(poi.y);

            // ensure is on screen. TODO - duplicate of code elsewhere. Might want to centralize that.
            if (
                screen_x > -20 && screen_y > -20 &&
                screen_x < projection.screen.width + 20 && screen_y < projection.screen.height + 20
            ) {

                // TODO - this is nasty. the createSinglePOI assumes that we pass in an
                //        instance of the POI class. traceInfo.pt is not a POI. Putting
                //        this here just to test tracing for now.
                var real_poi = new POI(poi.x,
                    poi.y,
                    POI.ZERO,
                    this.traceInfo.branchInfo.sketch,
                    this.traceInfo.branchInfo.branch);

                var dom_poi = POILabelsLayer.createSinglePOI(real_poi, projection.viewport);
                dom_poi.css({
                    left: screen_x + "px",
                    top: screen_y + "px"
                });
                dom_poi.addClass('dcg-temp');
                dom_poi.removeClass('dcg-poi');
                dom_poi.find('.dcg-pt').css('background-color', real_poi.sketch.color);
                dom_poi.find('.dcg-pt').css('border-color', real_poi.sketch.color);
                this.dom_node.append(dom_poi);

            }
        };
    });

    return TraceLayer;
});

define('graphing/movablepointslayer', ['require', 'pjs', 'jquery', './domlayer', 'graphing/graphmode', 'browser'], function(require) {
    var P = require('pjs');
    var $ = require('jquery');
    var DOMLayer = require('./domlayer');
    var GRAPHMODE = require('graphing/graphmode');
    var Browser = require('browser');

    var MovablePointsLayer = P(DOMLayer, function(layer, _super) {

        layer.init = function() {
            _super.init.apply(this, arguments);
            //collection of movablePoints that are rendered to the DOM
            // $ is a handle to the jquery element
            // shouldGarbageCollect is a flag
            //
            //We need to do this inside of init so that this object isn't
            //shared across graphs when we insert multiple graphs on a page
            //with the API
            this.renderedMovablePoints = {};
        };



        layer.redraw = function(projection, graphSketches) {
            /* jshint maxcomplexity:12 */
            // make sure that this is the correct size
            this.resize(projection.screen.width, projection.screen.height);

            // clear out hoveredSketchId if the sketch is gone
            var hoveredSketch = graphSketches[this.hoveredSketchId];
            if (!hoveredSketch) {
                this.hoveredSketchId = null;
            }

            // clear out pressedSketchId if the sketch is gone
            var pressedSketch = graphSketches[this.pressedSketchId];
            if (!pressedSketch) {
                this.pressedSketchId = null;
            }

            // Iterate through each graphSketch, find the opened poi and draw them
            // also saves which ones were drawn.
            var savedPOI = [];

            for (var id in this.renderedMovablePoints) {
                this.renderedMovablePoints[id].shouldGarbageCollect = true;
            }

            for (id in graphSketches) {
                var sketch = graphSketches[id];
                if (!sketch.visible) continue;

                var styles = {
                    hovered: sketch === hoveredSketch,
                    pressed: sketch === pressedSketch
                };

                var point = this.drawMovablePoint(sketch, this.dom_node, projection, styles);
                if (point) {
                    savedPOI.push(point);
                }
            }

            for (id in this.renderedMovablePoints) {
                if (this.renderedMovablePoints[id].shouldGarbageCollect) {
                    this.renderedMovablePoints[id].$.remove();
                    delete(this.renderedMovablePoints[id]);
                }
            }

            if (hoveredSketch && hoveredSketch.visible) {
                this.addGlobalClass('dcg-mouse-over-movable-point');
            } else {
                this.removeGlobalClass('dcg-mouse-over-movable-point');
            }

            if (pressedSketch && pressedSketch.visible) {
                this.addGlobalClass('dcg-dragging-movable-point');
            } else {
                this.removeGlobalClass('dcg-dragging-movable-point');
            }

            this.savedPOI = savedPOI;
        };

        layer.getDrawnPOI = function() {
            return this.savedPOI;
        };

        layer.init = function(width, height, $root) {
            _super.init.call(this, width, height, $root);
            this.renderedMovablePoints = {};
        };

        layer.drawMovablePoint = function(sketch, dom, projection, styles) {

            if (!sketch.branches ||
                sketch.branches.length !== 1 ||
                sketch.branches[0].graphMode !== GRAPHMODE.XYPOINT_MOVABLE) {
                return;
            }

            var poi = sketch.getPOI()[0];
            var screen_x = projection.mapx(poi.x);
            var screen_y = projection.mapy(poi.y);

            if (!(sketch.id in this.renderedMovablePoints)) {
                var $el = $("<div class='dcg-movable-point'>")
                    .append($("<div class='dcg-background'></div>"))
                    .append($("<div class='dcg-dot'></div></div>"));
                dom.append($el);
                this.renderedMovablePoints[sketch.id] = {
                    $: $el,
                    shouldGarbageCollect: true
                };
            }

            var dom_poi = this.renderedMovablePoints[sketch.id].$;

            // ensure is on screen. TODO - duplicate of code elsewhere. Might want to centralize that.
            if (
                screen_x > -20 && screen_y > -20 &&
                screen_x < projection.screen.width + 20 && screen_y < projection.screen.height + 20
            ) {
                dom_poi.css({
                    transform: Browser.translateRule(screen_x, screen_y),
                    backgroundColor: sketch.color
                });

                dom_poi.toggleClass('highlight', !!sketch.showHighlight);
                dom_poi.toggleClass('dcg-simulate-hovered', !!styles.hovered);
                dom_poi.toggleClass('dcg-simulate-active', !!styles.pressed);

                //don't garbage collect this point
                this.renderedMovablePoints[sketch.id].shouldGarbageCollect = false;
            }
            return poi;
        };


    });

    return MovablePointsLayer;
});
// fixes an issue with ghost clicks. borrowed the idea of using capture phase rather than bubble phase from:
//    https://developers.google.com/mobile/articles/fast_buttons?csw=1#ghost
//
// but the solution there is far from complete. It doesn't deal with focus being placed in textboxes still, and
// it doesn't prevent the ghost events from propagating down and back up through the dom. Mathquill listens for
// the mousedown and mouseup events, so when they were triggered erroneously, we should prevent them from propagating.
//
// the event handlers defined here need to be added before jquery has chance to add it's own listeners. This is
// especially important for the focus and blur events. The fact that touchtracking.js is split into two separate
// events here is unfortunate, but I think it's fine for now. There are talks of refactoring the touchtracking.js
// code anyways.
define('ipad.ghostevents', ['require'], function(require) {

    var inGhostEventMode = false;
    var startingActiveElement = null;

    function stopGhostEvent(evt) {
        if (inGhostEventMode) {
            evt.stopPropagation();
            evt.stopImmediatePropagation();
        }
    }

    function stopAndPreventGhostEvent(evt) {
        if (inGhostEventMode) {
            evt.preventDefault();
            evt.stopPropagation();
            evt.stopImmediatePropagation();
        }
    }

    // will get overriden by touchtracking.js
    // would be better not do things this way, but we need to split touchtracking.js into
    // a part that jquery depends on and a part that depends on jquery. This little inconvenience is what
    // splices all of touchtracking back together
    var touchTrackingCallbacks = {
        isGhostEvent: function(evt) {
            return false;
        }
    };

    // don't send ghost mousedwon events; someone might be listening for them
    document.addEventListener('mousedown', function(evt) {
        startingActiveElement = document.activeElement;

        inGhostEventMode = touchTrackingCallbacks.isGhostEvent(evt);

        // stop the mousedown event
        stopGhostEvent(evt);
    }, true);

    // don't send ghost mouseup events; someone might be listening for them
    document.addEventListener('mouseup', stopGhostEvent, true);

    // prevent links from being followed on ghost clicks.
    document.addEventListener('click', function(evt) {
        stopAndPreventGhostEvent(evt);

        // put focus where it was before the start of these events. the focusin and focusout
        // events fired from this will be stopped.
        if (inGhostEventMode && document.activeElement !== startingActiveElement) {
            if (document.activeElement) document.activeElement.blur();
            if (startingActiveElement) startingActiveElement.focus();
        }

        // anything after this is not a ghost event
        inGhostEventMode = false;
    }, true);

    // we prevent focus events from firing during ghost events
    document.addEventListener('focus', stopAndPreventGhostEvent, true);
    document.addEventListener('blur', stopAndPreventGhostEvent, true);

    return touchTrackingCallbacks;
});

/*
 * Touch/Mouse event handling gets complicated when a user has both a touch
 * device attached and a mouse attached. This tracking system helps deal with
 * that situation. We listen for the touch and mouse events on the document
 * and redispatch new, normalized events that work for many different devices
 * It's important to note that evt.stopPropagation() cannot be called on any
 * events that this is listening for.
 *
 * It normalizes 'touchStart' and 'mouseDown' to the 'tapstart' event.
 * It normalizes 'touchMove' and 'mouseMove' to the 'tapmove' event.
 * It normalizes 'touchEnd' and 'mouseUp' to the 'tapend' event.
 * It sends out a 'tap' event after a single touchStart and touchEnd.
 * It sends out a 'longhold' event if 500ms after a single 'tapstart'
 *    there hasn't been another event and the 'tapstart' is the only touch.
 *    Events have a 'wasLongheld' property that lets you know if a longhold
 *    has happened.
 *
 * TODO - dispatch 'doubletap' event after 'tap' and 'tap' near same location.
 *
 * One thing that it does is enforce that only one device, either touch or
 * or mouse, be used at a time. TOUCH_MODE starts on 'touchStart' and ends when
 * when all touches are lifted. MOUSE_MODE starts on 'mouseDown' and ends on
 * 'mouseUp'. When in TOUCH_MODE, it ignores all MOUSE_MODE events. When in
 * MOUSE_MODE, it ignores all TOUCH_MODE events.
 *
 * There is still one other slight complication. The ipad issues a 'mouseDown'
 * event after the 'touchEnd' event. That means following the logic above, we'd
 * leave TOUCH_MODE on touchEnd, and we'd get a mouseDown event. That'd put us
 * in MOUSE_MODE. We'd process the 'mouseDown' as if it were from a mouse, and
 * we'd happily process the 'mouseUp' event as well. In order to combat that,
 * on each 'mouseDown' event we check if we've recently been in TOUCH_MODE. We
 * enforce that half a second has passed since a person was in TOUCH_MODE
 * before they can enter MOUSE_MODE. If we decide that that's not ideal, we
 * can check if the mouseDown is near the 'touchStart' or 'touchEnd' events, but
 * that sounds like an unnecessary complication.
 *
 * One other interesting thing is that 'mouseMove' can be dispatched even when
 * the mouse button isn't pressed. For that reason, this doesn't require that
 * you be in MOUSE_MODE to listen for 'mouseMove' events.
 *
 * UPDATE 24/10 - DM
 * I have put in support for pointerevents & MSPointerEvents to allow for multitouch
 * on Windows 8 machines. For once, MS have made a good move and proposed a useful
 * standard in pointerevents - down the line that may end up being the W3C standard
 * which will involve some more work here. Primarily, they don't track multiple touches
 * in a single event, so here we are keeping track of them and then conforming that array
 * to the rest of our more touch/tap-esque system.
 */
define('touchtracking', ['require', 'jquery', 'ipad.ghostevents'], function(require) {

    var $ = require('jquery');
    var GhostEvents = require('ipad.ghostevents');

    GhostEvents.isGhostEvent = function(evt) {
        // I've seen no indication of "ghost events" when using PointerEvents.
        // Disabling altogether because the logic below doesn't work for PointerEvents.
        // The ipad appears to be the only device that sends legacy events after
        // the mouseup. Other devices send the legacy events after their touch,pointerevent
        // equivalent:
        //
        // ipad: touchstart, touchmove, touchend, mousedown, mouseup, click
        // surface: pointerdown, mousedown, pointerup, mouseup, click
        //
        // The logic below assumes that the touchend (or pointerend) has happened before
        // the evt in question. If it has not, then lastTarget will be null and we
        // will consider evt a ghostevent. The ghostevent code is specially tailored
        // to the ipad, so I'm not quick to change it.
        //
        // TODO - maybe make ghost event detection opt in rather opt out. IIRC, android
        // uses the same event sequence as the surface, so it's possible we're detecting
        // ghostevents on android when we shouldn't be.
        //
        // The effect of wrongly considering an event a ghost event is we preventDefault()
        // on it and possibly stopPropagation(). We also do fun things with focus.
        if (window.PointerEvent) {
            return false;
        }

        // not a ghost event if it's from a mouse
        if (mode !== TOUCH_MODE && !hasRecentlyEndedTouchMode()) {
            return false;
        }

        // it's a ghost event if the target of the event and our lastTarget aren't ancestors. What has happened is
        // the dom moved around while the legacy events were being generated. We'll be ignoring the upcoming
        // legacy events.
        if (evt.target === lastTarget) return false;
        if (evt.target && $.contains(evt.target, lastTarget)) return false;
        if (lastTarget && $.contains(lastTarget, evt.target)) return false;

        return true;
    };

    var NO_MODE = 0; // nothing pressed
    var TOUCH_MODE = 1; // finger is on screen
    var MOUSE_MODE = 2; // mouse is held down

    var mode = NO_MODE;
    var modeEvents = {};
    var modeTargets = [];
    var endTouchModeTime = 0;
    var endTouchModeTimeout = null;
    var lastTarget = null;

    var longholdTimeout = null;
    var pointerTouches = [];

    // returns an array of node, parent, grandparent, etc
    var getAncestors = function(node) {
        var nodes = [];
        while (node) {
            nodes.push(node);
            node = node.parentNode;
        }

        return nodes;
    };

    // only returns nodes within a .dcg-tap-container
    var filterSortedNodesWithinScope = function(sortedNodes) {
        var filtered = [];
        for (var i = 0; i < sortedNodes.length; i++) {
            var node = sortedNodes[i];
            filtered.push(node);

            if ($(node).hasClass('dcg-tap-container')) {
                return filtered;
            }
        }

        return [];
    };

    var beginMode = function(evnt) {
        lastTarget = null;

        if (evnt.type === 'mousedown') {
            mode = MOUSE_MODE;
            modeTargets = getAncestors(evnt.target);
        } else if (evnt.type === 'pointerdown' || evnt.type === 'MSPointerDown') {
            //we'll have filtered out all mouse and pen events by here, so this must've been a touch
            mode = TOUCH_MODE;
            modeTargets = getAncestors(evnt.target);
        } else {
            mode = TOUCH_MODE;
            modeTargets = getAncestors(evnt.originalEvent.touches[0].target);
        }
        // make the elements under the mouse look pressed
        $(filterSortedNodesWithinScope(modeTargets)).addClass('dcg-depressed');

        // save original scroll positions for elements we've moused on
        $(modeTargets).each(function() {
            var elm = $(this);

            elm.data({
                originalScrollTop: elm.scrollTop(),
                originalScrollLeft: elm.scrollLeft()
            });
        });

        modeEvents = {};
    };

    var endMode = function(evnt) {
        lastTarget = null;

        // nothing is pressed anymore
        $('.dcg-depressed').removeClass('dcg-depressed');

        // check if any of the elements we originally moused on have scrolled.
        $(modeTargets).each(function() {
            var elm = $(this);
            var verticalOffset = elm.data('originalScrollTop') - elm.scrollTop();
            var horizontalOffset = elm.data('originalScrollLeft') - elm.scrollLeft();
            // save original scroll positions
            if (verticalOffset || horizontalOffset) {
                modeEvents.scroll = true;
            }
        });

        if (modeEvents.tapstart === 1 && modeEvents.tapend === 1 && !modeEvents.tapcancel && !modeEvents.scroll) {

            // get the x and y position of event.
            var x = evnt.device === 'mouse' ? evnt.pageX : evnt.originalEvent.changedTouches[0].pageX;
            var y = evnt.device === 'mouse' ? evnt.pageY : evnt.originalEvent.changedTouches[0].pageY;

            // run through the original modeTargets to see if the touchend is
            // with the bounds.
            var tap_escaped_boundary = false;
            for (var i = 0; i < modeTargets.length && !tap_escaped_boundary; i++) {
                var target = $(modeTargets[i]);
                var offset = target.offset();

                // don't let tap events escape from a tapboundary.
                //
                // we allow you to mousedown on one element and mouseup on another. We
                // dispatch the tap event on the common ancestor. This allows you to be
                // imprecise when clicking. Sometimes that isn't ideal however. Say
                // you mouse down on a slider thumb and mouse up on the expression. By
                // default, we'd dispatch a tap event on the expression. That'd cause
                // the expression to be selected and focused. That's not what we want.
                // So, we define a tapboundary on the slider element. That will not
                // allow a tap event to start within the slider and end somewhere
                // outside of it. It must terminate within the boundary, otherwise we
                // won't dispatch a tap event at all.
                if (target.attr('tapboundary') === 'true') {
                    tap_escaped_boundary = true;
                }

                if (offset) {

                    // check if within top and left sides
                    if (x < offset.left || y < offset.top) continue;

                    // check if within right side
                    if (x > offset.left + target.outerWidth()) continue;

                    // check if within bottom side
                    if (y > offset.top + target.outerHeight()) continue;

                }

                lastTarget = target[0];
                dispatchEvent('tap', evnt, lastTarget);
                break;
            }
        }

        // start the timer after we process the tap event.
        // this fires an event 1000ms in the future. If anything had caused the ipad
        // legacy events to get delayed, that'll also cause this function call to
        // get delayed. For us to switch back to MOUSE_MODE, this event must have
        // fired and it must not have been fired within 500ms of us trying to
        // switch to MOUSE_MODE
        if (mode === TOUCH_MODE) {
            endTouchModeTimeout = setTimeout(function() {
                endTouchModeTimeout = null;
                endTouchModeTime = new Date().getTime();
            }, 1000);
        }

        modeTargets = [];
        mode = NO_MODE;
    };

    var hasRecentlyEndedTouchMode = function() {
        return endTouchModeTimeout || new Date().getTime() - endTouchModeTime < 500;
    };

    // it's important to clone touches because some devices keep updating the
    // same reference to a touch.
    var clone = function(touches) {
        var cloned = [];
        for (var i = 0; i < touches.length; i++) {

            var touch = touches[i];
            cloned.push({

                identifier: touch.identifier,
                x: touch.pageX,
                y: touch.pageY,

                screenX: touch.screenX,
                screenY: touch.screenY,
                pageX: touch.pageX,
                pageY: touch.pageY,
                clientX: touch.clientX,
                clientY: touch.clientY
            });
        }
        return cloned;
    };

    var dispatchEvent = function(type, evnt, differentTarget) {
        // count an event type. used to figure out if we should send out
        // a tap and doubletap event.
        if (modeEvents[type.toLowerCase()] === undefined) {
            modeEvents[type.toLowerCase()] = 1;
        } else {
            modeEvents[type.toLowerCase()]++;
        }

        var newEvnt = $.event.fix(evnt.originalEvent);
        newEvnt.type = type;
        newEvnt.device = mode === TOUCH_MODE ? 'touch' : 'mouse';
        newEvnt.touches = clone(evnt.originalEvent.touches);
        newEvnt.changedTouches = clone(evnt.originalEvent.changedTouches);
        newEvnt.target = differentTarget ? differentTarget : evnt.target;

        var wasLongheld = modeEvents.longhold > 0;
        newEvnt.wasLongheld = function() { return wasLongheld };

        // send out a 'longhold' 500ms after a 'tapstart' as long as nothing else happens between
        // now and then.
        clearTimeout(longholdTimeout);
        if (newEvnt.type === 'tapstart' && newEvnt.touches.length === 1) {
            longholdTimeout = setTimeout(function() {
                dispatchEvent('longhold', evnt, differentTarget);
            }, 500);
        }

        $(newEvnt.target).trigger(newEvnt);
    };

    // TODO - Remember nodes given .hovered last time instead of querying. Only
    //        problem I can see here is that it's possible for a person to
    //        clone an object that has the .hover and add it to
    //        the dom. Then it'll never lose the .hover class. If we find
    //        any more performance problems with this, then maybe we can worry
    //        about it, but I don't think we need that optimization.
    // Already optimized to leave .hover on elements that still are hovered. Saw
    // a preformance problem with sliders before optimization and problem went
    // away after optimization.
    var setHoveredNode = function(node) {

        var hoverableNodes = modeTargets; // gets a list of nodes that were under the mouse when it was pressed
        var checkIfNodeIsHoverable = !!modeTargets.length; // simple mouse move with no mouse down
        var hoveredBefore = $.makeArray($('.dcg-hovered'));
        var hoveredNow = [];
        var lostHover = [];
        var gainedHover = [];

        filterSortedNodesWithinScope(getAncestors(node)).forEach(function(node) {
            // only add to hovered list if it can be hovered.
            if (!checkIfNodeIsHoverable || hoverableNodes.indexOf(node) !== -1) {

                // hovered now, but wasn't before
                if (hoveredBefore.indexOf(node) === -1) {
                    gainedHover.push(node);
                }

                hoveredNow.push(node);
            }
        });

        // find the ones that used to be hovered but aren't any more
        for (var i = 0; i < hoveredBefore.length; i++) {
            node = hoveredBefore[i];
            if (hoveredNow.indexOf(node) === -1) {
                lostHover.push(node);
            }
        }

        $(lostHover).removeClass('dcg-hovered').trigger('tipsyhide');
        $(gainedHover).addClass('dcg-hovered').trigger('tipsyshow');
    };


    var removePointerEventById = function(id) {
        // Returns the removed event for use in some handlers
        for (var i = 0; i < pointerTouches.length; i++) {
            if (pointerTouches[i].pointerId === id) {
                return pointerTouches.splice(i, 1)[0];
            }
        }
    };

    //From:
    //http://msdn.microsoft.com/en-us/library/windows/apps/hh466130.aspx
    //IE10 uses longs, IE11 uses strings
    var isMSTouchEvent = function(evnt) {
        return (
            evnt.originalEvent.pointerType === 'touch' ||
            evnt.originalEvent.pointerType === 2
        );
    };

    // Apply touch & mouse event handlers for everything that isn't IE10+
    // and mspointerevents (IE10) & pointerevents for IE(11).
    $(document).on('pointerdown MSPointerDown', function(evnt) {
        if (mode === MOUSE_MODE || !isMSTouchEvent(evnt)) return;

        // setup TOUCH_MODE
        if (mode === NO_MODE) {
            beginMode(evnt);
        }

        // nothing can be hovered now
        setHoveredNode(null);

        // normalize pointer-event to a touch-event
        evnt.originalEvent.identifier = evnt.originalEvent.pointerId;
        evnt.originalEvent.touches = pointerTouches;
        evnt.originalEvent.changedTouches = [evnt.originalEvent];
        pointerTouches.push(evnt.originalEvent);

        dispatchEvent('tapstart', evnt);
    });

    $(document).on('pointermove MSPointerMove', function(evnt) {
        if (mode !== TOUCH_MODE || !isMSTouchEvent(evnt)) return;

        // Pointer events don't get updated, so we need to remove any existing
        // instances of this pointerId we are tracking and add the new data in.
        removePointerEventById(evnt.originalEvent.pointerId);
        pointerTouches.push(evnt.originalEvent);

        // normalize pointer-event to a touch-event
        evnt.originalEvent.identifier = evnt.originalEvent.pointerId;
        evnt.originalEvent.touches = pointerTouches;
        evnt.originalEvent.changedTouches = [evnt.originalEvent];
        dispatchEvent('tapmove', evnt);
    });

    $(document).on('pointercancel MSPointerCancel', function(evnt) {
        if (mode !== TOUCH_MODE || !isMSTouchEvent(evnt)) return;

        // Pointer events don't get updated, so we need to remove any existing
        // instances of this pointerId we are tracking
        removePointerEventById(evnt.originalEvent.pointerId);

        // normalize pointer-event to a touch-event
        evnt.originalEvent.identifier = evnt.originalEvent.pointerId;
        evnt.originalEvent.touches = pointerTouches;
        evnt.originalEvent.changedTouches = [evnt.originalEvent];

        dispatchEvent('tapcancel', evnt);
        // switch back to no mode if all touches are gone
        if (evnt.originalEvent.touches.length === 0) {
            endMode(evnt);
        }
    });

    $(document).on('pointerup MSPointerUp', function(evnt) {
        if (mode !== TOUCH_MODE || !isMSTouchEvent(evnt)) return;

        // Pointer events don't get updated, so we need to remove any existing
        // instances of this pointerId we are tracking
        removePointerEventById(evnt.originalEvent.pointerId);

        // normalize pointer-event to a touch-event
        evnt.originalEvent.identifier = evnt.originalEvent.pointerId;
        evnt.originalEvent.touches = pointerTouches;
        evnt.originalEvent.changedTouches = [evnt.originalEvent];

        dispatchEvent('tapend', evnt);
        // switch back to no mode if all touches are gone
        if (evnt.originalEvent.touches.length === 0) {
            endMode(evnt);
        }
    });

    $(document).on('touchstart', function(evnt) {
        if (mode === MOUSE_MODE) return;

        // setup TOUCH_MODE
        if (mode === NO_MODE) {
            beginMode(evnt);
        }

        // nothing can be hovered now
        setHoveredNode(null);
        dispatchEvent('tapstart', evnt);
    });

    $(document).on('touchmove', function(evnt) {
        if (mode !== TOUCH_MODE) return;
        dispatchEvent('tapmove', evnt);
    });

    $(document).on('touchcancel', function(evnt) {
        if (mode !== TOUCH_MODE) return;
        dispatchEvent('tapcancel', evnt);
        // switch back to no mode if all touches are gone
        if (evnt.originalEvent.touches.length === 0) {
            endMode(evnt);
        }
    });

    $(document).on('touchend', function(evnt) {
        if (mode !== TOUCH_MODE) return;
        dispatchEvent('tapend', evnt);
        // switch back to no mode if all touches are gone
        if (evnt.originalEvent.touches.length === 0) {
            endMode(evnt);
        }
    });

    $(document).on('mousedown', function(evnt) {
        if (evnt.button === 1 || evnt.button === 2) return;

        // Take evasive action for legacy clicks--that is, click events that are
        // synthesized by touch browsers after a sequence of touches has ended.
        // The problem we're trying to solve here is that if you move a DOM
        // element in response to a touch event, then the legacy mouse events will
        // be fired on whatever element happens to now be under where the touch
        // event occurred.
        //
        // For example, the "functions" menu is hidden when one of its buttons is
        // touched, and the legacy click event is subsequently fired on the graph
        // paper. This takes focus from the expression that was being edited.
        //
        // The solution is to preventDefault() on the legacy events if we are in
        // touch mode. However, this prevents inputs, textareas, and selects from
        // being focused properly in mobile webkit browsers. We compromise by
        // firing preventDefault() only if the target is not an input, textarea,
        // or select.
        if (mode === TOUCH_MODE || hasRecentlyEndedTouchMode()) {
            if (!$(evnt.target).is('input, textarea, select')) {
                evnt.preventDefault();
            }
            return;
        }

        // setup MOUSE_MODE
        beginMode(evnt);

        // add in missing touch api information
        evnt.originalEvent.touches = [evnt];
        evnt.originalEvent.changedTouches = [evnt];

        dispatchEvent('tapstart', evnt);
    });

    // Stop mousedown event from propagating for any element with an ancestor with
    // class .do-not-blur (and no ancestor with .do-blur)
    $(document).ready(function() {
        $(document).on("mousedown", function(e) {
            var doNotBlur = !!$(e.target).closest('.dcg-do-not-blur').length,
                doBlur = !!$(e.target).closest('.dcg-do-blur').length;
            if (doNotBlur && !doBlur) {
                e.preventDefault();
            }

            // we use preventDefault() in places and that will cause text selection
            // to be preserved when it shouldn't be. On mouse down, if the only
            // thing with selection is something that has the .dcg-text-selectable class
            // then we can safely remove selection.
            var selection = window.getSelection();
            if (selection.rangeCount === 1) {
                var range = selection.getRangeAt(0);
                if (
                    range.startContainer === range.endContainer &&
                    $(range.startContainer).closest('.dcg-text-selectable').length
                ) {
                    selection.removeAllRanges();
                }
            }

        });
    });

    // If the mouse isn't pressed, then the mousemove that moves us off the
    // the screen isn't reported. That'll leave the last hovered element hoverd.
    // this checks if we are in NO_MODE and have a mouseleave event.
    $(document).on('mouseleave', function(evnt) {
        // we can move the mouse while not being in mouseMode
        if (mode !== NO_MODE) return;

        // check if a significant amount of time has passed since
        // switching from TOUCH_MODE to NO_MODE
        if (hasRecentlyEndedTouchMode()) return;

        // nothing is hovered
        setHoveredNode(null);
    });

    $(document).on('mousemove', function(evnt) {
        if (evnt.button === 1 || evnt.button === 2) return;

        // we can move the mouse while not being in mouseMode
        if (mode === TOUCH_MODE) return;

        // check if a significant amount of time has passed since
        // switching from TOUCH_MODE to MOUSE_MODE
        if (hasRecentlyEndedTouchMode()) return;

        setHoveredNode(evnt.target);

        // add in missing touch api information
        evnt.originalEvent.touches = [evnt]; // TODO - not perfect because it could be a non-touch
        evnt.originalEvent.changedTouches = [evnt];

        dispatchEvent('tapmove', evnt);
    });


    $(document).on('mouseup', function(evnt) {
        if (evnt.button === 1 || evnt.button === 2) return;

        if (mode !== MOUSE_MODE) return;

        // add in missing touch api information
        evnt.originalEvent.touches = [];
        evnt.originalEvent.changedTouches = [evnt];

        dispatchEvent('tapend', evnt);

        endMode(evnt);
    });

    /* Uncomment to see visual dots on screen following mouse events

    $(document).on('tapstart tapend tapmove tap tapcancel', function (evt){
      console.log(evt.type, evt.originalEvent.changedTouches);

      function drawDot (touch, c, r, o) {
        if (evt.isDefaultPrevented()) r *= 10;

        var styles = [
          'position:absolute',
          'z-index: 5000000',
          'pointer-events: none',
          'left:' + (touch.pageX-r) + 'px',
          'top:' + (touch.pageY-r) + 'px',
          'width:' + (2*r) + 'px',
          'height:' + (2*r) + 'px',
          'border-radius:' + r + 'px',
          'background:'+ c,
          'opacity:'+ o
        ];

        return $('<div style="'+ styles.join(';') +'"></div>').appendTo('body');
      }

      for (var i in evt.originalEvent.changedTouches) {
        var touch = evt.originalEvent.changedTouches[i];
        if (evt.type === 'tapstart') {
          drawDot(touch, '#0F0', 6, .5);
        } else if (evt.type === 'tapend') {
          drawDot(touch, '#F00', 6, .5);
        } else if (evt.type === 'tapmove') {
          drawDot(touch, '#00F', 3, 1);
        } else if (evt.type === 'tap') {
          drawDot(touch, '#FF0', 12, .5);
        }
      }
    });

    */

    //Utilities to allow other modules to query this state
    return {
        isTapActive: function() {
            return (mode !== NO_MODE);
        }
    };

});

/*! Copyright (c) 2013 Brandon Aaron (http://brandon.aaron.sh)
 * Licensed under the MIT License (LICENSE.txt).
 *
 * Version: 3.1.9
 *
 * Requires: jQuery 1.2.2+
 */

(function(factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define('vendor/jquery.mousewheel', ['jquery'], factory);
    } else if (typeof exports === 'object') {
        // Node/CommonJS style for Browserify
        module.exports = factory;
    } else {
        // Browser globals
        factory(jQuery);
    }
}(function($) {

    var toFix = ['wheel', 'mousewheel', 'DOMMouseScroll', 'MozMousePixelScroll'],
        toBind = ('onwheel' in document || document.documentMode >= 9) ? ['wheel'] : ['mousewheel', 'DomMouseScroll', 'MozMousePixelScroll'],
        slice = Array.prototype.slice,
        nullLowestDeltaTimeout, lowestDelta;

    if ($.event.fixHooks) {
        for (var i = toFix.length; i;) {
            $.event.fixHooks[toFix[--i]] = $.event.mouseHooks;
        }
    }

    var special = $.event.special.mousewheel = {
        version: '3.1.9',

        setup: function() {
            if (this.addEventListener) {
                for (var i = toBind.length; i;) {
                    this.addEventListener(toBind[--i], handler, false);
                }
            } else {
                this.onmousewheel = handler;
            }
            // Store the line height and page height for this particular element
            $.data(this, 'mousewheel-line-height', special.getLineHeight(this));
            $.data(this, 'mousewheel-page-height', special.getPageHeight(this));
        },

        teardown: function() {
            if (this.removeEventListener) {
                for (var i = toBind.length; i;) {
                    this.removeEventListener(toBind[--i], handler, false);
                }
            } else {
                this.onmousewheel = null;
            }
        },

        getLineHeight: function(elem) {
            return parseInt($(elem)['offsetParent' in $.fn ? 'offsetParent' : 'parent']().css('fontSize'), 10);
        },

        getPageHeight: function(elem) {
            return $(elem).height();
        },

        settings: {
            adjustOldDeltas: true
        }
    };

    $.fn.extend({
        mousewheel: function(fn) {
            return fn ? this.bind('mousewheel', fn) : this.trigger('mousewheel');
        },

        unmousewheel: function(fn) {
            return this.unbind('mousewheel', fn);
        }
    });


    function handler(event) {
        var orgEvent = event || window.event,
            args = slice.call(arguments, 1),
            delta = 0,
            deltaX = 0,
            deltaY = 0,
            absDelta = 0;
        event = $.event.fix(orgEvent);
        event.type = 'mousewheel';

        // Old school scrollwheel delta
        if ('detail' in orgEvent) { deltaY = orgEvent.detail * -1; }
        if ('wheelDelta' in orgEvent) { deltaY = orgEvent.wheelDelta; }
        if ('wheelDeltaY' in orgEvent) { deltaY = orgEvent.wheelDeltaY; }
        if ('wheelDeltaX' in orgEvent) { deltaX = orgEvent.wheelDeltaX * -1; }

        // Firefox < 17 horizontal scrolling related to DOMMouseScroll event
        if ('axis' in orgEvent && orgEvent.axis === orgEvent.HORIZONTAL_AXIS) {
            deltaX = deltaY * -1;
            deltaY = 0;
        }

        // Set delta to be deltaY or deltaX if deltaY is 0 for backwards compatabilitiy
        delta = deltaY === 0 ? deltaX : deltaY;

        // New school wheel delta (wheel event)
        if ('deltaY' in orgEvent) {
            deltaY = orgEvent.deltaY * -1;
            delta = deltaY;
        }
        if ('deltaX' in orgEvent) {
            deltaX = orgEvent.deltaX;
            if (deltaY === 0) { delta = deltaX * -1; }
        }

        // No change actually happened, no reason to go any further
        if (deltaY === 0 && deltaX === 0) { return; }

        // Need to convert lines and pages to pixels if we aren't already in pixels
        // There are three delta modes:
        //   * deltaMode 0 is by pixels, nothing to do
        //   * deltaMode 1 is by lines
        //   * deltaMode 2 is by pages
        if (orgEvent.deltaMode === 1) {
            var lineHeight = $.data(this, 'mousewheel-line-height');
            delta *= lineHeight;
            deltaY *= lineHeight;
            deltaX *= lineHeight;
        } else if (orgEvent.deltaMode === 2) {
            var pageHeight = $.data(this, 'mousewheel-page-height');
            delta *= pageHeight;
            deltaY *= pageHeight;
            deltaX *= pageHeight;
        }

        // Store lowest absolute delta to normalize the delta values
        absDelta = Math.max(Math.abs(deltaY), Math.abs(deltaX));

        if (!lowestDelta || absDelta < lowestDelta) {
            lowestDelta = absDelta;

            // Adjust older deltas if necessary
            if (shouldAdjustOldDeltas(orgEvent, absDelta)) {
                lowestDelta /= 40;
            }
        }

        // Adjust older deltas if necessary
        if (shouldAdjustOldDeltas(orgEvent, absDelta)) {
            // Divide all the things by 40!
            delta /= 40;
            deltaX /= 40;
            deltaY /= 40;
        }

        // Get a whole, normalized value for the deltas
        delta = Math[delta >= 1 ? 'floor' : 'ceil'](delta / lowestDelta);
        deltaX = Math[deltaX >= 1 ? 'floor' : 'ceil'](deltaX / lowestDelta);
        deltaY = Math[deltaY >= 1 ? 'floor' : 'ceil'](deltaY / lowestDelta);

        // Add information to the event object
        event.deltaX = deltaX;
        event.deltaY = deltaY;
        event.deltaFactor = lowestDelta;
        // Go ahead and set deltaMode to 0 since we converted to pixels
        // Although this is a little odd since we overwrite the deltaX/Y
        // properties with normalized deltas.
        event.deltaMode = 0;

        // Add event and delta to the front of the arguments
        args.unshift(event, delta, deltaX, deltaY);

        // Clearout lowestDelta after sometime to better
        // handle multiple device types that give different
        // a different lowestDelta
        // Ex: trackpad = 3 and mouse wheel = 120
        if (nullLowestDeltaTimeout) { clearTimeout(nullLowestDeltaTimeout); }
        nullLowestDeltaTimeout = setTimeout(nullLowestDelta, 200);

        return ($.event.dispatch || $.event.handle).apply(this, args);
    }

    function nullLowestDelta() {
        lowestDelta = null;
    }

    function shouldAdjustOldDeltas(orgEvent, absDelta) {
        // If this is an older event and the delta is divisable by 120,
        // then we are assuming that the browser is treating this as an
        // older mouse wheel event and that we should divide the deltas
        // by 40 to try and get a more usable deltaFactor.
        // Side note, this actually impacts the reported scroll distance
        // in older browsers and can cause scrolling to be slower than native.
        // Turn this off by setting $.event.special.mousewheel.settings.adjustOldDeltas to false.
        return special.settings.adjustOldDeltas && orgEvent.type === 'mousewheel' && absDelta % 120 === 0;
    }

}));

define('graphing/viewportcontroller', ['require', 'jquery', 'pjs', './viewporttransformation', 'math/distance', './constants', 'touchtracking', 'jquery.handleevent', 'vendor/jquery.mousewheel'], function(require) {
    var $ = require('jquery');
    var P = require('pjs');
    var ViewportTransformation = require('./viewporttransformation');
    var Distance = require('math/distance');
    var constants = require('./constants');

    require('touchtracking');

    require('jquery.handleevent');
    require('vendor/jquery.mousewheel');

    var GraphController = P(function(proto) {
        proto.init = function(grapher, graphSettings) {
            this.grapher = grapher;
            this.graphSettings = graphSettings;
            this.$ = this.grapher.$;

            // callback
            this.triggerViewportStable = function() {};
            // using for jquery's animate feature. Would be nice to use something
            // more suited to only animation, but probably not worth the overhead.
            this.$animation = $('<div></div>');

            if (!this.graphSettings.config.lockViewport) {
                this.addMouseWheelEventHandler();
                this.addTouchEventHandler();
            }
        };

        proto.getViewport = function() {
            return this.grapher.viewport.clone();
        };

        proto.setViewport = function(viewport) {
            if (!viewport.isValid()) return;
            if (!this.grapher.isInTransientState() && viewport.equals(this.grapher.viewport)) {
                this.triggerViewportStable();
                return;
            }

            this.grapher.viewport = viewport.clone();
            this.endTransientState();
        };

        proto.setTransformation = function(transformation) {

            this.grapher.beginTransientState();
            this.grapher.transformation = transformation;
            this.grapher.redrawAllLayers();

            clearTimeout(this.endTransientTimeout);
            this.endTransientTimeout = setTimeout(this.endTransientState.bind(this), 250);
        };

        proto.endTransientState = function() {
            clearTimeout(this.endTransientTimeout);

            this.grapher.endTransientState();
            this.grapher.redrawAllLayers();

            this.triggerViewportStable();
        };

        proto.animateTransformation = function(transformation) {
            var self = this;
            var currentTransformation = this.grapher.transformation;
            var targetTransformation = currentTransformation.compose(transformation);
            this.cancelAnimation();
            this.$animation.css('percent', 0);
            this.$animation.animate({ 'percent': 100 }, {

                duration: constants.ANIMATE_ZOOM_DURATION,

                step: function(percent) {
                    self.setTransformation(
                        currentTransformation.lerp(targetTransformation, percent / 100.0)
                    );
                }
            });
        };

        proto.cancelAnimation = function() {
            this.$animation.stop();
        };

        // this is simple enough to encapsulate everything in a single closure.
        proto.addMouseWheelEventHandler = function() {
            // Keep track of whether the user is currently scrolling the page with the
            // mousewheel. We don't want to prevent them from scrolling past the
            // calculator. Use the heuristic that if the user has not moved their
            // mouse more than 10px since the last mousewheel that caused a scroll,
            // then they are still scrolling and we should let mousewheel events
            // pass through.
            var scrolling = false;
            var clientX;
            var clientY;

            $(window).on('scroll', function(evt) { scrolling = true; });

            $(window).on('mousewheel', function(evt) {
                // NOTE: jQuery 1.9+ doesn't require .originalEvent here. Can
                // drop it if we upgrade. We're using 1.8.3 at the time of writing.
                clientX = evt.originalEvent.clientX;
                clientY = evt.originalEvent.clientY;
            });

            $(window).on('mousemove', function(evt) {
                if (!scrolling) return;

                var dx = evt.originalEvent.clientX - clientX;
                var dy = evt.originalEvent.clientY - clientY;
                var dsq = dx * dx + dy * dy;

                if (dsq < 100) return;
                scrolling = false;
            });

            var mousewheel_counter = 0;
            var onMouseWheel = function(evt, delta) {
                if (scrolling) return;

                evt.preventDefault();

                if (mousewheel_counter > 0) return;

                mousewheel_counter += 1;
                setTimeout(function() { mousewheel_counter-- }, 50);
                delta = (delta > 0 ? 1 : -1);

                var t = this.grapher.transformation;

                this.setTransformation(
                    t.compose(ViewportTransformation(
                        0,
                        0,
                        (delta > 0) ? constants.ZOOM_FACTOR : 1 / constants.ZOOM_FACTOR
                    ))
                );
            };

            this.$.mousewheel(onMouseWheel.bind(this));
        };

        proto.handleDoubleClick = function(evt) {
            if (this.graphSettings.config.disable_dblclick_zooming) return;
            if (evt.wasHandled()) return;
            evt.preventDefault();

            var pageOffset = this.$.offset();
            var screen = this.grapher.screen;
            var xOffset = evt.pageX - (pageOffset.left + 0.5 * screen.width);
            var yOffset = evt.pageY - (pageOffset.top + 0.5 * screen.height);
            var scale = constants.DOUBLETAP_ZOOM;

            // VT(dx*(1 - scale), dy*(1 - scale), scale) ===
            // VT(dx, dy, 1).VT(0, 0, scale).VT(-dx, -dy, 1);
            // Scales about the click point instead of the origin.
            this.animateTransformation(ViewportTransformation(
                xOffset * (1 - scale),
                yOffset * (1 - scale),
                scale
            ));
        };

        proto.applyPanTouchChanges = function(oldTouches, newTouches) {
            var dx = newTouches[0].x - oldTouches[0].x;
            var dy = newTouches[0].y - oldTouches[0].y;
            var transformation = this.grapher.transformation.compose(
                ViewportTransformation(dx, dy, 1)
            );
            this.setTransformation(transformation);
        };

        proto.applyScaleTouchChanges = function(oldTouches, newTouches, scaleAxis) {

            var panX = Distance.mean(
                newTouches[0].x - oldTouches[0].x,
                newTouches[1].x - oldTouches[1].x
            );

            var panY = Distance.mean(
                newTouches[0].y - oldTouches[0].y,
                newTouches[1].y - oldTouches[1].y
            );

            var screen = this.grapher.screen;
            var offset = this.grapher.$.offset();

            var x0 = Distance.mean(oldTouches[0].x, oldTouches[1].x) -
                (offset.left + 0.5 * screen.width);
            var y0 = Distance.mean(oldTouches[0].y, oldTouches[1].y) -
                (offset.top + 0.5 * screen.height);

            var dxNew = Math.abs(newTouches[1].x - newTouches[0].x);
            var dyNew = Math.abs(newTouches[1].y - newTouches[0].y);
            var dxOld = Math.abs(oldTouches[1].x - oldTouches[0].x);
            var dyOld = Math.abs(oldTouches[1].y - oldTouches[0].y);

            // Decide if this is an isotropic or anisotropic scaling.
            var xScale, yScale;

            // avoid very large or small scaling when fingers cross
            var thresh = 50; // px,
            if (scaleAxis === 'x') {
                yScale = 1;
                xScale = Math.max(thresh, dxNew) / Math.max(thresh, dxOld);
            } else if (scaleAxis === 'y') {
                xScale = 1;
                yScale = Math.max(thresh, dyNew) / Math.max(thresh, dyOld);
            } else {
                xScale = yScale = (
                    Math.max(thresh, Distance.hypot(dxNew, dyNew)) /
                    Math.max(thresh, Distance.hypot(dxOld, dyOld))
                );
            }

            // offset*(1 - scale) is a trick for scaling about a point other than
            // the origin. It's equivalent to translating back to the origin,
            // scaling there, then translating back to offset.
            var transformation = this.grapher.transformation.compose(
                ViewportTransformation(
                    panX + x0 * (1 - xScale),
                    panY + y0 * (1 - yScale),
                    xScale,
                    yScale
                )
            );

            this.setTransformation(transformation);
        };

        // a complete closure to all touch event related code
        proto.addTouchEventHandler = function() {

            var self = this;
            var touches = [];
            var isDragging = false;

            var beginDrag = function(evnt) {

                // must not have been handled already. The POI controller may handle
                // this tapStart for POI purposes and we may want to ignore it.
                if (evnt.wasHandled()) return;

                // must not already be dragging
                if (isDragging) return;

                // must not have a touch down anywhere else. Only want to start dragging
                // if this is the first touch and it's on the grapher
                if (evnt.touches.length !== evnt.changedTouches.length) return;

                // setup drag
                isDragging = true;
                $(document).on('tapmove.graphdrag', updateDrag);
                $(document).on('tapstart.graphdrag tapend.graphdrag tapcancel.graphdrag', updateTouches);
            };

            var _computeScaleAxis = function(touches) {
                if (touches.length < 2) return undefined;

                var projection = self.grapher.createProjection();
                var offset = self.grapher.$.offset();
                var ox = projection.mapx(0);
                var oy = projection.mapy(0);

                // Clamp to screen edges
                ox = Math.min(Math.max(0, ox), projection.screen.width) + offset.left;
                oy = Math.min(Math.max(0, oy), projection.screen.height) + offset.top;

                var xClose = function(x) {
                    return 10 * Math.abs(x - ox) < projection.screen.width;
                };

                var yClose = function(y) {
                    return 10 * Math.abs(y - oy) < projection.screen.height;
                };

                var dx = touches[1].x - touches[0].x;
                var dy = touches[1].y - touches[0].y;

                if (
                    xClose(touches[0].x) &&
                    xClose(touches[1].x) &&
                    Math.abs(dy) > 3 * Math.abs(dx)
                ) {
                    return 'y';
                }

                if (
                    yClose(touches[0].y) &&
                    yClose(touches[1].y) &&
                    Math.abs(dx) > 3 * Math.abs(dy)
                ) {
                    return 'x';
                }

                return 'both';
            };

            var updateScaleAxis = function(touches) {
                if (!self.grapher.scaleAxis) {
                    self.grapher.scaleAxis = _computeScaleAxis(touches);
                }
                return self.grapher.scaleAxis;
            };

            var clearScaleAxis = function() {
                self.grapher.scaleAxis = undefined;
            };

            var updateDrag = function(evnt) {
                // must be dragging
                if (!isDragging) return;

                var newTouches = evnt.touches;

                if (touches.length === 2 && newTouches.length === 2) {
                    // zoom and pan
                    self.applyScaleTouchChanges(
                        touches,
                        newTouches,
                        updateScaleAxis(newTouches)
                    );
                } else {
                    clearScaleAxis();
                }

                if (touches.length === 1) {
                    // only option is to pan...
                    self.applyPanTouchChanges(touches, newTouches);
                }

                touches = newTouches;
            };

            var updateTouches = function(evnt) {

                // must be dragging
                if (!isDragging) return;

                self.cancelAnimation();

                // save our touches so that when we move one we can
                // figure out how the touches have moved.
                touches = evnt.touches;

                // check if drag is over
                if (evnt.touches.length === 0) {
                    isDragging = false;
                    $(document).off('.graphdrag');
                }

                if (evnt.touches.length < 2) {
                    clearScaleAxis();
                }

            };

            this.$.on('tapstart', beginDrag);
            this.$.on('dblclick', this.handleDoubleClick.bind(this));
        };

        proto.zoom = function(action) {
            if (action === 'in') {
                this.animateTransformation(
                    ViewportTransformation(0, 0, 2)
                );
            } else if (action === 'out') {
                this.animateTransformation(
                    ViewportTransformation(0, 0, 0.5)
                );
            } else if (action === 'default') {
                this.grapher.settings.setProperty('squareAxes', true);
                this.setViewport(this.grapher.computeDefaultViewport());
            }
        };

        proto.isZoomRestored = function() {
            return this.grapher.viewport.equals(this.grapher.computeDefaultViewport());
        };

        //executes a the axes squaring
        proto.enforceSquareAxes = function() {
            var settings = this.grapher.settings;

            if (!settings.squareAxes) return;

            var preserveDirection = settings.lastChangedAxis;

            var viewport = this.grapher.viewport.clone();
            if (preserveDirection == 'y') {
                viewport.squareXAxis(this.grapher.screen);
            } else {
                viewport.squareYAxis(this.grapher.screen);
            }
            viewport.round(this.grapher.screen);
            this.setViewport(viewport);
        };
    });

    return GraphController;
});

define('graphing/poicontroller', ['require', 'jquery', 'math/distance', 'lib/rounding', 'graphing/graphmode', 'conditional_blur'], function(require) {
    var $ = require('jquery');
    var Distance = require('math/distance');
    var Rounding = require('lib/rounding');
    var GRAPHMODE = require('graphing/graphmode');
    var conditionalBlur = require('conditional_blur');

    function POIController(grapher, graphSettings) {
        this.manager = grapher;
        this.graphSettings = graphSettings;
        this.$ = this.manager.$;

        this.triggerMovePoint = function(id, screen_pt, projection) {};
        this.triggerSelectExpression = function(id) {};
        this.triggerStartMovingPoint = function() {};
        this.triggerStopMovingPoint = function() {};

        //don't hook up touchandlers for POIs if we don't have a graph paper
        if (!this.graphSettings.config.graphpaper || this.graphSettings.config.disableMouseInteractions) return;
        this.addTouchEventHandlers();
        this.addHoverEventHandler();
    }

    POIController.prototype.getToleranceByDevice = function(device) {
        return device === 'touch' ? 20 : 10;
    };

    POIController.prototype.addHoverEventHandler = function() {

        $(document).on('tapmove', function(evt) {

            // only want this handler to proceed on mouse-based interactions
            if (evt.device === 'touch') return;

            var screen_pt = this.getMouseRelativeToGrapher(evt);
            var tolerance = this.getToleranceByDevice(evt.device);
            var realPointInfo = this.getPointUnderPoint(screen_pt, tolerance);
            var poi = null;
            var movableSketchId = null;

            // if there is a real point under the mouse, then don't show a POI hover
            if (realPointInfo) {
                var movable = realPointInfo.sketch.branches[realPointInfo.branch].graphMode === GRAPHMODE.XYPOINT_MOVABLE;
                movableSketchId = movable ? realPointInfo.sketch.id : null;
            } else {
                poi = this.getPOIUnderPoint(screen_pt, tolerance);
            }

            if (poi != this.manager.poiLabelsLayer.hoveredPOI) {
                this.manager.poiLabelsLayer.hoveredPOI = poi;
                this.manager.redrawPOILayer();
            }

            if (movableSketchId != this.manager.movablePointsLayer.hoveredSketchId) {
                this.manager.movablePointsLayer.hoveredSketchId = movableSketchId;
                this.manager.redrawMovablePointsLayer();
            }
        }.bind(this));
    };

    POIController.prototype.addTouchEventHandlers = function() {

        // hack to prevent dblclick zoom from working when on poi. Ideally, this
        // would happen more naturally. Maybe we wouldn't listen for dblclick within
        // the graphpaper. Only way that could happen is if we move these events
        // to click based instead of mousedown based.
        this.$.on('dblclick', function(evt) {
            var screen_pt = this.getMouseRelativeToGrapher(evt);
            var tolerance = this.getToleranceByDevice(evt.device);
            if (
                this.getPointUnderPoint(screen_pt, tolerance) ||
                this.getPOIUnderPoint(screen_pt, tolerance) ||
                this.getBranchInfoUnderPoint(screen_pt, tolerance)
            ) {
                evt.preventDefault();
                evt.handle();
            }
        }.bind(this));

        this.$.on('tapstart', function(evt) {
            var screen_pt = this.getMouseRelativeToGrapher(evt);
            var tolerance = this.getToleranceByDevice(evt.device);
            conditionalBlur();

            // Cache offset during dragging.
            this.pageOffset = this.$.offset();
            // check if we're on a point list
            var pointInfoUnderMouse = this.getPointUnderPoint(screen_pt, tolerance);
            if (pointInfoUnderMouse) {
                this.triggerStartMovingPoint(pointInfoUnderMouse.id);
                this.startMovingPoint(pointInfoUnderMouse);
                evt.handle(); //prevents panning/zooming
                return;
            }

            // check if we're on a POI. If so, either open or close the POI under
            // the mouse.
            if (this.togglePOIUnderPoint(screen_pt, tolerance)) {
                evt.handle(); //prevents panning/zooming
                return;
            }

            // check if we're on a curve
            var branchInfoUnderMouse = this.getBranchInfoUnderPoint(screen_pt, tolerance);

            if (this.graphSettings.config.onlyTraceSelected) {
                if (branchInfoUnderMouse && branchInfoUnderMouse.sketch && branchInfoUnderMouse.sketch.selected) {
                    this.startTracingBranch(branchInfoUnderMouse, screen_pt);
                    evt.handle(); //prevents panning/zooming
                    return;
                }
            } else {
                if (branchInfoUnderMouse) {
                    this.triggerSelectExpression(branchInfoUnderMouse.id);
                    this.startTracingBranch(branchInfoUnderMouse, screen_pt);
                    evt.handle(); //prevents panning/zooming
                    return;
                }
            }

            //select images / deselect only on full taps
            var self = this;
            this.$.on('tapmove.poicontroller', function() {
                self.$.off('.poicontroller');
            });
            this.$.on('tapend.poicontroller', function(evt) {
                self.$.off('.poicontroller');
                this.pageOffset = undefined;

                var branchInfoUnderMouse = self.getBranchInfoUnderPoint(screen_pt, tolerance);
                if (branchInfoUnderMouse && branchInfoUnderMouse.sketch && !branchInfoUnderMouse.sketch.selected) {
                    // selects expression
                    self.triggerSelectExpression(branchInfoUnderMouse.id);
                    return;
                }

                var imgUnderMouse = self.getImgUnderMouse(screen_pt, tolerance);
                if (imgUnderMouse) {
                    self.triggerSelectExpression(imgUnderMouse.id);
                    return;
                }

                self.triggerSelectExpression(null);
            });

        }.bind(this));
    };

    POIController.prototype.getMouseRelativeToGrapher = function(evt) {
        var pageOffset = this.pageOffset || this.$.offset();
        var pt = evt.touches ? evt.touches[0] : evt;

        return { x: pt.pageX - pageOffset.left, y: pt.pageY - pageOffset.top };
    };

    //modified to give precedence to a MOVABLE POINT
    POIController.prototype.getPointUnderPoint = function(screen_pt, tolerance) {
        var minDistance = tolerance;
        var pointInfo = null;
        var foundMovablePoint = false;
        var sketches = this.manager.graphSketches;
        var projection = this.manager.createProjection();
        for (var id in sketches) {
            var sketch = sketches[id];
            if (!sketch || !sketch.visible) continue;

            var branches = sketch.branches;
            if (!branches || !branches.length) continue;

            for (var i = 0; i < branches.length; i++) {
                var isMovable = (branches[i].graphMode === GRAPHMODE.XYPOINT_MOVABLE);
                if (
                    isMovable ||
                    // only search non-movable branches if we haven't alread found a movable point
                    (!foundMovablePoint && branches[i].graphMode === GRAPHMODE.XYPOINT)
                ) {
                    var list = branches[i].segments[0];

                    for (var j = 0; j < list.length; j++) {
                        var pt = list[j];
                        var mapped = projection.map_pt({ x: pt[0], y: pt[1] });
                        var dis = Distance.hypot(mapped.x - screen_pt.x, mapped.y - screen_pt.y);

                        if (
                            dis < minDistance ||
                            !foundMovablePoint && isMovable && dis < tolerance
                        ) {
                            minDistance = dis;
                            pointInfo = { id: id, branch: i, sketch: sketch, x: pt[0], y: pt[1] };
                        }
                    }
                }
            }
        }

        return pointInfo;
    };

    POIController.prototype.getPOIUnderPoint = function(screen_pt, tolerance) {
        var projection = this.manager.createProjection();
        var poi = this.manager.poiLabelsLayer.getDrawnPOI();
        poi = poi.concat(this.manager.poiDotsLayer.getDrawnPOI());

        if (!poi.length) return null;

        var test_poi = poi[0];
        var mapped_poi = projection.map_pt(test_poi);
        var closest_distance = tolerance;
        var closest_poi = null;

        var test_distance = Distance.hypot(mapped_poi.x - screen_pt.x, mapped_poi.y - screen_pt.y);
        if (test_distance < closest_distance) {
            closest_poi = test_poi;
            closest_distance = test_distance;
        }

        for (var i = 1; i < poi.length; i++) {
            test_poi = poi[i];
            mapped_poi = projection.map_pt(test_poi);

            test_distance = Distance.hypot(mapped_poi.x - screen_pt.x, mapped_poi.y - screen_pt.y);
            if (test_distance < closest_distance) {
                closest_distance = test_distance;
                closest_poi = test_poi;
            }
        }
        return closest_poi;
    };

    // because a POI can be in both the poiLabelsLayer and in
    // the poiDotsLayer, it's possible that this function returns
    // an array with duplicate elements. But, opened points will
    // be returned at the start. Could possibly clean this up,
    // but not too important because this really has only 1 purpose.
    // That purpose is to allow us to open all POI at the exact same
    // location as another one. The functions that use this don't care
    // if a specific POI is contained within the returned array more
    // than once.
    POIController.prototype.getAllPOIAtSameLocation = function(pt) {
        if (!pt) return [];

        var same_poi = [];
        var openedPOI = this.manager.poiLabelsLayer.getDrawnPOI();
        var unopenedPOI = this.manager.poiDotsLayer.getDrawnPOI();
        var all_poi = openedPOI.concat(unopenedPOI);

        if (!all_poi.length) return [];

        for (var i = 0; i < all_poi.length; i++) {
            var poi = all_poi[i];

            // doesn't handle the case where x or y is NaN, but in that
            // case I don't think we'd be able to assume the POI are at
            // the same location. NaN means hole and there's no guarantee
            // that the hole is in the same spot. At this point, we don't
            // have information about if this is a discontinuity or not and
            // if it's a discontinuity, we definitely don't know where it is.
            if (poi.x === pt.x && poi.y === pt.y) {
                same_poi.push(poi);
            }
        }
        return same_poi;
    };

    POIController.prototype.togglePOIUnderPoint = function(screen_pt, tolerance) {
        var poiUnderMouse = this.getPOIUnderPoint(screen_pt, tolerance);
        var allPOIUnderMouse = this.getAllPOIAtSameLocation(poiUnderMouse);

        if (allPOIUnderMouse.length) {

            // want to set all poi under mouse to open or all to closed
            var isOpen = allPOIUnderMouse[0].isOpen();

            for (var i = 0; i < allPOIUnderMouse.length; i++) {
                if (isOpen) {
                    allPOIUnderMouse[i].close();

                    // hide hovered poi
                    this.manager.poiLabelsLayer.hoveredPOI = null;
                } else {
                    allPOIUnderMouse[i].open();
                }
            }

            this.manager.redrawPOILayer();
            return true;
        } else {
            return false;
        }
    };

    POIController.prototype.getImgUnderMouse = function(screen_pt, tolerance) {
        var projection = this.manager.createProjection();
        var pt = projection.reverse_map_pt(screen_pt);

        var graphInfo = null;

        var isInside = function(val, center, width, padding) {
            return (
                (val < center + 0.5 * Math.abs(width) + padding) &&
                (val > center - 0.5 * Math.abs(width) + padding)
            );
        };

        for (var id in this.manager.graphImages) {
            var img = this.manager.graphImages[id];
            if (!img || img.hidden) continue;

            if (!isInside(pt.x, img.computed_x, img.computed_width, 0)) continue;
            if (!isInside(pt.y, img.computed_y, img.computed_height, 0)) continue;
            graphInfo = { id: id, img: img };
        }
        return graphInfo;
    };

    // TODO - cleanup
    // returns an object containing the id, sketch, and the branch
    POIController.prototype.getBranchInfoUnderPoint = function(screen_pt, tolerance) {

        var graphInfo = null;
        var minDis = tolerance;
        var projection = this.manager.createProjection();
        var pt = projection.reverse_map_pt(screen_pt);

        for (var id in this.manager.graphSketches) {
            var sketch = this.manager.graphSketches[id];
            if (!sketch || !sketch.visible) continue;

            var branches = sketch.branches;
            if (!branches || !branches.length) continue;

            for (var i = 0; i < branches.length; i++) {
                var distance = POIController.calculateDistanceFromBranch(branches[i], pt, projection);
                if (distance < minDis) {
                    minDis = distance;
                    graphInfo = { id: id, branch: i, sketch: sketch };
                }
            }
        }

        return graphInfo;
    };

    POIController.calculateDistanceFromBranch = function(branch, pt, projection) {
        var distanceInfo = POIController.getBranchesDistanceInfo(branch, pt, projection);
        if (!distanceInfo) return Infinity;
        return distanceInfo.minDistance;
    };

    // Computes the closest point on branch to pt in screen space, along with some additional info
    // that is useful for tracing.
    //
    // Returns an object
    // {
    //   closestPoint: { x: 1.0, y: 2.0},
    //   minDistance: 3.0,
    //   secondDistance: 4.0
    // }
    //
    // Where the closest point coordinates are in math space, but the distances are measured in
    // screen space.
    //
    // If the closest point on the branch lies to the left/right of pt, then secondDistance is the
    // distance to the closest point to the right/left of pt respectively. This information is used
    // by getBranchesTracePoint to interpolate between using the closest point and using a point
    // directly above the mouse in order to avoid discontinuous jumps in the trace point when there
    // is a discontinuous jump in the closest point on the curve.
    POIController.getBranchesDistanceInfo = function(branch, pt, projection) {

        var xscale = projection.screen.width / (projection.viewport.xmax - projection.viewport.xmin);
        var yscale = projection.screen.height / (projection.viewport.ymax - projection.viewport.ymin);

        var x = pt.x;
        var y = pt.y;

        switch (branch.graphMode) {
            case GRAPHMODE.Y:
                break;

            case GRAPHMODE.X:
                var tmp_swap = x;
                x = y;
                y = tmp_swap;
                tmp_swap = xscale;
                xscale = yscale;
                yscale = tmp_swap;
                break;

            default:
                return null;
        }

        var minLeftDistance = Infinity;
        var minRightDistance = Infinity;
        var closestLeftPoint;
        var closestRightPoint;

        for (var i = 0; i < branch.segments.length; i++) {
            var segment = branch.segments[i];
            for (var j = 0; j < segment.length - 3; j += 2) {
                var x1 = segment[j];
                var y1 = segment[j + 1];
                var x2 = segment[j + 2];
                var y2 = segment[j + 3];
                var p = Distance.closestPointOnSegment(
                    0, 0,
                    (x1 - x) * xscale, (y1 - y) * yscale,
                    (x2 - x) * xscale, (y2 - y) * yscale
                );
                var distance = Distance.hypot(p[0], p[1]);
                if (p[0] < 0) {
                    if (distance < minLeftDistance) {
                        minLeftDistance = distance;
                        closestLeftPoint = p;
                    }
                } else {
                    if (distance < minRightDistance) {
                        minRightDistance = distance;
                        closestRightPoint = p;
                    }
                }
            }
        }

        var closestPoint = (minLeftDistance < minRightDistance) ? closestLeftPoint : closestRightPoint;

        // Can happen if the branch has no segments, or if there is a segment with no points.
        if (!closestPoint) return null;

        var x_closest = closestPoint[0] / xscale + x;
        var y_closest = closestPoint[1] / yscale + y;

        return {
            closestPoint: {
                x: (branch.graphMode === GRAPHMODE.Y) ? x_closest : y_closest,
                y: (branch.graphMode === GRAPHMODE.Y) ? y_closest : x_closest
            },
            minDistance: Math.min(minLeftDistance, minRightDistance),
            secondDistance: Math.max(minLeftDistance, minRightDistance)
        };

    };

    // Picks a point on the curve that is close to pt for tracing.
    //
    // Considers the distance to the closest point on the curve that is to the left of pt and the
    // closest point on the curve that is to the right of pt. If these distances are very different,
    // uses the closest point on the curve. If these distances are similar, then a small change in the
    // position of pt could cause a discontinuous jump in the closestPoint, so we smoothly switch to
    // using a point directly above pt instead of the closest point.
    //
    // The two primary goals of this algorithm are to use the closest point on the curve when the mouse
    // is near the curve, and to avoid discontinuous jumps of the trace point as the mouse is moved.
    POIController.getBranchesTracePoint = function(branch, pt, projection) {
        // tables lack this, so we shouldn't don't try to see how close we are
        if (!branch || !branch.compiled || !branch.compiled.fn) return;
        var fn = branch.compiled.fn;

        var xscale = projection.screen.width / (projection.viewport.xmax - projection.viewport.xmin);
        var yscale = projection.screen.height / (projection.viewport.ymax - projection.viewport.ymin);

        var distanceInfo = this.getBranchesDistanceInfo(branch, pt, projection);

        if (!distanceInfo) return null;

        var aboveWeight = distanceInfo.minDistance / distanceInfo.secondDistance;

        // Exponent here is kind of a fudge factor. Higher exponents favor taking the closest point
        // over smoothly traversing the curve.
        aboveWeight = aboveWeight * aboveWeight;

        var dir = (branch.graphMode === GRAPHMODE.Y) ? 'x' : 'y';

        var x_weighted = (
            distanceInfo.closestPoint[dir] * (1 - aboveWeight) +
            pt[dir] * aboveWeight
        );

        // Want to find an x value with a nice decimal representation s.t.
        // x, f(x) lies within 1 pixel of x_weighted, f(x_weighted).
        // Evalutate function a half-pixel to the left and right of x_weighted,
        // and then linearly interpolate to restrict y values if necessary.
        var dx = 1 / (2 * xscale);
        var dy = 1 / (2 * yscale);

        var y_left = fn(x_weighted - dx);
        var y_mid = fn(x_weighted);
        var y_right = fn(x_weighted + dx);

        var dx_left = dx * Math.min(1, dy / Math.abs(y_left - y_mid));
        var dx_right = dx * Math.min(1, dy / Math.abs(y_right - y_mid));

        if (!isFinite(dx_left)) dx_left = dx;
        if (!isFinite(dx_right)) dx_right = dx;

        x_weighted = Rounding.shortestDecimalBetween(x_weighted - dx_left, x_weighted + dx_right);

        var above = POIController.fillHole(fn, x_weighted, xscale, yscale, pt.x, pt.y);

        return {
            x: (branch.graphMode === GRAPHMODE.Y) ? x_weighted : above,
            y: (branch.graphMode === GRAPHMODE.Y) ? above : x_weighted
        };
    };

    POIController.prototype.startMovingPoint = function(branchInfo) {
        var move_occured = false;
        var pt = {
            x: branchInfo.x,
            y: branchInfo.y
        };
        var id = branchInfo.id;
        var movable = branchInfo.sketch.branches[branchInfo.branch].graphMode === GRAPHMODE.XYPOINT_MOVABLE;

        this.manager.movablePointsLayer.pressedSketchId = movable ? branchInfo.sketch.id : null;
        this.manager.redrawMovablePointsLayer();

        $(document).on('tapmove.movepoint', function(evt) {
            move_occured = true;

            var projection = this.manager.createProjection();
            var screen_pt = this.getMouseRelativeToGrapher(evt);
            this.triggerMovePoint(id, screen_pt, projection);
        }.bind(this));

        $(document).on('tapend.movepoint tapcancel.movepoint', function(evt) {
            $(document).off('.movepoint');

            this.manager.movablePointsLayer.pressedSketchId = null;
            this.manager.redrawMovablePointsLayer();
            this.triggerStopMovingPoint(id);

            // if this was just a tap, then open a label for the point
            if (!move_occured) {
                var projection = this.manager.createProjection();
                var tolerance = this.getToleranceByDevice(evt.device);

                // figure out the exact location of the point on the screen
                var screen_pt = projection.map_pt({ x: pt.x, y: pt.y });
                var sketch = this.manager.getGraphSketch(id);

                // save how many poi are open for this id
                var oldPOICount = sketch.openPOI.length;
                // toggle the poi
                this.togglePOIUnderPoint(screen_pt, tolerance);
                // check how many poi are open for this particular id now
                var newPOICount = sketch.openPOI.length;

                // notify that the point was clicked. If it was deselected, send null.
                if (newPOICount > oldPOICount) this.triggerSelectExpression(id);
            }
        }.bind(this));
    };

    // TODO - duplicating some code here
    POIController.prototype.startTracingBranch = function(branchInfo, screen_pt) {
        this.last_screen_pt = screen_pt;
        var projection = this.manager.createProjection();
        var pt = projection.reverse_map_pt(screen_pt);

        var sketch = branchInfo.sketch;
        var branch = sketch.branches[branchInfo.branch];
        var tracePt = POIController.getBranchesTracePoint(branch, pt, projection);

        this.manager.traceLayer.traceInfo = { pt: tracePt, branchInfo: branchInfo };
        this.manager.redrawTraceLayer();

        $(document).on('tapmove.tracing', this.handleTraceUpdate.bind(this));
        $(document).on('tapend.tracing tapcancel.tracing', this.stopTracingBranch.bind(this));
    };

    POIController.prototype.stopTracingBranch = function(evt) {

        // if we're over an unopened hovered poi, open it
        var hoveredPOI = this.manager.poiLabelsLayer.hoveredPOI;
        if (hoveredPOI && !hoveredPOI.isOpen()) {
            hoveredPOI.open();
            this.manager.redrawPOILayer();
        }

        this.manager.traceLayer.traceInfo = null;
        this.manager.redrawTraceLayer();

        $(document).off('.tracing');
    };

    POIController.prototype.handleTraceUpdate = function(evt) {
        if (!this.manager.traceLayer.traceInfo) return;
        var projection = this.manager.createProjection();
        var screen_pt;
        if (evt) {
            screen_pt = this.getMouseRelativeToGrapher(evt);
            this.last_screen_pt = screen_pt;
        } else {
            screen_pt = this.last_screen_pt;
        }
        var pt = projection.reverse_map_pt(screen_pt);
        var minDis = Infinity;
        var bestBranch = -1;

        var traceInfo = this.manager.traceLayer.traceInfo;
        var traceSketch = this.manager.graphSketches[traceInfo.branchInfo.sketch.id];
        traceInfo.branchInfo.sketch = traceSketch;
        var branches = traceInfo.branchInfo.sketch.branches;
        //Look up new branch each time

        // Loop through branches to find which we're closest too
        for (var i = 0; i < branches.length; i++) {
            var branchDis = POIController.calculateDistanceFromBranch(branches[i], pt, projection);
            if (branchDis < minDis) {
                bestBranch = i;
                minDis = branchDis;
            }
        }

        var branch = branches[bestBranch];
        var tracePt = branch ? POIController.getBranchesTracePoint(branch, pt, projection) : null;

        this.manager.traceLayer.traceInfo.pt = tracePt;
        this.manager.redrawTraceLayer();
    };

    // TODO - might not belong here.. might be more appropriate in the math/poi.js
    // TODO - probably better to be smarter about 'tiny offset'. should use a
    //        dynmaic offset rather than always using 0.00000000001
    POIController.fillHole = function(fn, x_val, xscale, yscale, x, y) {
        var y_val = fn(x_val);
        if (isFinite(y_val)) return y_val;

        var x_left = x_val - 0.00000000001;
        var x_right = x_val + 0.00000000001;
        var y_left = fn(x_left);
        var y_right = fn(x_right);

        if (isNaN(y_left) && isNaN(y_right)) return NaN;
        if (isNaN(y_left)) return y_right;
        if (isNaN(y_right)) return y_left;

        var dx_left = (x - x_left) * xscale;
        var dx_right = (x - x_right) * xscale;
        var dy_left = (y - y_left) * yscale;
        var dy_right = (y - y_right) * yscale;

        if (Distance.hypot(dx_left, dy_left) < Distance.hypot(dx_right, dy_right)) {
            return y_left;
        } else {
            return y_right;
        }
    };

    return POIController;
});

define('graphing/grapher', ['require', 'jquery', 'browser', './viewport', './viewporttransformation', './screen', './poidotslayer', './poilabelslayer', './gridlayer', './graphsketch', './canvaslayer', './graphslayer', './imagelayer', './projection', './tracelayer', './movablepointslayer', 'math/poi', './viewportcontroller', './poicontroller'], function(require) {
    var $ = require('jquery');
    var Browser = require('browser');
    var Viewport = require('./viewport');
    var ViewportTransformation = require('./viewporttransformation');
    var Screen = require('./screen');
    var POIDotsLayer = require('./poidotslayer');
    var POILabelsLayer = require('./poilabelslayer');
    var GridLayer = require('./gridlayer');
    var GraphSketch = require('./graphsketch');
    var CanvasLayer = require('./canvaslayer');
    var GraphsLayer = require('./graphslayer');
    var ImageLayer = require('./imagelayer');
    var Projection = require('./projection');
    var TraceLayer = require('./tracelayer');
    var MovablePointsLayer = require('./movablepointslayer');
    var POI = require('math/poi');
    var ViewportController = require('./viewportcontroller');
    var POIController = require('./poicontroller');

    // This is the guy you talk to in order to allocate/deallocate graph layers.
    // container is the <div> element that holds the graph area. Grapher handles resize automatically.
    // onRecompute is the handler that should be called when a recompute is requested.
    // onRecompute(viewport as Viewport, screen as Screen)
    function Grapher(container, settings, $root) {
        this.container = container;
        this.$ = $(container);
        this.$root = $root;

        this.viewport = new Viewport();

        // a reference to an UnderscoreModel that we can ask for settings values
        this.settings = settings;

        // Warning, order matters here because both of these bind touch event
        // handlers, and we need tracing (poiController) to get priority over
        // dragging (viewportController).
        this.poiController = new POIController(this, settings);
        this.viewportController = ViewportController(this, settings);

        this.$.css('overflow', 'hidden');

        // image (canvas layer)
        this.imageLayer = ImageLayer();
        this.$.append(this.imageLayer.$);
        // gridlines (canvas layer)
        this.gridLayer = GridLayer();
        this.$.append(this.gridLayer.$);

        // poi dots (canvas layer)
        this.poiDotsLayer = POIDotsLayer();
        this.$.append(this.poiDotsLayer.$);

        // graphs (canvas layer)
        this.graphsLayer = GraphsLayer();
        this.$.append(this.graphsLayer.$);

        //movable points dom (DOM layer)
        this.movablePointsLayer = MovablePointsLayer(this.$root);
        this.movablePointsLayer.$.css('z-index', '0');
        this.$.append(this.movablePointsLayer.$);

        // poi labels and opened dots (DOM layer)
        this.poiLabelsLayer = POILabelsLayer(this.$root);
        // some weird interaction with overflow:hidden requires a z-index to be
        // set for openpoi to not flicker.
        this.poiLabelsLayer.$.css('z-index', '0');
        this.$.append(this.poiLabelsLayer.$);

        // trace layer (DOM layer)
        this.traceLayer = TraceLayer(this.$root);
        // some weird interaction with overflow:hidden requires a z-index to be
        // set for the tracing label to not flicker.
        this.traceLayer.$.css('z-index', '0');
        this.$.append(this.traceLayer.$);

        // needed to tell IE9 that the layer should steal mouse events.
        if (Browser.IS_IE9) {
            this.traceLayer.$.addClass('dcg-transparent-bg');
        }

        this.transformation = new ViewportTransformation();

        // Which axes are currently being scaled. Managed by GraphController.
        // 'x', 'y', 'both', or undefined
        this.scaleAxis = undefined;

        this.__transient = false;
        this.graphSketches = {};
        this.graphImages = {};
        this.__sketchOrder = [];
        this.selectedId = null;
    }

    Grapher.prototype.setSketchOrder = function(drawOrder) {
        this.__sketchOrder = drawOrder;
        this.redrawGraphsLayer();
        this.redrawImageLayer();
    };

    Grapher.prototype.clear = function() {
        this.graphSketches = {};
        this.graphImages = {};
    };

    Grapher.prototype.getGraphSketch = function(graphId) {
        if (graphId in this.graphSketches) {
            return this.graphSketches[graphId];
        } else {
            return null;
        }
    };

    Grapher.prototype.addGraphSketch = function(sketch) {
        this.graphSketches[sketch.id] = sketch;
    };

    Grapher.prototype.removeGraphSketch = function(graphId) {
        delete this.graphSketches[graphId];
    };

    Grapher.prototype.addGraphImage = function(image) {
        this.graphImages[image.id] = image;
    };
    Grapher.prototype.removeGraphImage = function(imageId) {
        delete this.graphImages[imageId];
    };

    Grapher.prototype.createProjection = function() {
        var projection = new Projection(this.screen, this.viewport, this.settings);

        if (this.isInTransientState()) {
            return this.transformation.transformProjection(projection);
        } else {
            return projection;
        }
    };

    Grapher.prototype.computeDefaultViewport = function() {
        var viewport = new Viewport(-10, 10, -10, 10);
        viewport.squareYAxis(this.screen);
        viewport.round(this.screen);

        return viewport;
    };

    // Updates the screen sizes of all of the layers and requests a redraw, viewport stays the same.
    Grapher.prototype.updateScreenSize = function(w, h) {
        if (w <= 0 || h <= 0) return;
        if (this.screen && this.screen.width === w && this.screen.height === h) return;
        this.$.width(w);

        var newScreen = new Screen(w, h);
        var newViewport;

        if (this.settings && this.settings.squareAxes) {

            // The following is used mainly in the API, for the case that the graphaper
            // starts off hidden or with zero size, and is later set to a finite size.
            if (!this.screen) {
                newViewport = this.viewport.clone();
                newViewport.squareYAxis(newScreen);
                newViewport.round(newScreen);
            } else {
                newViewport = this.createProjection().calculateViewportForScreen(newScreen);
            }
        } else {
            newViewport = this.viewport.clone();
        }

        this.screen = newScreen;

        this.viewportController.setViewport(newViewport);

        this.redrawAllLayers();
    };

    Grapher.prototype.beginTransientState = function() {
        if (this.isInTransientState()) return;

        var projection = this.createProjection();
        this.settings.isViewportTransient = true;
        this.graphsLayer.saveUnscaledCanvas(projection);

        this.__transient = true;
    };

    Grapher.prototype.endTransientState = function() {
        if (!this.isInTransientState()) return;
        var projection = this.createProjection();
        this.viewport = projection.viewport;
        this.viewport.round(projection.screen);
        this.settings.setProperty(
            'squareAxes',
            this.viewport.isSquare(projection.screen)
        );
        this.settings.isViewportTransient = false;
        this.transformation = new ViewportTransformation();
        this.graphsLayer.releaseUnscaledCanvas();
        this.__transient = false;
    };

    Grapher.prototype.isInTransientState = function() {
        return this.__transient;
    };

    Grapher.prototype.hide = function(id) {
        var sketch = this.getGraphSketch(id);
        if (sketch) sketch.visible = false;
    };

    Grapher.prototype.select = function(id) {
        var currentSketch = this.getGraphSketch(this.selectedId);
        if (currentSketch) currentSketch.selected = currentSketch.showPOI = currentSketch.showHighlight = false;
        var newSketch = this.getGraphSketch(id);
        if (newSketch) newSketch.selected = newSketch.showPOI = newSketch.showHighlight = true;
        this.selectedId = id;
    };

    Grapher.prototype.updateSketch = function(id, graphData) {
        //Pause updates while zooming, to stay in sync with cached canvas
        if (this.isInTransientState()) return;
        var currentSketch = this.getGraphSketch(id);

        //TODO When does this happen?
        if (!graphData.length) return this.hide(id);

        var newSketch = new GraphSketch(id, graphData);
        //TODO - handle differently-colored branches
        newSketch.color = graphData[0].color;
        newSketch.style = graphData[0].style;
        newSketch.updateFrom(currentSketch);
        newSketch.selected = newSketch.showPOI = newSketch.showHighlight = (String(id) === String(this.selectedId));
        this.addGraphSketch(newSketch);
    };

    Grapher.prototype.updateIntersections = function(id, intersections) {
        var sketch = this.getGraphSketch(id);
        if (sketch) sketch.updateIntersections(intersections);
    };

    Grapher.prototype.redrawAllLayers = function() {
        this.cancelRedrawSlowly();
        this.redrawGridLayer();
        this.redrawContentLayers();
    };

    Grapher.prototype.redrawContentLayers = function() {
        this.cancelRedrawSlowly();
        this.redrawGraphsLayer();
        this.redrawPOILayer();
        this.redrawTraceLayer();
        this.redrawMovablePointsLayer();
        this.redrawImageLayer();
    };

    Grapher.prototype.cancelRedrawSlowly = function() {
        clearTimeout(this.redraw_slowly_timeout);
        this.redraw_slowly_timeout = null;
    };

    Grapher.prototype.redrawSlowly = function(delay, step, n) {
        //This is an intentional slow-down used on initial graph loads to give a line-by-line drawing effect.
        //It draws only the first n graphs, and calls itself repeatedly on a timeout until all layers are drawn
        //Every delay ms, it draws step more graphs
        if (typeof(delay) === 'undefined') {
            delay = 30;
        }
        if (typeof(step) === 'undefined') {
            step = 1;
        }
        if (typeof(n) === 'undefined') {
            this.cancelRedrawSlowly();
            n = 0;
        }

        this.redrawGridLayer(); //Always draw grid first
        var sketches_to_draw = {};
        var stopped_early = false;
        var i = 0;
        for (var id in this.graphSketches) {
            if (i++ > n) {
                stopped_early = true;
                break;
            }
            sketches_to_draw[id] = this.graphSketches[id];
        }
        this.graphsLayer.redraw(this.createProjection(), sketches_to_draw, this.__sketchOrder);

        if (stopped_early) {
            var self = this;
            //Store timeout so that this can be interrupted
            this.redraw_slowly_timeout = setTimeout(function() { self.redrawSlowly(delay, step, n + step) }, delay);
        } else {
            //Only draw trace and POI if this was our last iteration
            this.redrawPOILayer();
            this.redrawTraceLayer();
            this.redrawMovablePointsLayer();

            this.redraw_slowly_timeout = null;
        }
    };

    Grapher.prototype.redrawGridLayer = function() {
        if (!this.screen) return;
        this.gridLayer.redraw(this.createProjection(), this.scaleAxis);
    };

    Grapher.prototype.redrawGraphsLayer = function() {
        if (!this.screen) return;
        if (!this.isInTransientState()) {
            this.graphsLayer.redraw(this.createProjection(), this.graphSketches, this.__sketchOrder);
        } else {
            this.graphsLayer.paintScaledCanvas(this.transformation);
        }
    };

    Grapher.prototype.redrawMovablePointsLayer = function() {
        if (!this.screen) return;
        this.movablePointsLayer.redraw(this.createProjection(), this.graphSketches);
    };

    Grapher.prototype.redrawPOILayer = function() {
        if (!this.screen) return;
        this.poiDotsLayer.redraw(this.createProjection(), this.graphSketches);
        this.poiLabelsLayer.redraw(this.createProjection(), this.graphSketches);
    };

    Grapher.prototype.redrawTraceLayer = function() {
        if (!this.screen) return;
        this.traceLayer.redraw(this.createProjection());
    };

    Grapher.prototype.redrawImageLayer = function() {
        if (!this.screen) return;
        this.imageLayer.redraw(this.createProjection(), this.graphImages, this.__sketchOrder);
    };

    Grapher.prototype.screenshot = function(width, height) {
        height = height || width || this.screen.height;
        width = width || this.screen.width;
        var screen = new Screen(width, height);

        var printLayer = CanvasLayer();
        printLayer.resize(width, height);
        var ctx = printLayer.ctx;

        var settings = this.settings.clone();
        if (width < 256 || height < 256) {
            settings.setProperty('xAxisNumbers', false);
            settings.setProperty('yAxisNumbers', false);
            settings.setProperty('polarNumbers', false);
        }

        var viewport = this.viewport.clone();

        if (viewport.isSquare(this.screen)) viewport.squareCrop(screen);

        var projection = new Projection(screen, viewport, settings);

        // Make a white background, since transparent backgrounds are funny in some
        // environments.
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, screen.width, screen.height);

        this.settings.takingScreenshot = true;
        this.imageLayer.redrawToCtx(ctx, projection, this.graphImages);
        this.gridLayer.redrawToCtx(ctx, projection);
        this.graphsLayer.redrawToCtx(ctx, projection, this.graphSketches);
        this.settings.takingScreenshot = false;

        return printLayer.canvas_node.get(0).toDataURL("image/png");
    };

    Grapher.prototype.thumbnail = Grapher.prototype.screenshot;

    Grapher.prototype.getOpenIntersectionIds = function() {
        var openPOI;
        var hiddenOpenPOI;
        var i;

        var intersectIds = {};

        for (var id in this.graphSketches) {
            if (!this.graphSketches.hasOwnProperty(id)) continue;
            openPOI = this.graphSketches[id].openPOI;
            for (i = openPOI.length - 1; i >= 0; i--) {
                if (openPOI[i].type === POI.INTERSECTION) intersectIds[id] = true;
            }
            hiddenOpenPOI = this.graphSketches[id].hiddenOpenPOI;
            for (i = hiddenOpenPOI.length - 1; i >= 0; i--) {
                if (hiddenOpenPOI[i].type === POI.INTERSECTION) intersectIds[id] = true;
            }
        }

        return intersectIds;
    };

    Grapher.prototype.getSetting = function(setting, _default) {
        var value = this.settings.getProperty(setting);
        return value !== undefined ? value : _default;
    };

    Grapher.prototype.setSetting = function(setting, value, _default) {
        this.settings.setProperty(
            setting,
            value !== undefined ? value : _default
        );
    };

    Grapher.prototype.getState = function() {
        var state = {};
        var self = this;

        this.settings.stateProperties.forEach(function(prop) {
            state[prop] = self.getSetting(prop);
        });

        state.viewport = this.viewportController.getViewport().toObject();

        return state;
    };

    // TODO - Each one of these setSetting commands will update the grids
    // layer. That's not terrible, but it might be nice to have control over
    // that.
    //
    // Might be worth adding the observer in here rather than in
    // graph_settings.js so that we can turn the observer off/on cleanly
    // any time we do a batch update like this.
    Grapher.prototype.setState = function(state) {
        this.setSetting('showGrid', state.showGrid, true);
        this.setSetting('polarMode', state.polarMode, false);
        this.setSetting('showXAxis', state.showXAxis, !!state.showAxes); // used to have a single showAxes option
        this.setSetting('showYAxis', state.showYAxis, !!state.showAxes); // used to have a single showAxes option
        this.setSetting('squareAxes', state.squareAxes, true);
        this.setSetting('xAxisStep', state.xAxisStep, state.labelXMode === 'pi' ? Math.PI : 0);
        this.setSetting('yAxisStep', state.yAxisStep, state.labelYMode === 'pi' ? Math.PI : 0);
        this.setSetting('degreeMode', state.degreeMode, false);
        this.setSetting('xAxisArrows', state.xAxisArrows, 'none');
        this.setSetting('yAxisArrows', state.yAxisArrows, 'none');
        this.setSetting('xAxisLabel', state.xAxisLabel, '');
        this.setSetting('yAxisLabel', state.yAxisLabel, '');
        this.setSetting('xAxisNumbers', state.xAxisNumbers, !!state.showLabels); //used to have a single showLabels option
        this.setSetting('yAxisNumbers', state.yAxisNumbers, !!state.showLabels); //used to have a single showLabels option
        this.setSetting('polarNumbers', state.polarNumbers, !!state.showLabels); //used to have a single showLabels option

        if ("viewport" in state) {
            var viewport = Viewport.fromObject(state.viewport);
            if (
                this.screen &&
                this.getSetting('squareAxes') &&
                !viewport.isSquare(this.screen)
            ) {
                viewport.squareYAxis(this.screen);
                viewport.round(this.screen);
            }

            this.viewportController.setViewport(viewport);
        }

    };

    return Grapher;
});

define('main/graph_settings', ['require', 'pjs', 'underscore_model'], function(require) {
    var P = require('pjs');
    var UnderscoreModel = require('underscore_model');

    /*
     * graph settings
     */

    var GraphSettings = P(UnderscoreModel, function(settings, _super) {

        //these are user-defined properties and can be saved in the state
        settings.init = function() {
            _super.init.call(this);
            this.stateProperties = [];

            //config holds properties of the individual API instance that
            //shouldn't be cloned (e.g. keyboardVisible). It has setProperty & getProperty
            //like any other underscore model
            this.config = new UnderscoreModel();

            // stored in state
            this.addStateProperty('showGrid', true);
            this.addStateProperty('polarMode', false);
            this.addStateProperty('showXAxis', true);
            this.addStateProperty('showYAxis', true);
            this.addStateProperty('xAxisStep', 0);
            this.addStateProperty('yAxisStep', 0);
            this.addStateProperty('degreeMode', false);
            this.addStateProperty('xAxisArrows', 'none');
            this.addStateProperty('yAxisArrows', 'none');
            this.addStateProperty('xAxisLabel', '');
            this.addStateProperty('yAxisLabel', '');
            this.addStateProperty('xAxisNumbers', true);
            this.addStateProperty('yAxisNumbers', true);
            this.addStateProperty('polarNumbers', true);
            this.addStateProperty('projectorMode', false);
            this.addStateProperty('squareAxes', true);

            // not stored in state
            this.computedStepSizes = {};
            this.squareAxes = true;

            //non computed -- these are the same for projectorMode and non-projector Mode
            this.labelHangingColor = 'rgba(150,150,150,1)';
            this.labelNormalColor = 'rgba(0,0,0,1)';

            //non-computed and not-stored in state. Just used for squaring Axes
            this.lastChangedAxis = 'x';

            // below here are properties that *are not* stored in the state and can,
            // right now, only be changed by toggling 'projectorMode'
            var self = this;

            function createProjectorProperty(property, offValue, onValue) {

                function computeProperty() {
                    self.setProperty(property, self.projectorMode ? onValue : offValue);
                }

                self.observe('projectorMode', computeProperty);
                computeProperty();
            }

            function createHighlightProperty(property, off_off, off_on, on_off, on_on) {
                function computeProperty() {
                    var value;
                    if (self.projectorMode) {
                        value = self.highlight ? on_on : on_off;
                    } else {
                        value = self.highlight ? off_on : off_off;
                    }

                    self.setProperty(property, value);
                }

                self.observe('projectorMode highlight', computeProperty);
                computeProperty();
            }

            //font size of labels
            createProjectorProperty('labelSize', 12, 16);
            //darker grid lines
            createProjectorProperty('majorAxisOpacity', 0.3, 0.5);

            //lighter grid lines
            createProjectorProperty('minorAxisOpacity', 0.12, 0.15);

            //main axes
            createProjectorProperty('axisOpacity', 0.7, 0.9);

            createProjectorProperty('axisLineWidth', 1, 2);

            //for antialiasing axes
            createProjectorProperty('axisLineOffset', 0.5, 0);

            //minimum separation between major axis lines
            createProjectorProperty('pixelsPerLabel', 70, 100);

            //line width for graphs
            createHighlightProperty('graphLineWidth', 2, 3, 6, 9);

            //line width for points
            createHighlightProperty('pointLineWidth', 7, 11, 15, 22);
        };

        settings.addStateProperty = function(prop, defaultValue) {
            this[prop] = defaultValue;
            this.stateProperties.push(prop);
        };

        settings.clone = function() {
            var newSettings = GraphSettings(this.grapher);

            var self = this;
            this.stateProperties.forEach(function(prop) {
                newSettings.setProperty(prop, self[prop]);
            });

            newSettings.setProperty('squareAxes', this.squareAxes);

            return newSettings;
        };

        settings.registerCallbacks = function(grapher, expressionsView, $rootElement) {

            var self = this;

            this.stateProperties.forEach(function(prop) {
                self.observe(prop, function() {
                    grapher.redrawGridLayer();
                });
            });

            this.observe('squareAxes', function() {
                grapher.viewportController.enforceSquareAxes();
            });

            this.observe('projectorMode', function() {
                //set class on the body for POIs & trace -- see poi.css
                $rootElement.toggleClass('dcg-PROJECTOR-MODE', !!self.projectorMode);
                if (expressionsView) {
                    expressionsView.onProjectorModeChange();
                }
                grapher.redrawAllLayers();
            });
        };
    });

    return GraphSettings;
});


define('expressions/abstractitem', ['require', 'pjs', 'underscore_model'], function(require) {
    var P = require('pjs');
    var UnderscoreModel = require('underscore_model');

    var AbstractItemModel = P(UnderscoreModel, function(model, _super) {

        var nextItemId = 1;

        model.init = function(state, list) {
            _super.init.call(this);

            // TODO - these belong on view, not the model
            this.index = -1;
            this.selected = false;
            this.list = list;

            // Normalize ids to strings. Note that some legacy states are stored with integer ids.
            for (var property in state) {
                if (state.hasOwnProperty(property)) {
                    if (property === 'id') {
                        this[property] = '' + state[property];
                    } else {
                        this[property] = state[property];
                    }
                }
            }

            if (!this.hasOwnProperty('id')) {
                this.id = '' + nextItemId++;
            } else if (parseInt(this.id, 10) >= nextItemId) {
                nextItemId = parseInt(this.id, 10) + 1;
            }

            this.observe('folder', this.updateFolder.bind(this));
            this.observe('selected', this.__onSelectedChange.bind(this));
        };

        model.eachLatex = function(fn) {}; // Not implemented

        model.onAddedToList = function() {};
        model.onRemovedFromList = function() {};

        // Record change for undo-redo
        model.onStateDidChange = function(prop) {
            var id = this.id;
            var oldValue = this.getOldProperty(prop);
            var newValue = this.getProperty(prop);

            var list = this.list;

            list.undoRedo.addTransaction({
                type: list.undoRedo.RESPONSE_TO_CHANGE,
                undo: function() {
                    list.getItemById(id).setProperty(prop, oldValue);
                },
                redo: function() {
                    list.getItemById(id).setProperty(prop, newValue);
                }
            });
        };

        model.updateCollapsed = function() {
            this.setProperty(
                'inCollapsedFolder',
                this.folder ? this.folder.collapsed : false
            );
        };

        model.updateFolder = function() {
            if (this.getOldProperty('folder')) {
                this.getOldProperty('folder').unobserve('.' + this.id);
            }
            if (this.folder) {
                this.folder.observe(
                    'collapsed.' + this.id,
                    this.updateCollapsed.bind(this)
                );
            }
            this.updateCollapsed();
        };

        // selecting an expression within a collapsed folder expands the folder.
        // this can happen by clicking the curve on the graphpaper
        model.__onSelectedChange = function() {
            // notify the list that the selectedItem has potentially changed. Putting this
            // as the very first handler to a selection change so that any calls (within this stack) to
            // list.getSelected() returns the correct thing.
            if (this.list) this.list.handleSelectionChange(this);

            // TODO - ideally the folder would be listening for this event on each of it's children, but the folder
            // doesn't have a reference to it's children. We should change that, but it's a potentially dangerous refactor.
            if (this.selected && this.inCollapsedFolder) {
                this.folder.updateSelectedHiddenChild();
            }
        };

    });

    return AbstractItemModel;
});

define('expressions/domain', ['require', 'underscore_model', 'pjs'], function(require) {
    var UnderscoreModel = require('underscore_model');
    var P = require('pjs');

    var DomainModel = P(UnderscoreModel, function(model, _super) {
        model.init = function(min, max) {
            _super.init.call(this);
            this.min = min;
            this.max = max;
        };

        model.isValid = function() {
            return isFinite(this.min) && isFinite(this.max) && (this.max > this.min);
        };

        model.serialize = function() {
            return { min: this.min, max: this.max };
        };
    });

    DomainModel.deserialize = function(obj) {
        if (!obj) return DomainModel();
        else return DomainModel(obj.min, obj.max);
    };

    return DomainModel;
});

/* big.js v1.0.1 https://github.com/MikeMcl/big.js/LICENCE */
;
(function(global) {


    /*
      big.js v1.0.1
      A small, fast Javascript library for arbitrary-precision arithmetic with decimal numbers.
      https://github.com/MikeMcl/big.js/
      Copyright (c) 2012 Michael Mclaughlin <M8ch88l@gmail.com>
      MIT Expat Licence
    */

    /****************************** EDITABLE DEFAULTS **********************************/


    // The default values below must be integers within the stated ranges (inclusive).

    /*
     * The maximum number of decimal places of the results of methods involving
     * division, i.e. 'div' and 'sqrt', and 'pow' with negative exponents.
     */
    Big['DP'] = 20; // 0 to MAX_DP

    /*
     * The rounding mode used when rounding to the above decimal places.
     *
     * 0 Round towards zero (i.e. truncate, no rounding).               (ROUND_DOWN     )
     * 1 Round to nearest neighbour. If equidistant, round up.          (ROUND_HALF_UP  )
     * 2 Round to nearest neighbour. If equidistant, to even neighbour. (ROUND_HALF_EVEN)
     */
    Big['RM'] = 1; // 0, 1 or 2

    // The maximum value of 'Big.DP'.
    var MAX_DP = 1E6, // 0 to 1e+6

        // The maximum magnitude of the exponent argument to the 'pow' method.
        MAX_POWER = 1E6, // 1 to 1e+6

        /*
         * The exponent value at and beneath which 'toString' returns exponential notation.
         * Javascript's Number type: -7
         * -1e+6 is the minimum recommended exponent value of a 'Big'.
         */
        TO_EXP_NEG = -7, // 0 to -1e+6

        /*
         * The exponent value at and above which 'toString' returns exponential notation.
         * Javascript's Number type: 21
         * 1e+6 is the maximum recommended exponent value of a 'Big', though there is no
         * enforcing or checking of a limit.
         */
        TO_EXP_POS = 21, // 0 to 1e+6


        /***********************************************************************************/

        P = Big.prototype,
        isValid = /^-?\d+(?:\.\d+)?(?:e[+-]?\d+)?$/i,
        ONE = new Big(1);


    // CONSTRUCTOR


    /*
     * The exported function.
     * Create and return a new instance of a 'Big' object.
     *
     * n {number|string|Big} A numeric value.
     */
    function Big(n) {
        var i, j, nL,
            x = this;

        // Enable constructor usage without new.
        if (!(x instanceof Big)) {
            return new Big(n)
        }

        // Duplicate.
        if (n instanceof Big) {
            x['s'] = n['s'];
            x['e'] = n['e'];
            x['c'] = n['c'].slice();
            return
        }

        // Minus zero?
        if (n === 0 && 1 / n < 0) {
            n = '-0'
                // Ensure 'n' is string and check validity.
        } else if (!isValid.test(n += '')) {
            throw NaN
        }

        // Determine sign.
        x['s'] = n.charAt(0) == '-' ? (n = n.slice(1), -1) : 1;

        // Decimal point?
        if ((i = n.indexOf('.')) > -1) {
            n = n.replace('.', '')
        }

        // Exponential form?
        if ((j = n.search(/e/i)) > 0) {

            // Determine exponent.
            if (i < 0) {
                i = j
            }
            i += +n.slice(j + 1);
            n = n.substring(0, j)

        } else if (i < 0) {

            // Integer.
            i = n.length
        }

        // Determine leading zeros.
        for (j = 0; n.charAt(j) == '0'; j++) {}

        if (j == (nL = n.length)) {

            // Zero.
            x['c'] = [x['e'] = 0]
        } else {

            // Determine trailing zeros.
            for (; n.charAt(--nL) == '0';) {}

            x['e'] = i - j - 1;
            x['c'] = [];

            // Convert string to array of digits (without leading and trailing zeros).
            for (i = 0; j <= nL; x['c'][i++] = +n.charAt(j++)) {}
        }
    }


    // PRIVATE FUNCTIONS


    /*
     * Round 'Big' 'x' to a maximum of 'dp' decimal places using rounding mode
     * 'rm'. (Called by 'div', 'sqrt' and 'round'.)
     *
     * x {Big} The 'Big' to round.
     * dp {number} Integer, 0 to MAX_DP inclusive.
     * rm {number} 0, 1 or 2 ( ROUND_DOWN, ROUND_HALF_UP or ROUND_HALF_EVEN )
     * [more] {boolean} Whether the result of division was truncated.
     */
    function rnd(x, dp, rm, more) {
        var xc = x['c'],
            i = x['e'] + dp + 1;

        if (rm !== 0 && rm !== 1 && rm !== 2) {
            throw '!Big.RM!'
        }

        // 'xc[i]' is the digit after the digit that may be rounded up.
        rm = rm && (xc[i] > 5 || xc[i] == 5 &&
            (rm == 1 || more || i < 0 || xc[i + 1] != null || xc[i - 1] & 1));

        if (i < 1 || !xc[0]) {
            x['c'] = rm
                // 1, 0.1, 0.01, 0.001, 0.0001 etc.
                ?
                (x['e'] = -dp, [1])
                // Zero.
                :
                [x['e'] = 0];
        } else {

            // Remove any digits after the required decimal places.
            xc.length = i--;

            // Round up?
            if (rm) {

                // Rounding up may mean the previous digit has to be rounded up and so on.
                for (; ++xc[i] > 9;) {
                    xc[i] = 0;

                    if (!i--) {
                        ++x['e'];
                        xc.unshift(1)
                    }
                }
            }

            // Remove trailing zeros.
            for (i = xc.length; !xc[--i]; xc.pop()) {}
        }

        return x
    }


    // PROTOTYPE/INSTANCE METHODS


    /*
     * Return
     * 1 if the value of this 'Big' is greater than the value of 'Big' 'y',
     * -1 if the value of this 'Big' is less than the value of 'Big' 'y', or
     * 0 if they have the same value,
     */
    P['cmp'] = function(y) {
        var xNeg,
            x = this,
            xc = x['c'],
            yc = (y = new Big(y))['c'],
            i = x['s'],
            j = y['s'],
            k = x['e'],
            l = y['e'];

        // Either zero?
        if (!xc[0] || !yc[0]) {
            return !xc[0] ? !yc[0] ? 0 : -j : i
        }

        // Signs differ?
        if (i != j) {
            return i
        }
        xNeg = i < 0;

        // Compare exponents.
        if (k != l) {
            return k > l ^ xNeg ? 1 : -1
        }

        // Compare digit by digit.
        for (i = -1,
            j = (k = xc.length) < (l = yc.length) ? k : l;
            ++i < j;) {

            if (xc[i] != yc[i]) {
                return xc[i] > yc[i] ^ xNeg ? 1 : -1
            }
        }

        // Compare lengths.
        return k == l ? 0 : k > l ^ xNeg ? 1 : -1
    };


    /*
     * Return a new 'Big' whose value is the value of this 'Big' divided by the
     * value of 'Big' 'y', rounded, if necessary, to a maximum of 'Big.DP'
     * decimal places using rounding mode 'Big.RM'.
     */
    P['div'] = function(y) {
        var x = this,
            dvd = x['c'],
            dvs = (y = new Big(y))['c'],
            s = x['s'] == y['s'] ? 1 : -1,
            dp = Big['DP'];

        if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
            throw '!Big.DP!'
        }

        // Either 0?
        if (!dvd[0] || !dvs[0]) {

            // Both 0?
            if (dvd[0] == dvs[0]) {
                throw NaN
            }

            // 'dvs' is 0?
            if (!dvs[0]) {
                // Throw +-Infinity.
                throw s / 0
            }

            // 'dvd' is 0. Return +-0.
            return new Big(s * 0)
        }


        var dvsL, dvsT, next, cmp, remI,
            dvsZ = dvs.slice(),
            dvdI = dvsL = dvs.length,
            dvdL = dvd.length,
            rem = dvd.slice(0, dvsL),
            remL = rem.length,
            quo = new Big(ONE),
            qc = quo['c'] = [],
            qi = 0,
            digits = dp + (quo['e'] = x['e'] - y['e']) + 1;

        quo['s'] = s;
        s = digits < 0 ? 0 : digits;

        // Create version of divisor with leading zero.
        dvsZ.unshift(0);

        // Add zeros to make remainder as long as divisor.
        for (; remL++ < dvsL; rem.push(0)) {}

        do {

            // 'next' is how many times the divisor goes into the current remainder.
            for (next = 0; next < 10; next++) {

                // Compare divisor and remainder.
                if (dvsL != (remL = rem.length)) {
                    cmp = dvsL > remL ? 1 : -1
                } else {
                    for (remI = -1, cmp = 0; ++remI < dvsL;) {

                        if (dvs[remI] != rem[remI]) {
                            cmp = dvs[remI] > rem[remI] ? 1 : -1;
                            break
                        }
                    }
                }

                // Subtract divisor from remainder (if divisor < remainder).
                if (cmp < 0) {

                    // Remainder cannot be more than one digit longer than divisor.
                    // Equalise lengths using divisor with extra leading zero?
                    for (dvsT = remL == dvsL ? dvs : dvsZ; remL;) {

                        if (rem[--remL] < dvsT[remL]) {

                            for (remI = remL; remI && !rem[--remI]; rem[remI] = 9) {}
                            --rem[remI];
                            rem[remL] += 10
                        }
                        rem[remL] -= dvsT[remL]
                    }
                    for (; !rem[0]; rem.shift()) {}
                } else {
                    break
                }
            }

            // Add the 'next' digit to the result array.
            qc[qi++] = cmp ? next : ++next;

            // Update the remainder.
            rem[0] && cmp ?
                (rem[remL] = dvd[dvdI] || 0) :
                (rem = [dvd[dvdI]])

        } while ((dvdI++ < dvdL || rem[0] != null) && s--);

        // Leading zero? Do not remove if result is simply zero (qi == 1).
        if (!qc[0] && qi != 1) {

            // There can't be more than one zero.
            qc.shift();
            quo['e']--;
        }

        // Round?
        if (qi > digits) {
            rnd(quo, dp, Big['RM'], rem[0] != null)
        }

        return quo
    }


    /*
     * Return a new 'Big' whose value is the value of this 'Big' minus the value
     * of 'Big' 'y'.
     */
    P['minus'] = function(y) {
        var d, i, j, xLTy,
            x = this,
            a = x['s'],
            b = (y = new Big(y))['s'];

        // Signs differ?
        if (a != b) {
            return y['s'] = -b, x['plus'](y)
        }

        var xc = x['c'],
            xe = x['e'],
            yc = y['c'],
            ye = y['e'];

        // Either zero?
        if (!xc[0] || !yc[0]) {

            // 'y' is non-zero?
            return yc[0] ?
                (y['s'] = -b, y)
                // 'x' is non-zero?
                :
                new Big(xc[0] ?
                    x
                    // Both are zero.
                    :
                    0)
        }

        // Determine which is the bigger number.
        // Prepend zeros to equalise exponents.
        if (xc = xc.slice(), a = xe - ye) {
            d = (xLTy = a < 0) ? (a = -a, xc) : (ye = xe, yc);

            for (d.reverse(), b = a; b--; d.push(0)) {}
            d.reverse()
        } else {

            // Exponents equal. Check digit by digit.
            j = ((xLTy = xc.length < yc.length) ? xc : yc).length;

            for (a = b = 0; b < j; b++) {

                if (xc[b] != yc[b]) {
                    xLTy = xc[b] < yc[b];
                    break
                }
            }
        }

        // 'x' < 'y'? Point 'xc' to the array of the bigger number.
        if (xLTy) {
            d = xc, xc = yc, yc = d;
            y['s'] = -y['s']
        }

        /*
         * Append zeros to 'xc' if shorter. No need to add zeros to 'yc' if shorter
         * as subtraction only needs to start at 'yc.length'.
         */
        if ((b = -((j = xc.length) - yc.length)) > 0) {

            for (; b--; xc[j++] = 0) {}
        }

        // Subtract 'yc' from 'xc'.
        for (b = yc.length; b > a;) {

            if (xc[--b] < yc[b]) {

                for (i = b; i && !xc[--i]; xc[i] = 9) {}
                --xc[i];
                xc[b] += 10
            }
            xc[b] -= yc[b]
        }

        // Remove trailing zeros.
        for (; xc[--j] == 0; xc.pop()) {}

        // Remove leading zeros and adbust exponent accordingly.
        for (; xc[0] == 0; xc.shift(), --ye) {}

        if (!xc[0]) {

            // Result must be zero.
            xc = [ye = 0]
        }

        return y['c'] = xc, y['e'] = ye, y
    };


    /*
     * Return a new 'Big' whose value is the value of this 'Big' modulo the
     * value of 'Big' 'y'.
     */
    P['mod'] = function(y) {
        y = new Big(y);
        var c,
            x = this,
            i = x['s'],
            j = y['s'];

        if (!y['c'][0]) {
            throw NaN
        }

        x['s'] = y['s'] = 1;
        c = y['cmp'](x) == 1;
        x['s'] = i, y['s'] = j;

        return c ?
            new Big(x) :
            (i = Big['DP'], j = Big['RM'],
                Big['DP'] = Big['RM'] = 0,
                x = x['div'](y),
                Big['DP'] = i, Big['RM'] = j,
                this['minus'](x['times'](y)))
    };


    /*
     * Return a new 'Big' whose value is the value of this 'Big' plus the value
     * of 'Big' 'y'.
     */
    P['plus'] = function(y) {
        var d,
            x = this,
            a = x['s'],
            b = (y = new Big(y))['s'];

        // Signs differ?
        if (a != b) {
            return y['s'] = -b, x['minus'](y)
        }

        var xe = x['e'],
            xc = x['c'],
            ye = y['e'],
            yc = y['c'];

        // Either zero?
        if (!xc[0] || !yc[0]) {

            // 'y' is non-zero?
            return yc[0] ?
                y :
                new Big(xc[0]

                    // 'x' is non-zero?
                    ?
                    x

                    // Both are zero. Return zero.
                    :
                    a * 0)
        }

        // Prepend zeros to equalise exponents.
        // Note: Faster to use reverse then do unshifts.
        if (xc = xc.slice(), a = xe - ye) {
            d = a > 0 ? (ye = xe, yc) : (a = -a, xc);

            for (d.reverse(); a--; d.push(0)) {}
            d.reverse()
        }

        // Point 'xc' to the longer array.
        if (xc.length - yc.length < 0) {
            d = yc, yc = xc, xc = d
        }

        /*
         * Only start adding at 'yc.length - 1' as the
         * further digits of 'xc' can be left as they are.
         */
        for (a = yc.length, b = 0; a; b = (xc[--a] = xc[a] + yc[a] + b) / 10 ^ 0, xc[a] %= 10) {}

        // No need to check for zero, as +x + +y != 0 && -x + -y != 0

        if (b) {
            xc.unshift(b);
            ++ye
        }

        // Remove trailing zeros.
        for (a = xc.length; xc[--a] == 0; xc.pop()) {}

        return y['c'] = xc, y['e'] = ye, y
    };


    /*
     * Return a 'Big' whose value is the value of this 'Big' raised to the power
     * 'e'. If 'e' is negative, round, if necessary, to a maximum of 'Big.DP'
     * decimal places using rounding mode 'Big.RM'.
     *
     * e {number} Integer, -MAX_POWER to MAX_POWER inclusive.
     */
    P['pow'] = function(e) {
        var isNeg = e < 0,
            x = new Big(this),
            y = ONE;

        if (e !== ~~e || e < -MAX_POWER || e > MAX_POWER) {
            throw '!pow!'
        }

        for (e = isNeg ? -e : e;;) {

            if (e & 1) {
                y = y['times'](x)
            }
            e >>= 1;

            if (!e) {
                break
            }
            x = x['times'](x)
        }

        return isNeg ? ONE['div'](y) : y
    };


    /*
     * Return a new 'Big' whose value is the value of this 'Big' rounded, if
     * necessary, to a maximum of 'dp' decimal places using rounding mode 'rm'.
     * If 'dp' is not specified, round to 0 decimal places.
     * If 'rm' is not specified, use 'Big.RM'.
     *
     * [dp] {number} Integer, 0 to MAX_DP inclusive.
     * [rm] 0, 1 or 2 ( i.e. ROUND_DOWN, ROUND_HALF_UP or ROUND_HALF_EVEN )
     */
    P['round'] = function(dp, rm) {
        var x = new Big(this);

        if (dp == null) {
            dp = 0
        } else if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
            throw '!round!'
        }
        rnd(x, dp, rm == null ? Big['RM'] : rm);

        return x
    };


    /*
     * Return a new 'Big' whose value is the square root of the value of this
     * 'Big', rounded, if necessary, to a maximum of 'Big.DP' decimal places
     * using rounding mode 'Big.RM'.
     */
    P['sqrt'] = function() {
        var estimate, r, approx,
            x = this,
            xc = x['c'],
            i = x['s'],
            e = x['e'],
            half = new Big('0.5');

        // Zero?
        if (!xc[0]) {
            return new Big(x)
        }

        // Negative?
        if (i < 0) {
            throw NaN
        }

        // Estimate.
        i = Math.sqrt(x.toString());

        // Math.sqrt underflow/overflow?
        // Pass 'x' to Math.sqrt as integer, then adjust the exponent of the result.
        if (i == 0 || i == 1 / 0) {
            estimate = xc.join('');

            if (!(estimate.length + e & 1)) {
                estimate += '0'
            }

            r = new Big(Math.sqrt(estimate).toString());
            r['e'] = (((e + 1) / 2) | 0) - (e < 0 || e & 1)
        } else {
            r = new Big(i.toString())
        }

        i = r['e'] + (Big['DP'] += 4);

        // Newton-Raphson loop.
        do {
            approx = r;
            r = half['times'](approx['plus'](x['div'](approx)))
        } while (approx['c'].slice(0, i).join('') !==
            r['c'].slice(0, i).join(''));

        rnd(r, Big['DP'] -= 4, Big['RM']);

        return r
    };


    /*
     * Return a new 'Big' whose value is the value of this 'Big' times the value
     * of 'Big' 'y'.
     */
    P['times'] = function(y) {
        var c,
            x = this,
            xc = x['c'],
            yc = (y = new Big(y))['c'],
            a = xc.length,
            b = yc.length,
            i = x['e'],
            j = y['e'];

        y['s'] = x['s'] == y['s'] ? 1 : -1;

        // Either 0?
        if (!xc[0] || !yc[0]) {

            return new Big(y['s'] * 0)
        }

        y['e'] = i + j;

        if (a < b) {
            c = xc, xc = yc, yc = c, j = a, a = b, b = j
        }

        for (j = a + b, c = []; j--; c.push(0)) {}

        // Multiply!
        for (i = b - 1; i > -1; i--) {

            for (b = 0, j = a + i; j > i; b = c[j] + yc[i] * xc[j - i - 1] + b,
                c[j--] = b % 10 | 0,
                b = b / 10 | 0) {}

            if (b) {
                c[j] = (c[j] + b) % 10
            }
        }

        b && ++y['e'];

        // Remove any leading zero.
        !c[0] && c.shift();

        // Remove trailing zeros.
        for (j = c.length; !c[--j]; c.pop()) {}

        return y['c'] = c, y
    };


    /*
     * Return a string representing the value of this 'Big'.
     * Return exponential notation if this 'Big' has a positive exponent equal
     * to or greater than 'TO_EXP_POS', or a negative exponent equal to or less
     * than 'TO_EXP_NEG'.
     */
    P['toString'] = P['valueOf'] = function() {
        var x = this,
            e = x['e'],
            str = x['c'].join(''),
            strL = str.length;

        // Exponential notation?
        if (e <= TO_EXP_NEG || e >= TO_EXP_POS) {
            str = str.charAt(0) + (strL > 1 ? '.' + str.slice(1) : '') +
                (e < 0 ? 'e' : 'e+') + e

            // Negative exponent?
        } else if (e < 0) {

            // Prepend zeros.
            for (; ++e; str = '0' + str) {}
            str = '0.' + str

            // Positive exponent?
        } else if (e > 0) {

            if (++e > strL) {

                // Append zeros.
                for (e -= strL; e--; str += '0') {}
            } else if (e < strL) {
                str = str.slice(0, e) + '.' + str.slice(e)
            }

            // Exponent zero.
        } else if (strL > 1) {
            str = str.charAt(0) + '.' + str.slice(1)
        }

        // Avoid '-0'
        return x['s'] < 0 && x['c'][0] ? '-' + str : str
    };


    /*
     ***************************************************************************
     *
     * If 'toExponential', 'toFixed', 'toPrecision' and 'format' are not
     * required they can safely be commented-out or deleted. No redundant code
     * will be left. 'format' is used only by 'toExponential', 'toFixed' and
     * 'toPrecision'.
     *
     ***************************************************************************
     */


    /*
     * PRIVATE FUNCTION
     *
     * Return a string representing the value of 'Big' 'x' in normal or
     * exponential notation to a fixed number of decimal places or significant
     * digits 'dp'.
     * (Called by toString, toExponential, toFixed and toPrecision.)
     *
     * x {Big} The 'Big' to format.
     * dp {number} Integer, 0 to MAX_DP inclusive.
     * toE {number} undefined (toFixed), 1 (toExponential) or 2 (toPrecision).
     */
    function format(x, dp, toE) {
        // The index (in normal notation) of the digit that may be rounded up.
        var i = dp - (x = new Big(x))['e'],
            c = x['c'];

        // Round?
        if (c.length > ++dp) {
            rnd(x, i, Big['RM'])
        }

        // Recalculate 'i' if toFixed as 'x.e' may have changed if value rounded up.
        i = !c[0] ? i + 1 : toE ? dp : (c = x['c'], x['e'] + i + 1);

        // Append zeros?
        for (; c.length < i; c.push(0)) {}
        i = x['e'];

        /*
         * 'toPrecision' returns exponential notation if the number of
         * significant digits specified is less than the number of digits
         * necessary to represent the integer part of the value in normal
         * notation.
         */
        return toE == 1 || toE == 2 && (dp <= i || i <= TO_EXP_NEG)

        // Exponential notation.
        ?
        (x['s'] < 0 && c[0] ? '-' : '') + (c.length > 1 ?
            (c.splice(1, 0, '.'), c.join('')) :
            c[0]) + (i < 0 ? 'e' : 'e+') + i

        // Normal notation.
            : x.toString()
    }


    /*
     * Return a string representing the value of this 'Big' in exponential
     * notation to 'dp' fixed decimal places and rounded, if necessary, using
     * 'Big.RM'.
     *
     * [dp] {number} Integer, 0 to MAX_DP inclusive.
     */
    P['toExponential'] = function(dp) {

        if (dp == null) {
            dp = this['c'].length - 1
        } else if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
            throw '!toExp!'
        }

        return format(this, dp, 1)
    };


    /*
     * Return a string representing the value of this 'Big' in normal notation
     * to 'dp' fixed decimal places and rounded, if necessary, using 'Big.RM'.
     *
     * [dp] {number} Integer, 0 to MAX_DP inclusive.
     */
    P['toFixed'] = function(dp) {
        var str,
            x = this,
            neg = TO_EXP_NEG,
            pos = TO_EXP_POS;

        TO_EXP_NEG = -(TO_EXP_POS = 1 / 0);

        if (dp == null) {
            str = x.toString()
        } else if (dp === ~~dp && dp >= 0 && dp <= MAX_DP) {
            str = format(x, x['e'] + dp);

            // (-0).toFixed() is '0', but (-0.1).toFixed() is '-0'.
            // (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.
            if (x['s'] < 0 && x['c'][0] && str.indexOf('-') < 0) {
                // As e.g. -0.5 if rounded to -0 will cause toString to omit the minus sign.
                str = '-' + str
            }
        }
        TO_EXP_NEG = neg, TO_EXP_POS = pos;

        if (!str) {
            throw '!toFix!'
        }

        return str
    };


    /*
     * Return a string representing the value of this 'Big' to 'sd' significant
     * digits and rounded, if necessary, using 'Big.RM'. If 'sd' is less than
     * the number of digits necessary to represent the integer part of the value
     * in normal notation, then use exponential notation.
     *
     * sd {number} Integer, 1 to MAX_DP inclusive.
     */
    P['toPrecision'] = function(sd) {

        if (sd == null) {
            return this.toString()
        } else if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {
            throw '!toPre!'
        }

        return format(this, sd - 1, 2)
    };


    // EXPORT


    // Node and other CommonJS-like environments that support module.exports.
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = Big

        //AMD.
    } else if (typeof define == 'function' && define.amd) {
        define('vendor/big', [], function() {
            return Big
        })

        //Browser.
    } else {
        global['Big'] = Big
    }

})(this);

define('big', ['require', 'vendor/big'], function(require) {
    var Big = require('vendor/big');
    Big.prototype.equals = function(x) { return this.cmp(x) === 0; };
    return Big;
});

define('expressions/slider', ['require', 'pjs', 'underscore_model', 'big', 'lib/rounding'], function(require) {
    var P = require('pjs');
    var UnderscoreModel = require('underscore_model');
    var Big = require('big');
    var Rounding = require('lib/rounding');

    var SliderModel = P(UnderscoreModel, function(model, _super) {

        model.DEFAULT_PERIOD = 8000; //8s

        model.init = function(options) {
            _super.init.call(this);
            if (!options) {
                options = {};
            }

            this.hardMin = !!options.hardMin;
            this.hardMax = !!options.hardMax;
            this.min = options.min === undefined ? -10 : options.min;
            this.max = options.max === undefined ? 10 : options.max;
            this.value = options.value !== undefined ? options.value : 0;
            this.step = options.step;
            this.animationPeriod = options.animationPeriod !== undefined ? options.animationPeriod : this.DEFAULT_PERIOD;
            this.playDirection = options.playDirection !== undefined ? options.playDirection : 1;
            this.isPlaying = options.isPlaying !== undefined ? options.isPlaying : false;
            this.observe('isPlaying', this.updateAnimationTargetValue.bind(this));
            this.observe('stepper isPlaying', this.updateObservedStepper.bind(this));
            this.observe('dragging isMoving isPlaying', this.setTransient.bind(this));

            this.observe('isPlaying', function() {
                if (this.isPlaying) {
                    this.animationTargetValue = this.value; //Animate target value smoothly, and just round displayed value
                }
            }.bind(this));

            this.observe('isPlaying dragging isMoving', this.setTransient.bind(this));
            this.observe('stepper isPlaying', this.updateObservedStepper.bind(this));

            // a slider can start of with isPlaying=true, so the observer for 'isPlaying' won't fire. Call it
            // manually here.
            this.updateAnimationTargetValue();

            // a slider can start off with 'isPlaying' === true. Manually call the observers that
            // would be called if we pressed the play button.
            this.setTransient();
        };

        model.updateAnimationTargetValue = function() {
            if (this.isPlaying) {
                this.animationTargetValue = this.value; //Animate target value smoothly, and just round displayed value
            }
        };

        model.setTransient = function() {
            this.setProperty(
                'transient',
                this.dragging || this.isPlaying || this.isMoving
            );
        };

        model.updateObservedStepper = function() {
            var canPlayStep = this.isPlaying && this.stepper;
            var shouldUnobserve = (!canPlayStep || this.stepper !== this._observedStepper) && this._observedStepper;
            var shouldObserve = canPlayStep && this._observedStepper !== this.stepper;

            if (shouldUnobserve) {
                this._observedStepper.unobserve('playStep.' + this.guid);
                this._observedStepper = undefined;
            }

            if (shouldObserve) {
                this._observedStepper = this.stepper;
                this._observedStepper.observe('playStep.' + this.guid, this.playStep.bind(this));
            }
        };

        model.playStep = function() {
            //PingPong behavior
            if (this.animationTargetValue >= this.max) {
                this.playDirection = -1;
            } else if (this.animationTargetValue <= this.min) {
                this.playDirection = +1;
            }

            var animationStep = (this.max - this.min) * ((1000 / this.stepper.stepHz) / this.animationPeriod);

            //Animate target without accumulating rounding error
            this.animationTargetValue += animationStep * this.playDirection;

            var newValue = this.computeSnappedValue(this.animationTargetValue); //Always snap to slider markers
            if (!this.step) {
                //If no markers, snap to a reasonable decimal close to the animation target
                newValue = Rounding.shortestDecimalBetween(newValue - animationStep * 0.1, newValue + animationStep * 0.1);
            }

            //don't exceed the endpoints
            newValue = Math.max(this.min, Math.min(this.max, newValue));

            //commit the value change
            this.setProperty('value', newValue);
        };

        model.serialize = function() {
            return {
                min: this.min,
                max: this.max,
                hardMin: this.hardMin,
                hardMax: this.hardMax,
                step: this.step,
                value: this.value,
                playDirection: this.playDirection,
                animationPeriod: this.animationPeriod,
                isPlaying: this.isPlaying
            };
        };

        model.computeSnappedValue = function(val) {
            if (this.step) {
                var nsteps = Math.round((val - this.min) / this.step);
                // Use big.js to do exact decimal arithmetic to avoid rounding errors here.
                var snapped = (new Big(this.step)).times(nsteps).plus(this.min);
                // Turn back to Number
                val = parseFloat(snapped.toString());
            }

            // enforce hard limits
            if (this.hardMin && val < this.min) val = this.min;
            if (this.hardMax && val > this.max) val = this.max;

            return val;
        };

    });

    return SliderModel;
});

define('expressions/colors', ['require'], function(require) {
    var RED = '#C0504D';
    var BLUE = '#4F81BD';
    var GREEN = '#9BBB59';
    var PURPLE = '#8064A2';
    var ORANGE = '#F79646';
    var BLACK = '#000000';
    var all = [RED, BLUE, GREEN, PURPLE, ORANGE, BLACK];
    var i = 0;

    function next() {
        var color = all[i];
        i = (i + 1) % all.length;
        return color;
    }

    function reset() {
        i = 0;
    }

    return {
        all: all,
        next: next,
        reset: reset,
        RED: RED,
        BLUE: BLUE,
        GREEN: GREEN,
        PURPLE: PURPLE,
        ORANGE: ORANGE,
        BLACK: BLACK
    };
});
define('expressions/expression', ['require', 'pjs', './abstractitem', './domain', './slider', './colors'], function(require) {
    var P = require('pjs');
    var AbstractItemModel = require('./abstractitem');
    var DomainModel = require('./domain');
    var SliderModel = require('./slider');
    var Colors = require('./colors');

    var ExpressionObject = P(AbstractItemModel, function(model, _super) {
        model.isExpression = true;

        model._computeNewLatex = function(latex, newValue) {
            //we know the expression will look like:
            // a bunch of stuff (we ignore this in the regex)
            // an "=" (doesn't slide if it's < or >)
            //
            // a bunch of stuff (spaces, parens, the rest of the le, ge, etc)  ($1)
            // the number we're trying to replace ($2)
            // a bunch more stuff (spaces, parens, etc.) (we ignore this in the regex)
            var regex = /=(.*?)([-\.0-9]+)/;

            //if they're typing something crazy like y=00001, we want to not overwrite their work
            var matches = latex.match(regex);
            if (parseFloat(matches[2]) === newValue) return latex;

            return latex.replace(regex, "=$1" + newValue);
        };

        model.isExpression = true;

        model.init = function(state, list) {
            _super.init.call(this, state, list);

            this.loading = true;
            // a default blank formula while we calculate the real one
            this.formula = { error: '' };
            // Use to signifiy that a plotted expression has not been fully resolved by the plotter.
            this.unresolved = false;

            // TODO - this is very temporary. Eventually we'll want to save the
            // slider info in here, but there are some old states that have obsolete
            // values stored in there. We've repurposed the .slider variable on this
            // class to be a SliderModel. Because the .slider value is being set
            // on instantiation, we aren't overwriting it with a SliderModel. Then,
            // when the .slider property is expected to do things that a SliderModel
            // can, it throws an error. When we migrate old graph states to use this
            // property, we need to remove the next line.
            delete this.slider;
            // fill in a color if not specified
            if (!this.color) {
                this.color = Colors.next();
            }
            // convert old style of color definition to simpler new version
            else if (typeof this.color === 'object') {
                this.color = this.color.value;
            }
            if (this.style === undefined) {
                this.style = 'normal';
            }
            if (this.hidden === undefined) {
                // Check userRequestedGraphing for legacy states
                this.hidden = (this.userRequestedGraphing === 'never');
            }

            if (this.latex === undefined) this.latex = '';

            // convert raw domain object to a DomainModel Object
            var raw_domain = this.domain ? this.domain : { min: 0, max: 1 };
            this.domain = DomainModel.deserialize(raw_domain);
            this.domain.observe('min max', function(property) {
                this.onExpressionDidChange();

                // handle undo/redo
                var id = this.id;
                var oldValue = this.domain.getOldProperty(property);
                var newValue = this.domain.getProperty(property);
                var list = this.list;

                list.undoRedo.addTransaction({
                    type: list.undoRedo.RESPONSE_TO_CHANGE,
                    undo: function() { list.getItemById(id).domain.setProperty(property, oldValue); },
                    redo: function() { list.getItemById(id).domain.setProperty(property, newValue); }
                });
            }.bind(this));

            if (!this.regressionParameters) this.regressionParameters = {};
            if (!this.residualVariable) this.residualVariable = '';

            this.computeShouldGraph();

            this.observe('formula', this.onFormulaUpdate.bind(this));
            this.observe('latex color hidden style', this.onStateDidChange.bind(this));
            this.observe('latex shouldGraph color style', this.onExpressionDidChange.bind(this));
            this.observe('hidden', this.computeShouldGraph.bind(this));
        };

        model.onStateDidChange = function(prop) {

            // ignore latex changes from transient slider
            if (prop === 'latex' && this.slider && this.slider.transient) {
                return;
            }

            // don't send to undo/redo if this is the first set
            if (prop === 'style' && this.getOldProperty('style') === undefined) {
                return;
            }

            _super.onStateDidChange.call(this, prop);
        };

        model.updateFolder = function() {
            _super.updateFolder.call(this);

            // TODO namespacing with the id seems kind of gross...
            if (this.getOldProperty('folder')) {
                this.getOldProperty('folder').unobserve('.' + this.id);
            }
            if (this.folder) {
                this.folder.observe(
                    'hidden.' + this.id,
                    this.computeShouldGraph.bind(this)
                );
            }
            this.computeShouldGraph();
        };

        model.computeShouldGraph = function() {
            if (this.folder && this.folder.hidden) {
                this.setProperty('shouldGraph', false);
                return;
            }
            this.setProperty('shouldGraph', !this.hidden);
        };

        model.onExpressionDidChange = function() {
            if (this.domain.isValid()) {
                this.requestParse();
            }
        };

        model.eachLatex = function(fn) {
            fn(this.latex);
            if (this.residualVariable) fn(this.residualVariable);
        };

        model.getParsableObject = function() {
            //Work-around for bug in Mathquill / expression list
            // where on deletion of an expression via back-space key, Mathquill fires both an UpwardDelete
            // and a Render event.  UpwardDelete causes the expressionList to delete, and Render causes
            // expression list to fire another add request for the already deleted expression, which comes
            // in with latex === undefined.
            if (this.latex === undefined) {
                return undefined;
            }
            return {
                type: 'statement',
                id: this.id,
                latex: this.latex,
                domain: this.domain.serialize(),
                shouldGraph: this.shouldGraph,
                color: this.color,
                style: this.style,
                residualVariable: this.residualVariable,
                regressionParameters: this.regressionParameters
            };
        };

        model.requestParse = function() {
            this.list.triggerAddExp(this.getParsableObject());
        };

        model.requestUnparse = function() {
            this.list.triggerRemoveExp(this.id);
        };

        model.onAddedToList = function() {
            this.requestParse();
        };

        model.onRemovedFromList = function() {
            // turn slider off when deleted
            if (this.slider) {
                this.slider.setProperty('isPlaying', false);
            }

            this.requestUnparse();
        };

        model.getState = function() {
            /* jshint maxcomplexity:11 */
            var state = {
                id: this.id,
                latex: this.latex,
                domain: this.domain.serialize(),
                hidden: this.hidden,
                color: this.color,
                style: this.style,
                residualVariable: this.residualVariable,
                regressionParameters: this.regressionParameters
            };

            // TODO - change this to state.slider = this.slider.serialize() but can't
            // do that until we convert all previously saved graphs to have a slider
            // object rather than three global properties. We either need to do that
            // or we need to make the setState() function backwards compatible.
            if (this.slider) {
                state.sliderMin = this.slider.min;
                state.sliderMax = this.slider.max;
                state.sliderHardMin = this.slider.hardMin;
                state.sliderHardMax = this.slider.hardMax;
                state.sliderInterval = this.slider.step;
                state.sliderAnimationPeriod = this.slider.animationPeriod;
                state.sliderPlayDirection = this.slider.playDirection;
                state.sliderIsPlaying = this.slider.isPlaying;
            }

            // if we haven't been parsed yet, just return what we started
            // with. Gross, gross, gross!
            else if (this.loading) {
                if (this.hasOwnProperty('sliderMin')) state.sliderMin = this.sliderMin;
                if (this.hasOwnProperty('sliderMax')) state.sliderMax = this.sliderMax;
                if (this.hasOwnProperty('sliderHardMin')) state.sliderHardMin = this.sliderHardMin;
                if (this.hasOwnProperty('sliderHardMax')) state.sliderHardMax = this.sliderHardMax;
                if (this.hasOwnProperty('sliderInterval')) state.sliderInterval = this.sliderInterval;
                if (this.hasOwnProperty('sliderAnimationPeriod')) state.sliderAnimationPeriod = this.sliderAnimationPeriod;
                if (this.hasOwnProperty('sliderPlayDirection')) state.sliderPlayDirection = this.sliderPlayDirection;
                if (this.hasOwnProperty('sliderIsPlaying')) state.sliderIsPlaying = this.sliderIsPlaying;
            }

            return state;
        };

        model.onFormulaUpdate = function() {
            var formula = this.formula;

            this.setProperty('error', formula.error ? formula.error : '');
            this.setProperty('isGraphable', formula.is_graphable);
            this.setProperty('dependent', formula.assignment);
            this.setProperty('isTableable', formula.is_tableable);
            this.setProperty('unresolved', false);

            this.validateStyle();

            if (formula.is_slidable) {
                // delay instantiation of a slider for this expression until we need one.
                if (!this.slider) this.createSliderModel();
                // When we're in transient mode, the frontend is in charge of writes to the slider
                // so ignore updates from the worker
                if (!this.slider.transient) this.slider.setProperty('value', formula.constant_value);
            } else {
                this.slider = null;
            }

            if (formula.is_regression) {
                this.regressionParameters = formula.regression.parameters;
                this.residualVariable = formula.regression.residualVariable;
            } else {
                this.regressionParameters = {};
            }
        };

        model.validateStyle = function() {
            var formula = this.formula;
            if (formula.error) return;

            // When we default the style back to expression default we need the
            // onStateDidChange handler to know to not send the change to undo/redo.
            // This is part of a bigger change that'll automatically cause the style
            // to change. Without the self.style = undefined catch we'll get an
            // extra undo/redo transaction stored. That'll also mess up Toast on setState.
            var self = this;

            function defaultStyleTo(style) {
                if (self.style !== style) {
                    self.style = undefined;
                    self.setProperty('style', style);
                }
            }

            // If we have changed from a point to a function or vis a versa, we need to be
            // the default draw style for that type.
            if (formula.is_point_list) {
                if (!(this.style === 'point' || this.style === 'open' || this.style === 'cross')) {
                    defaultStyleTo('point');
                }
            } else if (formula.is_inequality) {
                // Graphlayer will deal with making this dashed if the inequality requires it.
                defaultStyleTo('normal');
            } else {
                if (!(this.style === 'normal' || this.style === 'dashed')) {
                    defaultStyleTo('normal');
                }
            }
        };

        model.createSliderModel = function() {
            // Once created, the slider object won't be destroyed. The slider instance sticks
            // around to save information about limits. They'd get reset each time if we didn't
            // keep the slider. Also, things that observe changes to the slider shouldn't have
            // to change observers from one slider object to another.
            if (this.__singleSliderInstance) {
                this.slider = this.__singleSliderInstance;
                return;
            }

            this.slider = this.__singleSliderInstance = SliderModel({
                min: this.sliderMin !== undefined ? this.sliderMin : -10,
                max: this.sliderMax !== undefined ? this.sliderMax : 10,
                hardMin: this.sliderHardMin,
                hardMax: this.sliderHardMax,
                animationPeriod: this.sliderAnimationPeriod,
                playDirection: this.sliderPlayDirection,
                isPlaying: this.sliderIsPlaying,
                step: this.sliderInterval,
                value: this.formula.constant_value
            });

            var id = this.id;
            var list = this.list;

            this.slider.observe('step', function() {
                // don't record changes in undo/redo while slider is transient.
                // this is handled elsewhere specially
                if (this.slider.transient) return;

                var oldStep = this.slider.getOldProperty('step');
                var newStep = this.slider.getProperty('step');

                list.undoRedo.addTransaction({
                    type: list.undoRedo.RESPONSE_TO_CHANGE,
                    undo: function() {
                        list.getItemById(id).slider.setProperty('step', oldStep);
                    },
                    redo: function() {
                        list.getItemById(id).slider.setProperty('step', newStep);
                    }
                });
            }.bind(this));

            this.slider.observe('min', function() {
                // don't record changes in undo/redo while slider is transient.
                // this is handled elsewhere specially
                if (this.slider.transient) return;

                var oldMin = this.slider.getOldProperty('min');
                var newMin = this.slider.getProperty('min');
                var oldValue = this.slider.getProperty('value');
                var oldLatex = newMin > oldValue ? this.latex : null;
                var newLatex = newMin > oldValue ? this._computeNewLatex(oldLatex, newMin) : null;

                list.undoRedo.addTransaction({
                    type: list.undoRedo.CAUSE_OF_CHANGE,
                    undo: function() {
                        var expression = list.getItemById(id);
                        expression.slider.setProperty('min', oldMin);
                        if (oldLatex) {
                            expression.setProperty('latex', oldLatex);
                        }
                    },
                    redo: function() {
                        var expression = list.getItemById(id);
                        expression.slider.setProperty('min', newMin);
                        if (newLatex) {
                            expression.setProperty('latex', newLatex);
                        }
                    }
                });
            }.bind(this));

            this.slider.observe('max', function() {
                // don't record changes in undo/redo while slider is transient.
                // this is handled elsewhere specially
                if (this.slider.transient) return;

                var oldMax = this.slider.getOldProperty('max');
                var newMax = this.slider.getProperty('max');
                var oldValue = this.slider.getProperty('value');
                var oldLatex = newMax < oldValue ? this.latex : null;
                var newLatex = newMax < oldValue ? this._computeNewLatex(oldLatex, newMax) : null;

                list.undoRedo.addTransaction({
                    type: list.undoRedo.CAUSE_OF_CHANGE,
                    undo: function() {
                        var expression = list.getItemById(id);
                        expression.slider.setProperty('max', oldMax);
                        if (oldLatex) {
                            expression.setProperty('latex', oldLatex);
                        }
                    },
                    redo: function() {
                        var expression = list.getItemById(id);
                        expression.slider.setProperty('max', newMax);
                        if (newLatex) {
                            expression.setProperty('latex', newLatex);
                        }
                    }
                });
            }.bind(this));

            this.slider.observe('transient', function() {
                var wasTransient = this.slider.getOldProperty('transient');
                var isTransient = this.slider.getProperty('transient');

                // just turned transient
                if (!wasTransient && isTransient) {

                    // this will be filled in when we end the transient state.
                    var startingValues = this.slider.serialize();
                    var endingValues = this.slider.serialize();

                    // when undoing or redoing, pause the slider
                    startingValues.isPlaying = false;
                    endingValues.isPlaying = false;

                    // keep a record to ending values so that we can update them when we end transient state
                    this.transientEndingValues = endingValues;

                    list.undoRedo.addTransaction({
                        type: list.undoRedo.RESPONSE_TO_CHANGE,
                        undo: function() {
                            var expression = list.getItemById(id);

                            // set starting values
                            for (var prop in startingValues) {
                                if (startingValues.hasOwnProperty(prop)) {
                                    expression.slider.setProperty(prop, startingValues[prop]);
                                }
                            }
                        },
                        redo: function() {
                            var expression = list.getItemById(id);

                            // set ending values
                            for (var prop in endingValues) {
                                if (endingValues.hasOwnProperty(prop)) {
                                    expression.slider.setProperty(prop, endingValues[prop]);
                                }
                            }
                        }
                    });
                }

                // just ended being transient
                else if (wasTransient && !isTransient && this.transientEndingValues) {
                    var lastValues = this.slider.serialize();

                    // update the values stored within the undo/redo transaction
                    for (var prop in lastValues) {
                        if (lastValues.hasOwnProperty(prop)) {
                            this.transientEndingValues[prop] = lastValues[prop];
                        }
                    }
                }
            }.bind(this));

            this.slider.observe('value', function() {
                var newValue = this.slider.getProperty('value');

                // if slider value is smaller than min, decrease min to equal value
                if (newValue < this.slider.min) {
                    this.slider.setProperty('min', newValue);
                }

                // if slider value is bigger than max, increase max to equal value
                if (newValue > this.slider.max) {
                    this.slider.setProperty('max', newValue);
                }

                // compute and set what the new latex should be based on the value change
                var newLatex = this._computeNewLatex(this.latex, newValue);
                this.setProperty('latex', newLatex);
            }.bind(this));

            // the list is going to step the slider through its animation
            this.slider.setProperty('stepper', this.list);

            // let others know that we've created the slider model
            this.notifyPropertyChange('slider');
        };

        model.isEmpty = function() {
            var latex = this.latex;
            return !latex || latex.split(" ").join("") === "";
        };
    });

    return ExpressionObject;
});

define('expressions/text', ['require', 'pjs', './abstractitem'], function(require) {
    var P = require('pjs');
    var AbstractItemModel = require('./abstractitem');

    var TextObject = P(AbstractItemModel, function(model, _super) {
        model.isText = true;

        model.init = function(state, list) {
            _super.init.call(this, state, list);

            if (!this.text) this.text = '';
            this.observe('text', this.onStateDidChange.bind(this));
        };

        model.isEmpty = function() {
            return this.text.split(" ").join("") === "";
        };

        model.getState = function() {
            return {
                id: this.id,
                text: this.text
            };
        };
    });

    return TextObject;
});

define('expressions/table', ['require', 'underscore', 'pjs', 'underscore_model', 'graphing/columnmode', 'big', './abstractitem', './colors', 'graphing/label'], function(require) {
    var _ = require('underscore');
    var P = require('pjs');
    var UnderscoreModel = require('underscore_model');
    var COLUMNMODE = require('graphing/columnmode');
    var Big = require('big');
    var AbstractItemModel = require('./abstractitem');
    var Colors = require('./colors');
    var Label = require('graphing/label');

    var Cell = P(UnderscoreModel, function(cellModel, _super) {

        cellModel.init = function(column, state) {
            _super.init.call(this);

            this.column = column;

            if (state) {
                this.value = state.value;
                this.error = state.error;
            }
        };

        cellModel.isEmpty = function() {
            return this.value.split(' ').join("") === '';
        };
    });


    var Column = P(AbstractItemModel, function(colModel, _super) {

        colModel.init = function(table, index, state) {

            // backwards compatibility:
            // used to used showLine and showPoints
            // now we use hidden and columnMode
            if (state.showPoints !== undefined || state.showLine !== undefined) {
                state = JSON.parse(JSON.stringify(state)); // make copy so we don't modify passed in state

                if (state.showPoints && state.showLine) {
                    state.columnMode = COLUMNMODE.POINTS_AND_LINES;
                } else if (state.showPoints) {
                    state.columnMode = COLUMNMODE.POINTS;
                } else if (state.showLine) {
                    state.columnMode = COLUMNMODE.LINES;
                } else {
                    state.hidden = true;
                    state.columnMode = COLUMNMODE.POINTS;
                }
            }

            // default values
            this.latex = '';
            this.hidden = false;
            this.columnMode = COLUMNMODE.POINTS;
            this.values = [];
            this.error = '';

            _super.init.call(this, state);

            if (!this.color) {
                this.color = Colors.next();
            }

            if (!this.style) {
                this.style = 'point';
            }

            // any column other than the first should generate the correct number
            // of blank cells if none are passed in.
            if (index !== 0 && this.values.length === 0 && table.columns[0].cells) {
                this.values = []; // don't want to modify array passed in through 'state'
                var len = table.columns[0].cells.length;
                for (var i = 0; i < len; i++) {
                    this.values.push('');
                }
            }

            // map cells from raw values to objects
            var self = this;
            this.cells = this.values.map(function(value) {
                return Cell(self, { value: String(value) });
            });
            delete this.values;

            this.table = table;
            this.index = index;

            // first column can't be graphed
            if (index === 0) {
                this.hidden = true;
            }

            // observers
            this.isGraphable = !this.error;
            this.observe('error', function() {
                this.setProperty('isGraphable', !this.error);
            }.bind(this));
            this.observe('color columnMode hidden latex style', this.onStateChange.bind(this));

            // need to factor in whether the table is forcing the column hidden
            this.observe('hidden hiddenByTable', this.computeShouldGraph.bind(this));
            this.computeShouldGraph();
            this.observe('shouldGraph', this.table.requestParse.bind(this.table));
        };

        colModel.computeShouldGraph = function() {
            this.setProperty('shouldGraph', !this.hiddenByTable && !this.hidden);
        };

        colModel.onStateChange = function(property) {
            this.table.requestParse();

            var id = this.table.id;
            var index = this.index;
            var list = this.table.list;

            function getColumn() {
                return list.getItemById(id).columns[index];
            }

            var oldValue = this.getOldProperty(property);
            var newValue = this.getProperty(property);
            list.undoRedo.addTransaction({
                type: list.undoRedo.RESPONSE_TO_CHANGE,
                undo: function() { getColumn().setProperty(property, oldValue); },
                redo: function() { getColumn().setProperty(property, newValue); }
            });
        };

        colModel.isEmpty = function() {
            return this.latex.split(" ").join(" ") === "";
        };

        colModel.getValues = function() {
            var vals = [];
            var len = this.cells.length;
            for (var i = 0; i < len; i++) {
                var val = this.cells[i].value;
                if (val === null || val === undefined) {
                    vals.push('');
                } else {
                    vals.push(String(val));
                }
            }

            return vals;
        };

        colModel.triggerRowChange = function() {};

        colModel.insertCell = function(index, value) {
            var cell = Cell(this, { value: value });
            this.cells.splice(index, 0, cell);

            // add blank independent value in this spot if need be
            if (this.independentValues) {
                this.independentValues.splice(index, 0, '');
            }
        };

        colModel.removeCell = function(index) {
            this.cells.splice(index, 1);

            // remove independent value in this spot if need be
            if (this.independentValues) {
                this.independentValues.splice(index, 1);
            }
        };

        function formatValuesForDisplay(values) {
            var vals = [];

            for (var i = 0; i < values.length; i++) {
                var value = values[i];
                var val_str;
                if (!_.isNumber(value)) {
                    val_str = '';
                } else if (!isFinite(value)) {
                    val_str = "\\mathrm{undefined}";
                } else {
                    //logic similar to multiple-answer output in evaluation.js
                    if (Math.abs(value) < 1e-15) {
                        val_str = '0';
                    } else if (Math.abs(value) > 1e6 || Math.abs(value) < 1e-3) {
                        val_str = Label.latexSciNote(value.toExponential(6));
                    } else {
                        val_str = Label.stripZeros(value.toPrecision(8));
                    }
                }
                vals.push(val_str);
            }

            return vals;
        }

        colModel.setComputedValues = function(c_data) {

            // TODO - get the worker to pass back a blank array. It'll be important
            // for when we check that the size of the output matches the size of the
            // table. If there is a size mismatch, we must throw the computations
            // away because they are stale.

            // the worker thread doesn't pass back a list of values in this case.
            // we need to build list of null values
            if (c_data.values.length === 0 && c_data.error) {
                for (var i = 0; i < this.cells.length - 1; i++) {
                    c_data.values[i] = null;
                }
            }


            this.setProperty('error', c_data.error);
            this.setProperty('discrete', c_data.discrete);
            this.setProperty('disabled', c_data.dependent);
            this.setErrors(c_data.values);

            if (c_data.dependent) {

                // if we haven't saved the independent values, save them now before
                // they get overwritten with the values sent back from the evaluator.
                if (!this.independentValues) {
                    this.independentValues = this.getValues();
                }

                this.setValues(formatValuesForDisplay(c_data.values));
            } else if (this.independentValues) {

                // set the indepentedValues back.
                this.setValues(this.independentValues);

                // clear out the cached independent values.
                this.independentValues = null;

                // send the table back to the evaluator
                this.table.requestParse();
            }
        };

        colModel.setValues = function(values) {
            for (var i = 0; i < this.cells.length; i++) {
                this.cells[i].setProperty('value', values[i]);
            }
        };

        colModel.setErrors = function(values) {
            // if the computed value is a string, then it's an error
            for (var i = 0; i < values.length; i++) {
                if (typeof values[i] === "string") {
                    this.cells[i].setProperty('error', values[i]);
                } else {
                    this.cells[i].setProperty('error', '');
                }
            }
        };

        colModel.serialize = function() {
            return {
                values: this.getValues(),
                columnMode: this.columnMode,
                hidden: this.hidden,
                id: this.id,
                color: this.color,
                style: this.style,
                latex: this.latex
            };
        };

    });

    var TableObject = P(AbstractItemModel, function(model, _super) {

        model.isTable = true;

        model.init = function(state, list) {
            var r, c;
            _super.init.call(this, state, list);

            this.list = list;
            this.selectedCell = null;

            // TODO - get rid of this when we upgrade states in DB
            // what we used to call 'headings' is now 'columns'
            if (this.headings) {
                this.columns = this.headings;
                delete this.headings;
            }

            // TODO - get rid of this when we upgrade states in DB
            // what used to be 'rows' is now transposed and part of each column
            if (this.rows) {
                for (c = 0; c < this.columns.length; c++) {
                    var column = this.columns[c];
                    column.values = [];

                    for (r = 0; r < this.rows.length; r++) {
                        column.values.push(this.rows[r][c]);
                    }
                }

                delete this.rows;
            }

            // map raw columns to Column objects
            var self = this;
            if (!this.columns) this.columns = [];
            this.columns = this.columns.map(function(col_state, index) {
                return Column(self, index, col_state);
            });

            // add a column to the right
            this.columns.push(Column(this, this.columns.length, { disabled: true }));

            // add a bottom row of empty values
            var lastRow = this.columns[0].cells.length;
            _.each(this.columns, function(column) {
                column.insertCell(lastRow, '');
            });

            // observers
            this.observe('selected', this.onSelectedChange.bind(this));
            this.observe('formula', this.onFormulaUpdate.bind(this));
        };

        model.onFormulaUpdate = function() {
            this.setComputedValues(this.formula.column_data);
            this.setProperty('canAutoRegress', !!this.formula.can_auto_regress);
        };

        model.updateFolder = function() {
            _super.updateFolder.call(this);


            // TODO namespacing with the id seems kind of gross...
            if (this.getOldProperty('folder')) {
                this.getOldProperty('folder').unobserve('.' + this.id);
            }
            if (this.folder) {
                this.folder.observe(
                    'hidden.' + this.id,
                    this.computeColumnsHidden.bind(this)
                );
            }
            this.computeColumnsHidden();
        };

        model.computeColumnsHidden = function() {
            var hidden = this.folder && this.folder.hidden;

            _.each(this.columns, function(column) {
                column.setProperty('hiddenByTable', hidden);
            });
        };

        model.onSelectedChange = function() {
            if (!this.selected) {
                this.setProperty('selectedCell', null);
            }
        };

        model.insertColumn = function(index, column) {

            var id = this.id;
            var list = this.list;

            list.undoRedo.addTransaction({
                type: list.undoRedo.CAUSE_OF_CHANGE,
                undo: function() {
                    var table = list.getItemById(id);
                    table.__removeColumn(index);
                },

                redo: function() {
                    var table = list.getItemById(id);
                    table.__insertColumn(index, column);

                    // need to update reference to heading so that
                    // next time we press redo, we pass in the complete
                    // heading info. This makes sure the next redo uses
                    // the same color and id as the original column that
                    // was later deleted and then restored.
                    column = table.columns[index].serialize();
                }
            });

        };

        model.removeColumn = function(index) {

            var id = this.id;
            var column = this.columns[index].serialize();
            var list = this.list;
            list.undoRedo.addTransaction({
                type: list.undoRedo.CAUSE_OF_CHANGE,
                undo: function() {
                    var table = list.getItemById(id);
                    table.__insertColumn(index, column);
                },

                redo: function() {
                    var table = list.getItemById(id);
                    table.__removeColumn(index);
                }
            });
        };

        model.moveColumn = function(from, to) {
            var id = this.id;
            var list = this.list;

            list.undoRedo.addTransaction({
                type: list.undoRedo.CAUSE_OF_CHANGE,
                undo: function() {
                    var table = list.getItemById(id);
                    table.__moveColumn(to, from);
                },

                redo: function() {
                    var table = list.getItemById(id);
                    table.__moveColumn(from, to);
                }
            });
        };

        // this does the raw column insert. Called from the wrapper function that
        // makes it also work with undo redo.
        model.triggerColumnAdded = function(index) {};
        model.__insertColumn = function(index, columnData) {
            if (!columnData) {
                columnData = {};
            }

            // add column
            var column = Column(this, index, columnData);
            this.columns.splice(index, 0, column);

            // let every column after the insertion point know its new index
            for (var i = index + 1; i < this.columns.length; i++) {
                this.columns[i].setProperty('index', i);
            }

            this.triggerColumnAdded(index);

            this.requestParse();
        };

        // this does the raw column remove. Called from the wrapper function that
        // makes it also work with undo redo.
        model.triggerColumnRemoved = function(index) {};
        model.__removeColumn = function(index) {

            // remove column
            this.requestUnparseColumn(index);
            this.columns.splice(index, 1);

            // let every column after the deletion point know its new index
            for (var i = index; i < this.columns.length; i++) {
                this.columns[i].setProperty('index', i);
            }

            this.triggerColumnRemoved(index);

            this.requestParse();
        };

        // this does the raw column move. Called from the wrapper function that
        // makes it also work with undo redo.
        model.triggerColumnMoved = function(from, to) {};
        model.__moveColumn = function(from, to) {
            if (from === to) return;

            var len = this.columns.length;
            var column = this.columns[from];

            // can't move the first or last columns
            if (from < 1 || to < 1 || from >= len - 1 || to >= len - 1) return;

            // remove from items
            this.columns.splice(from, 1);

            // insert back in correct spot
            this.columns.splice(to, 0, column);

            // insert index on each column
            for (var i = 0; i < len; i++) {
                this.columns[i].setProperty('index', i);
            }

            // allow a view to tap into this
            this.triggerColumnMoved(from, to);
        };

        // Could try to recognize fractions and multiples of pi (or anything
        // really).
        model.getAutofillValues = function(index) {
            var i;
            var numberOfColumns = this.columns.length;
            var rowValues = [];
            for (i = 0; i < numberOfColumns; i++) {
                rowValues.push('');
            }

            var firstColumn = this.columns[0].getValues();

            // Use big.js https://github.com/desmosinc/big.js to compute exact
            // differences and sums so that autofilling decimals works.
            // big.js will throw errors if improper input is used.
            //
            // this line just ensures that there is a constant offset between
            // each value in the first column starting from the beginning up
            // right before where we want to auto fill.
            var valDiff;
            try {
                if (index > 1) {
                    valDiff = Big(firstColumn[1]).minus(firstColumn[0]);
                }

                for (i = 2; i < index && valDiff !== undefined; i++) {
                    var nextDiff = Big(firstColumn[i]).minus(firstColumn[i - 1]);
                    if (!valDiff.equals(nextDiff)) {
                        valDiff = undefined;
                    }
                }
            } catch (e) {
                valDiff = undefined;
            }

            // add valDiff to the previous row to figure out what the autocomplete
            // value should be
            if (valDiff !== undefined) {
                rowValues[0] = valDiff.plus(firstColumn[index - 1]).toString();
            }

            return rowValues;
        };

        model.setComputedValues = function(columns_data) {
            this.setProperty('changingMultipleCells', true);

            // there is mandatory empty cell at the end of columns, so
            // we subtract 1 for that.
            var currentRowCount = this.columns[0].cells.length - 1;

            // Find the column that wants to display the most values
            var i, maxRowCount = 0;
            for (i = 0; i < columns_data.length; i++) {
                var numberOfRows = columns_data[i].values.length;
                if (numberOfRows > maxRowCount) {
                    maxRowCount = numberOfRows;
                }
            }

            // TODO - figure out undo/redo for this. We are left with
            // an extra row because the added rows aren't insertted
            // into the undo/redo stream. Maybe automatically removing
            // rows when we don't need them will fix this?

            // Add as many rows as necessary so that the longest
            // column can be fully displayed
            for (i = maxRowCount - currentRowCount; i > 0; i--) {
                this.__insertRow(currentRowCount);
                currentRowCount++;
            }

            for (i = 0; i < columns_data.length; i++) {
                this.columns[i].setComputedValues(columns_data[i]);
            }

            this.setProperty('changingMultipleCells', false);
            this.triggerEvent('computedValuesSet');
        };

        model.triggerRowAdded = function(index) {};
        model.__insertRow = function(index, values) {
            for (var i = 0; i < this.columns.length; i++) {
                this.columns[i].insertCell(index, values ? values[i] : '');
            }
            this.triggerRowAdded(index);
        };
        model.insertRow = function(index, values) {
            this.__insertRow(index, values);

            var id = this.id;
            var list = this.list;
            list.undoRedo.addTransaction({
                type: list.undoRedo.RESPONSE_TO_CHANGE,
                undo: function() {
                    list.getItemById(id).removeRow(index);
                },
                redo: function() {
                    list.getItemById(id).insertRow(index, values);
                }
            });

            this.requestParse();
        };

        model.triggerRowRemoved = function(index) {};
        model.removeRow = function(index) {
            var values = [];

            //don't let the user delete a row if there's only one row (below the header)
            if (!this.columns.length || this.columns[0].cells.length <= 2) return;

            for (var i = 0; i < this.columns.length; i++) {
                values.push(this.columns[i].cells[index].value);
                this.columns[i].removeCell(index);
            }

            this.triggerRowRemoved(index);

            var id = this.id;
            var list = this.list;
            list.undoRedo.addTransaction({
                type: list.undoRedo.RESPONSE_TO_CHANGE,
                undo: function() {
                    list.getItemById(id).insertRow(index, values);
                },
                redo: function() {
                    list.getItemById(id).removeRow(index);
                }
            });

            this.requestParse();
        };

        model.eachLatex = function(fn) {
            for (var i = 0; i < this.columns.length; i++) {
                var column = this.columns[i];
                fn(column.latex);
                for (var j = 0; j < column.cells.length; j++) {
                    fn(column.cells[j].value);
                }
            }
        };

        model.getParsableObject = function() {

            var columns = this.columns.map(function(column) {

                // serialize column to pure JSON
                var obj = column.serialize();

                // use shouldGraph rather than hidden when deciding if to graph
                obj.hidden = !column.shouldGraph;

                // pop off blank bottom row
                obj.values.pop();

                return obj;
            });

            // popoff blank right column
            columns.pop();

            return {
                type: 'table',
                id: this.id,
                columns: columns
            };
        };

        model.requestParse = function() {
            this.list.triggerAddExp(this.getParsableObject());
        };

        model.requestUnparse = function() {
            var ids = [this.id];
            for (var i = 0; i < this.columns.length; i++) {
                ids.push(this.columns[i].id);
            }

            this.list.triggerRemoveExps(ids);
        };

        model.onAddedToList = function() {
            this.requestParse();
        };

        model.onRemovedFromList = function() {
            this.requestUnparse();
        };

        model.requestUnparseColumn = function(index) {
            this.list.triggerRemoveExp(this.columns[index].id);
        };

        model.getState = function() {

            // serialize each column
            var columns = this.columns.map(function(column) {
                var data = column.serialize();

                // pop off blank bottom row
                data.values.pop();

                // TODO - do we want to do this? Might be better for loadup if
                // we save the previous values along with wether or not the column
                // was disabled. If the evaluator ever changes, we can convert
                // old graph states or just let the new system overwrite the values like
                // it does now. The two big complaints I have is that computed columns
                // show up with an 'empty' underline temporarily and the table icon
                // flickers if the column is actually continuous rather than discrete.
                // if column is disabled, all values blanked
                // TODO - convert old graph states to have '' instead of null.
                if (column.disabled) {
                    data.values = data.values.map(function() { return '' });
                }

                return data;
            });

            // pop off blank right column
            columns.pop();

            return {
                id: this.id,
                columns: columns
            };
        };

        model.isEmpty = function() {
            return false;
        };
    });

    return TableObject;
});

define('loadcss!css/folder', function() {});
define('expressions/folder', ['require', 'loadcss!css/folder', 'pjs', 'underscore', './abstractitem'], function(require) {
    require('loadcss!css/folder');
    var P = require('pjs');
    var _ = require('underscore');
    var AbstractItemModel = require('./abstractitem');

    var FolderObject = P(AbstractItemModel, function(model, _super) {
        model.isFolder = true;

        model.init = function(state, list) {
            _super.init.call(this, state, list);

            if (!this.title) this.title = '';

            if (!this.memberIds) this.memberIds = {};
            this.hidden = !!this.hidden;
            this.collapsed = !!this.collapsed;

            this.updateCount();

            this.observe('selected collapsed', this.updateSelectedHiddenChild.bind(this));
            this.observe('title hidden', this.onStateDidChange.bind(this));
        };

        model.updateCount = function() {
            this.setProperty('count', _.size(this.memberIds));
        };

        model.getState = function() {
            return {
                id: this.id,
                type: 'folder',
                title: this.title,
                memberIds: this.memberIds,
                hidden: this.hidden,
                collapsed: this.collapsed
            };
        };

        model._addItem = function(itemId) {
            var list = this.list;
            var item = list.getItemById(itemId);

            this.memberIds[itemId] = true;
            if (item) item.setProperty('folder', this);

            this.updateCount();
        };

        model._removeItem = function(itemId) {
            var list = this.list;
            var item = list.getItemById(itemId);

            if (item) item.setProperty('folder', undefined);
            if (this.memberIds.hasOwnProperty(itemId)) {
                delete this.memberIds[itemId];
            }
            this.updateCount();
        };

        model.addItem = function(item) {
            var list = this.list;
            var id = this.id;
            var itemId = item.id;

            list.undoRedo.addTransaction({
                type: list.undoRedo.CAUSE_OF_CHANGE,
                redo: function() {
                    list.getItemById(id)._addItem(itemId);
                },
                undo: function() {
                    list.getItemById(id)._removeItem(itemId);
                }
            });
        };

        model.removeItem = function(item) {
            var list = this.list;
            var id = this.id;
            var itemId = item.id;

            list.undoRedo.addTransaction({
                type: list.undoRedo.CAUSE_OF_CHANGE,
                redo: function() {
                    list.getItemById(id)._removeItem(itemId);
                },
                undo: function() {
                    list.getItemById(id)._addItem(itemId);
                }
            });
        };

        model.updateSelectedHiddenChild = function() {
            var selectedItem = this.list.getSelected();

            if (this.collapsed) {
                // we are collapsed, and the selectedItem is a child ==> It's our selectedHiddenChild
                if (selectedItem && this.memberIds.hasOwnProperty(selectedItem.id)) {
                    this.setProperty('selectedHiddenChild', selectedItem);
                    this.setProperty('selected', true);
                }

                // we are collapsed, and we are not selected ==> We have no selectedHiddenChild
                else if (selectedItem !== this) {
                    this.setProperty('selectedHiddenChild', null);
                }
            } else {
                // we are not collapsed, and we are selected, and we have a selectedHiddenChild ==> select it
                if (selectedItem === this && this.selectedHiddenChild) {
                    this.selectedHiddenChild.setProperty('selected', true);
                }

                // no children are hidden
                this.setProperty('selectedHiddenChild', null);
            }
        };
    });

    return FolderObject;
});
define('expressions/helperexpression', ['require', 'pjs', 'math/evaluationstate', './abstractitem', './slider'], function(require) {
    var P = require('pjs');
    var EvaluationState = require('math/evaluationstate');
    var AbstractItemModel = require('./abstractitem');
    var SliderModel = require('./slider');

    var HelperExpressionObject = P(AbstractItemModel, function(model, _super) {

        model.isHelperExpression = true;

        model.init = function(state, list) {
            _super.init.call(this, state, list);

            this.hidden = !!this.hidden;
            this.is_slidable = false;

            this.formula = EvaluationState.default();
            this.observe('formula', this.onFormulaUpdate.bind(this));
            this.observe('latex hidden color', this.onExpressionDidChange.bind(this));
        };

        model.onExpressionDidChange = function() {
            this.requestParse();
        };

        model.getParsableObject = function() {
            return {
                type: 'statement',
                id: this.id,
                latex: this.latex,
                shouldGraph: !this.hidden,
                color: this.color
            };
        };

        model.requestParse = function() {
            this.list.triggerAddExp(this.getParsableObject());
        };

        model.requestUnparse = function() {
            this.list.triggerRemoveExp(this.id);
        };

        model.onAddedToList = function() {
            this.requestParse();
        };

        model.onRemovedFromList = function() {
            // turn slider off when deleted
            if (this.slider) {
                this.slider.setProperty('isPlaying', false);
            }

            this.requestUnparse();
        };

        model.getState = function() {
            var state = {
                id: this.id,
                latex: this.latex,
                color: this.color,
                hidden: this.hidden
            };

            // TODO - change this to state.slider = this.slider.serialize() but can't
            // do that until we convert all previously saved graphs to have a slider
            // object rather than three global properties. We either need to do that
            // or we need to make the setState() function backwards compatible.
            if (this.slider) {
                state.sliderMin = this.slider.min;
                state.sliderMax = this.slider.max;
                state.sliderHardMin = this.slider.hardMin;
                state.sliderHardMax = this.slider.hardMax;
                state.sliderInterval = this.slider.step;
                state.sliderAnimationPeriod = this.slider.animationPeriod;
                state.sliderPlayDirection = this.slider.playDirection;
                state.sliderIsPlaying = this.slider.isPlaying;
            }

            return state;
        };

        model.onFormulaUpdate = function() {
            var formula = this.formula;

            this.setProperty('error', formula.error ? formula.error : '');

            if (formula.is_slidable) {
                // delay instantiation of a slider for this expression until we need one.
                if (!this.slider) {
                    this.createSliderModel();
                }

                this.slider.setProperty('value', formula.constant_value);
            } else {
                this.slider = null;
            }

            this.setProperty('is_slidable', formula.is_slidable);
        };

        model.createSliderModel = function() {
            // Once created, the slider object won't be destroyed. The slider instance sticks
            // around to save information about limits. They'd get reset each time if we didn't
            // keep the slider. Also, things that observe changes to the slider shouldn't have
            // to change observers from one slider object to another.
            if (this.__singleSliderInstance) {
                this.slider = this.__singleSliderInstance;
                return;
            }
            this.slider = this.__singleSliderInstance = SliderModel({
                min: this.sliderMin !== undefined ? this.sliderMin : -10,
                max: this.sliderMax !== undefined ? this.sliderMax : 10,
                hardMin: this.sliderHardMin,
                hardMax: this.sliderHardMax,
                animationPeriod: this.sliderAnimationPeriod,
                playDirection: this.sliderPlayDirecction,
                isPlaying: this.sliderIsPlaying,
                step: this.sliderInterval,
                value: this.formula.constant_value
            });

            // let others know that we've created the slider model
            this.notifyPropertyChange('slider');
        };

        model.isEmpty = function() {
            var latex = this.latex;
            return !latex || latex.split(" ").join("") === "";
        };
    });

    return HelperExpressionObject;
});

define('expressions/image', ['require', 'pjs', './abstractitem', './helperexpression', 'i18n', 'underscore'], function(require) {
    var P = require('pjs');
    var AbstractItemModel = require('./abstractitem');
    var HelperExpressionObject = require('./helperexpression');
    var i18n = require('i18n');
    var _ = require('underscore');

    var ImageObject = P(AbstractItemModel, function(model, _super) {
        model.isImage = true;

        model.init = function(state, list) {
            _super.init.call(this, state, list);
            this.hidden = !!this.hidden;
            this.shouldGraph = !this.hidden;
            this.errors = {};
            this.helpers = {};
            this.alias_helpers = {};
            this.point_helpers = [];
            this.imageObj = new Image();

            this.observe('x y width height name opacity shouldGraph', this.onStateDidChange.bind(this));
            this.observe('hidden', this.onVisibilityChange.bind(this));
            this.observe('showPoints', this.onShowPointsChange.bind(this));
            this.observe('transient', this.onTransientChange.bind(this));
            this.observe('errors', this.onErrorsChange.bind(this));
            this.observe('image_url', this.loadImage.bind(this));

            function computeShowPoints() {
                this.setProperty('showPoints', this.shouldGraph && this.selected && this.loaded);
            }
            this.observe('shouldGraph selected loaded', computeShowPoints.bind(this));

            // parses inputs and computes values
            this.createInputHelper('x');
            this.createInputHelper('y');
            this.createInputHelper('width');
            this.createInputHelper('height');

            // the helpers that make static values slidable
            this.createAliasHelper('x');
            this.createAliasHelper('y');
            this.createAliasHelper('width');
            this.createAliasHelper('height');

            // the resize points
            this.createResizeHelper('left', 'top');
            this.createResizeHelper('left', 'middle');
            this.createResizeHelper('left', 'bottom');
            this.createResizeHelper('middle', 'bottom');
            this.createResizeHelper('right', 'bottom');
            this.createResizeHelper('right', 'middle');
            this.createResizeHelper('right', 'top');
            this.createResizeHelper('middle', 'top');

            // the center move point
            this.createMoveHelper();

            // check if any helper is transient (movable point being dragged)
            var self = this;
            this.point_helpers.forEach(function(helper) {
                helper.observe('transient', function() {
                    self.computeTransient();
                });
            });

            this.computeTransient();

            // only load image if url is set
            if (this.image_url) {
                this.loadImage();
            }
        };
        model.computeShouldGraph = function() {
            var shouldGraph = (this.folder && this.folder.hidden ? false : !this.hidden);
            this.setProperty("shouldGraph", shouldGraph);
        };
        model.computeTransient = function() {
            var is_transient = false;
            this.point_helpers.forEach(function(helper) {
                is_transient = is_transient || helper.transient;
            });

            this.setProperty('transient', !!is_transient);
        };
        model.computeVariables = function() {
            var vars = _.flatten([
                this.helpers.x.formula.variables,
                this.helpers.y.formula.variables,
                this.helpers.width.formula.variables,
                this.helpers.height.formula.variables
            ]);

            var uniq_vars = _.uniq(vars);
            this.setProperty('variables', uniq_vars);
        };
        model.onErrorsChange = function() {
            var errorMessages = {
                x: i18n.t('Invalid x coordinate.'),
                y: i18n.t('Invalid y coordinate.'),
                width: i18n.t('Invalid width.'),
                height: i18n.t('Invalid height.')
            };

            var errors = [];
            for (var id in this.errors) {
                errors.push(errorMessages[id]);
            }

            // just picking first error for now. Showing all the erros is a matter of formatting.
            this.setProperty('error', errors[0] || '');
        };
        model.onTransientChange = function() {
            var id = this.id;
            var list = this.list;
            var wasTransient = this.getOldProperty('transient');
            var isTransient = this.getProperty('transient');

            // just turned transient
            if (!wasTransient && isTransient) {

                // this will be filled in when we end the transient state.
                var startingValues = { x: this.x, y: this.y, width: this.width, height: this.height };
                var endingValues = { x: this.x, y: this.y, width: this.width, height: this.height };

                // keep a record to ending values so that we can update them when we end transient state
                this.transientEndingValues = endingValues;

                list.undoRedo.addTransaction({
                    type: list.undoRedo.RESPONSE_TO_CHANGE,
                    undo: function() {
                        var expression = list.getItemById(id);

                        // set starting values
                        for (var prop in startingValues) {
                            if (startingValues.hasOwnProperty(prop)) {
                                expression.setProperty(prop, startingValues[prop]);
                            }
                        }
                    },
                    redo: function() {
                        var expression = list.getItemById(id);

                        // set ending values
                        for (var prop in endingValues) {
                            if (endingValues.hasOwnProperty(prop)) {
                                expression.setProperty(prop, endingValues[prop]);
                            }
                        }
                    }
                });
            }

            // just ended being transient
            else if (wasTransient && !isTransient) {
                var lastValues = { x: this.x, y: this.y, width: this.width, height: this.height };

                // update the values stored within the undo/redo transaction
                for (var prop in lastValues) {
                    if (lastValues.hasOwnProperty(prop)) {
                        this.transientEndingValues[prop] = lastValues[prop];
                    }
                }
            }
        };

        model.updateFolder = function() {
            _super.updateFolder.call(this);

            if (this.getOldProperty('folder')) {
                this.getOldProperty('folder').unobserve('.' + this.guid);
            }
            if (this.folder) {
                this.folder.observe(
                    'hidden.' + this.guid,
                    this.computeShouldGraph.bind(this)
                );
            }
            this.computeShouldGraph();
        };

        model.createInputHelper = function(prop) {
            var self = this;
            var helper = HelperExpressionObject({ hidden: true }, self.list);
            helper.id = helper.guid;
            self.helpers[prop] = helper;

            // update the computed value when helper is computed
            helper.observe('formula', function() {
                var value = NaN,
                    error = '',
                    formula = helper.formula;

                self.computeVariables();

                if (isFinite(formula.constant_value)) {
                    value = formula.constant_value;
                } else if (formula.zero_values) {
                    value = formula.zero_values[0].val;
                }

                if (isNaN(value)) {
                    if (formula.error) {
                        error = formula.error;
                    } else {
                        error = i18n.t('Does not compute to constant.');
                    }

                    // check if this error has changed
                    if (self.errors[prop] !== error) {
                        self.errors[prop] = error;
                        self.notifyPropertyChange('errors');
                    }
                }

                // had an error, but now it's gone
                else if (self.errors.hasOwnProperty(prop)) {
                    delete self.errors[prop];
                    self.notifyPropertyChange('errors');
                }

                self.setProperty('computed_' + prop, value);
                self.list.triggerRedrawImages();
            });

            function updateLatex() {
                helper.setProperty('latex', self[prop]);
            }

            self.observe(prop, updateLatex);
            updateLatex();
        };

        model.getAliasIdentifier = function(prop) {
            return 'a_{' + prop + this.guid.split('_').join('') + '}';
        };

        /*
          when the inputs are simple numbers, we must use an alias expression
          to make them slidable.

          The point (1,2) is not slidable.

          This is slidable though:
          a = 1
          b = 2
          (a,b)

          These helpers define an expression in terms of the static value. The expression
          becomes slidable and we can drag the slider. When the slider is dragged, we update
          the original property.
        */
        model.createAliasHelper = function(prop) {
            var self = this;
            var helper = HelperExpressionObject({ hidden: true }, self.list);
            helper.id = helper.guid;
            self.helpers['alias_' + prop] = helper;

            // wait for the slider to be created
            helper.observe('slider', function() {
                helper.slider.observe('value', function() {
                    self.setProperty(prop, helper.slider.value.toString());
                });
            });

            // update the helper when property changes
            function updateLatex() {
                helper.setProperty('latex', self.getAliasIdentifier(prop) + '=' + self[prop]);
            }

            self.observe(prop, updateLatex);
            updateLatex();
            self.alias_helpers[prop] = helper;
        };

        model.createResizeHelper = function(xPos, yPos) {
            var self = this;
            var helper = HelperExpressionObject({ color: '#4F81BD', hidden: true }, self.list);
            helper.id = helper.guid;
            self.helpers[xPos + '_' + yPos] = helper;

            function updateLatex() {
                var widthExpr;
                if (self.alias_helpers.width.is_slidable) {
                    widthExpr = self.getAliasIdentifier('width');
                } else {
                    widthExpr = self.width;
                }

                var heightExpr;
                if (self.alias_helpers.height.is_slidable) {
                    heightExpr = self.getAliasIdentifier('height');
                } else {
                    heightExpr = self.height;
                }

                var xOffsetExpr;
                if (xPos === 'left') {
                    xOffsetExpr = '-(' + widthExpr + ')/2';
                } else if (xPos === 'right') {
                    xOffsetExpr = '+(' + widthExpr + ')/2';
                } else {
                    xOffsetExpr = '';
                }

                var yOffsetExpr;
                if (yPos === 'top') {
                    yOffsetExpr = '+(' + heightExpr + ')/2';
                } else if (yPos === 'bottom') {
                    yOffsetExpr = '-(' + heightExpr + ')/2';
                } else {
                    yOffsetExpr = '';
                }

                // makes it so the xCenter is stationary and not draggable.
                var xCenterExpr = '\\left\\{1>0:' + self.x + '\\right\\}';
                var yCenterExpr = '\\left\\{1>0:' + self.y + '\\right\\}';

                helper.setProperty('latex', '(' + xCenterExpr + xOffsetExpr + ',' + yCenterExpr + yOffsetExpr + ')');
            }

            function updateConstraint() {
                // don't update constraints while transient
                if (self.transient) return;

                // if width and height aren't simple, don't constrain the resize point
                if (!self.alias_helpers.width.is_slidable || !self.alias_helpers.height.is_slidable) {
                    helper.constrainPt = null;
                } else {

                    var heightToWidthRatio = self.computed_height / self.computed_width;
                    var x_middle = self.computed_x;
                    var y_middle = self.computed_y;

                    helper.constrainPt = function(pt) {
                        var x_offset = pt.x - x_middle;
                        var y_offset = heightToWidthRatio * x_offset * (xPos === 'left' ? 1 : -1) * (yPos === 'top' ? -1 : 1);
                        return { x: pt.x, y: y_middle + y_offset };
                    };
                }
            }

            self.alias_helpers.width.observe('is_slidable', updateLatex);
            self.alias_helpers.height.observe('is_slidable', updateLatex);
            self.observe('x y width height', updateLatex);
            updateLatex();

            // only do this if it's a corner point
            if (xPos !== 'middle' && yPos !== 'middle') {
                self.alias_helpers.width.observe('is_slidable', updateConstraint);
                self.alias_helpers.height.observe('is_slidable', updateConstraint);
                self.observe('computed_x computed_y computed_width computed_height transient', updateConstraint);

                updateConstraint();
            }

            self.point_helpers.push(helper);
        };

        model.createMoveHelper = function() {
            var self = this;
            var helper = HelperExpressionObject({ color: '#4F81BD', hidden: true }, self.list);
            helper.id = helper.guid;
            self.helpers.move = helper;

            function updateLatex() {
                var xExpr;
                if (self.alias_helpers.x.is_slidable) {
                    xExpr = self.getAliasIdentifier('x');
                } else {
                    xExpr = self.x;
                }

                var yExpr;
                if (self.alias_helpers.y.is_slidable) {
                    yExpr = self.getAliasIdentifier('y');
                } else {
                    yExpr = self.y;
                }

                helper.setProperty('latex', '(' + xExpr + ',' + yExpr + ')');
            }

            self.observe('x y', updateLatex);
            self.alias_helpers.x.observe('is_slidable', updateLatex);
            self.alias_helpers.y.observe('is_slidable', updateLatex);
            updateLatex();
            self.point_helpers.push(helper);
        };

        model.onShowPointsChange = function() {
            var hidden = !this.showPoints;

            // tell each point if it should be hidden
            this.point_helpers.forEach(function(helper) {
                helper.setProperty('hidden', hidden);
            });
        };

        model.onVisibilityChange = function() {
            this.computeShouldGraph();
            this.list.triggerRedrawImages();
        };

        model.onAddedToList = function() {
            // add all helpers
            for (var i in this.helpers) {
                var helper = this.helpers[i];
                this.list.addHelperItem(helper);
            }

            this.list.triggerAddImage(this);
        };

        model.onRemovedFromList = function() {
            // remove all helpers
            for (var i in this.helpers) {
                var helper = this.helpers[i];
                this.list.removeHelperItem(helper.id);
            }

            this.list.triggerRemoveImage(this);

            // don't listen for the image to load
            this.imageObj.onload = null;
        };

        model.loadImage = function() {
            var self = this;
            this.imageObj.onload = function() {
                self.setProperty('loaded', true);
            };

            this.imageObj.src = this.image_url;
        };

        model.isEmpty = function() {
            return false;
        };

        model.getState = function() {
            return {
                id: this.id,
                image_url: this.image_url,
                originalFilename: this.originalFilename,
                name: this.name,
                hidden: this.hidden,
                height: this.height,
                width: this.width,
                x: this.x,
                y: this.y,
                opacity: this.opacity,
                type: 'image'
            };
        };

        // Record change for undo-redo
        model.onStateDidChange = function(prop) {

            // Ignore changes while transient
            if (this.transient || this.isUploading) return;

            var oldValue = this.getOldProperty(prop);
            var newValue = this.getProperty(prop);
            if (oldValue === undefined) return;
            var id = this.id;
            var list = this.list;

            list.undoRedo.addTransaction({
                type: list.undoRedo.RESPONSE_TO_CHANGE,
                undo: function() {
                    list.getItemById(id).setProperty(prop, oldValue);
                },
                redo: function() {
                    list.getItemById(id).setProperty(prop, newValue);
                }
            });

            list.triggerRedrawImages();
        };

    });
    return ImageObject;
});
define('expressions/list', ['require', 'pjs', 'underscore', 'underscore_model', './expression', './text', './table', './folder', './image', 'lib/rounding'], function(require) {
    var P = require('pjs');
    var _ = require('underscore');
    var UnderscoreModel = require('underscore_model');
    var ExpressionObject = require('./expression');
    var TextObject = require('./text');
    var TableObject = require('./table');
    var FolderObject = require('./folder');
    var ImageObject = require('./image');
    var Rounding = require('lib/rounding');

    var ExpressionListModel = P(UnderscoreModel, function(model, _super) {

        model.init = function(undoRedo) {
            _super.init.call(this);
            var self = this;

            this.__items = [];
            this.__itemIds = {};
            this.__helperItemIds = {};
            this.drawOrder = [];

            // an optimization so that we don't compare entire items when changing
            // selectedItem property.
            this.setPropertyComparator('selectedItem', function(a, b) {
                return a === b;
            });

            this.undoRedo = undoRedo;

            // keep stepping sliders ever 40ms
            this.stepHz = 25;
            var stepSliders = function() {
                self.batchEvaluation(function() {
                    self.notifyPropertyChange('playStep');
                });

                setTimeout(function() {
                    stepSliders();
                }, 1000 / self.stepHz);
            };
            stepSliders();
        };

        model.getItemByIndex = function(index) {
            return this.__items[index] || null;
        };

        model.getItemsByIndexRange = function(min, max) {
            min = Math.max(0, min);
            max = Math.min(this.getItemCount() - 1, max);

            var arr = [];
            for (var i = min; i <= max; i++) {
                arr.push(this.getItemByIndex(i));
            }
            return arr;
        };

        model.eachLatex = function(fn) {
            for (var i = 0; i < this.__items.length; i++) {
                this.__items[i].eachLatex(fn);
            }
        };

        model.onChange = function(changes) {
            var id, expression, formula;

            for (id in changes) {
                if (!changes.hasOwnProperty(id)) continue;

                expression = this.getItemById(id);
                formula = changes[id];
                if (!expression) continue;
                expression.setProperty('loading', false);
                expression.setProperty('formula', formula);
            }
        };

        model.onGraphComputed = function(id, graphData) {
            var item = this.getItemById(id);
            if (!item) return;

            var branchResolved = function(branch) {
                if (!branch.hasOwnProperty('resolved')) return true;
                return branch.resolved;
            };

            var unresolved = !graphData.every(branchResolved);
            item.setProperty('unresolved', unresolved);
        };

        model.updateDrawOrder = function() {
            var drawOrder = [];
            var listItems = _.sortBy(this.__itemIds, function(item) { return item.index });
            _.each(listItems, function(item) {
                if (item.hasOwnProperty('columns')) {
                    _.each(item.columns, function(column) {
                        drawOrder.push(column.id);
                    });
                } else {
                    drawOrder.push(item.id);
                }
            });
            this.setProperty('drawOrder', drawOrder);
        };

        model.getItemById = function(id) {
            return this.__itemIds[id] || this.__helperItemIds[id];
        };

        model._insertItemAt = function(index, item) {
            var item_id = String(item.id);
            if (this.__itemIds.hasOwnProperty(item_id)) {
                throw Error('Item with id \'' + item_id + '\' is already in list');
            }

            // add item to list
            this.__itemIds[item_id] = item;
            this.__items.splice(index, 0, item);

            item.index = index;

            if (item.selected) {
                this.handleSelectionChange(item);
            }

            // request that expressions get evaluated
            item.onAddedToList();
        };

        model.handleSelectionChange = function(item) {
            var selected = item.selected;
            if (!selected && this.selectedItem === item) {
                this.setProperty('selectedItem', null);
            } else if (selected && !this.selectedItem) {
                this.setProperty('selectedItem', item);
            } else if (selected && this.selectedItem !== item) {
                this.selectedItem.setProperty('selected', false);
                this.setProperty('selectedItem', item);
            }
        };

        model.triggerItemInserted = function(index, item) {};
        model.insertItemAt = function(index, item) {

            // insert item
            this._insertItemAt(index, item);

            // allow view to tap into this
            this.triggerItemInserted(index, item);

            // add to undo/redo
            var self = this;
            var constructor = item.constructor;
            var state = item.getState();
            self.undoRedo.addTransaction({
                type: self.undoRedo.RESPONSE_TO_CHANGE,
                undo: function() {
                    // save the state when we remove because some properties may have been filled in after
                    // the initial creation. For example, images are created without a width, height, and image_url
                    // initially, but then get filled in after the upload is complete.
                    state = item.getState();
                    self.removeItemAt(index);
                },
                redo: function() {
                    self.insertItemAt(index, constructor(state, self));
                }
            });

            this.updateDrawOrder();
        };

        // Helper items are invisible items.
        model.addHelperItem = function(obj) {
            this.__helperItemIds[obj.id] = obj;
            obj.onAddedToList();
        };

        model.removeHelperItem = function(id) {
            var item = this.__helperItemIds[id];
            if (!item) return;

            item.onRemovedFromList();
            delete this.__helperItemIds[id];
        };

        model.addItem = function(obj) {
            var lastObject = this.getItemByIndex(this.getItemCount() - 1);
            // Replace empty expressions
            if (
                lastObject &&
                //TODO - remove headings after DB updated
                !(lastObject.text || lastObject.columns || lastObject.headings) &&
                lastObject.latex === ''
            ) {
                this.removeItemAt(this.getItemCount() - 1); //pop off last
            }

            this.insertItemAt(this.getItemCount(), obj); //push to end
        };

        model.updateItemById = function(id, properties) {
            this.getItemById(id).setProperties(properties);
            this.updateDrawOrder();
        };

        model._removeItemAt = function(index) {
            var item = this.__items[index];
            if (!item) return;

            if (this.selectedItem === item) {
                this.setProperty('selectedItem', null);
            }

            var self = this;
            if (item.isFolder) {
                for (var id in item.memberIds) {
                    self.removeItemAt(self.getItemById(id).index);
                }
            }

            this.__items.splice(index, 1);
            var item_id = String(item.id);
            delete this.__itemIds[item_id];

            item.onRemovedFromList();

            return item;
        };

        model._removeAllItems = function() {
            for (var i = 0; i < this.__items.length; i++) {
                this.__items[i].onRemovedFromList();
            }

            for (var id in this.__helperItemIds) {
                if (this.__helperItemIds.hasOwnProperty(id)) {
                    this.__helperItemIds[id].onRemovedFromList();
                }
            }

            this.__items = [];
            this.__itemIds = {};
            this.__helperItemIds = {};
            this.setProperty('selectedItem', false);
        };


        model.triggerItemRemoved = function(index, item) {};
        model.removeItemAt = function(index) {
            var self = this;

            self.undoRedo.oneTransaction(function() {

                var item = this._removeItemAt(index);

                // allow a view to tap into this
                this.triggerItemRemoved(index, item);

                var constructor = item.constructor;
                var state = item.getState();
                if (item.folder) item.folder.removeItem(item);

                self.undoRedo.addTransaction({
                    type: self.undoRedo.RESPONSE_TO_CHANGE,
                    undo: function() {
                        var newItem = constructor(state, self);
                        self.insertItemAt(index, newItem);
                    },
                    redo: function() {
                        self.removeItemAt(index);
                    }
                });
            }.bind(this));

            this.updateDrawOrder();
        };

        model.removeItemById = function(id) {
            var expression = this.getItemById(id);
            if (!expression) return;
            this.removeItemAt(expression.index);
        };

        model.triggerItemMoved = function(from, to) {};
        model.moveItemTo = function(a, b) {
            var self = this;

            var manipulator = function(from, to) {
                if (from === to) return;

                var len = self.getItemCount();
                var item = self.__items[from];

                // check that the numbers are within range
                if (from < 0 || to < 0 || from >= len || to >= len) return;

                // remove from items
                self.__items.splice(from, 1);

                // insert back in correct spot
                self.__items.splice(to, 0, item);

                // allow a view to tap into this
                self.triggerItemMoved(from, to);

                self.updateDrawOrder();
            };

            // add to undo/redo
            self.undoRedo.addTransaction({
                type: self.undoRedo.CAUSE_OF_CHANGE,
                undo: function() {
                    manipulator(b, a);
                },
                redo: function() {
                    manipulator(a, b);
                }
            });
        };
        model.moveItemsTo = function(a, b, n) {
            var self = this;

            self.undoRedo.oneTransaction(function() {
                var i;
                if (b >= a && b < a + n) return;
                if (a < b) {
                    for (i = 0; i < n; i++) {
                        self.moveItemTo(a, b);
                    }
                } else {
                    for (i = 0; i < n; i++) {
                        self.moveItemTo(a + i, b + i);
                    }
                }
            });
        };

        model.getItemCount = function() {
            return this.__items.length;
        };

        model.getAllSliders = function() {
            var sliders = [];

            for (var i = 0; i < this.__items.length; i++) {
                var item = this.__items[i];
                if (item.slider) {
                    sliders.push(item.slider);
                }
            }

            return sliders;
        };

        model.getSelected = function() {
            return this.selectedItem;
        };

        model.setSelected = function(i) {
            var nextSelected = i;

            if (typeof i === 'number') nextSelected = this.getItemByIndex(i);
            if (nextSelected) {
                nextSelected.setProperty('selected', true);
            } else {
                var selected = this.getSelected();
                if (selected) selected.setProperty('selected', false);
            }
        };

        model.onStartMovingPoint = function(id) {
            var movedExpr = this.getItemById(id);
            var moveIds = movedExpr && movedExpr.formula && movedExpr.formula.move_ids;
            if (!moveIds) return;

            if (movedExpr.isHelperExpression) {
                movedExpr.setProperty('transient', true);
            }

            // combine all changed sliders into a single transaction
            var self = this;
            self.undoRedo.oneTransaction(function() {
                for (var i = 0; i < moveIds.length; i++) {
                    if (moveIds[i] === undefined) continue;
                    var item = self.getItemById(moveIds[i]);
                    if (!item) continue;

                    item.slider.setProperty(
                        'isMoving',
                        true
                    );
                    item.slider.setProperty('dcg-isPlaying', false);
                }
            });


            // This might not be a failproof conditional in the future, but it works for now.
            // We ordinarily want to deselect expressions when we start dragging a point. But, we
            // don't want to deselect an image when we drag one of it's pull points. The pull points
            // are defined by helper expressions.
            if (!movedExpr.isHelperExpression) {
                this.setSelected(null);
            }
        };

        model.onStopMovingPoint = function(id) {
            var movedExpr = this.getItemById(id);
            var moveIds = movedExpr && movedExpr.formula && movedExpr.formula.move_ids;
            if (!moveIds) return;

            if (movedExpr.isHelperExpression) {
                movedExpr.setProperty('transient', false);
            }

            for (var i = 0; i < moveIds.length; i++) {
                if (moveIds[i] === undefined) continue;
                var item = this.getItemById(moveIds[i]);
                if (!item) continue;

                item.slider.setProperty(
                    'isMoving',
                    false
                );
            }
        };

        model.onMovePoint = function(id, screen_pt, projection) {
            var movedExpr = this.getItemById(id);
            var formula = movedExpr.formula;
            if (!formula) return;

            var moveIds = formula.move_ids;
            if (!moveIds) return;

            var moveMatrix = formula.move_matrix;
            if (!moveMatrix) return;

            // constrain your mouse to the viewport
            var screenTL = projection.map_pt({ x: projection.viewport.xmin, y: projection.viewport.ymax });
            var screenBR = projection.map_pt({ x: projection.viewport.xmax, y: projection.viewport.ymin });
            screen_pt.x = Math.min(Math.max(screen_pt.x, screenTL.x), screenBR.x);
            screen_pt.y = Math.min(Math.max(screen_pt.y, screenTL.y), screenBR.y);

            // further constrain the point if need be
            if (movedExpr.constrainPt) {
                var viewport_pt = projection.reverse_map_pt(screen_pt);
                screen_pt = projection.map_pt(movedExpr.constrainPt(viewport_pt));
            }

            // we are going to search within the square pixel around our mouse to
            // find the shortest decimal for x and for y. We get the topLeft and
            // bottomRight (in viewport units, not pixels) of that square pixel here.
            var tl = projection.reverse_map_pt({
                x: screen_pt.x - 0.5,
                y: screen_pt.y - 0.5
            });

            var br = projection.reverse_map_pt({
                x: screen_pt.x + 0.5,
                y: screen_pt.y + 0.5
            });

            // TODO - moved this here from somewhere else. Looks like the
            // code that depended on this was written to be a little more
            // general purpose (eg, valueLimits.length is referenced). Not sure
            // what was going on there, but we could simplify things.
            var valueLimits = [{ min: tl.x, max: br.x }, { min: tl.y, max: br.y }];

            var min, max, value;
            var expr;

            //Option move matrix to allow offset, factors, and multi-variable
            //dependencies.  Does in-place modification of values array
            //Possibly we should actually use Numeric or something real here
            var self = this;
            self.undoRedo.oneTransaction(function() {
                for (var i = 0; i < moveIds.length; i++) {
                    if (moveIds[i] === undefined) continue;
                    min = moveMatrix[i][valueLimits.length];
                    max = moveMatrix[i][valueLimits.length];
                    for (var j = 0; j < valueLimits.length; j++) {
                        var k = moveMatrix[i][j];
                        min += k * (k > 0 ? valueLimits[j].min : valueLimits[j].max);
                        max += k * (k > 0 ? valueLimits[j].max : valueLimits[j].min);
                    }

                    value = Rounding.shortestDecimalBetween(min, max);

                    var moveId = moveIds[i];

                    expr = self.getItemById(moveId);
                    if (expr && expr.slider) {
                        expr.slider.setProperty('value', expr.slider.computeSnappedValue(value));
                    }
                }
            });
        };

        model.isEmpty = function() {
            var len = this.getItemCount();
            if (len === 0) return true;
            if (len > 1) return false;

            // TODO - maybe this should be this.getItemByIndex(0).isEmpty(). Only
            // problem I see there is that tables aren't ever considered empty. Not
            // sure if we consider expression list empty if it only contains an
            // empty text.
            return this.getItemByIndex(0).latex === '';
        };

        model.getState = function() {
            var list_state = [];
            var len = this.getItemCount();

            for (var i = 0; i < len; i++) {
                list_state.push(this.getItemByIndex(i).getState());
            }

            return { list: list_state };
        };

        model.batchEvaluation = function(fn) {
            fn();
        };
        model.triggerSetState = function(list) {};
        model.setState = function(state) {
            var i;
            var list_content = [];
            var folders = [];
            var obj;

            for (i = 0; i < state.list.length; i++) {
                var expState = state.list[i];

                // Start rendering UI as shell until we know if it's on screen
                expState.renderShell = true;

                obj = this.fromState(expState);

                if (!obj) continue;

                if (obj.isFolder) folders.push(obj);

                list_content.push(obj);
            }

            // remove all items and then add the new ones in a single batch
            var self = this;
            this.batchEvaluation(function() {
                self._removeAllItems();

                for (i = 0; i < list_content.length; i++) {
                    self._insertItemAt(i, list_content[i]);
                }
            });

            // Tell expressions about their parent folders.
            folders.forEach(function(folder) {
                for (var id in folder.memberIds) {
                    // defensive programming. see #3920 where memberIds contained a missing id
                    var item = self.getItemById(id);
                    if (item) {
                        item.setProperty('folder', folder);
                    } else {
                        delete folder.memberIds[id];
                    }
                }
            });

            // allow the view to tap into this
            this.triggerSetState(list_content);

            this.updateDrawOrder();
        };

        // Factory method for making a single expression object of the appropriate
        // type from a serialized state.
        model.fromState = function(itemState) {
            if (itemState.text !== undefined) {
                return TextObject(itemState, this);
            }
            if (itemState.columns !== undefined || itemState.headings !== undefined) {
                // TODO - remove headings after DB updated
                return TableObject(itemState, this);
            }

            if (itemState.type === 'folder') return FolderObject(itemState, this);
            if (itemState.type === 'image') return ImageObject(itemState, this);

            // Handle legacy data about whether an expression should be hidden
            if (!itemState.hasOwnProperty('hidden')) {
                if (itemState.hasOwnProperty('graphed')) {
                    itemState.hidden = !itemState.graphed;
                } else if (itemState.hasOwnProperty('userRequestedGraphing')) {
                    itemState.hidden = (itemState.userRequestedGraphing === 'never');
                }
            }

            return ExpressionObject(itemState, this);
        };

        model.triggerRemoveExps = function() {};
        model.triggerRemoveExp = function() {};
        model.triggerAddExp = function() {};
    });


    return ExpressionListModel;
});

define('loadcss!css/expression_top_bar', function() {});
define('loadcss!css/expressions', function() {});
define('loadcss!css/expressions.icon', function() {});
define('expressions/dragdrop', ['require', 'jquery', 'pjs', 'tipsy', 'jquery.handleevent'], function(require) {
    var $ = require('jquery');
    var P = require('pjs');
    var Tipsy = require('tipsy');
    require('jquery.handleevent');

    var DragDrop = P(function(dragdrop) {

        // methods to be filled in by subclass
        dragdrop.toggleStyling = function(isDragging) {};
        dragdrop.onDragStart = function(evt, view) {};
        dragdrop.onDragStop = function(evt) {};
        dragdrop.commitDragState = function(dragState) {};
        dragdrop.updateScroll = function() {};
        dragdrop.computeDragPosition = function(x, y) { return { x: x, y: y } };
        dragdrop.computeDragState = function(list, dragPosition) { return {} };
        dragdrop.previewDragState = function(dragState) {};
        dragdrop.buildDragList = function() {};

        dragdrop.init = function(expressionsView) {
            this.expressionsView = expressionsView;
            this.active = false;
        };

        dragdrop.start = function(evt, view) {
            if (evt.touches.length !== 1) return;
            if (evt.wasHandled('longhold')) return;
            this.active = true;
            this.exppanel = this.expressionsView.$('.dcg-exppanel');

            this.setupEventListeners(evt);
            this.onDragStart(evt, view);

            this.dragList = this.buildDragList();
            this.toggleStyling(true);
            this.drag(evt.touches[0].x, evt.touches[0].y); //Do first drag

            // disable tipsy while dragging
            Tipsy.addDisableLock();
        };

        dragdrop.setupEventListeners = function(evt) {
            // save the touch identifier so that multitouch doesn't mess us up. Also
            // create a function that allows us to lookup the touch we care about.
            var touch_identifier = evt.touches[0].identifier;

            function getTouch(evt) {
                for (var i = 0; i < evt.touches.length; i++) {
                    var touch = evt.touches[i];
                    if (touch.identifier === touch_identifier) {
                        return touch;
                    }
                }
            }

            var self = this;

            // listen for mouse movements and tell DragDrop about them.
            $(document).on('tapmove.dragdrop', function(evt) {
                // touch must still be around
                var touch = getTouch(evt);
                if (!touch) return;
                self.drag(touch.x, touch.y);
            });

            // listen for mouse ups and tell DragDrop about them.
            $(document).on('tapend.dragdrop', function(evt) {
                // touch must not be around
                var touch = getTouch(evt);
                if (touch) return;
                self.stop();
                evt.handle('dragdrop');
            });

            //add event listener on exppanel.scroll
            this.exppanel.on('scroll.dragdrop', this.drag.bind(this));
        };

        dragdrop.stop = function(evt) {
            this.active = false;

            //Clear listeners
            $(document).off('.dragdrop');

            //Commit changes to model
            this.commitDragState(this.dragState);

            //Get rid of preview styling
            this.toggleStyling(false);

            this.onDragStop(evt);

            // reenable tipsy after dragging
            Tipsy.removeDisableLock();
        };

        dragdrop.drag = function(x, y) {
            if (!this.active) return;

            //Need to cache mouse position for scroll-triggered udpates
            if (typeof(x) === 'number') this.mouseX = x;
            if (typeof(y) === 'number') this.mouseY = y;

            var self = this;
            setTimeout(function() {
                self.updateScroll();
            }, 1);

            var dragPosition = this.computeDragPosition(this.mouseX, this.mouseY);
            this.dragState = this.computeDragState(this.dragList, dragPosition);
            this.previewDragState(this.dragState);
        };
    });

    // TODO - any kind of user interaction (undo, typing, etc) should call
    // finishDrag to prevent us from getting in a weird state where we're dragging
    // an expression that doesn't exist.

    return DragDrop;
});
define('expressions/dragdrop_expressions', ['require', 'underscore', 'browser', 'pjs', './dragdrop', 'conditional_blur'], function(require) {
    var _ = require('underscore');
    var Browser = require('browser');
    var P = require('pjs');
    var DragDrop = require('./dragdrop');
    var conditionalBlur = require('conditional_blur');

    var DragDropExpressions = P(DragDrop, function(dragdrop, _super) {

        dragdrop.toggleStyling = function(isDragging) {
            this.exppanel.toggleClass('dcg-isDragging', isDragging);
            this.draggedView.$().toggleClass('dcg-dragging', isDragging);
            if (!isDragging) {
                //Remove things that are set by preview code
                this.draggedView.$().removeClass('dcg-overFolder');
                this.expressionsView.$('.dcg-expressionitem').css('transform', 'none');
            }
        };

        dragdrop.onDragStart = function(evt, view) {
            this.expressionsView.model.setSelected(null);
            this.exppanel = this.expressionsView.$('.dcg-exppanel');

            conditionalBlur();
            evt.preventDefault();

            this.draggedView = view;
            this.draggedViewHeight = view.$().outerHeight() - 1; //because of the negative 1 margin

            this.panelTop = this.exppanel.offset().top;
            this.panelHeight = this.exppanel.height();
            this.panelBottom = this.panelTop + this.panelHeight;

            this.grabOffset = view.$().offset().top - evt.touches[0].y;
            this.grabY = this.computeDragPosition(evt.touches[0].x, evt.touches[0].y).y;
            this.grabIndex = view.model.index;
            this.draggedViewCount = 1;

            if (view.model.isFolder) {
                this.draggedViewCount += _.size(view.model.memberIds);
                this.dropCollapsed = view.model.collapsed; //Cache whether folder is collapsed before collapsing
                view.model.setProperty('collapsed', true);
            }
        };

        dragdrop.onDragStop = function(evt) {
            clearTimeout(this.scrollTimeout);

            //Select the expression we just dragged
            this.expressionsView.model.setSelected(this.draggedView.model);
        };

        dragdrop.buildDragList = function() {
            var self = this;
            var expressions = this.expressionsView.model.getItemsByIndexRange(0, Infinity);

            var list = [{
                y: -Infinity,
                index: 0,
                folder: undefined
            }];

            var lastItem = [{
                y: Infinity,
                index: 0,
                folder: undefined
            }];

            expressions.forEach(function(expression) {
                if (expression.id === self.draggedView.model.id) return;
                if (expression.folder && expression.folder.collapsed) return;
                if (expression.folder && self.draggedView.model.isFolder) return;

                //Figure out which expressions are included in this drag item
                var view = self.expressionsView.getItemView(expression.id);
                var belowGrabbedView = (expression.index > self.grabIndex);
                var elements = view.$();
                if (expression.isFolder && (expression.collapsed || self.draggedView.model.isFolder)) {
                    for (var id in expression.memberIds) {
                        elements.push(self.expressionsView.getItemView(id).$()[0]);
                    }
                }

                //Compute dimensions of the expression(s), removing draggedView from list
                var offset = (belowGrabbedView ? -self.draggedViewHeight : 0);
                var height = view.$().height();
                var top = view.$().position().top + offset;

                //Compute indexes for before and after the expression(s)
                var indexOffset = (belowGrabbedView ? -1 : 0); //-self.draggedViewCount : 0);
                var indexBefore = expression.index + indexOffset;
                var indexAfter = indexBefore + elements.length;

                //Compute folder insertion behavior
                var topFolder, midFolder;
                if (!self.draggedView.model.isFolder) {
                    topFolder = expression.folder;
                    midFolder = (expression.isFolder ? expression : expression.folder);
                }

                //Record what happens when dragging past the top of the expression
                list.push({
                    y: top,
                    index: indexBefore,
                    folder: topFolder
                });

                //Record what happens when dragging past the midpoint of the expression
                list.push({
                    y: top + height / 2,
                    index: indexAfter,
                    folder: midFolder,

                    elements: elements, //TODO - should include all elements dragged past
                    offset: offset
                });

                //Record what happens when dragging past the bottom of the expression
                //Only appended to list if this was the last item
                lastItem = {
                    y: top + height,
                    index: indexAfter,
                    folder: undefined
                };

            });
            list.push(lastItem);

            return list;
        };

        // allows expression list to scroll drag above or below it
        dragdrop.updateScroll = function() {
            clearTimeout(this.scrollTimeout);
            if (!this.active) return;
            var scrollSpeed = 0;

            //Use being over top of list (into header bar) as cue to start scrolling up
            scrollSpeed = Math.min(scrollSpeed, (this.mouseY - this.panelTop));

            //Use bottom 30 pixels as cue to start scrolling down  30px is smaller than one equation,
            //But still big enough to trigger easily
            scrollSpeed = Math.max(scrollSpeed, (this.mouseY - this.panelBottom + 30));

            //Adjust the speed based on the expressions list height.
            //A 30 pixel offset should get us to the other side in about 1 second of 30hz updates
            //30 pixels * 30 updates = 900
            scrollSpeed = (scrollSpeed * this.panelHeight / 900);

            if (scrollSpeed) {
                this.exppanel.scrollTop(this.exppanel.scrollTop() + scrollSpeed);
            }
        };

        //Compute position of the dragged view in terms of the scrolled list
        dragdrop.computeDragPosition = function(x, y) {
            //Clamp effective mouse position to edges of panel
            y = Math.max(y, Math.min(y, this.panelBottom), this.panelTop);

            //Make position relative to the panel
            y -= this.panelTop;

            //Add offset for where element was grabbed
            y += this.grabOffset;

            //Compensate for scrolling
            return { x: NaN, y: y + this.exppanel.scrollTop() };
        };

        //Takes a list of states, which each includes the y value at which it starts,
        //as well as the index and the folder which the dragged item would have it it
        //is dropped below that line.
        dragdrop.computeDragState = function(list, dragPosition) {
            function sortMethod(item) {
                return item.y;
            }

            var index = _.sortedIndex(list, { y: dragPosition.y }, sortMethod) - 1; //See where we would be inserted
            return {
                list: list,
                index: list[index].index,
                folder: list[index].folder,
                dragY: dragPosition.y
            };
        };

        //Update model to reflect new dragState
        dragdrop.commitDragState = function(dragState) {
            var self = this;
            var list = this.expressionsView.model;

            list.undoRedo.oneTransaction(function() {
                var draggedModel = self.draggedView.model;

                //Update ordering
                list.moveItemsTo(self.grabIndex, dragState.index, self.draggedViewCount);

                //Update folder membership
                var newFolder = dragState.folder;
                var oldFolder = draggedModel.folder;
                if (newFolder !== oldFolder) {
                    if (oldFolder) oldFolder.removeItem(draggedModel);
                    if (newFolder) newFolder.addItem(draggedModel);
                }

                //Restore folder collapsed state
                if (draggedModel.isFolder) {
                    draggedModel.setProperty('collapsed', self.dropCollapsed); //Restore collapsed state
                }
            });
        };

        //Display preview of dragState, but don't commit changes
        dragdrop.previewDragState = function(dragState) {
            var self = this;

            //Preview height and folder membership of dragged item
            this.draggedView.$().css("transform", Browser.translateRule(0, dragState.dragY - this.grabY));
            this.draggedView.$().toggleClass('dcg-overFolder', !!dragState.folder);

            //Update transforms for items above and below dragged view
            _.each(dragState.list, function(item) {
                if (item.elements) {
                    var offset = item.offset + (item.index > dragState.index ? self.draggedViewHeight : 0);
                    item.elements.css('transform', Browser.translateRule(0, offset));
                }
            });
        };
    });

    return DragDropExpressions;
});
define('loadcss!css/add_expression', function() {});
define('template!add_expression', ['underscore'], function(_) {
    return function(obj) {
        var __p = '';
        var print = function() { __p += Array.prototype.join.call(arguments, '') };
        with(obj || {}) {
            __p += '<div class="dcg-add-expression-dropdown dcg-popover dcg-bottom">\n  <div class="dcg-popover-interior">\n     ';
            if (expressions) {;
                __p += '\n     <div class=\'dcg-new-item dcg-do-not-blur dcg-action-newexpression\'>\n        <i class=\'dcg-icon-new-expression dcg-expression-icon\'></i>\n        ' +
                    (t('expression')) +
                    '\n     </div>\n     ';
            };
            __p += '\n    \n     ';
            if (texts) {;
                __p += '\n     <div class=\'dcg-new-item dcg-do-not-blur dcg-action-newtext\'>\n       <i class=\'dcg-icon-new-text dcg-expression-icon\'></i>\n       ' +
                    (t('note')) +
                    '\n     </div>\n     ';
            };
            __p += '\n\n     ';
            if (tables) {;
                __p += '\n     <div class=\'dcg-new-item dcg-do-not-blur dcg-action-newtable\'>\n       <i class=\'dcg-icon-new-table dcg-expression-icon\'></i>\n       ' +
                    (t('table')) +
                    '\n     </div>\n     ';
            };
            __p += '\n     \n     ';
            if (folders) {;
                __p += '\n     <div class=\'dcg-new-item dcg-do-not-blur dcg-action-newfolder\'>\n       <i class=\'dcg-icon-new-folder dcg-expression-icon\'></i>\n       ' +
                    (t('folder')) +
                    '\n     </div>\n     ';
            };
            __p += '\n\n     ';
            if (images) {;
                __p += '\n     <div class=\'dcg-new-item dcg-do-not-blur dcg-action-newimage\'>\n       <i class=\'dcg-icon-new-image dcg-expression-icon\'></i>\n       ' +
                    (t('image')) +
                    '\n       \n       ';
                // hiding the file input box. It's ugly. Our UI is prettier. We'll fake a click on it
                // when our UI is clicked
                ;
                __p += '\n       <input type="file" accept="image/*" style="display: none" />\n     </div>\n     ';
            };
            __p += '\n\n   </div>\n\n   <span class="dcg-arrow"></span>\n</div>\n';
        }
        return __p;
    };
});
/*
 * JavaScript Load Image 1.9.0
 * https://github.com/blueimp/JavaScript-Load-Image
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */

/*jslint nomen: true */
/*global define, window, document, URL, webkitURL, Blob, File, FileReader */

(function($) {


    // Loads an image for a given File object.
    // Invokes the callback with an img or optional canvas
    // element (if supported by the browser) as parameter:
    var loadImage = function(file, callback, options) {
            var img = document.createElement('img'),
                url,
                oUrl;
            img.onerror = callback;
            img.onload = function() {
                if (oUrl && !(options && options.noRevoke)) {
                    loadImage.revokeObjectURL(oUrl);
                }
                if (callback) {
                    callback(loadImage.scale(img, options));
                }
            };
            if (loadImage.isInstanceOf('Blob', file) ||
                // Files are also Blob instances, but some browsers
                // (Firefox 3.6) support the File API but not Blobs:
                loadImage.isInstanceOf('File', file)) {
                url = oUrl = loadImage.createObjectURL(file);
                // Store the file type for resize processing:
                img._type = file.type;
            } else if (typeof file === 'string') {
                url = file;
                if (options && options.crossOrigin) {
                    img.crossOrigin = options.crossOrigin;
                }
            } else {
                return false;
            }
            if (url) {
                img.src = url;
                return img;
            }
            return loadImage.readFile(file, function(e) {
                var target = e.target;
                if (target && target.result) {
                    img.src = target.result;
                } else {
                    if (callback) {
                        callback(e);
                    }
                }
            });
        },
        // The check for URL.revokeObjectURL fixes an issue with Opera 12,
        // which provides URL.createObjectURL but doesn't properly implement it:
        urlAPI = (window.createObjectURL && window) ||
        (window.URL && URL.revokeObjectURL && URL) ||
        (window.webkitURL && webkitURL);

    loadImage.isInstanceOf = function(type, obj) {
        // Cross-frame instanceof check
        return Object.prototype.toString.call(obj) === '[object ' + type + ']';
    };

    // Transform image coordinates, allows to override e.g.
    // the canvas orientation based on the orientation option,
    // gets canvas, options passed as arguments:
    loadImage.transformCoordinates = function() {
        return;
    };

    // Returns transformed options, allows to override e.g.
    // coordinate and dimension options based on the orientation:
    loadImage.getTransformedOptions = function(options) {
        return options;
    };

    // Canvas render method, allows to override the
    // rendering e.g. to work around issues on iOS:
    loadImage.renderImageToCanvas = function(
        canvas,
        img,
        sourceX,
        sourceY,
        sourceWidth,
        sourceHeight,
        destX,
        destY,
        destWidth,
        destHeight
    ) {
        canvas.getContext('2d').drawImage(
            img,
            sourceX,
            sourceY,
            sourceWidth,
            sourceHeight,
            destX,
            destY,
            destWidth,
            destHeight
        );
        return canvas;
    };

    // This method is used to determine if the target image
    // should be a canvas element:
    loadImage.hasCanvasOption = function(options) {
        return options.canvas || options.crop;
    };

    // Scales and/or crops the given image (img or canvas HTML element)
    // using the given options.
    // Returns a canvas object if the browser supports canvas
    // and the hasCanvasOption method returns true or a canvas
    // object is passed as image, else the scaled image:
    loadImage.scale = function(img, options) {
        options = options || {};
        var canvas = document.createElement('canvas'),
            useCanvas = img.getContext ||
            (loadImage.hasCanvasOption(options) && canvas.getContext),
            width = img.naturalWidth || img.width,
            height = img.naturalHeight || img.height,
            destWidth = width,
            destHeight = height,
            maxWidth,
            maxHeight,
            minWidth,
            minHeight,
            sourceWidth,
            sourceHeight,
            sourceX,
            sourceY,
            tmp,
            scaleUp = function() {
                var scale = Math.max(
                    (minWidth || destWidth) / destWidth,
                    (minHeight || destHeight) / destHeight
                );
                if (scale > 1) {
                    destWidth = Math.ceil(destWidth * scale);
                    destHeight = Math.ceil(destHeight * scale);
                }
            },
            scaleDown = function() {
                var scale = Math.min(
                    (maxWidth || destWidth) / destWidth,
                    (maxHeight || destHeight) / destHeight
                );
                if (scale < 1) {
                    destWidth = Math.ceil(destWidth * scale);
                    destHeight = Math.ceil(destHeight * scale);
                }
            };
        if (useCanvas) {
            options = loadImage.getTransformedOptions(options);
            sourceX = options.left || 0;
            sourceY = options.top || 0;
            if (options.sourceWidth) {
                sourceWidth = options.sourceWidth;
                if (options.right !== undefined && options.left === undefined) {
                    sourceX = width - sourceWidth - options.right;
                }
            } else {
                sourceWidth = width - sourceX - (options.right || 0);
            }
            if (options.sourceHeight) {
                sourceHeight = options.sourceHeight;
                if (options.bottom !== undefined && options.top === undefined) {
                    sourceY = height - sourceHeight - options.bottom;
                }
            } else {
                sourceHeight = height - sourceY - (options.bottom || 0);
            }
            destWidth = sourceWidth;
            destHeight = sourceHeight;
        }
        maxWidth = options.maxWidth;
        maxHeight = options.maxHeight;
        minWidth = options.minWidth;
        minHeight = options.minHeight;
        if (useCanvas && maxWidth && maxHeight && options.crop) {
            destWidth = maxWidth;
            destHeight = maxHeight;
            tmp = sourceWidth / sourceHeight - maxWidth / maxHeight;
            if (tmp < 0) {
                sourceHeight = maxHeight * sourceWidth / maxWidth;
                if (options.top === undefined && options.bottom === undefined) {
                    sourceY = (height - sourceHeight) / 2;
                }
            } else if (tmp > 0) {
                sourceWidth = maxWidth * sourceHeight / maxHeight;
                if (options.left === undefined && options.right === undefined) {
                    sourceX = (width - sourceWidth) / 2;
                }
            }
        } else {
            if (options.contain || options.cover) {
                minWidth = maxWidth = maxWidth || minWidth;
                minHeight = maxHeight = maxHeight || minHeight;
            }
            if (options.cover) {
                scaleDown();
                scaleUp();
            } else {
                scaleUp();
                scaleDown();
            }
        }
        if (useCanvas) {
            canvas.width = destWidth;
            canvas.height = destHeight;
            loadImage.transformCoordinates(
                canvas,
                options
            );
            return loadImage.renderImageToCanvas(
                canvas,
                img,
                sourceX,
                sourceY,
                sourceWidth,
                sourceHeight,
                0,
                0,
                destWidth,
                destHeight
            );
        }
        img.width = destWidth;
        img.height = destHeight;
        return img;
    };

    loadImage.createObjectURL = function(file) {
        return urlAPI ? urlAPI.createObjectURL(file) : false;
    };

    loadImage.revokeObjectURL = function(url) {
        return urlAPI ? urlAPI.revokeObjectURL(url) : false;
    };

    // Loads a given File object via FileReader interface,
    // invokes the callback with the event object (load or error).
    // The result can be read via event.target.result:
    loadImage.readFile = function(file, callback, method) {
        if (window.FileReader) {
            var fileReader = new FileReader();
            fileReader.onload = fileReader.onerror = callback;
            method = method || 'readAsDataURL';
            if (fileReader[method]) {
                fileReader[method](file);
                return fileReader;
            }
        }
        return false;
    };

    if (typeof define === 'function' && define.amd) {
        define('vendor/load-image/load-image', [], function() {
            return loadImage;
        });
    } else {
        $.loadImage = loadImage;
    }
}(this));

/*
 * JavaScript Load Image Orientation 1.0.0
 * https://github.com/blueimp/JavaScript-Load-Image
 *
 * Copyright 2013, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */

/*global define, window */

(function(factory) {

    if (typeof define === 'function' && define.amd) {
        // Register as an anonymous AMD module:
        define('vendor/load-image/load-image-orientation', ['./load-image'], factory);
    } else {
        // Browser globals:
        factory(window.loadImage);
    }
}(function(loadImage) {


    var originalHasCanvasOptionMethod = loadImage.hasCanvasOption;

    // This method is used to determine if the target image
    // should be a canvas element:
    loadImage.hasCanvasOption = function(options) {
        return originalHasCanvasOptionMethod(options) || options.orientation;
    };

    // Transform image orientation based on
    // the given EXIF orientation option:
    loadImage.transformCoordinates = function(canvas, options) {
        var ctx = canvas.getContext('2d'),
            width = canvas.width,
            height = canvas.height,
            orientation = options.orientation;
        if (!orientation) {
            return;
        }
        if (orientation > 4) {
            canvas.width = height;
            canvas.height = width;
        }
        switch (orientation) {
            case 2:
                // horizontal flip
                ctx.translate(width, 0);
                ctx.scale(-1, 1);
                break;
            case 3:
                // 180Â° rotate left
                ctx.translate(width, height);
                ctx.rotate(Math.PI);
                break;
            case 4:
                // vertical flip
                ctx.translate(0, height);
                ctx.scale(1, -1);
                break;
            case 5:
                // vertical flip + 90 rotate right
                ctx.rotate(0.5 * Math.PI);
                ctx.scale(1, -1);
                break;
            case 6:
                // 90Â° rotate right
                ctx.rotate(0.5 * Math.PI);
                ctx.translate(0, -height);
                break;
            case 7:
                // horizontal flip + 90 rotate right
                ctx.rotate(0.5 * Math.PI);
                ctx.translate(width, -height);
                ctx.scale(-1, 1);
                break;
            case 8:
                // 90Â° rotate left
                ctx.rotate(-0.5 * Math.PI);
                ctx.translate(-width, 0);
                break;
        }
    };

    // Transforms coordinate and dimension options
    // based on the given orientation option:
    loadImage.getTransformedOptions = function(options) {
        if (!options.orientation || options.orientation === 1) {
            return options;
        }
        var newOptions = {},
            i;
        for (i in options) {
            if (options.hasOwnProperty(i)) {
                newOptions[i] = options[i];
            }
        }
        switch (options.orientation) {
            case 2:
                // horizontal flip
                newOptions.left = options.right;
                newOptions.right = options.left;
                break;
            case 3:
                // 180Â° rotate left
                newOptions.left = options.right;
                newOptions.top = options.bottom;
                newOptions.right = options.left;
                newOptions.bottom = options.top;
                break;
            case 4:
                // vertical flip
                newOptions.top = options.bottom;
                newOptions.bottom = options.top;
                break;
            case 5:
                // vertical flip + 90 rotate right
                newOptions.left = options.top;
                newOptions.top = options.left;
                newOptions.right = options.bottom;
                newOptions.bottom = options.right;
                break;
            case 6:
                // 90Â° rotate right
                newOptions.left = options.top;
                newOptions.top = options.right;
                newOptions.right = options.bottom;
                newOptions.bottom = options.left;
                break;
            case 7:
                // horizontal flip + 90 rotate right
                newOptions.left = options.bottom;
                newOptions.top = options.right;
                newOptions.right = options.top;
                newOptions.bottom = options.left;
                break;
            case 8:
                // 90Â° rotate left
                newOptions.left = options.bottom;
                newOptions.top = options.left;
                newOptions.right = options.top;
                newOptions.bottom = options.right;
                break;
        }
        if (options.orientation > 4) {
            newOptions.maxWidth = options.maxHeight;
            newOptions.maxHeight = options.maxWidth;
            newOptions.minWidth = options.minHeight;
            newOptions.minHeight = options.minWidth;
            newOptions.sourceWidth = options.sourceHeight;
            newOptions.sourceHeight = options.sourceWidth;
        }
        return newOptions;
    };

}));

/*
 * JavaScript Load Image Meta 1.0.1
 * https://github.com/blueimp/JavaScript-Load-Image
 *
 * Copyright 2013, Sebastian Tschan
 * https://blueimp.net
 *
 * Image meta data handling implementation
 * based on the help and contribution of
 * Achim StÃ¶hr.
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */

/*jslint continue:true */
/*global define, window, DataView, Blob, Uint8Array, console */

(function(factory) {

    if (typeof define === 'function' && define.amd) {
        // Register as an anonymous AMD module:
        define('vendor/load-image/load-image-meta', ['./load-image'], factory);
    } else {
        // Browser globals:
        factory(window.loadImage);
    }
}(function(loadImage) {


    var hasblobSlice = window.Blob && (Blob.prototype.slice ||
        Blob.prototype.webkitSlice || Blob.prototype.mozSlice);

    loadImage.blobSlice = hasblobSlice && function() {
        var slice = this.slice || this.webkitSlice || this.mozSlice;
        return slice.apply(this, arguments);
    };

    loadImage.metaDataParsers = {
        jpeg: {
            0xffe1: [] // APP1 marker
        }
    };

    // Parses image meta data and calls the callback with an object argument
    // with the following properties:
    // * imageHead: The complete image head as ArrayBuffer (Uint8Array for IE10)
    // The options arguments accepts an object and supports the following properties:
    // * maxMetaDataSize: Defines the maximum number of bytes to parse.
    // * disableImageHead: Disables creating the imageHead property.
    loadImage.parseMetaData = function(file, callback, options) {
        options = options || {};
        var that = this,
            // 256 KiB should contain all EXIF/ICC/IPTC segments:
            maxMetaDataSize = options.maxMetaDataSize || 262144,
            data = {},
            noMetaData = !(window.DataView && file && file.size >= 12 &&
                file.type === 'image/jpeg' && loadImage.blobSlice);
        if (noMetaData || !loadImage.readFile(
                loadImage.blobSlice.call(file, 0, maxMetaDataSize),
                function(e) {
                    // Note on endianness:
                    // Since the marker and length bytes in JPEG files are always
                    // stored in big endian order, we can leave the endian parameter
                    // of the DataView methods undefined, defaulting to big endian.
                    var buffer = e.target.result,
                        dataView = new DataView(buffer),
                        offset = 2,
                        maxOffset = dataView.byteLength - 4,
                        headLength = offset,
                        markerBytes,
                        markerLength,
                        parsers,
                        i;
                    // Check for the JPEG marker (0xffd8):
                    if (dataView.getUint16(0) === 0xffd8) {
                        while (offset < maxOffset) {
                            markerBytes = dataView.getUint16(offset);
                            // Search for APPn (0xffeN) and COM (0xfffe) markers,
                            // which contain application-specific meta-data like
                            // Exif, ICC and IPTC data and text comments:
                            if ((markerBytes >= 0xffe0 && markerBytes <= 0xffef) ||
                                markerBytes === 0xfffe) {
                                // The marker bytes (2) are always followed by
                                // the length bytes (2), indicating the length of the
                                // marker segment, which includes the length bytes,
                                // but not the marker bytes, so we add 2:
                                markerLength = dataView.getUint16(offset + 2) + 2;
                                if (offset + markerLength > dataView.byteLength) {
                                    console.log('Invalid meta data: Invalid segment size.');
                                    break;
                                }
                                parsers = loadImage.metaDataParsers.jpeg[markerBytes];
                                if (parsers) {
                                    for (i = 0; i < parsers.length; i += 1) {
                                        parsers[i].call(
                                            that,
                                            dataView,
                                            offset,
                                            markerLength,
                                            data,
                                            options
                                        );
                                    }
                                }
                                offset += markerLength;
                                headLength = offset;
                            } else {
                                // Not an APPn or COM marker, probably safe to
                                // assume that this is the end of the meta data
                                break;
                            }
                        }
                        // Meta length must be longer than JPEG marker (2)
                        // plus APPn marker (2), followed by length bytes (2):
                        if (!options.disableImageHead && headLength > 6) {
                            if (buffer.slice) {
                                data.imageHead = buffer.slice(0, headLength);
                            } else {
                                // Workaround for IE10, which does not yet
                                // support ArrayBuffer.slice:
                                data.imageHead = new Uint8Array(buffer)
                                    .subarray(0, headLength);
                            }
                        }
                    } else {
                        console.log('Invalid JPEG file: Missing JPEG marker.');
                    }
                    callback(data);
                },
                'readAsArrayBuffer'
            )) {
            callback(data);
        }
    };

}));

/*
 * JavaScript Load Image iOS scaling fixes 1.0.3
 * https://github.com/blueimp/JavaScript-Load-Image
 *
 * Copyright 2013, Sebastian Tschan
 * https://blueimp.net
 *
 * iOS image scaling fixes based on
 * https://github.com/stomita/ios-imagefile-megapixel
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */

/*jslint nomen: true, bitwise: true */
/*global define, window, document */

(function(factory) {

    if (typeof define === 'function' && define.amd) {
        // Register as an anonymous AMD module:
        define('vendor/load-image/load-image-ios', ['./load-image'], factory);
    } else {
        // Browser globals:
        factory(window.loadImage);
    }
}(function(loadImage) {


    // Only apply fixes on the iOS platform:
    if (!window.navigator || !window.navigator.platform ||
        !(/iP(hone|od|ad)/).test(window.navigator.platform)) {
        return;
    }

    var originalRenderMethod = loadImage.renderImageToCanvas;

    // Detects subsampling in JPEG images:
    loadImage.detectSubsampling = function(img) {
        var canvas,
            context;
        if (img.width * img.height > 1024 * 1024) { // only consider mexapixel images
            canvas = document.createElement('canvas');
            canvas.width = canvas.height = 1;
            context = canvas.getContext('2d');
            context.drawImage(img, -img.width + 1, 0);
            // subsampled image becomes half smaller in rendering size.
            // check alpha channel value to confirm image is covering edge pixel or not.
            // if alpha value is 0 image is not covering, hence subsampled.
            return context.getImageData(0, 0, 1, 1).data[3] === 0;
        }
        return false;
    };

    // Detects vertical squash in JPEG images:
    loadImage.detectVerticalSquash = function(img, subsampled) {
        var naturalHeight = img.naturalHeight || img.height,
            canvas = document.createElement('canvas'),
            context = canvas.getContext('2d'),
            data,
            sy,
            ey,
            py,
            alpha;
        if (subsampled) {
            naturalHeight /= 2;
        }
        canvas.width = 1;
        canvas.height = naturalHeight;
        context.drawImage(img, 0, 0);
        data = context.getImageData(0, 0, 1, naturalHeight).data;
        // search image edge pixel position in case it is squashed vertically:
        sy = 0;
        ey = naturalHeight;
        py = naturalHeight;
        while (py > sy) {
            alpha = data[(py - 1) * 4 + 3];
            if (alpha === 0) {
                ey = py;
            } else {
                sy = py;
            }
            py = (ey + sy) >> 1;
        }
        return (py / naturalHeight) || 1;
    };

    // Renders image to canvas while working around iOS image scaling bugs:
    // https://github.com/blueimp/JavaScript-Load-Image/issues/13
    loadImage.renderImageToCanvas = function(
        canvas,
        img,
        sourceX,
        sourceY,
        sourceWidth,
        sourceHeight,
        destX,
        destY,
        destWidth,
        destHeight
    ) {
        if (img._type === 'image/jpeg') {
            var context = canvas.getContext('2d'),
                tmpCanvas = document.createElement('canvas'),
                tileSize = 1024,
                tmpContext = tmpCanvas.getContext('2d'),
                subsampled,
                vertSquashRatio,
                tileX,
                tileY;
            tmpCanvas.width = tileSize;
            tmpCanvas.height = tileSize;
            context.save();
            subsampled = loadImage.detectSubsampling(img);
            if (subsampled) {
                sourceX /= 2;
                sourceY /= 2;
                sourceWidth /= 2;
                sourceHeight /= 2;
            }
            vertSquashRatio = loadImage.detectVerticalSquash(img, subsampled);
            if (subsampled || vertSquashRatio !== 1) {
                sourceY *= vertSquashRatio;
                destWidth = Math.ceil(tileSize * destWidth / sourceWidth);
                destHeight = Math.ceil(
                    tileSize * destHeight / sourceHeight / vertSquashRatio
                );
                destY = 0;
                tileY = 0;
                while (tileY < sourceHeight) {
                    destX = 0;
                    tileX = 0;
                    while (tileX < sourceWidth) {
                        tmpContext.clearRect(0, 0, tileSize, tileSize);
                        tmpContext.drawImage(
                            img,
                            sourceX,
                            sourceY,
                            sourceWidth,
                            sourceHeight, -tileX, -tileY,
                            sourceWidth,
                            sourceHeight
                        );
                        context.drawImage(
                            tmpCanvas,
                            0,
                            0,
                            tileSize,
                            tileSize,
                            destX,
                            destY,
                            destWidth,
                            destHeight
                        );
                        tileX += tileSize;
                        destX += destWidth;
                    }
                    tileY += tileSize;
                    destY += destHeight;
                }
                context.restore();
                return canvas;
            }
        }
        return originalRenderMethod(
            canvas,
            img,
            sourceX,
            sourceY,
            sourceWidth,
            sourceHeight,
            destX,
            destY,
            destWidth,
            destHeight
        );
    };

}));

/*
 * JavaScript Load Image Exif Parser 1.0.0
 * https://github.com/blueimp/JavaScript-Load-Image
 *
 * Copyright 2013, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */

/*jslint unparam: true */
/*global define, window, console */

(function(factory) {

    if (typeof define === 'function' && define.amd) {
        // Register as an anonymous AMD module:
        define('vendor/load-image/load-image-exif', ['./load-image', './load-image-meta'], factory);
    } else {
        // Browser globals:
        factory(window.loadImage);
    }
}(function(loadImage) {


    loadImage.ExifMap = function() {
        return this;
    };

    loadImage.ExifMap.prototype.map = {
        'Orientation': 0x0112
    };

    loadImage.ExifMap.prototype.get = function(id) {
        return this[id] || this[this.map[id]];
    };

    loadImage.getExifThumbnail = function(dataView, offset, length) {
        var hexData,
            i,
            b;
        if (!length || offset + length > dataView.byteLength) {
            console.log('Invalid Exif data: Invalid thumbnail data.');
            return;
        }
        hexData = [];
        for (i = 0; i < length; i += 1) {
            b = dataView.getUint8(offset + i);
            hexData.push((b < 16 ? '0' : '') + b.toString(16));
        }
        return 'data:image/jpeg,%' + hexData.join('%');
    };

    loadImage.exifTagTypes = {
        // byte, 8-bit unsigned int:
        1: {
            getValue: function(dataView, dataOffset) {
                return dataView.getUint8(dataOffset);
            },
            size: 1
        },
        // ascii, 8-bit byte:
        2: {
            getValue: function(dataView, dataOffset) {
                return String.fromCharCode(dataView.getUint8(dataOffset));
            },
            size: 1,
            ascii: true
        },
        // short, 16 bit int:
        3: {
            getValue: function(dataView, dataOffset, littleEndian) {
                return dataView.getUint16(dataOffset, littleEndian);
            },
            size: 2
        },
        // long, 32 bit int:
        4: {
            getValue: function(dataView, dataOffset, littleEndian) {
                return dataView.getUint32(dataOffset, littleEndian);
            },
            size: 4
        },
        // rational = two long values, first is numerator, second is denominator:
        5: {
            getValue: function(dataView, dataOffset, littleEndian) {
                return dataView.getUint32(dataOffset, littleEndian) /
                    dataView.getUint32(dataOffset + 4, littleEndian);
            },
            size: 8
        },
        // slong, 32 bit signed int:
        9: {
            getValue: function(dataView, dataOffset, littleEndian) {
                return dataView.getInt32(dataOffset, littleEndian);
            },
            size: 4
        },
        // srational, two slongs, first is numerator, second is denominator:
        10: {
            getValue: function(dataView, dataOffset, littleEndian) {
                return dataView.getInt32(dataOffset, littleEndian) /
                    dataView.getInt32(dataOffset + 4, littleEndian);
            },
            size: 8
        }
    };
    // undefined, 8-bit byte, value depending on field:
    loadImage.exifTagTypes[7] = loadImage.exifTagTypes[1];

    loadImage.getExifValue = function(dataView, tiffOffset, offset, type, length, littleEndian) {
        var tagType = loadImage.exifTagTypes[type],
            tagSize,
            dataOffset,
            values,
            i,
            str,
            c;
        if (!tagType) {
            console.log('Invalid Exif data: Invalid tag type.');
            return;
        }
        tagSize = tagType.size * length;
        // Determine if the value is contained in the dataOffset bytes,
        // or if the value at the dataOffset is a pointer to the actual data:
        dataOffset = tagSize > 4 ?
            tiffOffset + dataView.getUint32(offset + 8, littleEndian) : (offset + 8);
        if (dataOffset + tagSize > dataView.byteLength) {
            console.log('Invalid Exif data: Invalid data offset.');
            return;
        }
        if (length === 1) {
            return tagType.getValue(dataView, dataOffset, littleEndian);
        }
        values = [];
        for (i = 0; i < length; i += 1) {
            values[i] = tagType.getValue(dataView, dataOffset + i * tagType.size, littleEndian);
        }
        if (tagType.ascii) {
            str = '';
            // Concatenate the chars:
            for (i = 0; i < values.length; i += 1) {
                c = values[i];
                // Ignore the terminating NULL byte(s):
                if (c === '\u0000') {
                    break;
                }
                str += c;
            }
            return str;
        }
        return values;
    };

    loadImage.parseExifTag = function(dataView, tiffOffset, offset, littleEndian, data) {
        var tag = dataView.getUint16(offset, littleEndian);
        data.exif[tag] = loadImage.getExifValue(
            dataView,
            tiffOffset,
            offset,
            dataView.getUint16(offset + 2, littleEndian), // tag type
            dataView.getUint32(offset + 4, littleEndian), // tag length
            littleEndian
        );
    };

    loadImage.parseExifTags = function(dataView, tiffOffset, dirOffset, littleEndian, data) {
        var tagsNumber,
            dirEndOffset,
            i;
        if (dirOffset + 6 > dataView.byteLength) {
            console.log('Invalid Exif data: Invalid directory offset.');
            return;
        }
        tagsNumber = dataView.getUint16(dirOffset, littleEndian);
        dirEndOffset = dirOffset + 2 + 12 * tagsNumber;
        if (dirEndOffset + 4 > dataView.byteLength) {
            console.log('Invalid Exif data: Invalid directory size.');
            return;
        }
        for (i = 0; i < tagsNumber; i += 1) {
            this.parseExifTag(
                dataView,
                tiffOffset,
                dirOffset + 2 + 12 * i, // tag offset
                littleEndian,
                data
            );
        }
        // Return the offset to the next directory:
        return dataView.getUint32(dirEndOffset, littleEndian);
    };

    loadImage.parseExifData = function(dataView, offset, length, data, options) {
        if (options.disableExif) {
            return;
        }
        var tiffOffset = offset + 10,
            littleEndian,
            dirOffset,
            thumbnailData;
        // Check for the ASCII code for "Exif" (0x45786966):
        if (dataView.getUint32(offset + 4) !== 0x45786966) {
            // No Exif data, might be XMP data instead
            return;
        }
        if (tiffOffset + 8 > dataView.byteLength) {
            console.log('Invalid Exif data: Invalid segment size.');
            return;
        }
        // Check for the two null bytes:
        if (dataView.getUint16(offset + 8) !== 0x0000) {
            console.log('Invalid Exif data: Missing byte alignment offset.');
            return;
        }
        // Check the byte alignment:
        switch (dataView.getUint16(tiffOffset)) {
            case 0x4949:
                littleEndian = true;
                break;
            case 0x4D4D:
                littleEndian = false;
                break;
            default:
                console.log('Invalid Exif data: Invalid byte alignment marker.');
                return;
        }
        // Check for the TIFF tag marker (0x002A):
        if (dataView.getUint16(tiffOffset + 2, littleEndian) !== 0x002A) {
            console.log('Invalid Exif data: Missing TIFF marker.');
            return;
        }
        // Retrieve the directory offset bytes, usually 0x00000008 or 8 decimal:
        dirOffset = dataView.getUint32(tiffOffset + 4, littleEndian);
        // Create the exif object to store the tags:
        data.exif = new loadImage.ExifMap();
        // Parse the tags of the main image directory and retrieve the
        // offset to the next directory, usually the thumbnail directory:
        dirOffset = loadImage.parseExifTags(
            dataView,
            tiffOffset,
            tiffOffset + dirOffset,
            littleEndian,
            data
        );
        if (dirOffset && !options.disableExifThumbnail) {
            thumbnailData = { exif: {} };
            dirOffset = loadImage.parseExifTags(
                dataView,
                tiffOffset,
                tiffOffset + dirOffset,
                littleEndian,
                thumbnailData
            );
            // Check for JPEG Thumbnail offset:
            if (thumbnailData.exif[0x0201]) {
                data.exif.Thumbnail = loadImage.getExifThumbnail(
                    dataView,
                    tiffOffset + thumbnailData.exif[0x0201],
                    thumbnailData.exif[0x0202] // Thumbnail data length
                );
            }
        }
        // Check for Exif Sub IFD Pointer:
        if (data.exif[0x8769] && !options.disableExifSub) {
            loadImage.parseExifTags(
                dataView,
                tiffOffset,
                tiffOffset + data.exif[0x8769], // directory offset
                littleEndian,
                data
            );
        }
        // Check for GPS Info IFD Pointer:
        if (data.exif[0x8825] && !options.disableExifGps) {
            loadImage.parseExifTags(
                dataView,
                tiffOffset,
                tiffOffset + data.exif[0x8825], // directory offset
                littleEndian,
                data
            );
        }
    };

    // Registers the Exif parser for the APP1 JPEG meta data segment:
    loadImage.metaDataParsers.jpeg[0xffe1].push(loadImage.parseExifData);

    // Adds the following properties to the parseMetaData callback data:
    // * exif: The exif tags, parsed by the parseExifData method

    // Adds the following options to the parseMetaData method:
    // * disableExif: Disables Exif parsing.
    // * disableExifThumbnail: Disables parsing of the Exif Thumbnail.
    // * disableExifSub: Disables parsing of the Exif Sub IFD.
    // * disableExifGps: Disables parsing of the Exif GPS Info IFD.

}));

/*
 * JavaScript Load Image Exif Map 1.0.2
 * https://github.com/blueimp/JavaScript-Load-Image
 *
 * Copyright 2013, Sebastian Tschan
 * https://blueimp.net
 *
 * Exif tags mapping based on
 * https://github.com/jseidelin/exif-js
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */

/*global define, window */

(function(factory) {

    if (typeof define === 'function' && define.amd) {
        // Register as an anonymous AMD module:
        define('vendor/load-image/load-image-exif-map', ['./load-image', './load-image-exif'], factory);
    } else {
        // Browser globals:
        factory(window.loadImage);
    }
}(function(loadImage) {


    loadImage.ExifMap.prototype.tags = {
        // =================
        // TIFF tags (IFD0):
        // =================
        0x0100: 'ImageWidth',
        0x0101: 'ImageHeight',
        0x8769: 'ExifIFDPointer',
        0x8825: 'GPSInfoIFDPointer',
        0xA005: 'InteroperabilityIFDPointer',
        0x0102: 'BitsPerSample',
        0x0103: 'Compression',
        0x0106: 'PhotometricInterpretation',
        0x0112: 'Orientation',
        0x0115: 'SamplesPerPixel',
        0x011C: 'PlanarConfiguration',
        0x0212: 'YCbCrSubSampling',
        0x0213: 'YCbCrPositioning',
        0x011A: 'XResolution',
        0x011B: 'YResolution',
        0x0128: 'ResolutionUnit',
        0x0111: 'StripOffsets',
        0x0116: 'RowsPerStrip',
        0x0117: 'StripByteCounts',
        0x0201: 'JPEGInterchangeFormat',
        0x0202: 'JPEGInterchangeFormatLength',
        0x012D: 'TransferFunction',
        0x013E: 'WhitePoint',
        0x013F: 'PrimaryChromaticities',
        0x0211: 'YCbCrCoefficients',
        0x0214: 'ReferenceBlackWhite',
        0x0132: 'DateTime',
        0x010E: 'ImageDescription',
        0x010F: 'Make',
        0x0110: 'Model',
        0x0131: 'Software',
        0x013B: 'Artist',
        0x8298: 'Copyright',
        // ==================
        // Exif Sub IFD tags:
        // ==================
        0x9000: 'ExifVersion', // EXIF version
        0xA000: 'FlashpixVersion', // Flashpix format version
        0xA001: 'ColorSpace', // Color space information tag
        0xA002: 'PixelXDimension', // Valid width of meaningful image
        0xA003: 'PixelYDimension', // Valid height of meaningful image
        0xA500: 'Gamma',
        0x9101: 'ComponentsConfiguration', // Information about channels
        0x9102: 'CompressedBitsPerPixel', // Compressed bits per pixel
        0x927C: 'MakerNote', // Any desired information written by the manufacturer
        0x9286: 'UserComment', // Comments by user
        0xA004: 'RelatedSoundFile', // Name of related sound file
        0x9003: 'DateTimeOriginal', // Date and time when the original image was generated
        0x9004: 'DateTimeDigitized', // Date and time when the image was stored digitally
        0x9290: 'SubSecTime', // Fractions of seconds for DateTime
        0x9291: 'SubSecTimeOriginal', // Fractions of seconds for DateTimeOriginal
        0x9292: 'SubSecTimeDigitized', // Fractions of seconds for DateTimeDigitized
        0x829A: 'ExposureTime', // Exposure time (in seconds)
        0x829D: 'FNumber',
        0x8822: 'ExposureProgram', // Exposure program
        0x8824: 'SpectralSensitivity', // Spectral sensitivity
        0x8827: 'PhotographicSensitivity', // EXIF 2.3, ISOSpeedRatings in EXIF 2.2
        0x8828: 'OECF', // Optoelectric conversion factor
        0x8830: 'SensitivityType',
        0x8831: 'StandardOutputSensitivity',
        0x8832: 'RecommendedExposureIndex',
        0x8833: 'ISOSpeed',
        0x8834: 'ISOSpeedLatitudeyyy',
        0x8835: 'ISOSpeedLatitudezzz',
        0x9201: 'ShutterSpeedValue', // Shutter speed
        0x9202: 'ApertureValue', // Lens aperture
        0x9203: 'BrightnessValue', // Value of brightness
        0x9204: 'ExposureBias', // Exposure bias
        0x9205: 'MaxApertureValue', // Smallest F number of lens
        0x9206: 'SubjectDistance', // Distance to subject in meters
        0x9207: 'MeteringMode', // Metering mode
        0x9208: 'LightSource', // Kind of light source
        0x9209: 'Flash', // Flash status
        0x9214: 'SubjectArea', // Location and area of main subject
        0x920A: 'FocalLength', // Focal length of the lens in mm
        0xA20B: 'FlashEnergy', // Strobe energy in BCPS
        0xA20C: 'SpatialFrequencyResponse',
        0xA20E: 'FocalPlaneXResolution', // Number of pixels in width direction per FPRUnit
        0xA20F: 'FocalPlaneYResolution', // Number of pixels in height direction per FPRUnit
        0xA210: 'FocalPlaneResolutionUnit', // Unit for measuring the focal plane resolution
        0xA214: 'SubjectLocation', // Location of subject in image
        0xA215: 'ExposureIndex', // Exposure index selected on camera
        0xA217: 'SensingMethod', // Image sensor type
        0xA300: 'FileSource', // Image source (3 == DSC)
        0xA301: 'SceneType', // Scene type (1 == directly photographed)
        0xA302: 'CFAPattern', // Color filter array geometric pattern
        0xA401: 'CustomRendered', // Special processing
        0xA402: 'ExposureMode', // Exposure mode
        0xA403: 'WhiteBalance', // 1 = auto white balance, 2 = manual
        0xA404: 'DigitalZoomRatio', // Digital zoom ratio
        0xA405: 'FocalLengthIn35mmFilm',
        0xA406: 'SceneCaptureType', // Type of scene
        0xA407: 'GainControl', // Degree of overall image gain adjustment
        0xA408: 'Contrast', // Direction of contrast processing applied by camera
        0xA409: 'Saturation', // Direction of saturation processing applied by camera
        0xA40A: 'Sharpness', // Direction of sharpness processing applied by camera
        0xA40B: 'DeviceSettingDescription',
        0xA40C: 'SubjectDistanceRange', // Distance to subject
        0xA420: 'ImageUniqueID', // Identifier assigned uniquely to each image
        0xA430: 'CameraOwnerName',
        0xA431: 'BodySerialNumber',
        0xA432: 'LensSpecification',
        0xA433: 'LensMake',
        0xA434: 'LensModel',
        0xA435: 'LensSerialNumber',
        // ==============
        // GPS Info tags:
        // ==============
        0x0000: 'GPSVersionID',
        0x0001: 'GPSLatitudeRef',
        0x0002: 'GPSLatitude',
        0x0003: 'GPSLongitudeRef',
        0x0004: 'GPSLongitude',
        0x0005: 'GPSAltitudeRef',
        0x0006: 'GPSAltitude',
        0x0007: 'GPSTimeStamp',
        0x0008: 'GPSSatellites',
        0x0009: 'GPSStatus',
        0x000A: 'GPSMeasureMode',
        0x000B: 'GPSDOP',
        0x000C: 'GPSSpeedRef',
        0x000D: 'GPSSpeed',
        0x000E: 'GPSTrackRef',
        0x000F: 'GPSTrack',
        0x0010: 'GPSImgDirectionRef',
        0x0011: 'GPSImgDirection',
        0x0012: 'GPSMapDatum',
        0x0013: 'GPSDestLatitudeRef',
        0x0014: 'GPSDestLatitude',
        0x0015: 'GPSDestLongitudeRef',
        0x0016: 'GPSDestLongitude',
        0x0017: 'GPSDestBearingRef',
        0x0018: 'GPSDestBearing',
        0x0019: 'GPSDestDistanceRef',
        0x001A: 'GPSDestDistance',
        0x001B: 'GPSProcessingMethod',
        0x001C: 'GPSAreaInformation',
        0x001D: 'GPSDateStamp',
        0x001E: 'GPSDifferential',
        0x001F: 'GPSHPositioningError'
    };

    loadImage.ExifMap.prototype.stringValues = {
        ExposureProgram: {
            0: 'Undefined',
            1: 'Manual',
            2: 'Normal program',
            3: 'Aperture priority',
            4: 'Shutter priority',
            5: 'Creative program',
            6: 'Action program',
            7: 'Portrait mode',
            8: 'Landscape mode'
        },
        MeteringMode: {
            0: 'Unknown',
            1: 'Average',
            2: 'CenterWeightedAverage',
            3: 'Spot',
            4: 'MultiSpot',
            5: 'Pattern',
            6: 'Partial',
            255: 'Other'
        },
        LightSource: {
            0: 'Unknown',
            1: 'Daylight',
            2: 'Fluorescent',
            3: 'Tungsten (incandescent light)',
            4: 'Flash',
            9: 'Fine weather',
            10: 'Cloudy weather',
            11: 'Shade',
            12: 'Daylight fluorescent (D 5700 - 7100K)',
            13: 'Day white fluorescent (N 4600 - 5400K)',
            14: 'Cool white fluorescent (W 3900 - 4500K)',
            15: 'White fluorescent (WW 3200 - 3700K)',
            17: 'Standard light A',
            18: 'Standard light B',
            19: 'Standard light C',
            20: 'D55',
            21: 'D65',
            22: 'D75',
            23: 'D50',
            24: 'ISO studio tungsten',
            255: 'Other'
        },
        Flash: {
            0x0000: 'Flash did not fire',
            0x0001: 'Flash fired',
            0x0005: 'Strobe return light not detected',
            0x0007: 'Strobe return light detected',
            0x0009: 'Flash fired, compulsory flash mode',
            0x000D: 'Flash fired, compulsory flash mode, return light not detected',
            0x000F: 'Flash fired, compulsory flash mode, return light detected',
            0x0010: 'Flash did not fire, compulsory flash mode',
            0x0018: 'Flash did not fire, auto mode',
            0x0019: 'Flash fired, auto mode',
            0x001D: 'Flash fired, auto mode, return light not detected',
            0x001F: 'Flash fired, auto mode, return light detected',
            0x0020: 'No flash function',
            0x0041: 'Flash fired, red-eye reduction mode',
            0x0045: 'Flash fired, red-eye reduction mode, return light not detected',
            0x0047: 'Flash fired, red-eye reduction mode, return light detected',
            0x0049: 'Flash fired, compulsory flash mode, red-eye reduction mode',
            0x004D: 'Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected',
            0x004F: 'Flash fired, compulsory flash mode, red-eye reduction mode, return light detected',
            0x0059: 'Flash fired, auto mode, red-eye reduction mode',
            0x005D: 'Flash fired, auto mode, return light not detected, red-eye reduction mode',
            0x005F: 'Flash fired, auto mode, return light detected, red-eye reduction mode'
        },
        SensingMethod: {
            1: 'Undefined',
            2: 'One-chip color area sensor',
            3: 'Two-chip color area sensor',
            4: 'Three-chip color area sensor',
            5: 'Color sequential area sensor',
            7: 'Trilinear sensor',
            8: 'Color sequential linear sensor'
        },
        SceneCaptureType: {
            0: 'Standard',
            1: 'Landscape',
            2: 'Portrait',
            3: 'Night scene'
        },
        SceneType: {
            1: 'Directly photographed'
        },
        CustomRendered: {
            0: 'Normal process',
            1: 'Custom process'
        },
        WhiteBalance: {
            0: 'Auto white balance',
            1: 'Manual white balance'
        },
        GainControl: {
            0: 'None',
            1: 'Low gain up',
            2: 'High gain up',
            3: 'Low gain down',
            4: 'High gain down'
        },
        Contrast: {
            0: 'Normal',
            1: 'Soft',
            2: 'Hard'
        },
        Saturation: {
            0: 'Normal',
            1: 'Low saturation',
            2: 'High saturation'
        },
        Sharpness: {
            0: 'Normal',
            1: 'Soft',
            2: 'Hard'
        },
        SubjectDistanceRange: {
            0: 'Unknown',
            1: 'Macro',
            2: 'Close view',
            3: 'Distant view'
        },
        FileSource: {
            3: 'DSC'
        },
        ComponentsConfiguration: {
            0: '',
            1: 'Y',
            2: 'Cb',
            3: 'Cr',
            4: 'R',
            5: 'G',
            6: 'B'
        },
        Orientation: {
            1: 'top-left',
            2: 'top-right',
            3: 'bottom-right',
            4: 'bottom-left',
            5: 'left-top',
            6: 'right-top',
            7: 'right-bottom',
            8: 'left-bottom'
        }
    };

    loadImage.ExifMap.prototype.getText = function(id) {
        var value = this.get(id);
        switch (id) {
            case 'LightSource':
            case 'Flash':
            case 'MeteringMode':
            case 'ExposureProgram':
            case 'SensingMethod':
            case 'SceneCaptureType':
            case 'SceneType':
            case 'CustomRendered':
            case 'WhiteBalance':
            case 'GainControl':
            case 'Contrast':
            case 'Saturation':
            case 'Sharpness':
            case 'SubjectDistanceRange':
            case 'FileSource':
            case 'Orientation':
                return this.stringValues[id][value];
            case 'ExifVersion':
            case 'FlashpixVersion':
                return String.fromCharCode(value[0], value[1], value[2], value[3]);
            case 'ComponentsConfiguration':
                return this.stringValues[id][value[0]] +
                    this.stringValues[id][value[1]] +
                    this.stringValues[id][value[2]] +
                    this.stringValues[id][value[3]];
            case 'GPSVersionID':
                return value[0] + '.' + value[1] + '.' + value[2] + '.' + value[3];
        }
        return String(value);
    };

    (function(exifMapPrototype) {
        var tags = exifMapPrototype.tags,
            map = exifMapPrototype.map,
            prop;

        // Map the tag names to tags:
        for (prop in tags) {
            if (tags.hasOwnProperty(prop)) {
                map[tags[prop]] = prop;
            }
        }
    }(loadImage.ExifMap.prototype));

    loadImage.ExifMap.prototype.getAll = function() {
        var map = {},
            prop,
            id;
        for (prop in this) {
            if (this.hasOwnProperty(prop)) {
                id = this.tags[prop];
                if (id) {
                    map[id] = this.getText(id);
                }
            }
        }
        return map;
    };

}));

define('loadImage', ['require', 'vendor/load-image/load-image-orientation', 'vendor/load-image/load-image-meta', 'vendor/load-image/load-image-ios', 'vendor/load-image/load-image-exif', 'vendor/load-image/load-image-exif-map', 'vendor/load-image/load-image'], function(require) {
    require('vendor/load-image/load-image-orientation');
    require('vendor/load-image/load-image-meta');
    require('vendor/load-image/load-image-ios');
    require('vendor/load-image/load-image-exif');
    require('vendor/load-image/load-image-exif-map');
    var loadImage = require('vendor/load-image/load-image');

    return loadImage;
});
define('expressions/add_expression', ['require', 'loadcss!css/add_expression', 'jquery', 'pjs', 'main/popover_view', 'graphing/label', 'template!add_expression', './expression', './table', './text', './folder', './image', 'browser', 'i18n', 'loadImage', 'conditional_blur'], function(require) {
    require('loadcss!css/add_expression');

    var $ = require('jquery');
    var P = require('pjs');
    var PopoverView = require('main/popover_view');
    var Label = require('graphing/label');
    var template = require('template!add_expression');
    var ExpressionObject = require('./expression');
    var TableObject = require('./table');
    var TextObject = require('./text');
    var FolderObject = require('./folder');
    var ImageObject = require('./image');
    var Browser = require('browser');
    var i18n = require('i18n');
    var LoadImage = require('loadImage');
    var conditionalBlur = require('conditional_blur');

    var UPLOAD_SUPPORTED = !!window.FileReader;
    var isShittyIos8 = (
        Browser.IS_IPAD &&
        Browser.IOS_VERSION &&
        Browser.IOS_VERSION[0] === 8 &&
        Browser.IOS_VERSION[1] === 0 &&
        Browser.IOS_VERSION[2] === 0
    );
    var AddExpressionView = P(PopoverView, function(view, _super) {

        view.template = template;
        view.direction = 'bottom';

        view.init = function(listView, $root, graphSettings, toastView) {
            _super.init.call(this);

            this.$root = $root;
            this.listView = listView;
            this.list = listView.model;
            this.graphSettings = graphSettings;
            this.toastView = toastView;

        };

        view.getTemplateParams = function() {
            var params = _super.getTemplateParams();

            params.expressions = true;
            params.texts = true;
            params.tables = true;
            params.folders = this.graphSettings.config.folders;
            params.images = this.graphSettings.config.images;

            return params;
        };

        view.didCreateElement = function() {
            _super.didCreateElement.call(this);

            if (Browser.IS_IPAD && Browser.IS_IN_IFRAME) {
                // prevents mobile safari from getting into a bad
                // state where the next tap on the screen defocuses
                // whatever is selected.
                // see #3106
                this.$().on('tapstart', function(evt) {
                    evt.preventDefault();
                });
            }

            this.$('.dcg-action-newexpression').on('tap', this.newExpression.bind(this));
            this.$('.dcg-action-newtext').on('tap', this.newText.bind(this));
            this.$('.dcg-action-newfolder').on('tap', this.newFolder.bind(this));
            this.$('.dcg-action-newtable').on('tap', this.newTableFromTap.bind(this));
            this.$('.dcg-action-newimage').on('tap', this.selectImage.bind(this));

            if (UPLOAD_SUPPORTED && !isShittyIos8) {
                this.initFilePicker();
            }

            // prevent dropping file from changing url. Also enables the drop event.
            $(document).on('dragstart drag dragend dragenter dragover dragleave drop', function(evt) {
                evt.preventDefault();
                evt.stopPropagation();
            });

            var $root = this.$root;

            var collection = $();

            function removeFileDraggedClass() {
                $root.removeClass('dcg-filedraggedover');
                collection = $();
                $root.off('.filedraggedover');
            }

            $root.on('dragenter', function(evt) {
                if (collection.size() === 0) {
                    $root.addClass('dcg-filedraggedover');
                    $root.on('tapstart.filedraggedover', removeFileDraggedClass);
                }
                collection = collection.add(evt.target);
            }).on('dragleave', function(evt) {
                collection = collection.not(evt.target);
                if (collection.size() === 0) {
                    removeFileDraggedClass();
                }
            }).on('drop', removeFileDraggedClass);

            var self = this;
            this.listView.$().on('drop', function(evt) {
                var files = evt.originalEvent.dataTransfer && evt.originalEvent.dataTransfer.files;
                if (files) {
                    for (var i = 0; i < files.length; i++) {
                        self.insertFile(files[i]);
                    }
                }
            });
        };

        view.insertFile = function(file) {
            if (!file) {
                alert(i18n.t('You did not select a file'));
                return;
            }

            if (!file.type.match('image/*')) {
                alert(i18n.t('The file "__file__" is not an image', { file: file.name }));
                return;
            }

            var imageObject = ImageObject({
                originalFilename: file.name,
                name: file.name,
                image_url: null,
                visible: true,
                selected: true,
                width: '0',
                height: '0',
                x: '0',
                y: '0',
                opacity: 1,
                isUploading: true
            }, this.list);

            this.newImage(imageObject);

            LoadImage.parseMetaData(file, function(data) {

                var orientation;
                if (data.exif) {
                    orientation = data.exif.get('Orientation');
                }

                var loadImageOptions = {
                    orientation: orientation,
                    canvas: true,
                    maxWidth: 2000,
                    maxHeight: 2000
                };

                LoadImage(file, function(canvas) {
                    var width = canvas.width;
                    var height = canvas.height;
                    var ratio = Math.max(width, height) / Math.min(width, height);
                    var maxFileSize = 50000;

                    if (width < height) {
                        height = 10;
                        width = Math.round(10 * height / ratio) / 10;
                    } else {
                        width = 10;
                        height = Math.round(10 * width / ratio) / 10;
                    }

                    // if it's a jpeg, kick in a little compression from the start. Prevents 1MB images from growing to 7MB
                    // simply because of a difference in compression algorithms.
                    var compressedDataURL;
                    if (file.type === 'image/jpeg') {
                        compressedDataURL = canvas.toDataURL('image/jpeg', 0.99);
                    } else {
                        compressedDataURL = canvas.toDataURL();
                    }

                    // if the file is too big, we scale the image down in width and height to scale the file size.
                    // simply dropping the resolution of the image should do a pretty good job of dropping our
                    // image size down. we allow three rounds of compression to hone in on a file that's just under
                    // the maxFileSize.  The first attempt usually gets us within 2*maxFileSize. The second attempt
                    // usually gets us to within 1.1*maxFileSize. I haven't found an image that the third attempt
                    // doesn't get us right under the maxFileSize.
                    var compressionAttempts = 0;
                    var fileSize = compressedDataURL.length;

                    while (compressionAttempts < 3 && fileSize > maxFileSize) {
                        var scaleFactor = Math.sqrt(maxFileSize / fileSize);
                        var scaledWidth = Math.round(scaleFactor * canvas.width);
                        var scaledHeight = Math.round(scaleFactor * canvas.height);

                        var scaledCanvas = $('<canvas width="' + scaledWidth + '" height="' + scaledHeight + '" ></canvas>')[0];
                        var ctx = scaledCanvas.getContext('2d');
                        ctx.drawImage(canvas, 0, 0, scaledWidth, scaledHeight);

                        if (file.type === 'image/jpeg') {
                            compressedDataURL = scaledCanvas.toDataURL('image/jpeg', 0.99);
                        } else {
                            compressedDataURL = scaledCanvas.toDataURL();
                        }

                        fileSize = compressedDataURL.length;
                        canvas = scaledCanvas;
                        scaledCanvas = null;
                        compressionAttempts++;
                    }


                    // finalize image data
                    imageObject.setProperty('width', width.toString());
                    imageObject.setProperty('height', height.toString());
                    imageObject.setProperty('image_url', compressedDataURL);
                    imageObject.setProperty('isUploading', false);

                }, loadImageOptions);
            }, {
                maxMetaDataSize: 262144,
                disableImageHead: false
            });
        };

        view.renderIsVisible = function() {
            if (this.isVisible) {
                if (this.direction === 'bottom' && this.listView.calcIsNarrow) {
                    this.direction = 'right';
                    this.$().addClass('dcg-right').removeClass('dcg-bottom');
                } else if (this.direction !== 'bottom' && !this.listView.calcIsNarrow) {
                    this.direction = 'bottom';
                    this.$().addClass('dcg-bottom').removeClass('dcg-right');
                }
            }
            _super.renderIsVisible.call(this);
        };

        view.initFilePicker = function() {
            var self = this;

            // create the filepicker
            this.$filepicker = this.$('input[type=file]');

            this.$filepicker.on('change', function(evt) {
                self.setProperty('isVisible', false);
                self.insertFile(evt.target.files[0]);
                self.$filepicker.val(''); // clear out selected file so we can reselect the file
            });
        };

        view.newExpression = function() {
            var ex = ExpressionObject({ selected: true, latex: '' }, this.list);
            this.insertItem(ex);
            return ex;
        };

        view.newText = function() {
            var tx = TextObject({ selected: true, text: '' }, this.list);
            this.insertItem(tx);
            return tx;
        };

        view.newFolder = function() {
            var fld = FolderObject({ selected: true }, this.list);
            this.insertItem(fld);
            return fld;
        };

        //filter through so that we're not mixing data & jQuery events
        view.newTableFromTap = function(e) {
            this.newTable();
        };

        view.newTable = function(data) {
            var properties = { selected: !data, latex: '' };

            // Choose an unused subscript for table entries
            var subscripts = [];
            this.list.eachLatex(function(latex) {
                var subscriptRe = new RegExp(/_(\d)|_\{(?:\s|\\space)(\d+)(?:\s|\\space)\}/g);
                while (true) {
                    var match = subscriptRe.exec(latex);
                    if (!match) break;
                    subscripts.push(parseInt(match[1], 10));
                }
            });
            subscripts.sort(function(a, b) { return a - b; });

            var subscript = 1;
            for (var i = 0; i < subscripts.length; i++) {
                if (subscripts[i] === subscript) subscript++;
            }

            //TODO: support pasting in tables with more than 2 columns? It's supported by parse_data
            //what should we choose for headers?
            properties.columns = [{
                    latex: Label.identifierToLatex('x_' + subscript),
                    values: (data ? data[0] : [1, 2, 3, 4, 5])
                },
                {
                    latex: Label.identifierToLatex('y_' + subscript),
                    values: (data ? data[1] : ['', '', '', '', ''])
                }
            ];

            // create a new expression and populate it
            var obj = TableObject(properties, this.list);
            this.insertItem(obj);
            if (!data) {
                this.listView.getSelectedView().addFocus('cell', 1, 1);
            }
            return obj;
        };

        view.selectImage = function() {
            conditionalBlur();

            if (isShittyIos8) {
                this.toastView.show(
                    "iOS 8.0 has temporarily broken image upload. So sorry!", { hideAfter: 10000 }
                );
                this.$('.dcg-action-newimage').addClass('dcg-disabled');
            } else if (UPLOAD_SUPPORTED) {
                this.$filepicker[0].click();
            } else {
                this.toastView.show(
                    i18n.t("Image upload is not supported in this browser."), { hideAfter: 10000 }
                );
                this.$('.dcg-action-newimage').addClass('dcg-disabled');
            }
        };

        view.newImage = function(imageObject) {
            var self = this;
            var list = this.list;

            list.undoRedo.oneTransaction(function() {
                self.insertItem(imageObject);
            });
        };

        //rules for insertItem (the + button at the top)
        //
        // overarching:
        //  (1) pressing that button should always have a visible result (i.e. never a no-op)
        //  (2) a folder can never be inserted inside of another folder
        //  (3) if an item's is a blank expression convert instead of creating a new one (unless that violates #1 or #2)
        //      (unless that violates 1 or 2)
        //  (4) insert below current expression where that's possible (below the folder where necessary)
        //  (5) insert at the highest visible point that's not in a folder

        view.insertItem = function(obj) {
            /* jshint maxcomplexity:15 */

            // close the popover
            this.setProperty('isVisible', false);

            //collect up some useful globals
            var list = this.list;
            var item = list.getSelected();

            //case 1: current empty expression needs to be replaced and is outside a folder
            //  only applies if:
            //  item.isExpression and item is empty
            //  obj is not an expression

            if (item && item.isExpression && !item.latex && !item.folder && !obj.isExpression) {

                list.undoRedo.oneTransaction(function() {
                    list.insertItemAt(item.index + 1, obj);
                    list.removeItemAt(item.index);
                });

                if (obj.selected) this.listView.getSelectedView().addFocus();
                return;
            }

            //case 2: current empty expression needs to be replaced and is inside a folder
            // only applies if:
            // item.isExpression and item is empty
            // obj is not an expression, obj is not a folder

            if (item && item.isExpression && !item.latex && item.folder && !obj.isExpression && !obj.isFolder) {
                list.undoRedo.oneTransaction(function() {
                    list.insertItemAt(item.index + 1, obj);
                    item.folder.addItem(obj);
                    list.removeItemAt(item.index);
                });
                if (obj.selected) this.listView.getSelectedView().addFocus();
                return;
            }

            //case 3: current is outside of a folder: insert right below where we are,
            // no funny business
            if (item && !item.folder && !item.isFolder) {
                this.list.insertItemAt(item.index + 1, obj);
                if (obj.selected) this.listView.getSelectedView().addFocus();
                return;
            }

            //case 4: current item is inside a folder, and we're not inserting a new folder
            // insert right below us, but inside of the folder
            if (item && item.folder && !obj.isFolder) {

                list.undoRedo.oneTransaction(function() {
                    list.insertItemAt(item.index + 1, obj);
                    item.folder.addItem(obj);
                });
                if (obj.selected) this.listView.getSelectedView().addFocus();
                return;
            }

            //case 5: insert into an existing folder
            if (item && item.isFolder && !item.collapsed && !obj.isFolder) {
                list.undoRedo.oneTransaction(function() {
                    list.insertItemAt(item.index + 1, obj);
                    item.addItem(obj);
                });
                if (obj.selected) this.listView.getSelectedView().addFocus();
                return;
            }

            //case 5: we need to seek downward from here and insert when we're ready.
            //this is either because nothing is selected, or because we're a folder
            //inside of a folder. in either case, seek downward until the first chance
            //that we have that's not inside of a folder.

            if (!item) item = this.listView.getFirstVisibleItem();
            // can't insert a folder right after the starting folder
            //(fixes problem if you try to insert a folder while in a folder)
            if (item.isFolder) item = this.list.getItemByIndex(item.index + 1);
            //after this, we search for the first non-foldered item, and insert right before it.
            while (item && item.folder) {
                item = this.list.getItemByIndex(item.index + 1);
            }

            var index = (item ? item.index : this.list.getItemCount());
            this.list.insertItemAt(index, obj);
            if (obj.selected) this.listView.getSelectedView().addFocus();
        };

    });

    return AddExpressionView;
});

define('scroll_helpers', ['require'], function(require) {
    //this ensures that innerEl is visible inside of outerEl by scrolling outerEl
    //padding is the space we want to enforce on either side, if available
    //
    //note: innerEl and outerEl are expected to be jQuery objects.
    var scrollVisible = function(innerEl, outerEl, padding) {
        var outerHeight = outerEl.height();
        var innerHeight = innerEl.height();

        var scrollTop = outerEl[0].scrollTop;
        //innerTop relative to the container (compensate for scroll and offset of container)
        var innerTop = innerEl.offset().top + scrollTop - outerEl.offset().top;

        // {padding}px from the top means innerTop - scrollTop = padding
        var maxScrollTop = innerTop - padding;
        // {padding}px from the bottom means outerHeight+scrollTop = innerHeight + innerTop + padding
        var minScrollTop = innerHeight + innerTop + padding - outerHeight;

        if (maxScrollTop >= minScrollTop) {
            //clamp value between the max and min scrollTop
            outerEl[0].scrollTop = Math.min(Math.max(scrollTop, minScrollTop), maxScrollTop);
        } else {
            //if we can't fit everything, just match padding on both sides by splitting the difference
            outerEl[0].scrollTop = 0.5 * (maxScrollTop + minScrollTop);
        }
    };

    return { scrollVisible: scrollVisible };
});

define('loadcss!css/new_expression', function() {});
define('template!new_expression', ['underscore'], function(_) {
    return function(obj) {
        var __p = '';
        var print = function() { __p += Array.prototype.join.call(arguments, '') };
        with(obj || {}) {
            __p += '<div class="dcg-expressionitem dcg-new-expression dcg-opened">\n  <div class=\'dcg-new-math-div dcg-do-not-blur dcg-action-newmath\'>\n    <div class=\'dcg-new-expression-fade\'></div>\n  </div>\n\n  <span\n     class="dcg-tab"\n  >\n     <span class=\'dcg-num dcg-variable-index\'>2</span>\n     <div class=\'dcg-tab-interior\'></div>\n  </span>\n\n</div>\n';
        }
        return __p;
    };
});
define('expressions/new_expression', ['require', 'loadcss!css/new_expression', 'pjs', 'underscore_view', 'template!new_expression', './expression'], function(require) {
    require('loadcss!css/new_expression');

    var P = require('pjs');
    var UnderscoreView = require('underscore_view');
    var template = require('template!new_expression');
    var ExpressionObject = require('./expression');

    var NewExpressionView = P(UnderscoreView, function(view, _super) {

        view.template = template;

        view.init = function(listView) {
            _super.init.call(this);
            this.observe('index', this.updateIndex.bind(this));
            this.listView = listView;
        };

        view.didInsertElement = function() {
            // update the index now and observe any changes
            this.updateIndex();

            this.$('.dcg-action-newmath').on('tap', this.newMath.bind(this));
        };

        view.updateIndex = function() {
            this.$('.dcg-variable-index').text(this.index);
        };

        view.newMath = function() {
            var constructor = ExpressionObject;
            var properties = { selected: true, latex: '' };
            var obj = constructor(properties, this.listView.model);
            this.listView.model.insertItemAt(this.listView.model.getItemCount(), obj);
            this.listView.getSelectedView().addFocus();
        };

    });

    return NewExpressionView;
});

define('expressions/abstract_icon', ['require', 'jquery', 'underscore_view', 'pjs', 'keys', 'i18n'], function(require) {
    var $ = require('jquery');
    var UnderscoreView = require('underscore_view');
    var P = require('pjs');
    var Keys = require('keys');
    var i18n = require('i18n');

    var icon_count = 0;

    var AbstractIconView = P(UnderscoreView, function(view, _super) {

        view.init = function(parentView) {
            this.parentView = parentView;
            this.model = parentView.model;

            _super.init.call(this);
            this.optionsmenu_guid = (++icon_count);

            // model.error is a message; this.error is boolean whether we care about
            // the error. One time we don't care is if the model is empty.
            this.model.observe('error.iconview', this.renderErrorTooltip.bind(this));
            this.observe('error', this.renderErrorTooltip.bind(this));

            this.observe('error errorStable', this.computeErrorShown.bind(this));
            this.observe('errorShown', this.renderErrorShown.bind(this));
        };

        view.destruct = function() {
            this.model.unobserve('.iconview');
        };

        view.computeErrorShown = function() {
            this.setProperty('errorShown', this.error && this.errorStable);
        };

        view.renderErrorTooltip = function() {
            var error = this.error ? i18n.unpack(this.model.error) : '';
            this.$().closest('.dcg-variable-errortooltip').attr('tooltip', error);
        };

        view.renderErrorShown = function() {
            this.$().toggleClass('dcg-error', !!this.errorShown);
        };

        view.didInsertElement = function() {
            this.renderErrorShown();
            this.renderErrorTooltip();
        };

        // defined in subclass
        view.createOptionsMenuView = function() {};

        view.toggleOptions = function() {
            if (this.error) {
                this.hideOptions();
                return;
            }
            if (this.optionsShown) {
                this.hideOptions();
                return;
            }

            this.optionsShown = true;

            // Add options menu to .dcg-main. workaround bug with "-webkit-scrolling-overflow: touch" and child "position:
            // relative" elements not respecting z-index
            // see: "-webkit-overflow-scrolling: touch is messing up z-index stacking"
            // [http://code.google.com/p/chromium/issues/detail?id=128325]
            this.optionsMenu = this.createOptionsMenuView(); //defined in subclass

            var id = this.optionsmenu_guid;

            // ipad sends out a scroll event when you tapstart on the button that
            // opens the context menu. We want that first scroll event to be
            // ignored, so we add the listener after a slight timeout to give the
            // first scroll event time to pass through.
            setTimeout(function() {
                //make sure options menu hasn't closed before the timeout fires
                if (this.optionsShown) {
                    this.getListView$().on("scroll.options-menu-" + id, function(evt) {
                        this.hideOptions();
                    }.bind(this));
                }
            }.bind(this), 0);

            $(document).on("keydown.options-menu-" + id, function(e) {
                if (Keys.lookup(e) === Keys.ESCAPE) {
                    this.hideOptions();
                }
            }.bind(this));

            $(document).on("tapstart.options-menu-" + id, function(e) {

                // close this unless:
                // * we click on the icon again (will handle that separately)
                // * we click insde the context-menu (that's been moved to the body)

                // we click inside the context menu (but not on the "close" button)
                if ($(e.target).closest('.dcg-options-menu').length) return;

                // we click within this view again
                if ($(e.target).closest(this.$()).length) return;

                this.hideOptions();

            }.bind(this));
        };

        view.getListView$ = function() {
            return this.$().closest('.dcg-tap-container').find('.dcg-exppanel');
        };

        view.hideOptions = function() {
                if (!this.optionsShown && !this.optionsMenu) return;
                this.optionsShown = false;

                var id = this.optionsmenu_guid;
                $(document).off("tapstart.options-menu-" + id);
                $(document).off("keydown.options-menu-" + id);
                this.getListView$().off("scroll.options-menu-" + id);

                if (this.optionsMenu) {
                    this.optionsMenu.remove();
                    this.optionsMenu = null;
                }
            },

            view.onDisplayChange = function() {
                var error = this.model.error ? true : false;
                if (this.model.isEmpty()) error = false;

                //next sequence of code will only add the errorStable property
                //if the error value hasn't changed within the last 500ms
                if (error !== this.error) {
                    this.setProperty('errorStable', false);
                    this.__errorTime = new Date().getTime();
                    setTimeout(this.onDisplayChange.bind(this), 100);
                } else if (this.__errorTime + 500 < new Date().getTime()) {
                    this.setProperty('errorStable', true);
                } else if (!this.errorStable) {
                    setTimeout(this.onDisplayChange.bind(this), 100);
                }

                this.setProperty('error', error);
            };

    });

    return AbstractIconView;
});
define('template!expression_options_menu', ['underscore'], function(_) {
    return function(obj) {
        var __p = '';
        var print = function() { __p += Array.prototype.join.call(arguments, '') };
        with(obj || {}) {
            __p += '<div class=\'dcg-exp-options-menu dcg-options-menu ';
            if (styles.length === 0) {;
                __p += 'dcg-colors-only';
            };
            __p += '\'>\n  <div class=\'dcg-triangle\'></div>\n  ';
            if (styles.length > 0) {;
                __p += '\n    <div class=\'dcg-styles-div\'>\n      <div class=\'dcg-styles-menu\'>\n        <div class=\'dcg-title\'>style:</div>\n        <div class=\'dcg-styles-menu\'>\n        ';
                _.each(styles, function(style) {;
                    __p += '\n          <span class="dcg-style-option dcg-graph-icon dcg-graph-' +
                        (style) +
                        '"\n            draw-style="' +
                        (style) +
                        '"\n            style=""\n            handleevent="true">\n          </span>\n        ';
                });
                __p += '\n        </div>\n      </div>\n    </div>\n  ';
            };
            __p += '\n  <div class=\'dcg-colors-div\'>\n    <div class=\'dcg-title\'>color:</div>\n    <div class="template-colorsview"></div>\n  </div>\n</div>\n';
        }
        return __p;
    };
});
define('loadcss!css/color_menu', function() {});
define('template!color_menu', ['underscore'], function(_) {
    return function(obj) {
        var __p = '';
        var print = function() { __p += Array.prototype.join.call(arguments, '') };
        with(obj || {}) {
            __p += '<div class="dcg-color-menu dcg-do-not-blur">\n  ';
            _.each(colors, function(color) {;
                __p += '\n    <span class="dcg-color-option"\n          color="' +
                    (color) +
                    '"\n          style="background: ' +
                    (color) +
                    '"\n          handleevent="true">\n          <i class=\'dcg-icon-check\'></i>\n    </span>\n  ';
            });
            __p += '\n</div>';
        }
        return __p;
    };
});
define('expressions/color_menu_view', ['require', 'loadcss!css/color_menu', 'jquery', 'pjs', 'underscore_view', './colors', 'template!color_menu'], function(require) {
    require('loadcss!css/color_menu');

    var $ = require('jquery');
    var P = require('pjs');
    var UnderscoreView = require('underscore_view');
    var Colors = require('./colors');

    var template = require('template!color_menu');

    var ExpressionColorsView = P(UnderscoreView, function(view, _super) {
        view.template = template,

            view.init = function(expression) {
                _super.init.call(this);
                this.expression = expression;
                this.expression.observe('color.colorview', this.renderSelectedColor.bind(this));
                this.expression.observe('hidden.colorview', this.renderSelectedColor.bind(this));
            };

        view.destruct = function() {
            this.expression.unobserve('.colorview');
        };

        view.renderSelectedColor = function() {
            var color = this.expression.color;
            this.$('.dcg-color-option').removeClass('dcg-selected');
            this.$('.dcg-color-option[color="' + color + '"]').addClass('dcg-selected');
        };

        view.didInsertElement = function() {
            this.$().on('tap tapstart', '.dcg-color-option', this.onSelectColor.bind(this));
            this.renderSelectedColor();
        };

        view.getTemplateParams = function() {
            return {
                colors: Colors.all
            };
        };

        view.onSelectColor = function(evt) {
            // when using mouse, fire on 'tapStart' and when on touch we
            // fire on the 'tap' event.
            if (evt.type === 'tap' && evt.device === 'mouse') return;
            if (evt.type === 'tapstart' && evt.device === 'touch') return;
            var color = $(evt.target).closest('.dcg-color-option').attr('color');
            this.expression.setProperty('color', color);

            //show expression (and its folder) if it was hidden
            this.expression.setProperty('hidden', false);
            if (this.expression.folder) this.expression.folder.setProperty('hidden', false);
        };

    });

    return ExpressionColorsView;
});

define('expressions/expression_options_view', ['require', 'pjs', 'jquery', 'underscore', 'underscore_view', 'template!expression_options_menu', './colors', './color_menu_view'], function(require) {
    var P = require('pjs');
    var $ = require('jquery');
    var _ = require('underscore');
    var UnderscoreView = require('underscore_view');
    var template = require('template!expression_options_menu');
    var Colors = require('./colors');
    var ColorMenuView = require('./color_menu_view');

    var ExpressionOptionsMenuView = P(UnderscoreView, function(view, _super) {
        view.template = template;

        view.init = function(expression) {
            this.expression = expression;
            this.expression.observe('color.colorview', this.renderSelectedColor.bind(this));
            this.expression.observe('hidden style shouldGraph', this.renderSelectedStyle.bind(this));
        };

        view.destruct = function() {
            if (this.colorsView) {
                this.colorsView.remove();
                this.colorsView = null;
            }
        };

        view.getTemplateParams = function() {
            var params = { colors: Colors.all, styles: [] };
            if (this.expression.formula.is_point_list && !this.expression.formula.move_ids) {
                params.styles = ['point', 'open'];
            } else if (!this.expression.table && !this.expression.formula.move_ids) {
                if (!this.expression.formula.is_inequality) {
                    params.styles = ['normal', 'dashed'];
                }
            }
            return params;
        };

        view.renderSelectedColor = function() {
            var color = this.expression.color;
            _.each(this.$('.dcg-style-option'), function(option) {
                $(option).css('background', color);
            });
        };

        view.onSelectStyle = function(evt) {
            // when using mouse, fire on 'tapStart' and when on touch we
            // fire on the 'tap' event.
            if (evt.type === 'tap' && evt.device === 'mouse') return;
            if (evt.type === 'tapstart' && evt.device === 'touch') return;

            var style = $(evt.target).closest('.dcg-style-option').attr('draw-style');
            this.expression.setProperty('hidden', false);
            this.expression.setProperty('style', style);

            //if we're in a folder, show it.
            if (this.expression.folder) this.expression.folder.setProperty('hidden', false);
        };

        view.renderSelectedStyle = function() {
            var style = this.expression.style;
            this.$('.dcg-style-option').removeClass('dcg-selected');
            if (this.expression.shouldGraph) {
                this.$('.dcg-style-option[draw-style="' + style + '"]').addClass('dcg-selected');
            }
        };

        view.didInsertElement = function() {
            // this view has a nested template. We instantiate the color picker
            // and replace a placeholder element within the html.
            this.colorsView = ColorMenuView(this.expression);
            this.colorsView.replace(this.$('.template-colorsview'));
            this.$().on('tap tapstart', '.dcg-style-option', this.onSelectStyle.bind(this));
            this.renderSelectedColor();
            this.renderSelectedStyle();
        };

    });

    return ExpressionOptionsMenuView;
});
define('template!expression_icon', ['underscore'], function(_) {
    return function(obj) {
        var __p = '';
        var print = function() { __p += Array.prototype.join.call(arguments, '') };
        with(obj || {}) {
            __p += '<span class="dcg-icon dcg-graph-icon dcg-variable-colorcss dcg-variable-errortooltip tipsy-sticky">\n\t<i class=\'dcg-icon-play\'></i>\n\t<i class=\'dcg-icon-pause\'></i>\n\t<i class=\'dcg-icon-hidden\'></i>\n</span>\n';
        }
        return __p;
    };
});
define('expressions/expression_icon_view', ['require', 'pjs', 'expressions/abstract_icon', './expression_options_view', 'math/comparators', 'template!expression_icon', 'jquery.handleevent'], function(require) {
    var P = require('pjs');
    var AbstractIconView = require('expressions/abstract_icon');
    var ExpressionOptionsMenuView = require('./expression_options_view');
    var Comparators = require('math/comparators');
    var template = require('template!expression_icon');
    require('jquery.handleevent');

    var ExpressionIconView = P(AbstractIconView, function(view, _super) {
        view.template = template;

        view.init = function(parentView) {
            _super.init.call(this, parentView);
            this.expression = this.model;

            // wait for the slider to be created. Then observe the isPlaying property on it
            this.expression.observe('slider.iconview', function() {
                this.expression.slider.observe('isPlaying.iconview', this.onDisplayChange.bind(this));
            }.bind(this));

            this.expression.observe('formula.iconview', this.onDisplayChange.bind(this));
            this.expression.observe('shouldGraph.iconview', this.onDisplayChange.bind(this));
            this.expression.observe('isGraphable.iconview', this.renderUngraphable.bind(this));
            this.expression.observe('loading.iconview', this.renderLoading.bind(this));
            this.expression.observe('color.iconview', this.renderColorCSS.bind(this));
            this.expression.observe('style.iconview', this.onDisplayChange.bind(this));

            this.parentView.observeEvent('hideContextMenu.iconview', this.hideOptions.bind(this));
        };

        view.destruct = function() {
            _super.destruct.call(this);

            this.expression.unobserve('.iconview');
            if (this.expression.slider) {
                this.expression.slider.unobserve('.iconview');
            }

            this.parentView.unobserve('.iconview');
        };

        view.renderUngraphable = function() {
            this.$().toggleClass('dcg-ungraphable', !this.expression.isGraphable);
        };

        view.renderLoading = function() {
            this.$().toggleClass('dcg-loading', !!this.expression.loading);
        };

        view.renderColorCSS = function() {
            this.$('.dcg-variable-colorcss').css({
                'border-color': this.expression.color,
                'background': this.expression.color
            });
        };

        view.didInsertElement = function() {
            var self = this;
            _super.didInsertElement.call(this);

            this.renderLoading();
            this.renderUngraphable();
            this.renderColorCSS();
            this.onDisplayChange();

            this.$icon = this.$('.dcg-icon');

            var handleIconTapped = function(evt, device) {
                if (evt.wasHandled('dragdrop')) return; //Don't toggle if we were handled by dragdrop
                if (evt.wasLongheld()) return;
                if (evt.device !== device) return;

                if (self.optionsShown) {
                    self.toggleOptions();
                    return false;
                }

                if (self.parentView.listView.editListMode) {
                    if (self.expression.isGraphable) {
                        self.toggleOptions();
                    }
                } else if (self.expression.formula.is_animatable) {
                    self.toggleSliderIsPlaying();
                } else {
                    self.toggleGraphShown();
                }
            };

            var handleIconLongHold = function(evt, device) {
                if (evt.device !== device) return;
                if (!self.model.isGraphable) return;

                evt.handle('longhold');
                self.toggleOptions();
            };

            this.$().closest('.dcg-action-icon-mouse').on('tap', function(evt) {
                handleIconTapped(evt, 'mouse');
            });

            this.$().closest('.dcg-action-icon-touch').on('tap', function(evt) {
                handleIconTapped(evt, 'touch');
            });

            this.$().closest('.dcg-action-icon-mouse').on('longhold', function(evt) {
                handleIconLongHold(evt, 'mouse');
            });

            this.$().closest('.dcg-action-icon-touch').on('longhold', function(evt) {
                handleIconLongHold(evt, 'touch');
            });
        };

        view.isGraphShown = function() {
            return this.expression.shouldGraph;
        };

        view.toggleSliderIsPlaying = function() {
            var slider = this.expression.slider;
            if (slider) {
                slider.setProperty('isPlaying', !slider.isPlaying);
            }
        };

        view.toggleGraphShown = function() {
            if (!this.model.isGraphable) return;
            if (this.errorShown) return;

            //note: if this expression is in a hidden folder this line will always fire, since
            //isGraphShown will be false. It'll be a no-op if the graph was shown when
            //the folder was hidden. That doesn't matter, because later on we turn on the folder
            //which will recalculate isGraphShown, so we'll recompute the icon anyway
            this.expression.setProperty('hidden', this.isGraphShown());

            //always show the folder if we're inside one
            if (this.expression.folder) this.expression.folder.setProperty('hidden', false);
        };

        view.createOptionsMenuView = function() {
            var listView = this.parentView.listView;
            var optionsView = ExpressionOptionsMenuView(this.expression);
            optionsView.appendTo(listView.$());

            // putting the ExpressionOptionsView at the topLeft of the .dcg-icon
            // it's up to the ExpressionOptionsView's css to position it beyond that
            var placeholder = this.$('.dcg-icon');
            var placeholderOffset = placeholder.offset();
            var listViewOffset = listView.$().offset();
            optionsView.$().css({
                position: 'absolute',
                top: placeholderOffset.top - listViewOffset.top + 'px',
                left: placeholderOffset.left - listViewOffset.left + 'px',
                display: 'block' //wait until we know where it is to show it. fixes #3154
            });
            return optionsView;
        };

        view.onDisplayChange = function() {
            /* jshint maxcomplexity:20 */
            _super.onDisplayChange.call(this);
            if (!this.$icon) return;

            var formula = this.expression.formula;
            var icon_class = '';

            if (formula.is_animatable) {
                if (this.expression.slider.isPlaying) {
                    icon_class = 'dcg-animate-pause';
                } else {
                    icon_class = 'dcg-animate-play';
                }
            } else if (this.error || !formula.is_graphable) {
                icon_class = '';
            } else {

                var shouldGraph = this.expression.shouldGraph;
                var style = this.expression.style;
                var operator = formula.operator;
                var shaded = Comparators.table[operator].direction !== 0;
                var dotted = Comparators.table[operator].inclusive === false;
                if (!shouldGraph) {
                    icon_class = 'dcg-graph-hidden';
                } else if (formula.move_ids) {
                    icon_class = 'dcg-graph-movable-point';
                } else if (formula.is_point_list) {
                    if (style === 'open') {
                        icon_class = 'dcg-graph-open';
                    } else if (style === 'cross') {
                        icon_class = 'dcg-graph-cross';
                    } else {
                        icon_class = 'dcg-graph-point';
                    }
                } else if (formula.is_shade_between) {
                    // TODO - missing icon for this
                    icon_class = 'dcg-graph-shaded-inequality';
                } else if (!dotted && !shaded) {
                    if (style === 'normal') {
                        icon_class = 'dcg-graph-normal';
                    } else if (style === 'dashed') {
                        icon_class = 'dcg-graph-dashed';
                    }
                } else if (!dotted && shaded) {
                    // TODO - missing icon for this
                    icon_class = 'dcg-graph-shaded-inequality';
                } else if (dotted && !shaded) {
                    icon_class = 'graph-inequality';
                } else if (dotted && shaded) {
                    icon_class = 'dcg-graph-shaded-inequality';
                }
            }

            // efficently changes the class of the icon
            if (this.rendered_icon_class === icon_class) return;
            if (this.rendered_icon_class) {
                this.$icon.removeClass(this.rendered_icon_class);
            }
            this.rendered_icon_class = icon_class;
            if (icon_class) {
                this.$icon.addClass(icon_class);
            }

        };
    });

    return ExpressionIconView;
});

define('template!evaluation_view', ['underscore'], function(_) {
    return function(obj) {
        var __p = '';
        var print = function() { __p += Array.prototype.join.call(arguments, '') };
        with(obj || {}) {
            __p += '<div>\n  <div class="dcg-evaluation dcg-do-blur" handleEvent="true">\n    <table>\n      <tr>\n        <th class="dcg-action-selectevaluation">\n          <span class="dcg-template-dependentlabelhtml"></span>\n          <span class="dcg-equals">=</span>\n        </th>\n        <td class="dcg-text-selectable template-evaluationshtml"></td>\n      </tr>\n    </table>\n  </div>\n  <div class="dcg-clear"></div>\n</div>';
        }
        return __p;
    };
});

define('expressions/evaluation', ['require', 'pjs', 'underscore_view', 'template!evaluation_view', 'i18n', 'graphing/label'], function(require) {
    var P = require('pjs');
    var UnderscoreView = require('underscore_view');
    var template = require('template!evaluation_view');
    var i18n = require('i18n');
    var Label = require('graphing/label');

    var EvaluationView = P(UnderscoreView, function(view, _super) {
        view.template = template;

        view.init = function(domain) {
            _super.init.call(this);
            this.evaluations = [];

            this.observe('dependentLabel', this.renderDependent.bind(this));
            this.observe('evaluations', this.renderEvaluations.bind(this));
        };

        view.renderDependent = function() {
            this.$('.dcg-template-dependentlabelhtml').html(this.dependentLabel);
        };

        view.renderEvaluations = function() {
            /* jshint maxcomplexity:12 */
            var vals = this.evaluations;
            var vals_str = [];

            for (var i = 0; i < vals.length; i++) {
                var f_val = vals[i];
                if (f_val.val === false) {
                    f_val.val = 'false';
                } else if (Array.isArray(f_val.val)) {
                    f_val.val = f_val.val.length + " element list";
                } else if (isNaN(f_val.val)) {
                    f_val.val = 'undefined';
                } else if (f_val.val === true) {
                    f_val.val = 'true';
                } else if (Math.abs(f_val.val) < 1e-15) {
                    f_val.val = 0;
                    //shrink output if there are 2 solutions
                } else if (vals.length > 1) {
                    if (Math.abs(f_val.val) > 1e6 || Math.abs(f_val.val) < 1e-3) {
                        f_val.val = Label.htmlSciNote(f_val.val.toExponential(6));
                    } else {
                        f_val.val = Number(f_val.val.toPrecision(8));
                    }
                } else {
                    if (Math.abs(f_val.val) > 1e9 || Math.abs(f_val.val) < 1e-6) {
                        f_val.val = Label.htmlSciNote(f_val.val.toExponential(8));
                    } else {
                        f_val.val = Number(f_val.val.toPrecision(12));
                    }
                }

                vals_str.push(f_val.val);
            }

            if (vals_str.length === 0) return;
            if (vals_str.length === 1) {
                // skipping jQuery because this happens in the inner loop of sliders
                // and draggable points.
                var elt = this.$evaluationContainer[0];
                elt.innerHTML = vals_str[0];
            } else {
                var output = vals_str.join('<span class="dcg-or">' + i18n.t('or') + '</span>');
                this.$evaluationContainer.html(output);
            }

        };

        view.didInsertElement = function() {
            this.$evaluationContainer = this.$('.template-evaluationshtml');
            this.renderDependent();
            this.renderEvaluations();

            this.$('.dcg-action-selectevaluation').on('tap', this.onSelectEvaluation.bind(this));
        };


        view.onSelectEvaluation = function() {
            var numberElement = this.$('td')[0];
            var range = document.createRange();
            range.selectNodeContents(numberElement);
            window.getSelection().removeAllRanges();
            window.getSelection().addRange(range);
        };

    });
    return EvaluationView;
});

define('template!unresolved_view', ['underscore'], function(_) {
    return function(obj) {
        var __p = '';
        var print = function() { __p += Array.prototype.join.call(arguments, '') };
        with(obj || {}) {
            __p += '<div class="dcg-unresolved">\n  <i class="dcg-icon-error" /> This function contains fine detail that has not been fully resolved.\n  <a href="http://support.desmos.com/entries/29577773-Unresolved-Detail-In-Plotted-Functions" target="_blank">Learn more.</a>\n</div>';
        }
        return __p;
    };
});
define('expressions/unresolved', ['require', 'pjs', 'underscore_view', 'template!unresolved_view'], function(require) {
    var P = require('pjs');
    var UnderscoreView = require('underscore_view');
    var template = require('template!unresolved_view');

    return P(UnderscoreView, function(view, _super) {
        view.template = template;
    });
});

define('template!domain_view', ['underscore'], function(_) {
    return function(obj) {
        var __p = '';
        var print = function() { __p += Array.prototype.join.call(arguments, '') };
        with(obj || {}) {
            __p += '<div class="dcg-domain dcg-do-blur" handleEvent="true">\n  \n  <div class="dcg-edit-domain dcg-variable-invalid dcg-desmos-input-container">\n    <table>\n      <tr>\n        <td>\n          <span class="dcg-before-input"></span>\n          <input type="number" limit="min" />\n          <span class="dcg-after-input"></span>\n        </td>\n        <td class="dcg-text">â‰¤</td>\n        <td class="dcg-text">t</td>\n        <td class="dcg-text">â‰¤</td>\n        <td>\n          <span class="dcg-before-input"></span>\n          <input type="number" limit="max" />\n          <span class="dcg-after-input"></span>\n        </td>\n      </tr>\n    </table>\n  </div>\n  \n  <div class="dcg-display-domain">\n    <span class="dcg-variable-min"></span> â‰¤ t â‰¤ <span class="dcg-variable-max"></span>    \n  </div>\n\n</div>';
        }
        return __p;
    };
});
define('expressions/domain_view', ['require', 'jquery', 'underscore_view', 'pjs', 'template!domain_view', 'keys', 'conditional_blur'], function(require) {
    var $ = require('jquery');
    var UnderscoreView = require('underscore_view');
    var P = require('pjs');
    var template = require('template!domain_view');
    var Keys = require('keys');
    var conditionalBlur = require('conditional_blur');

    var DomainView = P(UnderscoreView, function(view, _super) {
        view.template = template;

        view.init = function(domain) {
            _super.init.call(this);

            this.domain = domain;

            this.domain.observe('min.domainview', this.renderMin.bind(this));
            this.domain.observe('max.domainview', this.renderMax.bind(this));
            this.setProperty('editing', false);
            this.setProperty('invalid', !this.domain.isValid());
            this.observe('invalid', this.renderInvalid.bind(this));
            this.observe('editing', this.renderEditing.bind(this));
            this.storeLastValidDomain();
        };

        view.checkInvalid = function() {
            var min = parseFloat(this.$('input[limit=min]').attr('value'));
            var max = parseFloat(this.$('input[limit=max]').attr('value'));

            var invalid = (!isFinite(min) || !isFinite(max) || min >= max);
            this.setProperty('invalid', invalid);
        };

        view.destruct = function() {
            this.domain.unobserve('.domainview');
        };

        view.storeLastValidDomain = function() {
            if (this.domain.isValid()) {
                this.lastValidDomain = this.domain.serialize();
            }
        };

        view.renderInvalid = function() {
            this.$('.dcg-edit-domain').toggleClass('dcg-invalid', !!this.invalid);
        };

        view.renderEditing = function() {
            var editing = this.getProperty('editing');
            this.$().toggleClass('dcg-editing-domain', !!editing);
        };

        view.renderMin = function() {
            var min = this.domain.min;
            this.$('input[limit=min]').val(min);
            this.$('.dcg-variable-min').text(min);
        };

        view.renderMax = function() {
            var max = this.domain.max;
            this.$('input[limit=max]').val(max);
            this.$('.dcg-variable-max').text(max);
        };

        view.didInsertElement = function() {
            this.$('input').on('focusin', this.focusIn.bind(this))
                .on('focusout', this.focusOut.bind(this))
                .on('keydown keyup keypress', this.handleUserInput.bind(this));
            this.$('.dcg-display-domain').on('tap', this.onEditLimit.bind(this));
            this.renderEditing();
            this.renderMin();
            this.renderMax();
        };

        view.onEditLimit = function(evt) {
            evt.preventDefault();
            var $target = $(evt.toElement);
            this.setProperty('editing', true);
            if ($target.hasClass('dcg-variable-max')) {
                this.$('input[limit="max"]').focus().select();
            } else {
                this.$('input[limit="min"]').focus().select();
            }
        };

        view.stopEditing = function() {
            if (!this.domain.isValid() && this.lastValidDomain) {
                this.domain.setProperty('min', this.lastValidDomain.min);
                this.domain.setProperty('max', this.lastValidDomain.max);
            }
            this.setProperty('editing', false);
        };

        // blur input when enter pressed
        view.handleUserInput = function(evt) {
            if (Keys.lookup(evt) === Keys.ENTER) {
                conditionalBlur();
            } else {
                this.checkInvalid();

                // save the domain now so that it redraws
                if (!this.invalid) {
                    this.save(evt.target);
                }
            }
        };

        // went straight into a focus, so don't save
        view.focusIn = function(evt) {
            clearTimeout(this.saveAfterBlurTimeout);
            this.checkInvalid();
        };

        // if we don't focus into one of the other boxes really soon,
        // we'll just act like the save button was pressed. This is
        // a sideeffect of focusin being fired AFTER focusout. Temporarily,
        // nothing is focused and we can't tell if focus is about to be
        // placed or not.
        view.focusOut = function(evt) {
            var self = this;
            this.save(evt.target);
            this.saveAfterBlurTimeout = setTimeout(function() {
                clearTimeout(self.saveAfterBlurTimeout);
                self.stopEditing();
            }, 1);
            this.checkInvalid();
        };

        view.save = function(node) {
            if (node) {
                var target = $(node);
                var value = parseFloat(target.attr('value'));

                if (target.attr('limit') === 'min') {
                    // set the new min
                    if (value < this.domain.max) {
                        this.domain.setProperty('min', value);
                        // reset the value since it's invalid
                    } else {
                        target.attr('value', this.domain.min);
                    }
                } else if (target.attr('limit') === 'max') {
                    // set the new max
                    if (value > this.domain.min) {
                        this.domain.setProperty('max', value);
                        // reset the value since it's invalid
                    } else {
                        target.attr('value', this.domain.max);
                    }
                }
                this.storeLastValidDomain();
            }
        };
    });

    return DomainView;
});

define('loadcss!css/regression', function() {});
define('template!regression_view', ['underscore'], function(_) {
    return function(obj) {
        var __p = '';
        var print = function() { __p += Array.prototype.join.call(arguments, '') };
        with(obj || {}) {
            __p += '<div class="dcg-regression-container">\n  <div class="dcg-handle-event" handleEvent="true">\n    <div class="dcg-statistics">\n      <div class="dcg-regression-title dcg-residuals-title">\n        ' +
                (t('Statistics')) +
                '\n        <a class="dcg-regression-about-link" target="_blank">\n          <i class="dcg-icon-question-sign"></i>\n        </a>\n      </div>\n\n      <span class="dcg-statistics-value"></span>\n    </div>\n    <div class="dcg-residuals">\n      <div class="dcg-regression-title dcg-residuals-title">\n        ' +
                (t('Residuals')) +
                '\n      </div>\n      <span class="dcg-residuals-variable"></span>\n      <span class="dcg-residual-suggestion dcg-action-plot-residual dcg-btn">\n        plot\n      </span>\n    </div>\n\n    <div class="dcg-parameters-container">\n      <div class="dcg-regression-title dcg-parameters-title">\n        ' +
                (t('Parameters')) +
                '\n      </div>\n      <div class="dcg-parameters">\n      </div>\n    </div>\n\n    <div class="dcg-clear"></div>\n  </div>\n</div>';
        }
        return __p;
    };
});
define('expressions/regression_view', ['require', 'loadcss!css/regression', 'underscore_view', 'template!regression_view', 'pjs', 'jquery', 'underscore', 'graphing/label'], function(require) {
    require('loadcss!css/regression');
    var UnderscoreView = require('underscore_view');
    var template = require('template!regression_view');
    var P = require('pjs');
    var $ = require('jquery');
    var _ = require('underscore');
    var Label = require('graphing/label');

    return P(UnderscoreView, function(view, _super) {
        view.template = template;

        view.init = function(regression, listView) {
            _super.init.call(this);
            this.listView = listView;
            this.setProperty('regression', regression);
        };

        view.didCreateElement = function() {
            _super.didCreateElement.call(this);
            this.$statistics = this.$('.dcg-statistics-value');
            this.$residuals = this.$('.dcg-residuals-variable');
            this.$residualSuggestion = this.$('.dcg-residual-suggestion');
            this.$parameters = this.$('.dcg-parameters');
            this.$parametersContainer = this.$('.dcg-parameters-container');
            this.$regressionAboutLink = this.$('.dcg-regression-about-link');
            this.observeAndSync('regression', this.renderRegression.bind(this));

            this.$residualSuggestion.on('tap', this.plotResiduals.bind(this));
        };

        view.plotResiduals = function(evt) {
            var id = this.regression.residualSuggestionId;
            if (!id) return;
            var table = this.listView.model.getItemById(id);
            if (!table) return;

            table.insertColumn(table.columns.length - 1, {
                latex: Label.identifierToLatex(this.regression.residualVariable)
            });
        };

        view.getRoundedValue = function(val, digits, zeroCutoff) {
            if (Math.abs(val) < zeroCutoff) return 0;

            if (Math.abs(val) > 1e9 || Math.abs(val) < 1e-6) {
                return Label.latexSciNote(val.toExponential(digits - 1));
            }
            return Number(val.toPrecision(digits));
        };

        view.getRoundedParam = function(param, digits) {
            return this.getRoundedValue(this.regression.parameters[param], digits, 1e-15);
        };

        view.renderStats = function() {
            this.renderAboutLink();

            //render r value: https://github.com/desmosinc/knox/issues/4337
            if (this.regression.statistics.hasOwnProperty('r')) {
                var rVal = this.getRoundedValue(this.regression.statistics.r, 3, 1e-15);
                var $r = $('<span>').text('r=' + rVal).mathquill();
                this.$statistics.html($r);
                return;
            }

            if (this.regression.statistics.hasOwnProperty('Rsquared')) {
                var rsquaredVal = this.getRoundedValue(this.regression.statistics.Rsquared, 3, 1e-15);
                var rsquared = $('<span>').text('R^2=' + rsquaredVal).mathquill();
                this.$statistics.html(rsquared);
                return;
            }

            if (this.regression.statistics.hasOwnProperty('RMSE')) {
                var RMSE = this.getRoundedValue(this.regression.statistics.RMSE, 4, 1e-8);
                var $RMSE = $('<span>').text('RMSE=' + RMSE).mathquill();
                this.$statistics.html($RMSE);
                return;
            }
        };

        view.renderAboutLink = function() {
            //show regression warning only if R^2 is negative. should link to a help page
            if (this.regression.statistics.hasOwnProperty('RMSE')) {
                this.$regressionAboutLink[0].href = 'http://support.desmos.com/entries/60176149-What-is-RMSE-';
                this.$regressionAboutLink.show();
            } else if (this.regression.statistics.Rsquared < 0) {
                this.$regressionAboutLink[0].href =
                    'http://support.desmos.com/entries/60460125-Why-am-I-seeing-a-negative-R-2-value-';
                this.$regressionAboutLink.show();
            } else {
                this.$regressionAboutLink.hide();
            }
        };

        view.renderRegression = function() {
            this.renderStats();

            //render residual variable
            var residualVariable = $('<span>').text(this.regression.residualVariable).mathquill();
            this.$residuals.html(residualVariable);

            this.$residualSuggestion.toggleClass('dcg-visible', !!this.regression.residualSuggestionId);

            //render parameters
            this.$parameters.html('');
            this.$parametersContainer.toggle(_.size(this.regression.parameters) > 0);
            for (var p in this.regression.parameters) {
                var eq = $('<span>').addClass('dcg-parameter')
                    .text(p + '=' + this.getRoundedParam(p, 3))
                    .mathquill();
                this.$parameters.append(eq);
            }
        };
    });
});
define('loadcss!css/slider', function() {});
define('template!slider_view', ['underscore'], function(_) {
    return function(obj) {
        var __p = '';
        var print = function() { __p += Array.prototype.join.call(arguments, '') };
        with(obj || {}) {
            __p += '<span class="dcg-slider-container" tapboundary="true">\n\n  <div class="dcg-do-blur dcg-slider" handleEvent="true">\n    <div class="dcg-minLabel dcg-template-minlabelhtml">\n    </div>\n    <div class="dcg-maxLabel">\n      <span class="dcg-template-maxlabelhtml"></span>\n    </div>\n    <div class="dcg-track dcg-action-moveslider">\n      <div class="dcg-ticks dcg-template-tickmarkhtml"></div>\n      <div class="dcg-graphic"></div>\n    </div>\n    <div class="dcg-zeroMarker dcg-action-moveslider">\n      <div class="dcg-graphic"></div>\n    </div>\n    <div class="dcg-thumb dcg-action-startdragging" disablescroll="true">\n      <div class="dcg-graphic"></div>\n      <div class="dcg-center"></div>\n    </div>\n  </div>\n\n  <div class="dcg-slider_menu dcg-do-blur dcg-desmos-input-container" handleEvent="true">\n    <table>\n      <tr>\n        <td>\n          <span class="dcg-before-input"></span>\n            <input class="dcg-slider_min" limit="min" type="number">\n          <span class="dcg-after-input"></span>\n    ';
            /*
                 Need to be careful with unescaped html insertion. This html is generated
                 from user input by mathquill, so we"re relying on mathquill to escape
                 html as necessary.
               */
            ;
            __p += '\n        </td>\n        <td class="dcg-text">\n          â‰¤\n        </td>\n        <td class="dcg-template-dependentlabelhtml dcg-text"></td>\n        <td class="dcg-text">â‰¤</td>\n        <td>\n          <span class="dcg-before-input"></span>\n            <input class="dcg-slider_max" limit="max" type="number">\n          <span class="dcg-after-input"></span>\n        </td>\n        <td class="dcg-step dcg-text">' +
                (t('step:')) +
                '</td>\n        <td>\n          <span class="dcg-before-input"></span>\n            <input class="dcg-slider_interval" limit="step" type="number">\n          <span class="dcg-after-input"></span>\n        </td>\n      </tr>\n    </table>\n  </div>\n  \n</span>';
        }
        return __p;
    };
});
define('expressions/slider_view', ['require', 'loadcss!css/slider', 'jquery', 'pjs', 'lib/rounding', 'underscore_view', 'template!slider_view', 'underscore', 'keys', 'conditional_blur'], function(require) {
    require('loadcss!css/slider');

    var $ = require('jquery');
    var P = require('pjs');
    var Rounding = require('lib/rounding');
    var UnderscoreView = require('underscore_view');
    var template = require('template!slider_view');
    var _ = require('underscore');
    var Keys = require('keys');
    var conditionalBlur = require('conditional_blur');

    var label2html = function(num) {
        var onum = num;
        var str = String(num).split("-").join("");

        if (str.length > 4 || str.indexOf("e") != -1) {
            // size of input
            var digits = Math.floor(Math.log(Math.abs(num)) / Math.LN10);

            // move the decimial over to the unit's place
            num = num / Math.pow(10, digits);

            // round to 1 sig figs
            num = Math.round(num);

            if (Math.abs(num) >= 10) {
                digits++;
                if (num < 0) {
                    num = -1;
                } else {
                    num = 1;
                }
            }

            if (digits >= -3 && digits <= 3) {
                str = String(onum);
                if (str.indexOf("0.") === 0) {
                    str = str.substr(1);
                } else if (str.indexOf("-0.") === 0) {
                    str = "-" + str.substr(2);
                }

                return str.substr(0, 5);
            }

            var coef;
            if (num === 1) {
                coef = '';
            } else if (num === -1) {
                coef = '-';
            } else {
                coef = num + "<span class='dcg-cross'>\u00D7</span>";
            }

            return coef + "10<span class='dcg-sup'>" + digits + "</span> ";
        } else {
            return String(num);
        }
    };

    var SliderView = P(UnderscoreView, function(view, _super) {
        view.template = template;
        view.animationSpeeds = [0.05, 0.1, 0.15, 0.2, 0.35, 0.5, 0.75, 1, 1.5, 2, 3.5, 5, 7.5, 10, 15, 20];

        view.init = function(slider, parentView) {
            _super.init.call(this);
            this.slider = slider;
            this.parentView = parentView;

            // we hold a local copy of the slider's value. this allows us to
            // throttle how quickly we set the value back to the slider.
            this.value = this.slider.value;

            // if the slider's value changes, we immediately overwrite our local
            // copy of the variable with the new official value.
            this.slider.observe('value', function() {
                this.setProperty('value', this.slider.value);
            }.bind(this));

            this.editing = false;

            // Watch changes to the properties while we edit the slider.
            this.slider.observe('min.sliderview max.sliderview', this.renderThumbPosition.bind(this));
            this.observe('value', this.renderThumbPosition.bind(this));

            this.slider.observe('min.sliderview max.sliderview', this.renderZeroMarker.bind(this));
            this.slider.observe('min.sliderview max.sliderview step.sliderview', this.renderTickMarks.bind(this));
            this.slider.observe('min.sliderview hardMin.sliderview', this.renderMin.bind(this));
            this.slider.observe('max.sliderview hardMax.sliderview', this.renderMax.bind(this));
            this.slider.observe('step.sliderview', this.renderStep.bind(this));
            this.observe('dependentLabel', this.renderDependent.bind(this));
            this.observe('editing', this.renderEditing.bind(this));
            this.observe('editing', function() {
                this.slider.setProperty('isPlaying', false);
            }.bind(this));
            this.observe('invalid', this.renderInvalid.bind(this));
            this.slider.observe('dragging.sliderview', this.renderDragging.bind(this));
            this.slider.observe('isPlaying.sliderview', this.renderIsPlaying.bind(this));
            this.slider.observe('animationPeriod', this.renderAnimationPeriod.bind(this));
        };

        view.renderAnimationPeriod = function() {
            var speed = this.computeSpeed();
            var text = speed + 'x';
            this.parentView.$('.dcg-variable-speed').text(text);
            this.parentView.$('.dcg-action-slower').toggleClass('dcg-disabled', _.min(this.animationSpeeds) >= speed);
            this.parentView.$('.dcg-action-faster').toggleClass('dcg-disabled', _.max(this.animationSpeeds) <= speed);
        };

        view.destruct = function() {
            this.slider.unobserve('.sliderview');
        };

        view.renderDependent = function() {
            this.$('.dcg-template-dependentlabelhtml').html(this.dependentLabel);
        };

        view.renderDragging = function() {
            this.$thumb.toggleClass('dcg-down', !!this.slider.dragging);
        };

        view.renderStep = function() {
            if (this.slider.step === undefined) {
                this.$('input[limit=step]').val('');
            } else {
                this.$('input[limit=step]').val(this.slider.step);
            }
        };

        view.renderMin = function() {
            this.$('.dcg-template-minlabelhtml').html(label2html(this.slider.min));
            this.$('input[limit=min]').val(this.slider.hardMin ? this.slider.min : '');
        };

        view.renderMax = function() {
            this.$('.dcg-template-maxlabelhtml').html(label2html(this.slider.max));
            this.$('input[limit=max]').val(this.slider.hardMax ? this.slider.max : '');
        };

        view.renderEditing = function() {
            this.$().toggleClass('dcg-editing-limits', this.editing);
        };

        view.renderInvalid = function() {
            this.$('.dcg-slider_menu').toggleClass('dcg-invalid', !!this.invalid);
        };

        view.renderThumbPosition = function() {

            //TODO: this is for api usage with expressions: false.
            //Ideally, this method should never be reached if we have no expression views
            if (!this.$thumb) return;

            var left;
            var min = this.slider.min;
            var max = this.slider.max;
            var val = this.value;

            if (val <= min) {
                left = 0;
            } else if (val >= max) {
                left = 100;
            } else {
                left = (val - min) / (max - min) * 100;
            }

            // TODO would like to use translateX here, but percentages are
            // referenced to the element, not its parent. Could put the thumb
            // in a container that is width: 100%.
            this.$thumb.css('left', left + "%");
        };

        view.renderZeroMarker = function() {
            var t = (0 - this.slider.min) / (this.slider.max - this.slider.min);
            var css = {};
            if (t >= 0 && t <= 1) {
                var left = t * 100;
                css.display = "block";
                css.left = left + '%';
            } else {
                css.display = "none";
            }

            this.$('.dcg-zeroMarker').css(css);
        };

        view.renderTickMarks = function() {
            var step = this.slider.step;
            var min = this.slider.min;
            var max = this.slider.max;

            var percent = 100 * step / (max - min);
            if (percent < 3) percent = 0; // don't draw too many ticks

            var html = "";
            if (percent > 0 && percent < 100) {
                for (var i = percent; i < 100; i += percent) {
                    html += '<div class="dcg-tick" style="left:' + i + '%"></div>';
                }
            }

            this.$('.dcg-template-tickmarkhtml').html(html);
        };

        view.getDimensions = function() {
            var track = this.$('.dcg-track');
            var trackLeft = track.offset().left;
            var trackRight = trackLeft + track.width();
            return {
                trackLeft: trackLeft,
                trackRight: trackRight
            };
        };

        view.computeSpeed = function() {
            var speed = this.slider.DEFAULT_PERIOD / this.slider.animationPeriod;
            speed = Number(speed.toFixed(3)); // in case the speed isn't very precise
            return speed;
        };

        view.setPeriodFromSpeed = function(speed) {
            var period = this.slider.DEFAULT_PERIOD / speed;
            this.slider.setProperty('animationPeriod', period);
        };

        view.animateSlower = function() {
            var speed = this.computeSpeed();
            var slowers = _.filter(this.animationSpeeds, function(val) { return val < speed; });
            if (slowers.length === 0) return;

            this.setPeriodFromSpeed(_.max(slowers));
        };

        view.animateFaster = function() {
            var speed = this.computeSpeed();
            var fasters = _.filter(this.animationSpeeds, function(val) { return val > speed; });
            if (fasters.length === 0) return;

            this.setPeriodFromSpeed(_.min(fasters));
        };

        view.didInsertElement = function() {
            this.$thumb = this.$('.dcg-thumb');

            // setup event handlers
            this.$('.dcg-action-startdragging').on('tapstart', this.onStartDragging.bind(this));
            this.$('.dcg-action-moveslider').on('tap', function(evt) {
                var touch = evt.changedTouches[0];
                this.slider.setProperty('isPlaying', false);
                this.setValueByTouch(touch);
                this.commitSliderValue();
            }.bind(this));

            this.$().on('focusout', this.focusOut.bind(this));
            this.$().on('focusin', this.focusIn.bind(this));
            this.$().on('keydown', this.keyDown.bind(this));
            this.$('input[limit]').on('keypress keydown keyup', this.checkInvalid.bind(this));

            this.$('.dcg-action-play').on('tap', function() {
                this.slider.setProperty('isPlaying', true);
            }.bind(this));

            //Editing from main view - only active when using mouse
            this.$().on('tap', '.dcg-minLabel', this.onEditMin.bind(this));
            this.$().on('tap', '.dcg-maxLabel', this.onEditMax.bind(this));

            this.renderTickMarks();
            this.renderThumbPosition();
            this.renderZeroMarker();
            this.renderDependent();
            this.renderMin();
            this.renderMax();
            this.renderStep();
            this.renderAnimationPeriod();
            this.renderIsPlaying();

            this.checkInvalid();
        };

        view.setValueByTouch = function(touch) {

            // properties of the slider
            var min = this.slider.min;
            var max = this.slider.max;

            // figures out where the slider is located on the screen.
            var dimensions = this.getDimensions();

            var left = dimensions.trackLeft;
            var right = dimensions.trackRight;
            var width = right - left;
            var pixel_units = (max - min) / width;

            // figures out the percent 0%-100% of the thumbs position
            var t = Math.min(1, Math.max(0, (touch.pageX - left) / width));

            var val = min * (1 - t) + max * t;

            // round to a pretty number
            val = Rounding.shortestDecimalBetween(val - pixel_units, val + pixel_units);

            // snap to the step interval
            val = this.slider.computeSnappedValue(val);

            val = Math.max(min, Math.min(max, val));

            this.setProperty('value', val);
        };

        view.onStartDragging = function(evt) {

            // only start dragging if this is the first touch
            if (evt.touches.length !== 1) return;

            // updated by eli. On Android it's especially noticeable, but in general
            // it feels like we want to defocus expressions we're sliding a slider
            // unintended positive side effect:
            // also improves performance, since we don't need to stream POIs while sliding
            this.parentView.clearListFocus();

            var self = this;

            // Stop any slider animation
            this.slider.setProperty('isPlaying', false);

            var getTouchByIdentifier = function(evt, identifier) {
                var touches = evt.touches;
                var touch = null;

                for (var i = 0; i < touches.length; i++) {
                    if (touches[i].identifier === identifier) {
                        touch = touches[i];
                    }
                }

                return touch;
            };
            var throttleInterval = 30;
            var commitSliderValueThrottled = _.throttle(self.commitSliderValue.bind(self), throttleInterval);

            self.slider.setProperty('dragging', true);

            var touchIdentifier = evt.changedTouches[0].identifier;
            var onMouseMove = function(evt) {

                // lookup the touch that started this
                var touch = getTouchByIdentifier(evt, touchIdentifier);
                if (!touch) return;

                self.setValueByTouch(touch);

                // We commit the slider's value manually here instead of using an
                // observer on 'value' because we need precise control of when the
                // value is committed. When the user types in mathquill, that causes
                // a change in the sliders value. We don't want that change to get
                // routed back into commitSliderValue(). If it did, the user would never
                // be able to type decimals. When they typed "a=1.", the
                // commitSliderValue() function would turn that into "a=1" again.
                commitSliderValueThrottled();
            };

            var stopDragging = function() {
                $(document).off('tapmove', onMouseMove);
                $(document).off('tapend tapcancel', onMouseUp);

                self.slider.setProperty('dragging', false);
            };

            var onMouseUp = function(evt) {

                // checks if the touch that started the slider is still around. If so,
                // don't do anything here. A different touch must have lifted.
                var touch = getTouchByIdentifier(evt, touchIdentifier);
                if (touch) return;

                stopDragging();
                self.commitSliderValue();
            };

            $(document).on('tapmove', onMouseMove);
            $(document).on('tapend tapcancel', onMouseUp);
        };

        view.commitSliderValue = function() {
            this.slider.setProperty('value', this.value);
        };

        view.checkInvalid = function() {
            var min = this.$('input[limit=min]').attr('value');
            if (min === '') {
                min = this.slider.min;
            } else {
                min = parseFloat(min);
            }

            var max = this.$('input[limit=max]').attr('value');
            if (max === '') {
                max = this.slider.max;
            } else {
                max = parseFloat(max);
            }

            var step = this.$('input[limit=step]').attr('value');
            if (step === '') {
                step = 0;
            } else {
                step = parseFloat(step);
            }

            var invalid = (!isFinite(min) || !isFinite(max) || min >= max || step < 0 || step > (max - min));
            this.setProperty('invalid', invalid);
        };

        // blur input when enter pressed
        view.keyDown = function(evt) {
                if (Keys.lookup(evt) === Keys.ENTER) {
                    conditionalBlur();
                } else {
                    this.checkInvalid();
                }
            },

            // went straight into a focus, so don't save
            view.focusIn = function(evt) {
                this.slider.setProperty('isPlaying', false);
                clearTimeout(this.saveAfterBlurTimeout);
                this.checkInvalid();
            },

            // if we don't focus into one of the other boxes really soon,
            // we'll just act like the save button was pressed. This is
            // a sideeffect of focusin being fired AFTER focusout. Temporarily,
            // nothing is focused and we can't tell if focus is about to be
            // placed or not.
            view.focusOut = function(evt) {
                var self = this;
                this.save(evt.target);

                this.saveAfterBlurTimeout = setTimeout(function() {
                    clearTimeout(self.saveAfterBlurTimeout);
                    self.onClose();
                }, 1);

                this.checkInvalid();
            },

            view.save = function(node) {
                /* jshint maxcomplexity:12 */
                if (node) {
                    var target = $(node);
                    var value = target.attr('value');
                    if (value === '') {
                        value = undefined;
                    } else {
                        value = parseFloat(value);
                    }

                    var step = (this.$('.dcg-slider_interval').attr('value') === '') ? 0 : this.slider.step;

                    if (target.hasClass('dcg-slider_min')) {

                        // turn min soft
                        if (value === undefined) {
                            this.slider.setProperty('hardMin', false);
                        }

                        // set the new min
                        else if (value < this.slider.max && this.slider.max - value >= step) {
                            this.slider.setProperty('min', value);
                            this.slider.setProperty('hardMin', true);

                            // revert the min value
                        } else {
                            this.renderMin();
                        }

                    } else if (target.hasClass('dcg-slider_max')) {

                        // set max as soft
                        if (value === undefined) {
                            this.slider.setProperty('hardMax', false);
                        }

                        // set the new min
                        if (value > this.slider.min && value - this.slider.min >= step) {
                            this.slider.setProperty('max', value);
                            this.slider.setProperty('hardMax', true);

                            // revert the max value
                        } else {
                            this.renderMax();
                        }

                    } else if (target.hasClass('dcg-slider_interval')) {

                        // clear the step value
                        if (value === undefined) {
                            this.slider.setProperty('step', undefined);
                        }

                        // set the new step interval
                        else if (value >= 0 && value <= this.slider.max - this.slider.min) {
                            this.slider.setProperty('step', value);

                            // revert the slider step
                        } else {
                            this.renderStep();
                        }
                    }
                }
            };

        view.onClose = function() {
            this.setProperty('editing', false);
        };

        view.onEditMin = function(evt) {
            this.setProperty('editing', true);
            evt.preventDefault();
            this.$('.dcg-slider_min').focus().select();
        };

        view.onEditMax = function(evt) {
            this.setProperty('editing', true);
            evt.preventDefault();
            this.$('.dcg-slider_max').focus().select();
        };

        view.renderIsPlaying = function() {
            if (this.slider.step < 0) {
                this.slider.setProperty('isPlaying', false);
                return;
            }
            this.parentView.$().toggleClass('dcg-isPlaying', !!this.slider.isPlaying);
        };

    });

    return SliderView;
});

define('template!prompt_sliders', ['underscore'], function(_) {
    return function(obj) {
        var __p = '';
        var print = function() { __p += Array.prototype.join.call(arguments, '') };
        with(obj || {}) {
            __p += '<div class="dcg-create_sliders dcg-action-createslider" handleEvent="true">\n  <span class="dcg-msg">' +
                (t('add slider:')) +
                '</span>\n  <span class="btns">\n    ';
            _.each(variables, function(variable) {;
                __p += '\n      <div class="dcg-slider_btn_container" var_name="' +
                    (variable.name) +
                    '" >\n        <div class="dcg-btn dcg-btn-small ' +
                    ((variables.length === 1 ? 'dcg-btn-blue' : 'dcg-btn-gray')) +
                    '">' +
                    (variable.label) +
                    '</div>\n      </div>\n    ';
            });
            __p += '\n\n    ';
            if (variables.length > 1) {;
                __p += '\n      <div class="dcg-slider_btn_container dcg-all">\n        <div class="dcg-btn dcg-btn-small dcg-btn-blue">' +
                    (t('all')) +
                    '</div>\n      </div>\n    ';
            };
            __p += '\n  </span>\n</div>';
        }
        return __p;
    };
});
define('expressions/promptslider_view', ['require', 'jquery', 'pjs', 'underscore_view', 'template!prompt_sliders', './expression'], function(require) {
    var $ = require('jquery');
    var P = require('pjs');
    var UnderscoreView = require('underscore_view');
    var template = require('template!prompt_sliders');
    var ExpressionObject = require('./expression');

    var PromptSliderView = P(UnderscoreView, function(view, _super) {

        view.template = template;

        view.init = function(expressionView) {
            _super.init.call(this);

            this.variables = [];
            this.expressionView = expressionView;
            this.observe('variables', this.rerender.bind(this));
        };

        view.didInsertElement = function() {
            this.$('.dcg-action-createslider').on('tap', this.onCreateSlider.bind(this));
        };

        view.getTemplateParams = function() {
            var vars = this.variables;
            var formattedVariables = [];
            for (var i = 0; i < 4 && i < vars.length; i++) {
                var v = vars[i];
                var vName, vHtml = v.split('{').join('').split('}').join('').split('_');

                if (vHtml.length > 1) {
                    vName = vHtml[0] + "_{" + vHtml[1] + "}";
                    vHtml = vHtml[0] + "<sub>" + vHtml[1] + "</sub>";
                } else {
                    vName = vHtml[0];
                    vHtml = vHtml[0];
                }

                formattedVariables.push({ name: vName, label: vHtml });
            }

            return { variables: formattedVariables };
        };

        view.onCreateSlider = function(evt) {

            // this action feels like it should defocus expressions
            this.expressionView.clearListFocus();

            var dom = $(evt.target).closest('.dcg-slider_btn_container');
            if (!dom.length) return;

            var vars;
            if (dom.hasClass('dcg-all')) {
                vars = this.variables.map(function(raw_variable) {
                    var split = raw_variable.split('{').join('').split('}').join('').split('_');
                    if (split.length === 1) {
                        return raw_variable;
                    } else {
                        return split[0] + "_{" + split[1] + "}";
                    }
                });
            } else {
                vars = [dom.attr('var_name')];
            }

            if (!vars.length) return;

            this.createSliders(vars);
        };

        view.createSliders = function(vars) {
            var expressionView = this.expressionView;
            var expressionModel = this.expressionView.model;

            // build the list of states
            // this is important, because the first time, it will generate
            // an id for us automatically. If we undo then redo, we need to
            // reusue the generated ids.
            // set slider min/max so that they don't
            // get set automatically and messup undo/redo
            var var_states = [];
            for (var i = 0; i < vars.length; i++) {
                var_states.push({
                    latex: vars[i] + '=1',
                    sliderMin: -10, // TODO - combine this lines into:
                    sliderMax: 10, // slider: {min: -10, max: 10}
                    hidden: true //don't show a circle when we create an r= slider
                });
            }

            var index = expressionModel.index;
            var folder = expressionModel.folder;
            var next_index = index + 1;

            var list = expressionModel.list;
            list.undoRedo.addTransaction({
                type: list.undoRedo.CAUSE_OF_CHANGE,

                undo: function() {
                    for (var i = 0; i < vars.length; i++) {
                        list.removeItemAt(next_index);
                    }
                },

                redo: function() {
                    for (var i = var_states.length - 1; i >= 0; i--) {
                        var obj = ExpressionObject(var_states[i], list);
                        var_states[i].id = obj.id; // store the generated id for next time
                        list.insertItemAt(next_index, obj);
                        if (folder) folder.addItem(obj);
                    }
                }
            });

            // temporarily disables animation while slider is created
            expressionView.setProperty('doAnimate', false);
            clearTimeout(expressionView.restoreAnimationTimeout);
            expressionView.restoreAnimationTimeout = setTimeout(function() {
                expressionView.setProperty('doAnimate', true);
            }, 500);
        };
    });

    return PromptSliderView;
});

define('loadcss!vendor_css/mathquill/mathquill', function() {});
/**
 * Copyleft 2010-2011 Jay and Han (laughinghan@gmail.com)
 *   under the GNU Lesser General Public License
 *     http://www.gnu.org/licenses/lgpl.html
 * Project Website: http://mathquill.com
 */

(function() {

    var $ = jQuery,
        undefined,
        _, //temp variable of prototypes
        mqCmdId = 'mathquill-command-id',
        mqBlockId = 'mathquill-block-id',
        min = Math.min,
        max = Math.max;

    var __slice = [].slice;

    function noop() {}

    /**
     * sugar to make defining lots of commands easier.
     * TODO: rethink this.
     */
    function bind(cons /*, args... */ ) {
        var args = __slice.call(arguments, 1);
        return function() {
            return cons.apply(this, args);
        };
    }

    /**
     * a development-only debug method.  This definition and all
     * calls to `pray` will be stripped from the minified
     * build of mathquill.
     *
     * This function must be called by name to be removed
     * at compile time.  Do not define another function
     * with the same name, and only call this function by
     * name.
     */
    function pray(message, cond) {
        if (!cond) throw new Error('prayer failed: ' + message);
    }
    var P = (function(prototype, ownProperty, undefined) {
        // helper functions that also help minification
        function isObject(o) { return typeof o === 'object'; }

        function isFunction(f) { return typeof f === 'function'; }

        function P(_superclass /* = Object */ , definition) {
            // handle the case where no superclass is given
            if (definition === undefined) {
                definition = _superclass;
                _superclass = Object;
            }

            // C is the class to be returned.
            // There are three ways C will be called:
            //
            // 1) We call `new C` to create a new uninitialized object.
            //    The behavior is similar to Object.create, where the prototype
            //    relationship is set up, but the ::init method is not run.
            //    Note that in this case we have `this instanceof C`, so we don't
            //    spring the first trap. Also, `args` is undefined, so the initializer
            //    doesn't get run.
            //
            // 2) A user will simply call C(a, b, c, ...) to create a new object with
            //    initialization.  This allows the user to create objects without `new`,
            //    and in particular to initialize objects with variable arguments, which
            //    is impossible with the `new` keyword.  Note that in this case,
            //    !(this instanceof C) springs the return trap at the beginning, and
            //    C is called with the `new` keyword and one argument, which is the
            //    Arguments object passed in.
            //
            // 3) For internal use only, if new C(args) is called, where args is an
            //    Arguments object.  In this case, the presence of `new` means the
            //    return trap is not sprung, but the initializer is called if present.
            //
            //    You can also call `new C([a, b, c])`, which is equivalent to `C(a, b, c)`.
            //
            //  TODO: the Chrome inspector shows all created objects as `C` rather than `Object`.
            //        Setting the .name property seems to have no effect.  Is there a way to override
            //        this behavior?
            function C(args) {
                var self = this;
                if (!(self instanceof C)) return new C(arguments);
                if (args && isFunction(self.init)) self.init.apply(self, args);
            }

            // set up the prototype of the new class
            // note that this resolves to `new Object`
            // if the superclass isn't given
            var proto = C[prototype] = new _superclass();

            // other variables, as a minifier optimization
            var _super = _superclass[prototype];
            var extensions;

            // set the constructor property on the prototype, for convenience
            proto.constructor = C;

            C.mixin = function(def) {
                C[prototype] = P(C, def)[prototype];
                return C;
            }

            return (C.open = function(def) {
                extensions = {};

                if (isFunction(def)) {
                    // call the defining function with all the arguments you need
                    // extensions captures the return value.
                    extensions = def.call(C, proto, _super, C, _superclass);
                } else if (isObject(def)) {
                    // if you passed an object instead, we'll take it
                    extensions = def;
                }

                // ...and extend it
                if (isObject(extensions)) {
                    for (var ext in extensions) {
                        if (ownProperty.call(extensions, ext)) {
                            proto[ext] = extensions[ext];
                        }
                    }
                }

                // if there's no init, we assume we're inheriting a non-pjs class, so
                // we default to applying the superclass's constructor.
                if (!isFunction(proto.init)) {
                    proto.init = function() { _superclass.apply(this, arguments); };
                }

                return C;
            })(definition);
        }

        // ship it
        return P;

        // as a minifier optimization, we've closured in a few helper functions
        // and the string 'prototype' (C[p] is much shorter than C.prototype)
    })('prototype', ({}).hasOwnProperty);
    /*************************************************
     * Textarea Manager
     *
     * An abstraction layer wrapping the textarea in
     * an object with methods to manipulate and listen
     * to events on, that hides all the nasty cross-
     * browser incompatibilities behind a uniform API.
     *
     * Design goal: This is a *HARD* internal
     * abstraction barrier. Cross-browser
     * inconsistencies are not allowed to leak through
     * and be dealt with by event handlers. All future
     * cross-browser issues that arise must be dealt
     * with here, and if necessary, the API updated.
     *
     * Organization:
     * - key values map and stringify()
     * - manageTextarea()
     *    + defer() and flush()
     *    + event handler logic
     *    + attach event handlers and export methods
     *
     * We put focus into a span[tabindex=0] by default.
     * This prevents virtual keyboards from opening on
     * touch-enabled devices. But, that has the effect
     * of disabling real keyboards. Focus is shifted
     * from the span[tabindex=0] to a textarea the
     * moment a keydown event is fired. The side-effect
     * of the keydown still takes place within the
     * textarea. The textarea is used from that moment
     * on until the textarea is blurred. At that point
     * we disable the textarea again until the next
     * keydown event.
     ************************************************/

    // TODO - create the textarea and spanarea within the
    // textarea manager in order to better enforce the
    // *HARD* internal abstraction barrier.

    var manageTextarea = (function() {

        var NONE = 0;
        var SPANAREA = 1;
        var TEXTAREA = 2;

        // The following [key values][1] map was compiled from the
        // [DOM3 Events appendix section on key codes][2] and
        // [a widely cited report on cross-browser tests of key codes][3],
        // except for 10: 'Enter', which I've empirically observed in Safari on iOS
        // and doesn't appear to conflict with any other known key codes.
        //
        // [1]: http://www.w3.org/TR/2012/WD-DOM-Level-3-Events-20120614/#keys-keyvalues
        // [2]: http://www.w3.org/TR/2012/WD-DOM-Level-3-Events-20120614/#fixed-virtual-key-codes
        // [3]: http://unixpapa.com/js/key.html
        var KEY_VALUES = {
            8: 'Backspace',
            9: 'Tab',

            10: 'Enter', // for Safari on iOS

            13: 'Enter',

            16: 'Shift',
            17: 'Control',
            18: 'Alt',
            20: 'CapsLock',

            27: 'Esc',

            32: 'Spacebar',

            33: 'PageUp',
            34: 'PageDown',
            35: 'End',
            36: 'Home',

            37: 'Left',
            38: 'Up',
            39: 'Right',
            40: 'Down',

            45: 'Insert',

            46: 'Del',

            144: 'NumLock'
        };

        function stopEvent(evt) {
            evt.stopPropagation();
            evt.stopImmediatePropagation();
        }

        // To the extent possible, create a normalized string representation
        // of the key combo (i.e., key code and modifier keys).
        function stringify(evt) {
            var which = evt.which || evt.keyCode;
            var keyVal = KEY_VALUES[which];
            var key;
            var modifiers = [];

            if (evt.ctrlKey) modifiers.push('Ctrl');
            if (evt.originalEvent && evt.originalEvent.metaKey) modifiers.push('Meta');
            if (evt.altKey) modifiers.push('Alt');
            if (evt.shiftKey) modifiers.push('Shift');

            key = keyVal || String.fromCharCode(which);

            if (!modifiers.length && !keyVal) return key;

            modifiers.push(key);
            return modifiers.join('-');
        }

        // A global listener that's attached once. It monitors for keydown events.
        // Whenever one occurs, it checks if the currently active element has
        // permission to enable the physical keyboard for a mathquill. If so,
        // it calls the closured function to do so. When that mathquill loses focus
        // it will automatically disable the keyboard again. This means that a
        // bluetooh keyboard can be added and removed throught a session and we'll
        // update the mathquills accordingly. The only edge case is if you remove
        // a keyboard while editing a mathquill. In that case, the virtual keypad
        // will popup.
        $(document).on('keydown', function() {
            var activeElement = document.activeElement;
            var enableKeyboard = $(activeElement).data('enablePhysicalKeyboard')
            if (enableKeyboard) {
                enableKeyboard();
            }
        });

        // Sets up the listeners to automatically switch between spanarea and
        // the textarea. This allows us to use the physical keyboard wihtout
        // bringing up a native virtual keyboard when a physical keyboard is
        // not present. Should only be used when there is a user supplied
        // keypad present.
        //
        // We enable physical keyboards when this mathquill's spanara is
        // focused and we observe a native 'keydown' event. We assume
        // that command came from a physical keyboard. We JIT switch
        // focus to a real textarea in order to catch the keypress.
        function autoSwitchTextarea(spanarea, textarea, exports) {
            var focusedElement = NONE;

            function disablePhysicalKeyboard() {
                spanarea.attr('tabindex', '0');

                // must actively blur textarea before setting to disabled.
                // IE does some funny thing where it changes focus to somewhere
                // else.
                textarea.blur();
                textarea.attr('disabled', 'true');
            }

            function enablePhysicalKeyboard() {
                focusedElement = TEXTAREA;
                spanarea.removeAttr('tabindex');
                textarea.removeAttr('disabled');
                textarea.focus();
                textarea.select();
            }

            exports.focus = function() {
                if (focusedElement === NONE) {
                    spanarea.focus();
                }
            };

            exports.blur = function() {
                if (focusedElement === TEXTAREA) {
                    textarea.blur();
                }
                if (focusedElement === SPANAREA) {
                    spanarea.blur();
                }
            };

            // we do some work to make sure that focusin and focusout
            // events are only fired once and are fired only when they
            // should be. The transition from spanarea being focused to
            // textarea being focused needs to happen silently. This
            // code makes sure that happens. It also eliminates multiple
            // focusin and focusout events from being fired in IE.
            spanarea.on('focusin', function(evt) {
                if (focusedElement !== NONE) {
                    stopEvent(evt);
                } else {
                    focusedElement = SPANAREA;
                    exports.onFocus();
                }
            }).on('focusout', function(evt) {
                if (focusedElement !== SPANAREA) {
                    stopEvent(evt);
                } else {
                    focusedElement = NONE;
                    exports.onBlur();
                }
            });

            textarea.on('focusin', function(evt) {
                stopEvent(evt);
                // enablePhysicalKeyboard will set
                // focusedElement = TEXTAREA
            }).on('focusout', function(evt) {
                if (focusedElement !== TEXTAREA) {
                    stopEvent(evt);
                } else {
                    focusedElement = NONE;
                    disablePhysicalKeyboard();
                    exports.onBlur();
                }
            });

            // if we get a keydown event while this element is active, we'll
            // enable the physical physical keyboard.
            spanarea.data('enablePhysicalKeyboard', enablePhysicalKeyboard);

            // start off with spanarea enabled
            disablePhysicalKeyboard();
        }

        // this defaults to how mathquill normally works. We always back
        // the textareaManager with a real textarea. This is the effect of
        // always bringing up the native virtual keyboard on devices that
        // do not have a physical keyboard attached.
        function alwaysUseTextarea(spanarea, textarea, exports) {
            var focusedElement = NONE;

            exports.focus = function() {
                if (focusedElement === NONE) {
                    textarea.focus();
                }
            };

            exports.blur = function() {
                if (focusedElement === TEXTAREA) {
                    textarea.blur();
                }
            };

            // we do some work to make sure that focusin and focusout
            // events are only fired once and are fired only when they
            // should be. The transition from spanarea being focused to
            // textarea being focused needs to happen silently. This
            // code makes sure that happens. It also eliminates multiple
            // focusin and focusout events from being fired in IE.
            textarea.on('focusin', function(evt) {
                if (focusedElement !== NONE) {
                    stopEvent(evt);
                } else {
                    focusedElement = TEXTAREA;
                    exports.onFocus();
                }
            }).on('focusout', function(evt) {
                if (focusedElement !== TEXTAREA) {
                    stopEvent(evt);
                } else {
                    focusedElement = NONE;
                    exports.onBlur();
                }
            });
        }


        // create a textarea manager that calls callbacks at useful times
        // and exports useful public methods
        return function manageTextarea(textarea, spanarea, opts) {
            var exports = {}
            var keydown = null;
            var keypress = null;

            if (!opts) opts = {};
            var textCallback = opts.text || noop;
            var keyCallback = opts.key || noop;
            var pasteCallback = opts.paste || noop;
            var onCut = opts.cut || noop;

            var target = $(opts.container || textarea);

            // defer() runs fn immediately after the current thread.
            // flush() will run it even sooner, if possible.
            // flush always needs to be called before defer, and is called a
            // few other places besides.
            var timeout, deferredFn;

            function defer(fn) {
                timeout = setTimeout(fn);
                deferredFn = fn;
            }

            function flush() {
                if (timeout) {
                    clearTimeout(timeout);
                    timeout = undefined;
                    deferredFn();
                }
            }

            // -*- public methods -*- //
            exports.onFocus = function() {}
            exports.onBlur = function() {}

            exports.select = function(text) {
                flush();

                textarea.val(text);

                // IE throws error if you try to select an unfocused textarea
                if (text && document.activeElement === textarea[0]) {
                    textarea[0].select();
                }
            }

            if (window.overrideNativeOnscreenKeypad) {
                autoSwitchTextarea(spanarea, textarea, exports);
            } else {
                alwaysUseTextarea(spanarea, textarea, exports);
            }

            target.bind('keydown keypress input keyup focusout paste', flush);

            // -*- helper subroutines -*- //

            // Determine whether there's a selection in the textarea.
            // This will always return false in IE < 9, which don't support
            // HTMLTextareaElement::selection{Start,End}.
            function hasSelection() {
                var dom = textarea[0];

                if (!('selectionStart' in dom)) return false;
                return dom.selectionStart !== dom.selectionEnd;
            }

            function popText(callback) {
                var text = textarea.val();
                textarea.val('');
                if (text) callback(text);
            }

            function handleKey() {
                keyCallback(stringify(keydown), keydown);
            }

            // -*- event handlers -*- //
            function onKeydown(e) {
                keydown = e;
                keypress = null;

                handleKey();
            }

            function onKeypress(e) {
                // call the key handler for repeated keypresses.
                // This excludes keypresses that happen directly
                // after keydown.  In that case, there will be
                // no previous keypress, so we skip it here
                if (keydown && keypress) handleKey();

                keypress = e;

                defer(function() {
                    // If there is a selection, the contents of the textarea couldn't
                    // possibly have just been typed in.
                    // This happens in browsers like Firefox and Opera that fire
                    // keypress for keystrokes that are not text entry and leave the
                    // selection in the textarea alone, such as Ctrl-C.
                    // Note: we assume that browsers that don't support hasSelection()
                    // also never fire keypress on keystrokes that are not text entry.
                    // This seems reasonably safe because:
                    // - all modern browsers including IE 9+ support hasSelection(),
                    //   making it extremely unlikely any browser besides IE < 9 won't
                    // - as far as we know IE < 9 never fires keypress on keystrokes
                    //   that aren't text entry, which is only as reliable as our
                    //   tests are comprehensive, but the IE < 9 way to do
                    //   hasSelection() is poorly documented and is also only as
                    //   reliable as our tests are comprehensive
                    // If anything like #40 or #71 is reported in IE < 9, see
                    // b1318e5349160b665003e36d4eedd64101ceacd8

                    //updated by Eli
                    //in Safari, when text is selected inside of the textarea
                    //and then a key is pressed, there's a brief moment where
                    //the new text is selected. This circumvents that problem, by
                    //trying again a moment later
                    //this should be a no-op except in Safari
                    //NOTE / TODO: this still seems to introduce a problem with vertical
                    //alignment. In DCG, try:
                    // * type "1"
                    // * highlight the "1"
                    // * type "/"
                    // note that vertical alignment of the icon is broken
                    // it's only fixed when another action is taken that changes
                    // vertical alignment (i.e. a division inside of one of the
                    // division signs)
                    if (hasSelection()) {
                        setTimeout(function() {
                            if (!hasSelection())
                                popText(textCallback);
                        });
                    } else {
                        popText(textCallback);
                    }

                    if (hasSelection()) return;

                    popText(textCallback);
                });
            }

            function onBlur() { keydown = keypress = null; }

            function onPaste(e) {
                // browsers are dumb.
                //
                // In Linux, middle-click pasting causes onPaste to be called,
                // when the textarea is not necessarily focused.  We focus it
                // here to ensure that the pasted text actually ends up in the
                // textarea.
                //
                // It's pretty nifty that by changing focus in this handler,
                // we can change the target of the default action.  (This works
                // on keydown too, FWIW).
                //
                // And by nifty, we mean dumb (but useful sometimes).
                textarea.focus();

                defer(function() {
                    popText(pasteCallback);
                });
            }

            // -*- attach event handlers -*- //
            target.bind({
                keydown: onKeydown,
                keypress: onKeypress,
                focusout: onBlur,
                cut: onCut,
                paste: onPaste
            });

            // -*- export public methods -*- //
            return exports;
        };
    }());
    var Parser = P(function(_, _super, Parser) {
        // The Parser object is a wrapper for a parser function.
        // Externally, you use one to parse a string by calling
        //   var result = SomeParser.parse('Me Me Me! Parse Me!');
        // You should never call the constructor, rather you should
        // construct your Parser from the base parsers and the
        // parser combinator methods.

        function parseError(stream, message) {
            if (stream) {
                stream = "'" + stream + "'";
            } else {
                stream = 'EOF';
            }

            throw 'Parse Error: ' + message + ' at ' + stream;
        }

        _.init = function(body) { this._ = body; };

        _.parse = function(stream) {
            return this.skip(eof)._(stream, success, parseError);

            function success(stream, result) { return result; }
        };

        // -*- primitive combinators -*- //
        _.or = function(alternative) {
            pray('or is passed a parser', alternative instanceof Parser);

            var self = this;

            return Parser(function(stream, onSuccess, onFailure) {
                return self._(stream, onSuccess, failure);

                function failure(newStream) {
                    return alternative._(stream, onSuccess, onFailure);
                }
            });
        };

        _.then = function(next) {
            var self = this;

            return Parser(function(stream, onSuccess, onFailure) {
                return self._(stream, success, onFailure);

                function success(newStream, result) {
                    var nextParser = (next instanceof Parser ? next : next(result));
                    pray('a parser is returned', nextParser instanceof Parser);
                    return nextParser._(newStream, onSuccess, onFailure);
                }
            });
        };

        // -*- optimized iterative combinators -*- //
        _.many = function() {
            var self = this;

            return Parser(function(stream, onSuccess, onFailure) {
                var xs = [];
                while (self._(stream, success, failure));
                return onSuccess(stream, xs);

                function success(newStream, x) {
                    stream = newStream;
                    xs.push(x);
                    return true;
                }

                function failure() {
                    return false;
                }
            });
        };

        _.times = function(min, max) {
            if (arguments.length < 2) max = min;
            var self = this;

            return Parser(function(stream, onSuccess, onFailure) {
                var xs = [];
                var result = true;
                var failure;

                for (var i = 0; i < min; i += 1) {
                    result = self._(stream, success, firstFailure);
                    if (!result) return onFailure(stream, failure);
                }

                for (; i < max && result; i += 1) {
                    result = self._(stream, success, secondFailure);
                }

                return onSuccess(stream, xs);

                function success(newStream, x) {
                    xs.push(x);
                    stream = newStream;
                    return true;
                }

                function firstFailure(newStream, msg) {
                    failure = msg;
                    stream = newStream;
                    return false;
                }

                function secondFailure(newStream, msg) {
                    return false;
                }
            });
        };

        // -*- higher-level combinators -*- //
        _.result = function(res) { return this.then(succeed(res)); };
        _.atMost = function(n) { return this.times(0, n); };
        _.atLeast = function(n) {
            var self = this;
            return self.times(n).then(function(start) {
                return self.many().map(function(end) {
                    return start.concat(end);
                });
            });
        };

        _.map = function(fn) {
            return this.then(function(result) { return succeed(fn(result)); });
        };

        _.skip = function(two) {
            return this.then(function(result) { return two.result(result); });
        };

        // -*- primitive parsers -*- //
        var string = this.string = function(str) {
            var len = str.length;
            var expected = "expected '" + str + "'";

            return Parser(function(stream, onSuccess, onFailure) {
                var head = stream.slice(0, len);

                if (head === str) {
                    return onSuccess(stream.slice(len), head);
                } else {
                    return onFailure(stream, expected);
                }
            });
        };

        var regex = this.regex = function(re) {
            pray('regexp parser is anchored', re.toString().charAt(1) === '^');

            var expected = 'expected ' + re;

            return Parser(function(stream, onSuccess, onFailure) {
                var match = re.exec(stream);

                if (match) {
                    var result = match[0];
                    return onSuccess(stream.slice(result.length), result);
                } else {
                    return onFailure(stream, expected);
                }
            });
        };

        var succeed = Parser.succeed = function(result) {
            return Parser(function(stream, onSuccess) {
                return onSuccess(stream, result);
            });
        };

        var fail = Parser.fail = function(msg) {
            return Parser(function(stream, _, onFailure) {
                return onFailure(stream, msg);
            });
        };

        var letter = Parser.letter = regex(/^[a-z]/i);
        var letters = Parser.letters = regex(/^[a-z]*/i);
        var digit = Parser.digit = regex(/^[0-9]/);
        var digits = Parser.digits = regex(/^[0-9]*/);
        var whitespace = Parser.whitespace = regex(/^\s+/);
        var optWhitespace = Parser.optWhitespace = regex(/^\s*/);

        var any = Parser.any = Parser(function(stream, onSuccess, onFailure) {
            if (!stream) return onFailure(stream, 'expected any character');

            return onSuccess(stream.slice(1), stream.charAt(0));
        });

        var all = Parser.all = Parser(function(stream, onSuccess, onFailure) {
            return onSuccess('', stream);
        });

        var eof = Parser.eof = Parser(function(stream, onSuccess, onFailure) {
            if (stream) return onFailure(stream, 'expected EOF');

            return onSuccess(stream, stream);
        });
    });
    /*************************************************
     * Base classes of the MathQuill virtual DOM tree
     *
     * Only doing tree node manipulation via these
     * adopt/ disown methods guarantees well-formedness
     * of the tree.
     ************************************************/

    /**
     * MathQuill virtual-DOM tree-node abstract base class
     */
    var Node = P(function(_) {
        _.prev = 0;
        _.next = 0;
        _.parent = 0;
        _.firstChild = 0;
        _.lastChild = 0;

        _.children = function() {
            return Fragment(this.firstChild, this.lastChild);
        };

        _.eachChild = function(fn) {
            return this.children().each(fn);
        };

        _.foldChildren = function(fold, fn) {
            return this.children().fold(fold, fn);
        };

        _.adopt = function(parent, prev, next) {
            Fragment(this, this).adopt(parent, prev, next);
            return this;
        };

        _.disown = function() {
            Fragment(this, this).disown();
            return this;
        };
    });

    /**
     * An entity outside the virtual tree with one-way pointers (so it's only a
     * "view" of part of the tree, not an actual node/entity in the tree) that
     * delimits a doubly-linked list of sibling nodes.
     * It's like a fanfic love-child between HTML DOM DocumentFragment and the Range
     * classes: like DocumentFragment, its contents must be sibling nodes
     * (unlike Range, whose contents are arbitrary contiguous pieces of subtrees),
     * but like Range, it has only one-way pointers to its contents, its contents
     * have no reference to it and in fact may still be in the visible tree (unlike
     * DocumentFragment, whose contents must be detached from the visible tree
     * and have their 'parent' pointers set to the DocumentFragment).
     */
    var Fragment = P(function(_) {
        _.first = 0;
        _.last = 0;

        _.init = function(first, last) {
            pray('no half-empty fragments', !first === !last);

            if (!first) return;

            pray('first node is passed to Fragment', first instanceof Node);
            pray('last node is passed to Fragment', last instanceof Node);
            pray('first and last have the same parent',
                first.parent === last.parent);

            this.first = first;
            this.last = last;
        };

        function prayWellFormed(parent, prev, next) {
            pray('a parent is always present', parent);
            pray('prev is properly set up', (function() {
                // either it's empty and next is the first child (possibly empty)
                if (!prev) return parent.firstChild === next;

                // or it's there and its next and parent are properly set up
                return prev.next === next && prev.parent === parent;
            })());

            pray('next is properly set up', (function() {
                // either it's empty and prev is the last child (possibly empty)
                if (!next) return parent.lastChild === prev;

                // or it's there and its next and parent are properly set up
                return next.prev === prev && next.parent === parent;
            })());
        }

        _.adopt = function(parent, prev, next) {
            prayWellFormed(parent, prev, next);

            var self = this;
            self.disowned = false;

            var first = self.first;
            if (!first) return this;

            var last = self.last;

            if (prev) {
                // NB: this is handled in the ::each() block
                // prev.next = first
            } else {
                parent.firstChild = first;
            }

            if (next) {
                next.prev = last;
            } else {
                parent.lastChild = last;
            }

            self.last.next = next;

            self.each(function(el) {
                el.prev = prev;
                el.parent = parent;
                if (prev) prev.next = el;

                prev = el;
            });

            return self;
        };

        _.disown = function() {
            var self = this;
            var first = self.first;

            // guard for empty and already-disowned fragments
            if (!first || self.disowned) return self;

            self.disowned = true;

            var last = self.last;
            var parent = first.parent;

            prayWellFormed(parent, first.prev, first);
            prayWellFormed(parent, last, last.next);

            if (first.prev) {
                first.prev.next = last.next;
            } else {
                parent.firstChild = last.next;
            }

            if (last.next) {
                last.next.prev = first.prev;
            } else {
                parent.lastChild = first.prev;
            }

            return self;
        };

        _.each = function(fn) {
            var self = this;
            var el = self.first;
            if (!el) return self;

            for (; el !== self.last.next; el = el.next) {
                if (fn.call(self, el) === false) break;
            }

            return self;
        };

        _.fold = function(fold, fn) {
            this.each(function(el) {
                fold = fn.call(this, fold, el);
            });

            return fold;
        };
    });
    /*************************************************
     * Abstract classes of math blocks and commands.
     ************************************************/

    var uuid = (function() {
        var id = 0;

        return function() { return id += 1; };
    })();

    /**
     * Math tree node base class.
     * Some math-tree-specific extensions to Node.
     * Both MathBlock's and MathCommand's descend from it.
     */
    var MathElement = P(Node, function(_) {
        _.init = function(obj) {
            this.id = uuid();
            MathElement[this.id] = this;
        };

        _.toString = function() {
            return '[MathElement ' + this.id + ']';
        };

        _.bubble = function(event /*, args... */ ) {
            var args = __slice.call(arguments, 1);

            for (var ancestor = this; ancestor; ancestor = ancestor.parent) {
                var res = ancestor[event] && ancestor[event].apply(ancestor, args);
                if (res === false) break;
            }

            return this;
        };

        _.postOrder = function(fn /*, args... */ ) {
            if (typeof fn === 'string') {
                var methodName = fn;
                fn = function(el) {
                    if (methodName in el) el[methodName].apply(el, arguments);
                };
            }

            (function recurse(desc) {
                desc.eachChild(recurse);
                fn(desc);
            })(this);
        };

        _.jQ = $();
        _.jQadd = function(jQ) { this.jQ = this.jQ.add(jQ); };

        this.jQize = function(html) {
            // Sets the .jQ of the entire math subtree rooted at this command.
            // Expects .createBlocks() to have been called already, since it
            // calls .html().
            var jQ = $(html);

            function jQadd(el) {
                if (el.getAttribute) {
                    var cmdId = el.getAttribute('mathquill-command-id');
                    var blockId = el.getAttribute('mathquill-block-id');
                    if (cmdId) MathElement[cmdId].jQadd(el);
                    if (blockId) MathElement[blockId].jQadd(el);
                }
            }

            function traverse(el) {
                for (el = el.firstChild; el; el = el.nextSibling) {
                    jQadd(el);
                    if (el.firstChild) traverse(el);
                }
            }

            for (var i = 0; i < jQ.length; i += 1) {
                jQadd(jQ[i]);
                traverse(jQ[i]);
            }
            return jQ;
        };

        _.finalizeInsert = function() {
            var self = this;
            self.postOrder('finalizeTree');

            // note: this order is important.
            // empty elements need the empty box provided by blur to
            // be present in order for their dimensions to be measured
            // correctly in redraw.
            self.postOrder('blur');

            // adjust context-sensitive spacing
            self.postOrder('respace');
            if (self.next.respace) self.next.respace();
            if (self.prev.respace) self.prev.respace();

            self.postOrder('redraw');
            self.bubble('redraw');
            self.bubble('redraw');
        };

        _.seek = function(cursor, clientX, clientY, root, clientRect) {
            var frontier = [];

            function popClosest() {
                var iClosest, minSqDist = Infinity;
                for (var i = 0; i < frontier.length; i += 1) {
                    if (!frontier[i]) continue;
                    var sqDist = frontier[i].sqDist;
                    if (sqDist < minSqDist) iClosest = i, minSqDist = sqDist;
                }
                var closest = frontier[iClosest];
                frontier[iClosest] = null;
                return closest;
            }

            function seekPoint(node) {
                var pt = node.seekPoint(clientX, clientY, clientRect);
                if (!pt) return;
                var dx = clientX - pt.x,
                    dy = clientY - pt.y;
                frontier.push({ point: pt, sqDist: dx * dx + dy * dy });
            }

            function addNode(node) {
                if (!node) return;
                var rect = clientRect(node);
                var closestX = max(rect.left, min(rect.right, clientX));
                var closestY = max(rect.top, min(rect.bottom, clientY));
                var dx = clientX - closestX,
                    dy = clientY - closestY;
                frontier.push({ node: node, sqDist: dx * dx + dy * dy });
            }

            function addContainer(node) {
                if (node === root) return; // no potential Points outside root container
                var rect = clientRect(node);
                var dist = max(0, min(clientX - rect.left, clientY - rect.top,
                    rect.right - clientX, rect.bottom - clientY));
                frontier.push({ container: node, sqDist: dist * dist });
            }

            seekPoint(this);
            this.eachChild(addNode);
            addContainer(this);
            for (var closest = popClosest(); !closest.point; closest = popClosest()) {
                if (closest.container) {
                    var container = closest.container,
                        outer = container.parent;
                    seekPoint(outer);
                    outer.eachChild(function(n) { if (n !== container) addNode(n); });
                    addContainer(outer);
                } else {
                    seekPoint(closest.node);
                    closest.node.eachChild(addNode);
                }
            }
            if (closest.point.next) cursor.insertBefore(closest.point.next)
            else cursor.appendTo(closest.point.parent);
        };
    });

    /**
     * Commands and operators, like subscripts, exponents, or fractions.
     * Descendant commands are organized into blocks.
     */
    var MathCommand = P(MathElement, function(_, _super) {
        _.init = function(ctrlSeq, htmlTemplate, textTemplate) {
            var cmd = this;
            _super.init.call(cmd);

            if (!cmd.ctrlSeq) cmd.ctrlSeq = ctrlSeq;
            if (htmlTemplate) cmd.htmlTemplate = htmlTemplate;
            if (textTemplate) cmd.textTemplate = textTemplate;
        };

        // obvious methods
        _.replaces = function(replacedFragment) {
            replacedFragment.disown();
            this.replacedFragment = replacedFragment;
        };
        _.isEmpty = function() {
            return this.foldChildren(true, function(isEmpty, child) {
                return isEmpty && child.isEmpty();
            });
        };

        _.parser = function() {
            var block = latexMathParser.block;
            var self = this;

            return block.times(self.numBlocks()).map(function(blocks) {
                self.blocks = blocks;

                for (var i = 0; i < blocks.length; i += 1) {
                    blocks[i].adopt(self, self.lastChild, 0);
                }

                return self;
            });
        };

        // createBefore(cursor) and the methods it calls
        _.createBefore = function(cursor) {
            var cmd = this;
            var replacedFragment = cmd.replacedFragment;

            cmd.createBlocks();
            MathElement.jQize(cmd.html());
            if (replacedFragment) {
                replacedFragment.adopt(cmd.firstChild, 0, 0);
                replacedFragment.jQ.appendTo(cmd.firstChild.jQ);
            }

            cursor.jQ.before(cmd.jQ);
            cursor.prev = cmd.adopt(cursor.parent, cursor.prev, cursor.next);

            cmd.finalizeInsert(cursor);

            cmd.placeCursor(cursor);
        };
        _.createBlocks = function() {
            var cmd = this,
                numBlocks = cmd.numBlocks(),
                blocks = cmd.blocks = Array(numBlocks);

            for (var i = 0; i < numBlocks; i += 1) {
                var newBlock = blocks[i] = MathBlock();
                newBlock.adopt(cmd, cmd.lastChild, 0);
            }
        };
        _.respace = noop; //placeholder for context-sensitive spacing
        _.placeCursor = function(cursor) {
            //append the cursor to the first empty child, or if none empty, the last one
            cursor.appendTo(this.foldChildren(this.firstChild, function(prev, child) {
                return prev.isEmpty() ? prev : child;
            }));
        };

        _.seekPoint = noop;
        _.expectedCursorYNextTo = function(clientRect) {
            return this.firstChild.expectedCursorYInside(clientRect);
        };

        // remove()
        _.remove = function() {
            this.disown()
            this.jQ.remove();

            this.postOrder(function(el) { delete MathElement[el.id]; });

            return this;
        };

        // methods involved in creating and cross-linking with HTML DOM nodes
        /*
          They all expect an .htmlTemplate like
            '<span>&0</span>'
          or
            '<span><span>&0</span><span>&1</span></span>'

          See html.test.js for more examples.

          Requirements:
          - For each block of the command, there must be exactly one "block content
            marker" of the form '&<number>' where <number> is the 0-based index of the
            block. (Like the LaTeX \newcommand syntax, but with a 0-based rather than
            1-based index, because JavaScript because C because Dijkstra.)
          - The block content marker must be the sole contents of the containing
            element, there can't even be surrounding whitespace, or else we can't
            guarantee sticking to within the bounds of the block content marker when
            mucking with the HTML DOM.
          - The HTML not only must be well-formed HTML (of course), but also must
            conform to the XHTML requirements on tags, specifically all tags must
            either be self-closing (like '<br/>') or come in matching pairs.
            Close tags are never optional.

          Note that &<number> isn't well-formed HTML; if you wanted a literal '&123',
          your HTML template would have to have '&amp;123'.
        */
        _.numBlocks = function() {
            var matches = this.htmlTemplate.match(/&\d+/g);
            return matches ? matches.length : 0;
        };
        _.html = function() {
            // Render the entire math subtree rooted at this command, as HTML.
            // Expects .createBlocks() to have been called already, since it uses the
            // .blocks array of child blocks.
            //
            // See html.test.js for example templates and intended outputs.
            //
            // Given an .htmlTemplate as described above,
            // - insert the mathquill-command-id attribute into all top-level tags,
            //   which will be used to set this.jQ in .jQize().
            //   This is straightforward:
            //     * tokenize into tags and non-tags
            //     * loop through top-level tokens:
            //         * add #cmdId attribute macro to top-level self-closing tags
            //         * else add #cmdId attribute macro to top-level open tags
            //             * skip the matching top-level close tag and all tag pairs
            //               in between
            // - for each block content marker,
            //     + replace it with the contents of the corresponding block,
            //       rendered as HTML
            //     + insert the mathquill-block-id attribute into the containing tag
            //   This is even easier, a quick regex replace, since block tags cannot
            //   contain anything besides the block content marker.
            //
            // Two notes:
            // - The outermost loop through top-level tokens should never encounter any
            //   top-level close tags, because we should have first encountered a
            //   matching top-level open tag, all inner tags should have appeared in
            //   matching pairs and been skipped, and then we should have skipped the
            //   close tag in question.
            // - All open tags should have matching close tags, which means our inner
            //   loop should always encounter a close tag and drop nesting to 0. If
            //   a close tag is missing, the loop will continue until i >= tokens.length
            //   and token becomes undefined. This will not infinite loop, even in
            //   production without pray(), because it will then TypeError on .slice().

            var cmd = this;
            var blocks = cmd.blocks;
            var cmdId = ' mathquill-command-id=' + cmd.id;
            var tokens = cmd.htmlTemplate.match(/<[^<>]+>|[^<>]+/g);

            pray('no unmatched angle brackets', tokens.join('') === this.htmlTemplate);

            // add cmdId to all top-level tags
            for (var i = 0, token = tokens[0]; token; i += 1, token = tokens[i]) {
                // top-level self-closing tags
                if (token.slice(-2) === '/>') {
                    tokens[i] = token.slice(0, -2) + cmdId + '/>';
                }
                // top-level open tags
                else if (token.charAt(0) === '<') {
                    pray('not an unmatched top-level close tag', token.charAt(1) !== '/');

                    tokens[i] = token.slice(0, -1) + cmdId + '>';

                    // skip matching top-level close tag and all tag pairs in between
                    var nesting = 1;
                    do {
                        i += 1, token = tokens[i];
                        pray('no missing close tags', token);
                        // close tags
                        if (token.slice(0, 2) === '</') {
                            nesting -= 1;
                        }
                        // non-self-closing open tags
                        else if (token.charAt(0) === '<' && token.slice(-2) !== '/>') {
                            nesting += 1;
                        }
                    } while (nesting > 0);
                }
            }
            return tokens.join('').replace(/>&(\d+)/g, function($0, $1) {
                return ' mathquill-block-id=' + blocks[$1].id + '>' + blocks[$1].join('html');
            });
        };

        // methods to export a string representation of the math tree
        _.latex = function() {
            return this.foldChildren(this.ctrlSeq, function(latex, child) {
                return latex + '{' + (child.latex() || ' ') + '}';
            });
        };
        _.textTemplate = [''];
        _.text = function() {
            var i = 0;
            return this.foldChildren(this.textTemplate[i], function(text, child) {
                i += 1;
                var child_text = child.text();
                if (text && this.textTemplate[i] === '(' &&
                    child_text[0] === '(' && child_text.slice(-1) === ')')
                    return text + child_text.slice(1, -1) + this.textTemplate[i];
                return text + child.text() + (this.textTemplate[i] || '');
            });
        };
    });

    /**
     * Lightweight command without blocks or children.
     */
    var Symbol = P(MathCommand, function(_, _super) {
        _.init = function(ctrlSeq, html, text) {
            if (!text) text = ctrlSeq && ctrlSeq.length > 1 ? ctrlSeq.slice(1) : ctrlSeq;

            _super.init.call(this, ctrlSeq, html, [text]);
        };

        _.parser = function() { return Parser.succeed(this); };
        _.numBlocks = function() { return 0; };

        _.replaces = function(replacedFragment) {
            replacedFragment.remove();
        };
        _.createBlocks = noop;

        _.seek = function(cursor, clientX, clientY, root, clientRect) {
            var rect = clientRect(this),
                left = rect.left,
                right = rect.right;
            // insert at whichever side the click was closer to
            if (clientX - left < right - clientX) cursor.insertBefore(this);
            else cursor.insertAfter(this);
        };
        _.expectedCursorYNextTo = function(clientRect) {
            return (clientRect(this).top + clientRect(this).bottom) / 2;
        };

        _.latex = function() { return this.ctrlSeq; };
        _.text = function() { return this.textTemplate; };
        _.placeCursor = noop;
        _.isEmpty = function() { return true; };
    });

    /**
     * Children and parent of MathCommand's. Basically partitions all the
     * symbols and operators that descend (in the Math DOM tree) from
     * ancestor operators.
     */
    var MathBlock = P(MathElement, function(_) {
        _.join = function(methodName) {
            return this.foldChildren('', function(fold, child) {
                return fold + child[methodName]();
            });
        };
        _.latex = function() { return this.join('latex'); };
        _.text = function() {
            return this.firstChild === this.lastChild ?
                this.firstChild.text() :
                '(' + this.join('text') + ')';
        };
        _.isEmpty = function() {
            return this.firstChild === 0 && this.lastChild === 0;
        };
        _.seekPoint = function(clientX, clientY, clientRect) {
            if (!this.firstChild) {
                var pt = { next: 0, x: (clientRect(this).left + clientRect(this).right) / 2 };
            } else {
                function pointLeftOf(n) { return { next: n, x: clientRect(n).left }; }
                var pt = pointLeftOf(this.firstChild);
                if (clientX > pt.x) {
                    pt = pointLeftOf(this.lastChild);
                    var rightwardPt = { next: 0, x: clientRect(pt.next).right };
                    while (clientX < pt.x) rightwardPt = pt, pt = pointLeftOf(pt.next.prev);
                    if (rightwardPt.x - clientX < clientX - pt.x) pt = rightwardPt;
                }
            }
            return {
                parent: this,
                next: pt.next,
                x: pt.x,
                y: this.expectedCursorYInside(clientRect)
            };
        };
        _.expectedCursorYInside = function(clientRect) {
            if (this.firstChild) return this.firstChild.expectedCursorYNextTo(clientRect);
            else return (clientRect(this).top + clientRect(this).bottom) / 2;
        };
        _.focus = function() {
            this.jQ.addClass('mq-hasCursor');
            this.jQ.removeClass('mq-empty');

            return this;
        };
        _.blur = function() {
            this.jQ.removeClass('mq-hasCursor');
            if (this.isEmpty())
                this.jQ.addClass('mq-empty');

            return this;
        };
    });

    /**
     * Math tree fragment base class.
     * Some math-tree-specific extensions to Fragment.
     */
    var MathFragment = P(Fragment, function(_, _super) {
        _.init = function(first, last) {
            // just select one thing if only one argument
            _super.init.call(this, first, last || first);
            this.jQ = this.fold($(), function(jQ, child) { return child.jQ.add(jQ); });
        };
        _.latex = function() {
            return this.fold('', function(latex, el) { return latex + el.latex(); });
        };
        _.remove = function() {
            this.jQ.remove();

            this.each(function(el) {
                el.postOrder(function(desc) {
                    delete MathElement[desc.id];
                });
            });

            return this.disown();
        };
    });
    /*********************************************
     * Root math elements with event delegation.
     ********************************************/

    function createRoot(container, root, textbox, editable) {
        var contents = container.contents().detach();

        if (!textbox) {
            container.addClass('mathquill-rendered-math');
        }

        root.jQ = $('<span class="mathquill-root-block"/>').appendTo(container.attr(mqBlockId, root.id));
        root.revert = function() {
            container.empty().unbind('.mathquill')
                .removeClass('mathquill-rendered-math mathquill-editable mathquill-textbox')
                .append(contents);
        };

        root.cursor = Cursor(root);

        root.renderLatex(contents.text());
    }

    function setupTextarea(editable, container, root, cursor) {
        var textareaSpan = root.textarea = $('<span class="mq-textarea"></span>');
        textarea = $(document.createElement('textarea')).appendTo(textareaSpan)
        spanarea = $(document.createElement('span')).appendTo(textareaSpan)

        /******
         * TODO [Han]: Document this
         */
        var textareaSelectionTimeout;
        root.selectionChanged = function() {
            if (textareaSelectionTimeout === undefined) {
                textareaSelectionTimeout = setTimeout(setTextareaSelection);
            }
            forceIERedraw(container[0]);
        };

        function setTextareaSelection() {
            textareaSelectionTimeout = undefined;
            var latex = cursor.selection ? '$' + cursor.selection.latex() + '$' : '';
            root.textareaManager.select(latex);
            root.triggerSpecialEvent('selectionChanged');
        }

        // TODO - this causes issues with IE. I don't think we need it
        // since we prevent text selection with css. Would be best
        // to figure out how to fix this.
        /*
        //prevent native selection except textarea
        container.bind('selectstart.mathquill', function(e) {
          if (e.target !== textarea[0] && e.target !== spanarea[0]) e.preventDefault();
          e.stopPropagation();
        });*/

        hookUpTextarea(editable, container, root, cursor, textarea, spanarea, textareaSpan, setTextareaSelection);
    }

    function mouseEvents(ultimateRootjQ) {
        //drag-to-select event handling
        ultimateRootjQ.bind('mousedown.mathquill', function(e) {
            e.preventDefault();

            var container = $(e.target);
            if (!container.hasClass('mathquill-editable')) {
                container = container.closest('.mathquill-root-block').parent();
            }
            var root = MathElement[container.attr(mqBlockId) || ultimateRootjQ.attr(mqBlockId)];
            var cursor = root.cursor,
                blink = cursor.blink;
            var textareaSpan = root.textarea;

            if (root.ignoreMousedownTimeout !== undefined) {
                clearTimeout(root.ignoreMousedownTimeout);
                root.ignoreMousedownTimeout = undefined;
                return;
            }

            var cachedClientRect = cachedClientRectFnForNewCache();

            function mousemove(e) {
                cursor.seek($(e.target), e.clientX, e.clientY, cachedClientRect);

                if (cursor.prev !== anticursor.prev ||
                    cursor.parent !== anticursor.parent) {
                    cursor.selectFrom(anticursor);
                }

                e.preventDefault();
            }

            // docmousemove is attached to the document, so that
            // selection still works when the mouse leaves the window.
            function docmousemove(e) {
                // [Han]: i delete the target because of the way seek works.
                // it will not move the mouse to the target, but will instead
                // just seek those X and Y coordinates.  If there is a target,
                // it will try to move the cursor to document, which will not work.
                // cursor.seek needs to be refactored.
                delete e.target;

                return mousemove(e);
            }

            function mouseup(e) {
                anticursor = undefined;
                cursor.blink = blink;
                if (!cursor.selection) {
                    if (root.editable) {
                        cursor.show();
                    } else {
                        textareaSpan.detach();
                    }
                }

                // delete the mouse handlers now that we're not dragging anymore
                container.unbind('mousemove', mousemove);
                $(e.target.ownerDocument).unbind('mousemove', docmousemove).unbind('mouseup', mouseup);
            }

            cursor.blink = noop;
            cursor.hideHandle().seek($(e.target), e.clientX, e.clientY, cachedClientRect);

            var anticursor = { parent: cursor.parent, prev: cursor.prev, next: cursor.next };

            if (!root.editable && root.blurred) container.prepend(textareaSpan);
            root.textareaManager.focus();
            root.blurred = false;

            container.mousemove(mousemove);
            $(e.target.ownerDocument).mousemove(docmousemove).mouseup(mouseup);
        });
    }

    function setupTouchHandle(editable, root, cursor) {
        // event handling for touch-draggable handle
        /**
         * Usage:
         * jQ.on('touchstart', firstFingerOnly(function(touchstartCoords) {
         *   return { // either of these are optional:
         *     touchmove: function(touchmoveCoords) {},
         *     touchend: function(touchendCoords) {}
         *   };
         * });
         */
        function firstFingerOnly(ontouchstart) {
            return function(e) {
                e.preventDefault();
                var e = e.originalEvent,
                    target = $(e.target);
                if (e.changedTouches.length < e.touches.length) return; // not first finger
                var touchstart = e.changedTouches[0];
                var handlers = ontouchstart(touchstart) || 0;
                if (handlers.touchmove) {
                    target.bind('touchmove', function(e) {
                        var touchmove = e.originalEvent.changedTouches[0];
                        if (touchmove.id !== touchstart.id) return;
                        handlers.touchmove.call(this, touchmove);
                    });
                }
                target.bind('touchend', function(e) {
                    var touchend = e.originalEvent.changedTouches[0];
                    if (touchend.id !== touchstart.id) return;
                    if (handlers.touchend) handlers.touchend.call(this, touchend);
                    target.unbind('touchmove touchend');
                });
            };
        }
        var blink = cursor.blink;
        cursor.handle.on('touchstart', firstFingerOnly(function(e) {
            cursor.blink = noop;
            var cursorRect = cursor.jQ[0].getBoundingClientRect();
            var offsetX = e.clientX - cursorRect.left;
            var offsetY = e.clientY - (cursorRect.top + cursorRect.bottom) / 2;
            var cachedClientRect = cachedClientRectFnForNewCache();
            var onAnimationEnd;
            root.onAnimationEnd = function() { onAnimationEnd(); };
            return {
                touchmove: function(e) {
                    var adjustedX = e.clientX - offsetX,
                        adjustedY = e.clientY - offsetY;
                    cursor.seek(elAtPt(adjustedX, adjustedY, root), adjustedX, adjustedY, cachedClientRect, true);
                    visualHapticFeedback();
                    onAnimationEnd = visualHapticFeedback;

                    function visualHapticFeedback() {
                        var cursorRect = cursor.jQ[0].getBoundingClientRect();
                        cursor.repositionHandle(cursorRect);

                        var dx = adjustedX - cursorRect.left;
                        var dy = adjustedY - (cursorRect.top + cursorRect.bottom) / 2;
                        var dist = Math.sqrt(dx * dx + dy * dy);
                        var weight = (Math.log(dist) + 1) / dist;
                        var skewX = Math.atan2(weight * dx, offsetY);
                        var scaleY = (weight * dy + offsetY) / offsetY;
                        var steeperScale = 2 * (scaleY - 1) + 1;
                        cursor.handle.css({
                            WebkitTransform: 'translateX(.5px) skewX(' + skewX + 'rad) scaleY(' + scaleY + ')',
                            opacity: 1 - steeperScale * .5
                        });
                    }
                },
                touchend: function(e) {
                    cursor.handle.css({ WebkitTransform: '', opacity: '' });
                    cursor.blink = blink;
                    cursor.show(true);
                    onAnimationEnd = function() {
                        cursor.repositionHandle(cursor.jQ[0].getBoundingClientRect());
                        cursor.handle.css({ WebkitTransform: '', opacity: '' });
                        delete root.onAnimationEnd;
                    };
                }
            };
        }));
    }

    function hookUpTextarea(editable, container, root, cursor, textarea, spanarea, textareaSpan, setTextareaSelection) {
        if (!editable) {
            root.blurred = true;
            root.textareaManager = manageTextarea(textarea, spanarea, { container: container });
            container.bind('copy', setTextareaSelection)
                .prepend('<span class="mq-selectable">$' + root.latex() + '$</span>');
            textarea.bind('cut paste', false).blur(function() {
                cursor.clearSelection();
                setTimeout(detach); //detaching during blur explodes in WebKit
            });

            function detach() {
                textareaSpan.detach();
                root.blurred = true;
            }
            return;
        }

        root.textareaManager = manageTextarea(textarea, spanarea, {
            container: container,
            key: function(key, evt) {
                cursor.parent.bubble('onKey', key, evt);
            },
            text: function(text) {
                cursor.parent.bubble('onText', text);
            },
            cut: function(e) {
                if (cursor.selection) {
                    setTimeout(function() {
                        cursor.prepareEdit();
                        cursor.parent.bubble('redraw');
                        root.triggerSpecialEvent('render');
                    });
                }

                e.stopPropagation();
                root.triggerSpecialEvent('render');
            },
            paste: function(text) {
                // FIXME HACK the parser in RootTextBlock needs to be moved to
                // Cursor::writeLatex or something so this'll work with
                // MathQuill textboxes
                if (text.slice(0, 1) === '$' && text.slice(-1) === '$') {
                    text = text.slice(1, -1);
                }

                cursor.writeLatex(text).show();
                root.triggerSpecialEvent('render');
            }
        });

        container.prepend(textareaSpan);
    }

    function rootCSSClasses(container, textbox) {
        container.addClass('mathquill-editable');
        if (textbox)
            container.addClass('mathquill-textbox');
    }

    function focusBlurEvents(root, cursor) {
        root.textareaManager.onFocus = function() {
            root.blurred = false;
            if (!cursor.parent)
                cursor.appendTo(root);
            cursor.parent.jQ.addClass('mq-hasCursor');
            if (cursor.selection) {
                cursor.selection.jQ.removeClass('mq-blur');
                setTimeout(root.selectionChanged); //re-select textarea contents after tabbing away and back
            } else {
                cursor.show();
            }
        };

        root.textareaManager.onBlur = function() {
            root.blurred = true;
            cursor.hide().parent.blur();
            if (cursor.selection) {
                cursor.selection.jQ.addClass('mq-blur');
            }
        };

        root.textareaManager.onBlur()
    }

    function desmosCustomEvents(container, root, cursor) {
        container.bind('select_all', function(e) {
                cursor.prepareMove().appendTo(root);
                while (cursor.prev) cursor.selectLeft();
            })
            .bind('custom_paste', function(e, text) {
                if (text.slice(0, 1) === '$' && text.slice(-1) === '$') {
                    text = text.slice(1, -1);
                }

                cursor.writeLatex(text).show();
                root.triggerSpecialEvent('render');
            });
    }

    function elAtPt(clientX, clientY, root) {
        var el = document.elementFromPoint(clientX, clientY);
        return $.contains(root.jQ[0], el) ? $(el) : root.jQ;
    }

    function cachedClientRectFnForNewCache() {
        var cache = {};

        function elById(el, id) {
            if (!cache[id]) {
                pray('only called within Cursor::seek', 'scrollLeft' in cachedClientRect);
                var rect = el.getBoundingClientRect(),
                    dx = cachedClientRect.scrollLeft;
                cache[id] = {
                    top: rect.top,
                    right: rect.right + dx,
                    bottom: rect.bottom,
                    left: rect.left + dx
                };
            }
            return cache[id];
        };

        function cachedClientRect(node) { return elById(node.jQ[0], node.id); };
        cachedClientRect.elById = elById;
        return cachedClientRect;
    }

    var RootMathBlock = P(MathBlock, function(_, _super) {
        _.latex = function() {
            return _super.latex.call(this).replace(/(\\[a-z]+) (?![a-z])/ig, '$1');
        };
        _.text = function() {
            return this.foldChildren('', function(text, child) {
                return text + child.text();
            });
        };
        _.renderLatex = function(latex) {
            var all = Parser.all;
            var eof = Parser.eof;

            var block = latexMathParser.skip(eof).or(all.result(false)).parse(latex);
            this.firstChild = this.lastChild = 0;
            if (block) {
                block.children().adopt(this, 0, 0);
            }

            var jQ = this.jQ;

            if (block) {
                var html = block.join('html');
                jQ.html(html);
                MathElement.jQize(jQ);
                this.focus().finalizeInsert();
            } else {
                jQ.empty();
            }

            this.cursor.appendTo(this);
        };
        _.renderSliderLatex = function(latex) {
            function makeCmd(ch) {
                var cmd;
                var code = ch.charCodeAt(0);
                if ((65 <= code && code <= 90) || (97 <= code && code <= 122))
                    cmd = Variable(ch);
                else {
                    if (CharCmds[ch] || LatexCmds[ch])
                        cmd = (CharCmds[ch] || LatexCmds[ch])(ch);
                    else {
                        cmd = VanillaSymbol(ch);
                    }
                }
                return cmd;
            }

            // valid assignment left-hand-sides: https://github.com/desmosinc/knox/blob/27709c6066a544f160123a6bd775829ec8cd7080/frontend/desmos/publicgrapher/jison/latex.jison#L13-L15
            var matches = /^([a-z])(?:_([a-z0-9]|\{[a-z0-9]+\}))?=([-0-9.]+)$/i.exec(latex);

            pray('valid restricted slider LaTeX', matches);
            var letter = matches[1];
            var subscript = matches[2];
            var value = matches[3];

            this.firstChild = this.lastChild = 0;

            letter = Variable(letter);

            if (subscript) {
                var sub = LatexCmds._('_');
                var subBlock = MathBlock().adopt(sub, 0, 0);
                sub.blocks = [subBlock];
                if (subscript.length === 1) {
                    makeCmd(subscript).adopt(subBlock, subBlock.lastChild, 0);
                } else {
                    for (var i = 1; i < subscript.length - 1; i += 1) {
                        makeCmd(subscript.charAt(i)).adopt(subBlock, subBlock.lastChild, 0);
                    }
                }
            }

            letter.adopt(this, this.lastChild, 0);
            if (sub) sub.adopt(this, this.lastChild, 0);
            LatexCmds['=']('=').adopt(this, this.lastChild, 0);
            for (var i = 0, l = value.length; i < l; i += 1) {
                var ch = value.charAt(i);
                var cmd = makeCmd(ch);
                cmd.adopt(this, this.lastChild, 0);
            }

            var jQ = this.jQ;

            var html = this.join('html');
            jQ.html(html);
            MathElement.jQize(jQ);
            //this.finalizeInsert();

            this.cursor.parent = this;
            this.cursor.prev = this.lastChild;
            this.cursor.next = 0;
        };
        _.up = function() { this.triggerSpecialEvent('upPressed'); };
        _.down = function() { this.triggerSpecialEvent('downPressed'); };
        _.moveOutOf = function(dir) { this.triggerSpecialEvent(dir + 'Pressed'); };
        _.onKey = function(key, e) {
            switch (key) {
                case 'Ctrl-Shift-Backspace':
                case 'Ctrl-Backspace':
                    while (this.cursor.prev || this.cursor.selection) {
                        this.cursor.backspace();
                    }
                    break;

                case 'Shift-Backspace':
                case 'Backspace':
                    this.cursor.backspace();
                    this.triggerSpecialEvent('render');
                    break;

                    // Tab or Esc -> go one block right if it exists, else escape right.
                case 'Esc':
                case 'Tab':
                    var parent = this.cursor.parent;
                    // cursor is in root editable, continue default
                    if (parent === this.cursor.root) return;

                    this.cursor.prepareMove();
                    if (parent.next) {
                        // go one block right
                        this.cursor.prependTo(parent.next);
                    } else {
                        // get out of the block
                        this.cursor.insertAfter(parent.parent);
                    }
                    break;

                    // Shift-Tab -> go one block left if it exists, else escape left.
                case 'Shift-Tab':
                case 'Shift-Esc':
                    var parent = this.cursor.parent;
                    //cursor is in root editable, continue default
                    if (parent === this.cursor.root) return;

                    this.cursor.prepareMove();
                    if (parent.prev) {
                        // go one block left
                        this.cursor.appendTo(parent.prev);
                    } else {
                        //get out of the block
                        this.cursor.insertBefore(parent.parent);
                    }
                    break;

                    // Prevent newlines from showing up
                case 'Enter':
                    this.triggerSpecialEvent('enterPressed');
                    break;


                    // End -> move to the end of the current block.
                case 'End':
                    this.cursor.prepareMove().appendTo(this.cursor.parent);
                    break;

                    // Ctrl-End -> move all the way to the end of the root block.
                case 'Ctrl-End':
                    this.cursor.prepareMove().appendTo(this);
                    break;

                    // Shift-End -> select to the end of the current block.
                case 'Shift-End':
                    while (this.cursor.next) {
                        this.cursor.selectRight();
                    }
                    break;

                    // Ctrl-Shift-End -> select to the end of the root block.
                case 'Ctrl-Shift-End':
                    while (this.cursor.next || this.cursor.parent !== this) {
                        this.cursor.selectRight();
                    }
                    break;

                    // Home -> move to the start of the root block or the current block.
                case 'Home':
                    this.cursor.prepareMove().prependTo(this.cursor.parent);
                    break;

                    // Ctrl-Home -> move to the start of the current block.
                case 'Ctrl-Home':
                    this.cursor.prepareMove().prependTo(this);
                    break;

                    // Shift-Home -> select to the start of the current block.
                case 'Shift-Home':
                    while (this.cursor.prev) {
                        this.cursor.selectLeft();
                    }
                    break;

                    // Ctrl-Shift-Home -> move to the start of the root block.
                case 'Ctrl-Shift-Home':
                    while (this.cursor.prev || this.cursor.parent !== this) {
                        this.cursor.selectLeft();
                    }
                    break;

                case 'Left':
                    this.cursor.moveLeft();
                    break;
                case 'Shift-Left':
                    this.cursor.selectLeft();
                    break;
                case 'Ctrl-Left':
                    break;
                case 'Meta-Left':
                    break;

                case 'Right':
                    this.cursor.moveRight();
                    break;
                case 'Shift-Right':
                    this.cursor.selectRight();
                    break;
                case 'Ctrl-Right':
                    break;
                case 'Meta-Right':
                    break;

                case 'Up':
                    this.cursor.moveUp();
                    break;
                case 'Down':
                    this.cursor.moveDown();
                    break;

                case 'Shift-Up':
                    if (this.cursor.prev) {
                        while (this.cursor.prev) this.cursor.selectLeft();
                    } else {
                        this.cursor.selectLeft();
                    }

                case 'Shift-Down':
                    if (this.cursor.next) {
                        while (this.cursor.next) this.cursor.selectRight();
                    } else {
                        this.cursor.selectRight();
                    }

                case 'Ctrl-Up':
                    break;
                case 'Meta-Up':
                    break;
                case 'Ctrl-Down':
                    break;
                case 'Meta-Down':
                    break;

                case 'Ctrl-Shift-Del':
                case 'Ctrl-Del':
                    while (this.cursor.next || this.cursor.selection) {
                        this.cursor.deleteForward();
                    }
                    this.triggerSpecialEvent('render');
                    break;

                case 'Shift-Del':
                case 'Del':
                    this.cursor.deleteForward();
                    this.triggerSpecialEvent('render');
                    break;

                case 'Meta-A':
                case 'Ctrl-A':
                    //so not stopPropagation'd at RootMathCommand
                    if (this !== this.cursor.root) return;

                    this.cursor.prepareMove().appendTo(this);
                    while (this.cursor.prev) this.cursor.selectLeft();
                    break;

                default:
                    this.scrollHoriz();
                    return false;
            }
            e.preventDefault();
            this.scrollHoriz();
            return false;
        };
        _.onText = function(ch) {
            this.cursor.write(ch);
            this.triggerSpecialEvent('render');
            this.scrollHoriz();
            return false;
        };
        _.scrollHoriz = function() {
            var cursor = this.cursor,
                seln = cursor.selection;
            var rootRect = this.jQ[0].getBoundingClientRect();
            if (!seln) {
                if (!cursor.jQ[0]) return;
                var x = cursor.jQ[0].getBoundingClientRect().left;
                if (x > rootRect.right - 20) var scrollBy = x - (rootRect.right - 20);
                else if (x < rootRect.left + 20) var scrollBy = x - (rootRect.left + 20);
                else return;
            } else {
                var rect = seln.jQ[0].getBoundingClientRect();
                var overLeft = rect.left - (rootRect.left + 20);
                var overRight = rect.right - (rootRect.right - 20);
                if (seln.first === cursor.next) {
                    if (overLeft < 0) var scrollBy = overLeft;
                    else if (overRight > 0) {
                        if (rect.left - overRight < rootRect.left + 20) var scrollBy = overLeft;
                        else var scrollBy = overRight;
                    } else return;
                } else {
                    if (overRight > 0) var scrollBy = overRight;
                    else if (overLeft < 0) {
                        if (rect.right - overLeft > rootRect.right - 20) var scrollBy = overRight;
                        else var scrollBy = overLeft;
                    } else return;
                }
            }
            this.jQ.stop().animate({ scrollLeft: '+=' + scrollBy }, 100, this.onAnimationEnd);
        };

        //triggers a special event occured:
        //  1) pressed up and was at 'top' of equation
        //  2) pressed down and was at 'bottom' of equation
        //  3) pressed backspace and equation was empty
        //  4) the equation was rendered
        //  5) etc
        _.triggerSpecialEvent = function(eventName) {
            var jQ = this.jQ;
            setTimeout(function() { jQ.trigger(eventName); }, 1);
        };
    });

    var RootMathCommand = P(MathCommand, function(_, _super) {
        _.init = function(cursor) {
            _super.init.call(this, '$');
            this.cursor = cursor;
        };
        _.htmlTemplate = '<span class="mathquill-rendered-math">&0</span>';
        _.createBlocks = function() {
            this.firstChild =
                this.lastChild =
                RootMathBlock();

            this.blocks = [this.firstChild];

            this.firstChild.parent = this;

            var cursor = this.firstChild.cursor = this.cursor;
            this.firstChild.onText = function(ch) {
                if (ch !== '$' || cursor.parent !== this)
                    cursor.write(ch);
                else if (this.isEmpty()) {
                    cursor.insertAfter(this.parent).backspace()
                        .insertNew(VanillaSymbol('\\$', '$')).show();
                } else if (!cursor.next)
                    cursor.insertAfter(this.parent);
                else if (!cursor.prev)
                    cursor.insertBefore(this.parent);
                else
                    cursor.write(ch);

                return false;
            };
        };
        _.latex = function() {
            return '$' + this.firstChild.latex() + '$';
        };
    });

    var RootTextBlock = P(MathBlock, function(_) {
        _.renderLatex = function(latex) {
            var self = this
            var cursor = self.cursor;
            self.jQ.children().slice(1).remove();
            self.firstChild = self.lastChild = 0;
            cursor.show().appendTo(self);

            var regex = Parser.regex;
            var string = Parser.string;
            var eof = Parser.eof;
            var all = Parser.all;

            // Parser RootMathCommand
            var mathMode = string('$').then(latexMathParser)
                // because TeX is insane, math mode doesn't necessarily
                // have to end.  So we allow for the case that math mode
                // continues to the end of the stream.
                .skip(string('$').or(eof))
                .map(function(block) {
                    // HACK FIXME: this shouldn't have to have access to cursor
                    var rootMathCommand = RootMathCommand(cursor);

                    rootMathCommand.createBlocks();
                    var rootMathBlock = rootMathCommand.firstChild;
                    block.children().adopt(rootMathBlock, 0, 0);

                    return rootMathCommand;
                });

            var escapedDollar = string('\\$').result('$');
            var textChar = escapedDollar.or(regex(/^[^$]/)).map(VanillaSymbol);
            var latexText = mathMode.or(textChar).many();
            var commands = latexText.skip(eof).or(all.result(false)).parse(latex);

            if (commands) {
                for (var i = 0; i < commands.length; i += 1) {
                    commands[i].adopt(self, self.lastChild, 0);
                }

                var html = self.join('html');
                MathElement.jQize(html).appendTo(self.jQ);

                this.finalizeInsert();
            }
        };
        _.onKey = RootMathBlock.prototype.onKey;
        _.onText = function(ch) {
            this.cursor.prepareEdit();
            if (ch === '$')
                this.cursor.insertNew(RootMathCommand(this.cursor));
            else
                this.cursor.insertNew(VanillaSymbol(ch));

            return false;
        };
        _.scrollHoriz = RootMathBlock.prototype.scrollHoriz;
    });
    /***************************
     * Commands and Operators.
     **************************/

    var CharCmds = {},
        LatexCmds = {}; //single character commands, LaTeX commands

    var scale, // = function(jQ, x, y) { ... }
        //will use a CSS 2D transform to scale the jQuery-wrapped HTML elements,
        //or the filter matrix transform fallback for IE 5.5-8, or gracefully degrade to
        //increasing the fontSize to match the vertical Y scaling factor.

        //ideas from http://github.com/louisremi/jquery.transform.js
        //see also http://msdn.microsoft.com/en-us/library/ms533014(v=vs.85).aspx

        forceIERedraw = noop,
        div = document.createElement('div'),
        div_style = div.style,
        transformPropNames = {
            transform: 1,
            WebkitTransform: 1,
            MozTransform: 1,
            OTransform: 1,
            msTransform: 1
        },
        transformPropName;

    for (var prop in transformPropNames) {
        if (prop in div_style) {
            transformPropName = prop;
            break;
        }
    }

    if (transformPropName) {
        scale = function(jQ, x, y) {
            jQ.css(transformPropName, 'scale(' + x + ',' + y + ')');
        };
    } else if ('filter' in div_style) { //IE 6, 7, & 8 fallback, see https://github.com/laughinghan/mathquill/wiki/Transforms
        forceIERedraw = function(el) { el.className = el.className; };
        scale = function(jQ, x, y) { //NOTE: assumes y > x
            x /= (1 + (y - 1) / 2);
            jQ.css('fontSize', y + 'em');
            if (!jQ.hasClass('mq-matrixed-container')) {
                jQ.addClass('mq-matrixed-container')
                    .wrapInner('<span class="mq-matrixed"></span>');
            }
            var innerjQ = jQ.children()
                .css('filter', 'progid:DXImageTransform.Microsoft' +
                    '.Matrix(M11=' + x + ",SizingMethod='auto expand')"
                );

            function calculateMarginRight() {
                jQ.css('marginRight', (innerjQ.width() - 1) * (x - 1) / x + 'px');
            }
            calculateMarginRight();
            var intervalId = setInterval(calculateMarginRight);
            $(window).load(function() {
                clearTimeout(intervalId);
                calculateMarginRight();
            });
        };
    } else {
        scale = function(jQ, x, y) {
            jQ.css('fontSize', y + 'em');
        };
    }

    var Style = P(MathCommand, function(_, _super) {
        _.init = function(ctrlSeq, tagName, attrs) {
            _super.init.call(this, ctrlSeq, '<' + tagName + ' ' + attrs + '>&0</' + tagName + '>');
        };
    });

    //fonts
    LatexCmds.mathrm = bind(Style, '\\mathrm', 'span', 'class="mq-roman mq-font"');
    LatexCmds.mathit = bind(Style, '\\mathit', 'i', 'class="mq-font"');
    LatexCmds.mathbf = bind(Style, '\\mathbf', 'b', 'class="mq-font"');
    LatexCmds.mathsf = bind(Style, '\\mathsf', 'span', 'class="mq-sans-serif mq-font"');
    LatexCmds.mathtt = bind(Style, '\\mathtt', 'span', 'class="mq-monospace mq-font"');
    //text-decoration
    LatexCmds.underline = bind(Style, '\\underline', 'span', 'class="mq-non-leaf mq-underline"');
    LatexCmds.overline = LatexCmds.bar = bind(Style, '\\overline', 'span', 'class="mq-non-leaf mq-overline"');

    var SupSub = P(MathCommand, function(_, _super) {
        _.init = function(ctrlSeq, tag, text) {
            _super.init.call(this, ctrlSeq, '<' + tag + ' class="mq-non-leaf"><span class="mq-non-leaf mq-' + tag + '">&0</span></' + tag + '>', [text]);
        };
        _.finalizeTree = function() {
            //TODO: use inheritance
            pray('SupSub is only _ and ^',
                this.ctrlSeq === '^' || this.ctrlSeq === '_'
            );

            if (this.ctrlSeq === '_') {
                this.down = this.firstChild;
                this.firstChild.up = insertBeforeUnlessAtEnd;
            } else {
                this.up = this.firstChild;
                this.firstChild.down = insertBeforeUnlessAtEnd;
            }
        };

        function insertBeforeUnlessAtEnd(cursor) {
            // cursor.insertBefore(cmd), unless cursor at the end of block, and every
            // ancestor cmd is at the end of every ancestor block
            var cmd = this.parent,
                ancestorCmd = cursor;
            do {
                if (ancestorCmd.next) {
                    cursor.insertBefore(cmd);
                    return false;
                }
                ancestorCmd = ancestorCmd.parent.parent;
            } while (ancestorCmd !== cmd);
            cursor.insertAfter(cmd);
            return false;
        }
        _.latex = function() {
            if (this.ctrlSeq === '_' && this.respaced) return '';

            var latex = '';

            if (this.ctrlSeq === '^' && this.next.respaced) {
                var block = this.next.firstChild.latex();
                if (block.length === 1) latex += '_' + block;
                else latex += '_{' + block + '}';
            }

            var block = this.firstChild.latex();
            if (block.length === 1) latex += this.ctrlSeq + block;
            else latex += this.ctrlSeq + '{' + (block || ' ') + '}';

            return latex;
        };
        _.redraw = function() {
            if (this.prev)
                this.prev.respace();
            //SupSub::respace recursively calls respace on all the following SupSubs
            //so if prev is a SupSub, no need to call respace on this or following nodes
            if (!(this.prev instanceof SupSub)) {
                this.respace();
                //and if next is a SupSub, then this.respace() will have already called
                //this.next.respace()
                if (this.next && !(this.next instanceof SupSub))
                    this.next.respace();
            }
        };
        _.respace = function() {
            if (
                this.prev.ctrlSeq === '\\int ' || (
                    this.prev instanceof SupSub && this.prev.ctrlSeq != this.ctrlSeq &&
                    this.prev.prev && this.prev.prev.ctrlSeq === '\\int '
                )
            ) {
                if (!this['int']) {
                    this['int'] = true;
                    this.jQ.addClass('mq-int');
                }
            } else {
                if (this['int']) {
                    this['int'] = false;
                    this.jQ.removeClass('mq-int');
                }
            }

            this.respaced = this.prev instanceof SupSub && this.prev.ctrlSeq != this.ctrlSeq && !this.prev.respaced;
            if (this.respaced) {
                var fontSize = +this.jQ.css('fontSize').slice(0, -2),
                    prevWidth = this.prev.jQ.outerWidth(),
                    thisWidth = this.jQ.outerWidth();
                this.jQ.css({
                    left: (this['int'] && this.ctrlSeq === '_' ? -.25 : 0) - prevWidth / fontSize + 'em',
                    marginRight: .1 - min(thisWidth, prevWidth) / fontSize + 'em'
                        //1px extra so it doesn't wrap in retarded browsers (Firefox 2, I think)
                });
            } else if (this['int'] && this.ctrlSeq === '_') {
                this.jQ.css({
                    left: '-.25em',
                    marginRight: ''
                });
            } else {
                this.jQ.css({
                    left: '',
                    marginRight: ''
                });
            }

            if (this.respaced) {
                if (this.ctrlSeq === '^') this.down = this.firstChild.down = this.prev.firstChild;
                else this.up = this.firstChild.up = this.prev.firstChild;
            } else if (this.next.respaced) {
                if (this.ctrlSeq === '_') this.up = this.firstChild.up = this.next.firstChild;
                else this.down = this.firstChild.down = this.next.firstChild;
            } else {
                if (this.ctrlSeq === '_') {
                    delete this.up;
                    this.firstChild.up = insertBeforeUnlessAtEnd;
                } else {
                    delete this.down;
                    this.firstChild.down = insertBeforeUnlessAtEnd;
                }
            }

            if (this.next instanceof SupSub)
                this.next.respace();

            return this;
        };

        _.onKey = function(key, e) {
            if (this.getCursor().parent.parent !== this) return;

            switch (key) {
                case 'Tab':
                    if (this.next.respaced) {
                        this.getCursor().prepareMove().prependTo(this.next.firstChild);
                        e.preventDefault();
                        return false;
                    }
                    break;
                case 'Shift-Tab':
                    if (this.respaced) {
                        this.getCursor().prepareMove().appendTo(this.prev.firstChild);
                        e.preventDefault();
                        return false;
                    }
                    break;
                case 'Left':
                    if (!this.getCursor().prev && this.respaced) {
                        this.getCursor().prepareMove().insertBefore(this.prev);
                        return false;
                    }
                    break;
                case 'Right':
                    if (!this.getCursor().next && this.next.respaced) {
                        this.getCursor().prepareMove().insertAfter(this.next);
                        return false;
                    }
            }
        };
        _.getCursor = function() {
            var cursor;
            for (var ancestor = this.parent; !cursor; ancestor = ancestor.parent) {
                cursor = ancestor.cursor;
            }
            this.getCursor = function() { return cursor; };
            return this.getCursor();
        };
        _.expectedCursorYNextTo = function(clientRect) {
            // superscripts and subscripts are vertical-align-ed +/- 0.5em, so
            // their bottom or top edge almost perfectly aligns with the
            // cursor's center
            if (this.ctrlSeq === '_') return clientRect(this).top;
            else return clientRect(this).bottom;
        };
    });

    LatexCmds.subscript =
        LatexCmds._ = bind(SupSub, '_', 'sub', '_');

    LatexCmds.superscript =
        LatexCmds.supscript =
        LatexCmds['^'] = bind(SupSub, '^', 'sup', '**');

    var BigSymbol = P(MathCommand, function(_, _super) {
        _.init = function(ch, html) {
            var htmlTemplate =
                '<span class="mq-large-operator mq-non-leaf">' +
                '<span class="mq-to"><span>&1</span></span>' +
                '<big>' + html + '</big>' +
                '<span class="mq-from"><span>&0</span></span>' +
                '</span>';
            Symbol.prototype.init.call(this, ch, htmlTemplate);
        };
        _.placeCursor = function(cursor) {
            cursor.appendTo(this.firstChild).writeLatex('n=').show();
        };
        _.latex = function() {
            function simplify(latex) {
                return latex.length === 1 ? latex : '{' + (latex || ' ') + '}';
            }
            return this.ctrlSeq + '_' + simplify(this.firstChild.latex()) +
                '^' + simplify(this.lastChild.latex());
        };
        _.parser = function() {
            var string = Parser.string;
            var optWhitespace = Parser.optWhitespace;
            var succeed = Parser.succeed;
            var block = latexMathParser.block;

            var self = this;
            var blocks = self.blocks = [MathBlock(), MathBlock()];
            for (var i = 0; i < blocks.length; i += 1) {
                blocks[i].adopt(self, self.lastChild, 0);
            }

            return optWhitespace.then(string('_').or(string('^'))).then(function(supOrSub) {
                var child = blocks[supOrSub === '_' ? 0 : 1];
                return block.then(function(block) {
                    block.children().adopt(child, child.lastChild, 0);
                    return succeed(self);
                });
            }).many().result(self);
        };
        _.finalizeTree = function() {
            this.down = this.firstChild;
            this.firstChild.up = insertAfterUnlessAtBeginning;
            this.up = this.lastChild;
            this.lastChild.down = insertAfterUnlessAtBeginning;
        };

        function insertAfterUnlessAtBeginning(cursor) {
            // cursor.insertAfter(cmd), unless cursor at the beginning of block, and every
            // ancestor cmd is at the beginning of every ancestor block
            var cmd = this.parent,
                ancestorCmd = cursor;
            do {
                if (ancestorCmd.prev) {
                    cursor.insertAfter(cmd);
                    return false;
                }
                ancestorCmd = ancestorCmd.parent.parent;
            } while (ancestorCmd !== cmd);
            cursor.insertBefore(cmd);
            return false;
        }
    });
    LatexCmds['\u2211'] = LatexCmds.sum = LatexCmds.summation = LatexCmds.Sigma = bind(BigSymbol, '\\sum ', '&sum;');
    LatexCmds['\u220F'] = LatexCmds.prod = LatexCmds.product = LatexCmds.Pi = bind(BigSymbol, '\\prod ', '&prod;');

    var Fraction =
        LatexCmds.frac =
        LatexCmds.dfrac =
        LatexCmds.cfrac =
        LatexCmds.fraction = P(MathCommand, function(_, _super) {
            _.ctrlSeq = '\\frac';
            _.htmlTemplate =
                '<span class="mq-fraction mq-non-leaf">' +
                '<span class="mq-numerator">&0</span>' +
                '<span class="mq-denominator">&1</span>' +
                '<span style="display:inline-block;width:0;overflow:hidden">&nbsp;</span>' +
                '</span>';
            _.textTemplate = ['(', '/', ')'];
            _.finalizeTree = function() {
                this.up = this.lastChild.up = this.firstChild;
                this.down = this.firstChild.down = this.lastChild;
            };
            _.expectedCursorYNextTo = function(clientRect) {
                // vertical-align-ed -0.5em, so the top edge of the span that sets
                // the baseline almost perfectly aligns with the cursor's center
                return clientRect.elById(this.jQ[0].lastChild, this.id + .5).top;
            };
        });

    var LiveFraction =
        LatexCmds.over =
        CharCmds['/'] = P(Fraction, function(_, _super) {
            _.createBefore = function(cursor) {
                if (!this.replacedFragment) {
                    var prev = cursor.prev;
                    if (prev instanceof TextBlock || prev instanceof Fraction) {
                        prev = prev.prev;
                    } else {
                        while (prev &&
                            !(
                                prev instanceof BinaryOperator ||
                                prev instanceof TextBlock ||
                                prev instanceof BigSymbol ||
                                prev instanceof Fraction ||
                                prev.ctrlSeq === ',' ||
                                prev.ctrlSeq === ':' ||
                                prev.ctrlSeq === '\\space '
                            ) //lookbehind for operator
                        )
                            prev = prev.prev;

                        if (prev instanceof BigSymbol && prev.next instanceof SupSub) {
                            prev = prev.next;
                            if (prev.next instanceof SupSub && prev.next.ctrlSeq != prev.ctrlSeq)
                                prev = prev.next;
                        }
                    }

                    if (prev !== cursor.prev) {
                        this.replaces(MathFragment(prev.next || cursor.parent.firstChild, cursor.prev));
                        cursor.prev = prev;
                    }
                }
                _super.createBefore.call(this, cursor);
            };
        });

    var SquareRoot =
        LatexCmds.sqrt =
        LatexCmds['âˆš'] = P(MathCommand, function(_, _super) {
            _.ctrlSeq = '\\sqrt';
            _.htmlTemplate =
                '<span class="mq-non-leaf">' +
                '<span class="mq-scaled mq-sqrt-prefix">&radic;</span>' +
                '<span class="mq-non-leaf mq-sqrt-stem">&0</span>' +
                '</span>';
            _.textTemplate = ['sqrt(', ')'];
            _.parser = function() {
                return latexMathParser.optBlock.then(function(optBlock) {
                    return latexMathParser.block.map(function(block) {
                        var nthroot = NthRoot();
                        nthroot.blocks = [optBlock, block];
                        optBlock.adopt(nthroot, 0, 0);
                        block.adopt(nthroot, optBlock, 0);
                        return nthroot;
                    });
                }).or(_super.parser.call(this));
            };
            _.redraw = function() {
                var block = this.lastChild.jQ;
                scale(block.prev(), 1, block.innerHeight() / +block.css('fontSize').slice(0, -2) - .1);
            };
        });


    var NthRoot =
        LatexCmds.nthroot = P(SquareRoot, function(_, _super) {
            _.htmlTemplate =
                '<sup class="mq-nthroot mq-non-leaf">&0</sup>' +
                '<span class="mq-scaled">' +
                '<span class="mq-sqrt-prefix mq-scaled">&radic;</span>' +
                '<span class="mq-sqrt-stem mq-non-leaf">&1</span>' +
                '</span>';
            _.textTemplate = ['sqrt[', '](', ')'];
            _.latex = function() {
                return '\\sqrt[' + this.firstChild.latex() + ']{' + this.lastChild.latex() + '}';
            };
            _.onKey = function(key, e) {
                if (this.getCursor().parent.parent !== this) return;

                switch (key) {
                    case 'Right':
                        if (this.getCursor().next) return;
                    case 'Tab':
                        if (this.getCursor().parent === this.firstChild) {
                            this.getCursor().prepareMove().prependTo(this.lastChild);
                            e.preventDefault();
                            return false;
                        }
                        break;
                    case 'Left':
                        if (this.getCursor().prev) return;
                    case 'Shift-Tab':
                        if (this.getCursor().parent === this.lastChild) {
                            this.getCursor().prepareMove().appendTo(this.firstChild);
                            e.preventDefault();
                            return false;
                        }
                }
            };
            _.getCursor = SupSub.prototype.getCursor;
            _.expectedCursorYNextTo = function(clientRect) {
                // superscripts are vertical-align-ed 0.5em, so their bottom edge
                // almost perfectly aligns with the cursor's center
                return clientRect.elById(this.jQ[0], this.id + .5).bottom;
            };
        });

    // Round/Square/Curly/Angle Brackets (aka Parens/Brackets/Braces)
    var Bracket = P(MathCommand, function(_, _super) {
        _.init = function(open, close, ctrlSeq, end) {
            _super.init.call(this, '\\left' + ctrlSeq,
                '<span class="mq-non-leaf">' +
                '<span class="mq-scaled mq-paren">' + open + '</span>' +
                '<span class="mq-non-leaf">&0</span>' +
                '<span class="mq-scaled mq-paren">' + close + '</span>' +
                '</span>', [open, close]);
            this.end = '\\right' + end;
        };
        _.jQadd = function() {
            _super.jQadd.apply(this, arguments);
            var jQ = this.jQ;
            this.bracketjQs = jQ.children(':first').add(jQ.children(':last'));
        };
        //When typed, auto-expand paren to end of block
        _.finalizeTree = function() {
            if (this.firstChild.isEmpty() && this.next) {
                var nextAll = MathFragment(this.next, this.parent.lastChild).disown();
                nextAll.adopt(this.firstChild, 0, 0);
                nextAll.jQ.appendTo(this.firstChild.jQ);
            }
        };
        _.placeCursor = function(cursor) {
            cursor.prependTo(this.firstChild);
        };
        _.latex = function() {
            return this.ctrlSeq + this.firstChild.latex() + this.end;
        };
        _.redraw = function() {
            var blockjQ = this.firstChild.jQ;

            var height = blockjQ.outerHeight() / +blockjQ.css('fontSize').slice(0, -2);

            scale(this.bracketjQs, min(1 + .2 * (height - 1), 1.2), 1.05 * height);
        };
    });

    LatexCmds.left = P(MathCommand, function(_) {
        _.parser = function() {
            var regex = Parser.regex;
            var string = Parser.string;
            var regex = Parser.regex;
            var succeed = Parser.succeed;
            var block = latexMathParser.block;
            var optWhitespace = Parser.optWhitespace;

            return optWhitespace.then(regex(/^(?:[([|]|\\\{)/))
                .then(function(open) {
                    if (open.charAt(0) === '\\') open = open.slice(1);

                    var cmd = CharCmds[open]();

                    return latexMathParser
                        .map(function(block) {
                            cmd.blocks = [block];
                            block.adopt(cmd, 0, 0);
                        })
                        .then(string('\\right'))
                        .skip(optWhitespace)
                        .then(regex(/^(?:[\])|]|\\\})/))
                        .then(function(close) {
                            if (close.slice(-1) !== cmd.end.slice(-1)) {
                                return Parser.fail('open doesn\'t match close');
                            }

                            return succeed(cmd);
                        });
                });
        };
    });

    LatexCmds.right = P(MathCommand, function(_) {
        _.parser = function() {
            return Parser.fail('unmatched \\right');
        };
    });

    LatexCmds.lbrace =
        CharCmds['{'] = bind(Bracket, '{', '}', '\\{', '\\}');
    LatexCmds.langle =
        LatexCmds.lang = bind(Bracket, '&lang;', '&rang;', '\\langle ', '\\rangle ');

    // Closing bracket matching opening bracket above
    var CloseBracket = P(Bracket, function(_, _super) {
        _.createBefore = function(cursor) {
            // if I'm replacing a selection fragment, just wrap in parens
            if (this.replacedFragment) return _super.createBefore.call(this, cursor);

            // elsewise, if my parent is a matching open-paren, then close it here,
            // i.e. move everything after me in the open-paren to after the parens
            var openParen = cursor.parent.parent;
            if (openParen.ctrlSeq === this.ctrlSeq) {
                if (cursor.next) {
                    var nextAll = MathFragment(cursor.next, openParen.firstChild.lastChild).disown();
                    nextAll.adopt(openParen.parent, openParen, openParen.next);
                    nextAll.jQ.insertAfter(openParen.jQ);
                    if (cursor.next.respace) cursor.next.respace();
                }
                cursor.insertAfter(openParen);
                openParen.bubble('redraw');
            }
            // or if not, make empty paren group and put cursor inside it
            // (I think this behavior is weird - Han)
            else {
                _super.createBefore.call(this, cursor);
                cursor.appendTo(this.firstChild); // FIXME HACK
            }
        };
        _.finalizeTree = noop;
        _.placeCursor = function(cursor) {
            this.firstChild.blur();
            cursor.insertAfter(this);
        };
    });

    LatexCmds.rbrace =
        CharCmds['}'] = bind(CloseBracket, '{', '}', '\\{', '\\}');
    LatexCmds.rangle =
        LatexCmds.rang = bind(CloseBracket, '&lang;', '&rang;', '\\langle ', '\\rangle ');

    var parenMixin = function(_, _super) {
        _.init = function(open, close) {
            _super.init.call(this, open, close, open, close);
        };
    };

    var Paren = P(Bracket, parenMixin);

    LatexCmds.lparen =
        CharCmds['('] = bind(Paren, '(', ')');
    LatexCmds.lbrack =
        LatexCmds.lbracket =
        CharCmds['['] = bind(Paren, '[', ']');

    var CloseParen = P(CloseBracket, parenMixin);

    LatexCmds.rparen =
        CharCmds[')'] = bind(CloseParen, '(', ')');
    LatexCmds.rbrack =
        LatexCmds.rbracket =
        CharCmds[']'] = bind(CloseParen, '[', ']');

    var Pipes =
        LatexCmds.lpipe =
        LatexCmds.rpipe =
        CharCmds['|'] = P(Paren, function(_, _super) {
            _.init = function() {
                _super.init.call(this, '|', '|');
            }

            _.createBefore = function(cursor) {
                if (!cursor.next && cursor.parent.parent && cursor.parent.parent.end === this.end && !this.replacedFragment)
                    cursor.insertAfter(cursor.parent.parent);
                else
                    MathCommand.prototype.createBefore.call(this, cursor);
            };
            _.finalizeTree = noop;
        });

    // DISABLED in DCG
    var TextBlock =
        LatexCmds.text =
        LatexCmds.textnormal =
        LatexCmds.textrm =
        LatexCmds.textup =
        LatexCmds.textmd = P(MathCommand, function(_, _super) {
            _.ctrlSeq = '\\text';
            _.htmlTemplate = '<span class="mq-text">&0</span>';
            _.replaces = function(replacedText) {
                if (replacedText instanceof MathFragment)
                    this.replacedText = replacedText.remove().jQ.text();
                else if (typeof replacedText === 'string')
                    this.replacedText = replacedText;
            };
            _.textTemplate = ['"', '"'];
            _.parser = function() {
                // TODO: correctly parse text mode
                var string = Parser.string;
                var regex = Parser.regex;
                var optWhitespace = Parser.optWhitespace;
                return optWhitespace
                    .then(string('{')).then(regex(/^[^}]*/)).skip(string('}'))
                    .map(function(text) {
                        var cmd = TextBlock();
                        cmd.createBlocks();
                        var block = cmd.firstChild;
                        for (var i = 0; i < text.length; i += 1) {
                            var ch = VanillaSymbol(text.charAt(i));
                            ch.adopt(block, block.lastChild, 0);
                        }
                        return cmd;
                    });
            };
            _.createBlocks = function() {
                //FIXME: another possible Law of Demeter violation, but this seems much cleaner, like it was supposed to be done this way
                this.firstChild =
                    this.lastChild =
                    InnerTextBlock();

                this.blocks = [this.firstChild];

                this.firstChild.parent = this;
            };
            _.finalizeInsert = function() {
                //FIXME HACK blur removes the TextBlock
                this.firstChild.blur = function() { delete this.blur; return this; };
                _super.finalizeInsert.call(this);
            };
            _.createBefore = function(cursor) {
                _super.createBefore.call(this, this.cursor = cursor);

                if (this.replacedText)
                    for (var i = 0; i < this.replacedText.length; i += 1)
                        this.write(this.replacedText.charAt(i));
            };
            _.write = function(ch) {
                this.cursor.insertNew(VanillaSymbol(ch));
            };
            _.onKey = function(key, e) {
                //backspace and delete and ends of block don't unwrap
                if (!this.cursor.selection &&
                    (
                        (key === 'Backspace' && !this.cursor.prev) ||
                        (key === 'Del' && !this.cursor.next)
                    )
                ) {
                    if (this.isEmpty())
                        this.cursor.insertAfter(this);

                    return false;
                }
            };
            _.onText = function(ch) {
                this.cursor.prepareEdit();
                if (ch !== '$')
                    this.write(ch);
                else if (this.isEmpty())
                    this.cursor.insertAfter(this).backspace().insertNew(VanillaSymbol('\\$', '$'));
                else if (!this.cursor.next)
                    this.cursor.insertAfter(this);
                else if (!this.cursor.prev)
                    this.cursor.insertBefore(this);
                else { //split apart
                    var next = TextBlock(MathFragment(this.cursor.next, this.firstChild.lastChild));
                    next.placeCursor = function(cursor) { //FIXME HACK: pretend no prev so they don't get merged
                        this.prev = 0;
                        delete this.placeCursor;
                        this.placeCursor(cursor);
                    };
                    next.firstChild.focus = function() { return this; };
                    this.cursor.insertAfter(this).insertNew(next);
                    next.prev = this;
                    this.cursor.insertBefore(next);
                    delete next.firstChild.focus;
                }
                this.cursor.root.triggerSpecialEvent('render');
                return false;
            };
        });

    var InnerTextBlock = P(MathBlock, function(_, _super) {
        _.blur = function() {
            this.jQ.removeClass('mq-hasCursor');
            if (this.isEmpty()) {
                var textblock = this.parent,
                    cursor = textblock.cursor;
                if (cursor.parent === this)
                    this.jQ.addClass('mq-empty');
                else {
                    cursor.hide();
                    textblock.remove();
                    if (cursor.next === textblock)
                        cursor.next = textblock.next;
                    else if (cursor.prev === textblock)
                        cursor.prev = textblock.prev;

                    cursor.show().parent.bubble('redraw');
                }
            }
            return this;
        };
        _.focus = function() {
            _super.focus.call(this);

            var textblock = this.parent;
            if (textblock.next.ctrlSeq === textblock.ctrlSeq) { //TODO: seems like there should be a better way to move MathElements around
                var innerblock = this,
                    cursor = textblock.cursor,
                    next = textblock.next.firstChild;

                next.eachChild(function(child) {
                    child.parent = innerblock;
                    child.jQ.appendTo(innerblock.jQ);
                });

                if (this.lastChild)
                    this.lastChild.next = next.firstChild;
                else
                    this.firstChild = next.firstChild;

                next.firstChild.prev = this.lastChild;
                this.lastChild = next.lastChild;

                next.parent.remove();

                if (cursor.prev)
                    cursor.insertAfter(cursor.prev);
                else
                    cursor.prependTo(this);

                cursor.parent.bubble('redraw');
            } else if (textblock.prev.ctrlSeq === textblock.ctrlSeq) {
                var cursor = textblock.cursor;
                if (cursor.prev)
                    textblock.prev.firstChild.focus();
                else
                    cursor.appendTo(textblock.prev.firstChild);
            }
            return this;
        };
    });


    function makeTextBlock(latex, tagName, attrs) {
        return P(TextBlock, {
            ctrlSeq: latex,
            htmlTemplate: '<' + tagName + ' ' + attrs + '>&0</' + tagName + '>'
        });
    }

    LatexCmds.em = LatexCmds.italic = LatexCmds.italics =
        LatexCmds.emph = LatexCmds.textit = LatexCmds.textsl =
        makeTextBlock('\\textit', 'i', 'class="mq-text"');
    LatexCmds.strong = LatexCmds.bold = LatexCmds.textbf =
        makeTextBlock('\\textbf', 'b', 'class="mq-text"');
    LatexCmds.sf = LatexCmds.textsf =
        makeTextBlock('\\textsf', 'span', 'class="mq-sans-serif mq-text"');
    LatexCmds.tt = LatexCmds.texttt =
        makeTextBlock('\\texttt', 'span', 'class="mq-monospace mq-text"');
    LatexCmds.textsc =
        makeTextBlock('\\textsc', 'span', 'style="font-variant:small-caps" class="mq-text"');
    LatexCmds.uppercase =
        makeTextBlock('\\uppercase', 'span', 'style="text-transform:uppercase" class="mq-text"');
    LatexCmds.lowercase =
        makeTextBlock('\\lowercase', 'span', 'style="text-transform:lowercase" class="mq-text"');

    // input box to type a variety of LaTeX commands beginning with a backslash
    // DISABLED in DCG
    var LatexCommandInput =
        P(MathCommand, function(_, _super) {
            _.ctrlSeq = '\\';
            _.replaces = function(replacedFragment) {
                this._replacedFragment = replacedFragment.disown();
                this.isEmpty = function() { return false; };
            };
            _.htmlTemplate = '<span class="mq-latex-command-input mq-non-leaf">\\<span>&0</span></span>';
            _.textTemplate = ['\\'];
            _.createBlocks = function() {
                _super.createBlocks.call(this);
                this.firstChild.focus = function() {
                    this.parent.jQ.addClass('mq-hasCursor');
                    if (this.isEmpty())
                        this.parent.jQ.removeClass('mq-empty');

                    return this;
                };
                this.firstChild.blur = function() {
                    this.parent.jQ.removeClass('mq-hasCursor');
                    if (this.isEmpty())
                        this.parent.jQ.addClass('mq-empty');

                    return this;
                };
            };
            _.createBefore = function(cursor) {
                _super.createBefore.call(this, cursor);
                this.cursor = cursor.appendTo(this.firstChild);
                if (this._replacedFragment) {
                    var el = this.jQ[0];
                    this.jQ =
                        this._replacedFragment.jQ.addClass('mq-blur').bind(
                            'mousedown mousemove', //FIXME: is monkey-patching the mousedown and mousemove handlers the right way to do this?
                            function(e) {
                                $(e.target = el).trigger(e);
                                return false;
                            }
                        ).insertBefore(this.jQ).add(this.jQ);
                }
            };
            _.latex = function() {
                return '\\' + this.firstChild.latex() + ' ';
            };
            _.onKey = function(key, e) {
                if (key === 'Tab' || key === 'Enter') {
                    this.renderCommand();
                    this.cursor.root.triggerSpecialEvent('render');
                    e.preventDefault();
                    return false;
                }
            };
            _.onText = function(ch) {
                if (ch.match(/[a-z]/i)) {
                    this.cursor.prepareEdit();
                    this.cursor.insertNew(VanillaSymbol(ch));
                    return false;
                }
                this.renderCommand();
                if (ch === ' ' || (ch === '\\' && this.firstChild.isEmpty())) {
                    this.cursor.root.triggerSpecialEvent('render');
                    return false;
                }
            };
            _.renderCommand = function() {
                this.jQ = this.jQ.last();
                this.remove();
                if (this.next) {
                    this.cursor.insertBefore(this.next);
                } else {
                    this.cursor.appendTo(this.parent);
                }

                var latex = this.firstChild.latex(),
                    cmd;
                if (!latex) latex = 'backslash';
                this.cursor.insertCmd(latex, this._replacedFragment);
            };
        });

    var Binomial =
        LatexCmds.binom =
        LatexCmds.binomial = P(MathCommand, function(_, _super) {
            _.ctrlSeq = '\\binom';
            _.htmlTemplate =
                '<span class="mq-paren mq-scaled">(</span>' +
                '<span class="mq-non-leaf">' +
                '<span class="mq-array mq-non-leaf">' +
                '<span>&0</span>' +
                '<span>&1</span>' +
                '</span>' +
                '</span>' +
                '<span class="mq-paren mq-scaled">)</span>';
            _.textTemplate = ['choose(', ',', ')'];
            _.redraw = function() {
                var blockjQ = this.jQ.eq(1);

                var height = blockjQ.outerHeight() / +blockjQ.css('fontSize').slice(0, -2);

                var parens = this.jQ.filter('.mq-paren');
                scale(parens, min(1 + .2 * (height - 1), 1.2), 1.05 * height);
            };
            // vertical-align: middle, so
            _.expectedCursorYNextTo = Symbol.prototype.expectedCursorYNextTo;
        });

    var Choose =
        LatexCmds.choose = P(Binomial, function(_) {
            _.createBefore = LiveFraction.prototype.createBefore;
        });

    var Vector =
        LatexCmds.vector = P(MathCommand, function(_, _super) {
            _.ctrlSeq = '\\vector';
            _.htmlTemplate = '<span class="mq-array"><span>&0</span></span>';
            _.latex = function() {
                return '\\begin{matrix}' + this.foldChildren([], function(latex, child) {
                    latex.push(child.latex());
                    return latex;
                }).join('\\\\') + '\\end{matrix}';
            };
            _.text = function() {
                return '[' + this.foldChildren([], function(text, child) {
                    text.push(child.text());
                    return text;
                }).join() + ']';
            }
            _.createBefore = function(cursor) {
                _super.createBefore.call(this, this.cursor = cursor);
            };
            _.onKey = function(key, e) {
                var currentBlock = this.cursor.parent;

                if (currentBlock.parent === this) {
                    if (key === 'Enter') { //enter
                        var newBlock = MathBlock();
                        newBlock.parent = this;
                        newBlock.jQ = $('<span></span>')
                            .attr(mqBlockId, newBlock.id)
                            .insertAfter(currentBlock.jQ);
                        if (currentBlock.next)
                            currentBlock.next.prev = newBlock;
                        else
                            this.lastChild = newBlock;

                        newBlock.next = currentBlock.next;
                        currentBlock.next = newBlock;
                        newBlock.prev = currentBlock;
                        this.bubble('redraw').cursor.appendTo(newBlock);

                        e.preventDefault();
                        return false;
                    } else if (key === 'Tab' && !currentBlock.next) {
                        if (currentBlock.isEmpty()) {
                            if (currentBlock.prev) {
                                this.cursor.insertAfter(this);
                                delete currentBlock.prev.next;
                                this.lastChild = currentBlock.prev;
                                currentBlock.jQ.remove();
                                this.bubble('redraw');

                                e.preventDefault();
                                return false;
                            } else
                                return;
                        }

                        var newBlock = MathBlock();
                        newBlock.parent = this;
                        newBlock.jQ = $('<span></span>').attr(mqBlockId, newBlock.id).appendTo(this.jQ);
                        this.lastChild = newBlock;
                        currentBlock.next = newBlock;
                        newBlock.prev = currentBlock;
                        this.bubble('redraw').cursor.appendTo(newBlock);

                        e.preventDefault();
                        return false;
                    } else if (e.which === 8) { //backspace
                        if (currentBlock.isEmpty()) {
                            if (currentBlock.prev) {
                                this.cursor.appendTo(currentBlock.prev)
                                currentBlock.prev.next = currentBlock.next;
                            } else {
                                this.cursor.insertBefore(this);
                                this.firstChild = currentBlock.next;
                            }

                            if (currentBlock.next)
                                currentBlock.next.prev = currentBlock.prev;
                            else
                                this.lastChild = currentBlock.prev;

                            currentBlock.jQ.remove();
                            if (this.isEmpty())
                                this.cursor.deleteForward();
                            else
                                this.bubble('redraw');

                            e.preventDefault();
                            return false;
                        } else if (!this.cursor.prev) {
                            e.preventDefault();
                            return false;
                        }
                    }
                }
            };
            // vertical-align: middle, so
            _.expectedCursorYNextTo = Binomial.prototype.expectedCursorYNextTo;
        });

    LatexCmds.MathQuillMathField = P(MathCommand, function(_, _super) {
        _.ctrlSeq = '\\MathQuillMathField';
        _.htmlTemplate = '<span class="mathquill-editable">&0</span>';
        _.parser = function() {
            var self = this
            var string = Parser.string,
                regex = Parser.regex,
                succeed = Parser.succeed;
            // Note regex that whitelists of valid CSS classname characters:
            // https://github.com/mathquill/mathquill/pull/191#discussion_r4327442
            return string('[').then(regex(/^[-\w\s\\\xA0-\xFF]*/)).skip(string(']'))
                .map(function(classnames) { self.classnames = classnames; })
                .or(succeed()).then(_super.parser.call(self));
        };
        _.finalizeTree = function() {
            // parsed \MathQuillMathField{contents}, `this` is this MathCommand,
            // replace its sole child MathBlock with a RootMathBlock
            var self = this,
                rootBlock = RootMathBlock();

            delete MathElement[rootBlock.id];
            rootBlock.id = self.firstChild.id;
            MathElement[rootBlock.id] = rootBlock;

            self.firstChild.children().disown().adopt(rootBlock, 0, 0);
            rootBlock.parent = self;
            self.firstChild = self.lastChild = rootBlock;
            self.blocks = [rootBlock];

            rootBlock.jQ = self.jQ.wrapInner('<span class="mathquill-root-block"/>').children();

            rootBlock.editable = true;
            var cursor = rootBlock.cursor = Cursor(rootBlock).appendTo(rootBlock);
            setupTextarea(true, self.jQ, rootBlock, cursor);
            setupTouchHandle(true, rootBlock, cursor);
            focusBlurEvents(rootBlock, cursor);
            desmosCustomEvents(self.jQ, rootBlock, cursor);
            self.jQ.addClass(self.classnames);
        };

        _.latex = function() { return this.firstChild.latex(); };
        _.text = function() { return this.firstChild.text(); };
    });
    /**********************************
     * Symbols and Special Characters
     *********************************/

    var Variable = P(Symbol, function(_, _super) {
        _.init = function(ch, html) {
            _super.init.call(this, ch, '<var>' + (html || ch) + '</var>');
        }
        _.createBefore = function(cursor) {
            //want the longest possible autocommand, so assemble longest series of letters (Variables) first
            var ctrlSeq = this.ctrlSeq;
            for (var i = 0, prev = cursor.prev; i < MAX_AUTOCMD_LEN - 1 && prev && prev instanceof Variable; i += 1, prev = prev.prev)
                ctrlSeq = prev.ctrlSeq + ctrlSeq;
            //then test if there's an autocommand here, starting with the longest possible and slicing
            while (ctrlSeq.length) {
                if (AutoCmds.hasOwnProperty(ctrlSeq)) {
                    for (var i = 1; i < ctrlSeq.length; i += 1) cursor.backspace();
                    cursor.insertNew(LatexCmds[ctrlSeq](ctrlSeq));
                    return;
                }
                ctrlSeq = ctrlSeq.slice(1);
            }
            _super.createBefore.apply(this, arguments);
        };
        _.respace =
            _.finalizeTree = function() {
                //TODO: in better architecture, should be done in createBefore and backspace
                //respace is called too often, inefficient

                //want the longest possible autocommand, so assemble longest series of letters (Variables)
                var ctrlSeq = this.ctrlSeq;
                if (ctrlSeq.length > 1) return;
                for (var prev = this.prev; prev instanceof Variable && prev.ctrlSeq.length === 1; prev = prev.prev)
                    ctrlSeq = prev.ctrlSeq + ctrlSeq;
                for (var next = this.next; next instanceof Variable && next.ctrlSeq.length === 1; next = next.next)
                    ctrlSeq += next.ctrlSeq;

                this.isVariable = true;

                //removeClass from all the things before figuring out what's an autocmd, if any
                MathFragment(prev.next || this.parent.firstChild, next.prev || this.parent.lastChild)
                    .each(function(el) {
                        el.jQ.removeClass('mq-un-italicized mq-last');
                        delete el.isFirstLetter;
                        delete el.isLastLetter;
                    });

                //test if there's an autocommand here, going through substrings from longest to shortest
                outer: for (var i = 0, first = prev.next || this.parent.firstChild; i < ctrlSeq.length; i += 1, first = first.next) {
                    for (var len = min(MAX_UNITALICIZED_LEN, ctrlSeq.length - i); len > 0; len -= 1) {
                        if (UnItalicizedCmds.hasOwnProperty(ctrlSeq.slice(i, i + len))) {
                            first.isFirstLetter = true;
                            for (var j = 0, letter = first; j < len; j += 1, letter = letter.next) {
                                letter.jQ.addClass('mq-un-italicized');
                                letter.isVariable = false;
                                var last = letter;
                            }
                            last.isLastLetter = true;
                            if (!(last.next instanceof SupSub || last.next instanceof Bracket))
                                last.jQ.addClass('mq-last');
                            i += len - 1;
                            first = last;
                            continue outer;
                        }
                    }
                }
            };
        _.latex = function() {
            return (
                this.isFirstLetter ? '\\' + this.ctrlSeq :
                this.isLastLetter ? this.ctrlSeq + ' ' :
                this.ctrlSeq
            );
        };
        _.text = function() {
            var text = this.ctrlSeq;
            if (this.prev && !(this.prev instanceof Variable) &&
                !(this.prev instanceof BinaryOperator))
                text = '*' + text;
            if (this.next && !(this.next instanceof BinaryOperator) &&
                !(this.next.ctrlSeq === '^'))
                text += '*';
            return text;
        };
    });

    var UnItalicized = P(Symbol, function(_, _super) {
        _.init = function(fn) {
            this.ctrlSeq = fn;
        };
        _.createBefore = function(cursor) {
            cursor.writeLatex(this.ctrlSeq).show();
        };
        _.parser = function() {
            var fn = this.ctrlSeq;
            var block = MathBlock();
            for (var i = 0; i < fn.length; i += 1) {
                Variable(fn.charAt(i)).adopt(block, block.lastChild, 0);
            }
            return Parser.succeed(block.children());
        };
    });

    //backslashless commands, words where adjacent letters (Variables)
    //that form them automatically are turned into commands
    var UnItalicizedCmds = {
            mean: 1,
            ln: 1,
            log: 1,
            min: 1,
            nCr: 1,
            nPr: 1,
            gcd: 1,
            lcm: 1,
            mcm: 1,
            mcd: 1,
            ceil: 1,
            exp: 1,
            abs: 1,
            max: 1,
            mod: 1,
            gcf: 1,
            exp: 1,
            floor: 1,
            sign: 1,
            signum: 1,
            round: 1,
            length: 1,
            stdev: 1,
            stddev: 1,
            stdDev: 1,
            stdevp: 1,
            stddevp: 1,
            stdDevP: 1,
            total: 1,
            'var': 1,
            variance: 1
        },
        MAX_UNITALICIZED_LEN = 9,
        AutoCmds = {
            sqrt: 1,
            nthroot: 1,
            sum: 1,
            prod: 1,
            pi: 1,
            Pi: 1,
            phi: 1,
            Sigma: 1,
            tau: 1,
            Gamma: 1,
            theta: 1
                /*,
                  int: 1*/
        },
        MAX_AUTOCMD_LEN = 7;

    (function() {
        var trigs = { sin: 1, cos: 1, tan: 1, sec: 1, cosec: 1, csc: 1, cotan: 1, cot: 1, ctg: 1 };
        for (var trig in trigs) {
            UnItalicizedCmds[trig] =
                UnItalicizedCmds['arc' + trig] =
                UnItalicizedCmds[trig + 'h'] =
                UnItalicizedCmds['arc' + trig + 'h'] = 1;
        }

        for (var fn in UnItalicizedCmds)
            LatexCmds[fn] = UnItalicized;
    }());

    var VanillaSymbol = P(Symbol, function(_, _super) {
        _.init = function(ch, html) {
            _super.init.call(this, ch, '<span>' + (html || ch) + '</span>');
        };
    });

    CharCmds[' '] = bind(VanillaSymbol, '\\space ', ' ');

    LatexCmds.prime = CharCmds["'"] = bind(VanillaSymbol, "'", '&prime;');

    // does not use Symbola font
    var NonSymbolaSymbol = P(Symbol, function(_, _super) {
        _.init = function(ch, html) {
            _super.init.call(this, ch, '<span class="mq-nonSymbola">' + (html || ch) + '</span>');
        };
    });

    LatexCmds['@'] = NonSymbolaSymbol;
    LatexCmds['&'] = bind(NonSymbolaSymbol, '\\&', '&amp;');
    LatexCmds['%'] = bind(NonSymbolaSymbol, '\\%', '%');

    //the following are all Greek to me, but this helped a lot: http://www.ams.org/STIX/ion/stixsig03.html

    //lowercase Greek letter variables
    LatexCmds.alpha =
        LatexCmds.beta =
        LatexCmds.gamma =
        LatexCmds.delta =
        LatexCmds.zeta =
        LatexCmds.eta =
        LatexCmds.theta =
        LatexCmds.iota =
        LatexCmds.kappa =
        LatexCmds.mu =
        LatexCmds.nu =
        LatexCmds.xi =
        LatexCmds.rho =
        LatexCmds.sigma =
        LatexCmds.tau =
        LatexCmds.chi =
        LatexCmds.psi =
        LatexCmds.omega = P(Variable, function(_, _super) {
            _.init = function(latex) {
                _super.init.call(this, '\\' + latex + ' ', '&' + latex + ';');
            };
        });

    //why can't anybody FUCKING agree on these
    LatexCmds.phi = //W3C or Unicode?
        bind(Variable, '\\phi ', '&#981;');

    LatexCmds.phiv = //Elsevier and 9573-13
        LatexCmds.varphi = //AMS and LaTeX
        bind(Variable, '\\varphi ', '&phi;');

    LatexCmds.epsilon = //W3C or Unicode?
        bind(Variable, '\\epsilon ', '&#1013;');

    LatexCmds.epsiv = //Elsevier and 9573-13
        LatexCmds.varepsilon = //AMS and LaTeX
        bind(Variable, '\\varepsilon ', '&epsilon;');

    LatexCmds.piv = //W3C/Unicode and Elsevier and 9573-13
        LatexCmds.varpi = //AMS and LaTeX
        bind(Variable, '\\varpi ', '&piv;');

    LatexCmds.sigmaf = //W3C/Unicode
        LatexCmds.sigmav = //Elsevier
        LatexCmds.varsigma = //LaTeX
        bind(Variable, '\\varsigma ', '&sigmaf;');

    LatexCmds.thetav = //Elsevier and 9573-13
        LatexCmds.vartheta = //AMS and LaTeX
        LatexCmds.thetasym = //W3C/Unicode
        bind(Variable, '\\vartheta ', '&thetasym;');

    LatexCmds.upsilon = //AMS and LaTeX and W3C/Unicode
        LatexCmds.upsi = //Elsevier and 9573-13
        bind(Variable, '\\upsilon ', '&upsilon;');

    //these aren't even mentioned in the HTML character entity references
    LatexCmds.gammad = //Elsevier
        LatexCmds.Gammad = //9573-13 -- WTF, right? I dunno if this was a typo in the reference (see above)
        LatexCmds.digamma = //LaTeX
        bind(Variable, '\\digamma ', '&#989;');

    LatexCmds.kappav = //Elsevier
        LatexCmds.varkappa = //AMS and LaTeX
        bind(Variable, '\\varkappa ', '&#1008;');

    LatexCmds.rhov = //Elsevier and 9573-13
        LatexCmds.varrho = //AMS and LaTeX
        bind(Variable, '\\varrho ', '&#1009;');

    //Greek constants, look best in un-italicised Times New Roman
    LatexCmds.pi = LatexCmds['\u03C0'] = bind(NonSymbolaSymbol, '\\pi ', '&pi;');
    LatexCmds.theta = LatexCmds['\u03B8'] = bind(NonSymbolaSymbol, '\\theta ', '&theta;');
    LatexCmds.lambda = bind(NonSymbolaSymbol, '\\lambda ', '&lambda;');

    //uppercase greek letters

    LatexCmds.Upsilon = //LaTeX
        LatexCmds.Upsi = //Elsevier and 9573-13
        LatexCmds.upsih = //W3C/Unicode "upsilon with hook"
        LatexCmds.Upsih = //'cos it makes sense to me
        bind(Symbol, '\\Upsilon ', '<var style="font-family: serif">&upsih;</var>'); //Symbola's 'upsilon with a hook' is a capital Y without hooks :(

    //other symbols with the same LaTeX command and HTML character entity reference
    LatexCmds.Gamma =
        LatexCmds.Delta =
        LatexCmds.Theta =
        LatexCmds.Lambda =
        LatexCmds.Xi =
        LatexCmds.Phi =
        LatexCmds.Psi =
        LatexCmds.Omega =
        LatexCmds.forall = P(VanillaSymbol, function(_, _super) {
            _.init = function(latex) {
                _super.init.call(this, '\\' + latex + ' ', '&' + latex + ';');
            };
        });

    // symbols that aren't a single MathCommand, but are instead a whole
    // Fragment. Creates the Fragment from a LaTeX string
    var LatexFragment = P(MathCommand, function(_) {
        _.init = function(latex) { this.latex = latex; };
        _.createBefore = function(cursor) { cursor.writeLatex(this.latex); };
        _.parser = function() {
            var frag = latexMathParser.parse(this.latex).children();
            return Parser.succeed(frag);
        };
    });

    // for what seems to me like [stupid reasons][1], Unicode provides
    // subscripted and superscripted versions of all ten Arabic numerals,
    // as well as [so-called "vulgar fractions"][2].
    // Nobody really cares about most of them, but some of them actually
    // predate Unicode, dating back to [ISO-8859-1][3], apparently also
    // known as "Latin-1", which among other things [Windows-1252][4]
    // largely coincides with, so Microsoft Word sometimes inserts them
    // and they get copy-pasted into MathQuill.
    //
    // (Irrelevant but funny story: Windows-1252 is actually a strict
    // superset of the "closely related but distinct"[3] "ISO 8859-1" --
    // see the lack of a dash after "ISO"? Completely different character
    // set, like elephants vs elephant seals, or "Zombies" vs "Zombie
    // Redneck Torture Family". What kind of idiot would get them confused.
    // People in fact got them confused so much, it was so common to
    // mislabel Windows-1252 text as ISO-8859-1, that most modern web
    // browsers and email clients treat the MIME charset of ISO-8859-1
    // as actually Windows-1252, behavior now standard in the HTML5 spec.)
    //
    // [1]: http://en.wikipedia.org/wiki/Unicode_subscripts_and_superscripts
    // [2]: http://en.wikipedia.org/wiki/Number_Forms
    // [3]: http://en.wikipedia.org/wiki/ISO/IEC_8859-1
    // [4]: http://en.wikipedia.org/wiki/Windows-1252
    LatexCmds['\u00b9'] = bind(LatexFragment, '^1');
    LatexCmds['\u00b2'] = bind(LatexFragment, '^2');
    LatexCmds['\u00b3'] = bind(LatexFragment, '^3');
    LatexCmds['\u00bc'] = bind(LatexFragment, '\\frac14');
    LatexCmds['\u00bd'] = bind(LatexFragment, '\\frac12');
    LatexCmds['\u00be'] = bind(LatexFragment, '\\frac34');
    LatexCmds['\u2152'] = bind(LatexFragment, '\\frac{1}{10}');
    LatexCmds['\u2153'] = bind(LatexFragment, '\\frac13');
    LatexCmds['\u2154'] = bind(LatexFragment, '\\frac23');


    var BinaryOperator = P(Symbol, function(_, _super) {
        _.init = function(ctrlSeq, html, text) {
            _super.init.call(this,
                ctrlSeq, '<span class="mq-binary-operator">' + html + '</span>', text
            );
        };
        _.createBefore = function(cursor) {
            var ctrlSeq = cursor.prev.ctrlSeq + this.ctrlSeq;
            if (ctrlSeq === '<=')
                cursor.backspace().insertNew(BinaryOperator('\\le ', '&le;'));
            else if (ctrlSeq === '>=')
                cursor.backspace().insertNew(BinaryOperator('\\ge ', '&ge;'));
            else
                _super.createBefore.apply(this, arguments);
        };
    });

    var PlusMinus = P(BinaryOperator, function(_) {
        _.init = VanillaSymbol.prototype.init;

        _.respace = function() {
            if (!this.prev) {
                this.jQ[0].className = '';
            } else if (
                this.prev instanceof BinaryOperator &&
                this.next && !(this.next instanceof BinaryOperator)
            ) {
                this.jQ[0].className = 'mq-unary-operator';
            } else {
                this.jQ[0].className = 'mq-binary-operator';
            }
            return this;
        };
    });

    LatexCmds['+'] = bind(PlusMinus, '+', '+');
    //yes, these are different dashes, I think one is an en dash and the other is a hyphen
    LatexCmds['\u2013'] = LatexCmds['\u2212'] = LatexCmds['-'] = bind(PlusMinus, '-', '&minus;');
    LatexCmds['\u00B1'] = LatexCmds.pm = LatexCmds.plusmn = LatexCmds.plusminus =
        bind(PlusMinus, '\\pm ', '&plusmn;');
    LatexCmds.mp = LatexCmds.mnplus = LatexCmds.minusplus =
        bind(PlusMinus, '\\mp ', '&#8723;');

    CharCmds['*'] = LatexCmds.sdot = LatexCmds.cdot =
        bind(BinaryOperator, '\\cdot ', '&middot;');
    //semantically should be &sdot;, but &middot; looks better

    LatexCmds['='] = bind(BinaryOperator, '=', '=');
    LatexCmds['<'] = bind(BinaryOperator, '<', '&lt;');
    LatexCmds['>'] = bind(BinaryOperator, '>', '&gt;');
    LatexCmds['~'] = bind(BinaryOperator, '~', '~');

    LatexCmds.notin =
        LatexCmds.sim =
        LatexCmds.cong =
        LatexCmds.equiv =
        LatexCmds.oplus =
        LatexCmds.otimes = P(BinaryOperator, function(_, _super) {
            _.init = function(latex) {
                _super.init.call(this, '\\' + latex + ' ', '&' + latex + ';');
            };
        });

    LatexCmds.times = bind(BinaryOperator, '\\times ', '&times;', '[x]');

    LatexCmds['\u00F7'] = LatexCmds.div = LatexCmds.divide = LatexCmds.divides =
        bind(BinaryOperator, '\\div ', '&divide;', '[/]');

    LatexCmds['\u2260'] = LatexCmds.ne = LatexCmds.neq = bind(BinaryOperator, '\\ne ', '&ne;');

    LatexCmds.ast = LatexCmds.star = LatexCmds.loast = LatexCmds.lowast =
        bind(BinaryOperator, '\\ast ', '&lowast;');
    //case 'there4 = // a special exception for this one, perhaps?
    LatexCmds.therefor = LatexCmds.therefore =
        bind(BinaryOperator, '\\therefore ', '&there4;');

    LatexCmds.cuz = // l33t
        LatexCmds.because = bind(BinaryOperator, '\\because ', '&#8757;');

    LatexCmds.prop = LatexCmds.propto = bind(BinaryOperator, '\\propto ', '&prop;');

    LatexCmds['\u2248'] = LatexCmds.asymp = LatexCmds.approx = bind(BinaryOperator, '\\approx ', '&asymp;');

    LatexCmds.lt = bind(BinaryOperator, '<', '&lt;');

    LatexCmds.gt = bind(BinaryOperator, '>', '&gt;');

    LatexCmds['\u2264'] = LatexCmds.le = LatexCmds.leq = bind(BinaryOperator, '\\le ', '&le;');

    LatexCmds['\u2265'] = LatexCmds.ge = LatexCmds.geq = bind(BinaryOperator, '\\ge ', '&ge;');

    LatexCmds.isin = LatexCmds['in'] = bind(BinaryOperator, '\\in ', '&isin;');

    LatexCmds.ni = LatexCmds.contains = bind(BinaryOperator, '\\ni ', '&ni;');

    LatexCmds.notni = LatexCmds.niton = LatexCmds.notcontains = LatexCmds.doesnotcontain =
        bind(BinaryOperator, '\\not\\ni ', '&#8716;');

    LatexCmds.sub = LatexCmds.subset = bind(BinaryOperator, '\\subset ', '&sub;');

    LatexCmds.sup = LatexCmds.supset = LatexCmds.superset =
        bind(BinaryOperator, '\\supset ', '&sup;');

    LatexCmds.nsub = LatexCmds.notsub =
        LatexCmds.nsubset = LatexCmds.notsubset =
        bind(BinaryOperator, '\\not\\subset ', '&#8836;');

    LatexCmds.nsup = LatexCmds.notsup =
        LatexCmds.nsupset = LatexCmds.notsupset =
        LatexCmds.nsuperset = LatexCmds.notsuperset =
        bind(BinaryOperator, '\\not\\supset ', '&#8837;');

    LatexCmds.sube = LatexCmds.subeq = LatexCmds.subsete = LatexCmds.subseteq =
        bind(BinaryOperator, '\\subseteq ', '&sube;');

    LatexCmds.supe = LatexCmds.supeq =
        LatexCmds.supsete = LatexCmds.supseteq =
        LatexCmds.supersete = LatexCmds.superseteq =
        bind(BinaryOperator, '\\supseteq ', '&supe;');

    LatexCmds.nsube = LatexCmds.nsubeq =
        LatexCmds.notsube = LatexCmds.notsubeq =
        LatexCmds.nsubsete = LatexCmds.nsubseteq =
        LatexCmds.notsubsete = LatexCmds.notsubseteq =
        bind(BinaryOperator, '\\not\\subseteq ', '&#8840;');

    LatexCmds.nsupe = LatexCmds.nsupeq =
        LatexCmds.notsupe = LatexCmds.notsupeq =
        LatexCmds.nsupsete = LatexCmds.nsupseteq =
        LatexCmds.notsupsete = LatexCmds.notsupseteq =
        LatexCmds.nsupersete = LatexCmds.nsuperseteq =
        LatexCmds.notsupersete = LatexCmds.notsuperseteq =
        bind(BinaryOperator, '\\not\\supseteq ', '&#8841;');

    /*

    //the canonical sets of numbers
    LatexCmds.N = LatexCmds.naturals = LatexCmds.Naturals =
      bind(VanillaSymbol,'\\mathbb{N}','&#8469;');

    LatexCmds.P =
    LatexCmds.primes = LatexCmds.Primes =
    LatexCmds.projective = LatexCmds.Projective =
    LatexCmds.probability = LatexCmds.Probability =
      bind(VanillaSymbol,'\\mathbb{P}','&#8473;');

    LatexCmds.Z = LatexCmds.integers = LatexCmds.Integers =
      bind(VanillaSymbol,'\\mathbb{Z}','&#8484;');

    LatexCmds.Q = LatexCmds.rationals = LatexCmds.Rationals =
      bind(VanillaSymbol,'\\mathbb{Q}','&#8474;');

    LatexCmds.R = LatexCmds.reals = LatexCmds.Reals =
      bind(VanillaSymbol,'\\mathbb{R}','&#8477;');

    LatexCmds.C =
    LatexCmds.complex = LatexCmds.Complex =
    LatexCmds.complexes = LatexCmds.Complexes =
    LatexCmds.complexplane = LatexCmds.Complexplane = LatexCmds.ComplexPlane =
      bind(VanillaSymbol,'\\mathbb{C}','&#8450;');

    LatexCmds.H = LatexCmds.Hamiltonian = LatexCmds.quaternions = LatexCmds.Quaternions =
      bind(VanillaSymbol,'\\mathbb{H}','&#8461;');

    //spacing
    LatexCmds.quad = LatexCmds.emsp = bind(VanillaSymbol,'\\quad ','    ');
    LatexCmds.qquad = bind(VanillaSymbol,'\\qquad ','        ');
    spacing special characters, gonna have to implement this in LatexCommandInput::onText somehow
    case ',':
      return VanillaSymbol('\\, ',' ');
    case ':':
      return VanillaSymbol('\\: ','  ');
    case ';':
      return VanillaSymbol('\\; ','   ');
    case '!':
      return Symbol('\\! ','<span style="margin-right:-.2em"></span>');

    //binary operators
    LatexCmds.diamond = bind(VanillaSymbol, '\\diamond ', '&#9671;');
    LatexCmds.bigtriangleup = bind(VanillaSymbol, '\\bigtriangleup ', '&#9651;');
    LatexCmds.ominus = bind(VanillaSymbol, '\\ominus ', '&#8854;');
    LatexCmds.uplus = bind(VanillaSymbol, '\\uplus ', '&#8846;');
    LatexCmds.bigtriangledown = bind(VanillaSymbol, '\\bigtriangledown ', '&#9661;');
    LatexCmds.sqcap = bind(VanillaSymbol, '\\sqcap ', '&#8851;');
    LatexCmds.triangleleft = bind(VanillaSymbol, '\\triangleleft ', '&#8882;');
    LatexCmds.sqcup = bind(VanillaSymbol, '\\sqcup ', '&#8852;');
    LatexCmds.triangleright = bind(VanillaSymbol, '\\triangleright ', '&#8883;');
    LatexCmds.odot = bind(VanillaSymbol, '\\odot ', '&#8857;');
    LatexCmds.bigcirc = bind(VanillaSymbol, '\\bigcirc ', '&#9711;');
    LatexCmds.dagger = bind(VanillaSymbol, '\\dagger ', '&#0134;');
    LatexCmds.ddagger = bind(VanillaSymbol, '\\ddagger ', '&#135;');
    LatexCmds.wr = bind(VanillaSymbol, '\\wr ', '&#8768;');
    LatexCmds.amalg = bind(VanillaSymbol, '\\amalg ', '&#8720;');

    //relationship symbols
    LatexCmds.models = bind(VanillaSymbol, '\\models ', '&#8872;');
    LatexCmds.prec = bind(VanillaSymbol, '\\prec ', '&#8826;');
    LatexCmds.succ = bind(VanillaSymbol, '\\succ ', '&#8827;');
    LatexCmds.preceq = bind(VanillaSymbol, '\\preceq ', '&#8828;');
    LatexCmds.succeq = bind(VanillaSymbol, '\\succeq ', '&#8829;');
    LatexCmds.simeq = bind(VanillaSymbol, '\\simeq ', '&#8771;');
    LatexCmds.mid = bind(VanillaSymbol, '\\mid ', '&#8739;');
    LatexCmds.ll = bind(VanillaSymbol, '\\ll ', '&#8810;');
    LatexCmds.gg = bind(VanillaSymbol, '\\gg ', '&#8811;');
    LatexCmds.parallel = bind(VanillaSymbol, '\\parallel ', '&#8741;');
    LatexCmds.bowtie = bind(VanillaSymbol, '\\bowtie ', '&#8904;');
    LatexCmds.sqsubset = bind(VanillaSymbol, '\\sqsubset ', '&#8847;');
    LatexCmds.sqsupset = bind(VanillaSymbol, '\\sqsupset ', '&#8848;');
    LatexCmds.smile = bind(VanillaSymbol, '\\smile ', '&#8995;');
    LatexCmds.sqsubseteq = bind(VanillaSymbol, '\\sqsubseteq ', '&#8849;');
    LatexCmds.sqsupseteq = bind(VanillaSymbol, '\\sqsupseteq ', '&#8850;');
    LatexCmds.doteq = bind(VanillaSymbol, '\\doteq ', '&#8784;');
    LatexCmds.frown = bind(VanillaSymbol, '\\frown ', '&#8994;');
    LatexCmds.vdash = bind(VanillaSymbol, '\\vdash ', '&#8870;');
    LatexCmds.dashv = bind(VanillaSymbol, '\\dashv ', '&#8867;');

    //arrows
    LatexCmds.longleftarrow = bind(VanillaSymbol, '\\longleftarrow ', '&#8592;');
    LatexCmds.longrightarrow = bind(VanillaSymbol, '\\longrightarrow ', '&#8594;');
    LatexCmds.Longleftarrow = bind(VanillaSymbol, '\\Longleftarrow ', '&#8656;');
    LatexCmds.Longrightarrow = bind(VanillaSymbol, '\\Longrightarrow ', '&#8658;');
    LatexCmds.longleftrightarrow = bind(VanillaSymbol, '\\longleftrightarrow ', '&#8596;');
    LatexCmds.updownarrow = bind(VanillaSymbol, '\\updownarrow ', '&#8597;');
    LatexCmds.Longleftrightarrow = bind(VanillaSymbol, '\\Longleftrightarrow ', '&#8660;');
    LatexCmds.Updownarrow = bind(VanillaSymbol, '\\Updownarrow ', '&#8661;');
    LatexCmds.mapsto = bind(VanillaSymbol, '\\mapsto ', '&#8614;');
    LatexCmds.nearrow = bind(VanillaSymbol, '\\nearrow ', '&#8599;');
    LatexCmds.hookleftarrow = bind(VanillaSymbol, '\\hookleftarrow ', '&#8617;');
    LatexCmds.hookrightarrow = bind(VanillaSymbol, '\\hookrightarrow ', '&#8618;');
    LatexCmds.searrow = bind(VanillaSymbol, '\\searrow ', '&#8600;');
    LatexCmds.leftharpoonup = bind(VanillaSymbol, '\\leftharpoonup ', '&#8636;');
    LatexCmds.rightharpoonup = bind(VanillaSymbol, '\\rightharpoonup ', '&#8640;');
    LatexCmds.swarrow = bind(VanillaSymbol, '\\swarrow ', '&#8601;');
    LatexCmds.leftharpoondown = bind(VanillaSymbol, '\\leftharpoondown ', '&#8637;');
    LatexCmds.rightharpoondown = bind(VanillaSymbol, '\\rightharpoondown ', '&#8641;');
    LatexCmds.nwarrow = bind(VanillaSymbol, '\\nwarrow ', '&#8598;');

    //Misc
    */
    LatexCmds.space = bind(VanillaSymbol, '\\space ', '&nbsp;');
    /*
    LatexCmds.ldots = bind(VanillaSymbol, '\\ldots ', '&#8230;');
    LatexCmds.cdots = bind(VanillaSymbol, '\\cdots ', '&#8943;');
    LatexCmds.vdots = bind(VanillaSymbol, '\\vdots ', '&#8942;');
    LatexCmds.ddots = bind(VanillaSymbol, '\\ddots ', '&#8944;');
    LatexCmds.surd = bind(VanillaSymbol, '\\surd ', '&#8730;');
    LatexCmds.triangle = bind(VanillaSymbol, '\\triangle ', '&#9653;');
    LatexCmds.ell = bind(VanillaSymbol, '\\ell ', '&#8467;');
    LatexCmds.top = bind(VanillaSymbol, '\\top ', '&#8868;');
    LatexCmds.flat = bind(VanillaSymbol, '\\flat ', '&#9837;');
    LatexCmds.natural = bind(VanillaSymbol, '\\natural ', '&#9838;');
    LatexCmds.sharp = bind(VanillaSymbol, '\\sharp ', '&#9839;');
    LatexCmds.wp = bind(VanillaSymbol, '\\wp ', '&#8472;');
    LatexCmds.bot = bind(VanillaSymbol, '\\bot ', '&#8869;');
    LatexCmds.clubsuit = bind(VanillaSymbol, '\\clubsuit ', '&#9827;');
    LatexCmds.diamondsuit = bind(VanillaSymbol, '\\diamondsuit ', '&#9826;');
    LatexCmds.heartsuit = bind(VanillaSymbol, '\\heartsuit ', '&#9825;');
    LatexCmds.spadesuit = bind(VanillaSymbol, '\\spadesuit ', '&#9824;');

    //variable-sized
    LatexCmds.oint = bind(VanillaSymbol, '\\oint ', '&#8750;');
    LatexCmds.bigcap = bind(VanillaSymbol, '\\bigcap ', '&#8745;');
    LatexCmds.bigcup = bind(VanillaSymbol, '\\bigcup ', '&#8746;');
    LatexCmds.bigsqcup = bind(VanillaSymbol, '\\bigsqcup ', '&#8852;');
    LatexCmds.bigvee = bind(VanillaSymbol, '\\bigvee ', '&#8744;');
    LatexCmds.bigwedge = bind(VanillaSymbol, '\\bigwedge ', '&#8743;');
    LatexCmds.bigodot = bind(VanillaSymbol, '\\bigodot ', '&#8857;');
    LatexCmds.bigotimes = bind(VanillaSymbol, '\\bigotimes ', '&#8855;');
    LatexCmds.bigoplus = bind(VanillaSymbol, '\\bigoplus ', '&#8853;');
    LatexCmds.biguplus = bind(VanillaSymbol, '\\biguplus ', '&#8846;');

    //delimiters
    LatexCmds.lfloor = bind(VanillaSymbol, '\\lfloor ', '&#8970;');
    LatexCmds.rfloor = bind(VanillaSymbol, '\\rfloor ', '&#8971;');
    LatexCmds.lceil = bind(VanillaSymbol, '\\lceil ', '&#8968;');
    LatexCmds.rceil = bind(VanillaSymbol, '\\rceil ', '&#8969;');
    LatexCmds.slash = bind(VanillaSymbol, '\\slash ', '&#47;');
    LatexCmds.opencurlybrace = bind(VanillaSymbol, '\\opencurlybrace ', '&#123;');
    LatexCmds.closecurlybrace = bind(VanillaSymbol, '\\closecurlybrace ', '&#125;');

    //various symbols

    LatexCmds.caret = bind(VanillaSymbol,'\\caret ','^');
    LatexCmds.underscore = bind(VanillaSymbol,'\\underscore ','_');
    LatexCmds.backslash = bind(VanillaSymbol,'\\backslash ','\\');
    LatexCmds.vert = bind(VanillaSymbol,'|');
    LatexCmds.perp = LatexCmds.perpendicular = bind(VanillaSymbol,'\\perp ','&perp;');
    LatexCmds.nabla = LatexCmds.del = bind(VanillaSymbol,'\\nabla ','&nabla;');
    LatexCmds.hbar = bind(VanillaSymbol,'\\hbar ','&#8463;');

    LatexCmds.AA = LatexCmds.Angstrom = LatexCmds.angstrom =
      bind(VanillaSymbol,'\\text\\AA ','&#8491;');

    LatexCmds.ring = LatexCmds.circ = LatexCmds.circle =
      bind(VanillaSymbol,'\\circ ','&#8728;');

    LatexCmds.bull = LatexCmds.bullet = bind(VanillaSymbol,'\\bullet ','&bull;');

    LatexCmds.setminus = LatexCmds.smallsetminus =
      bind(VanillaSymbol,'\\setminus ','&#8726;');

    LatexCmds.not = //bind(Symbol,'\\not ','<span class="not">/</span>');
    LatexCmds['Â¬'] = LatexCmds.neg = bind(VanillaSymbol,'\\neg ','&not;');

    LatexCmds['â€¦'] = LatexCmds.dots = LatexCmds.ellip = LatexCmds.hellip =
    LatexCmds.ellipsis = LatexCmds.hellipsis =
      bind(VanillaSymbol,'\\dots ','&hellip;');

    LatexCmds.converges =
    LatexCmds.darr = LatexCmds.dnarr = LatexCmds.dnarrow = LatexCmds.downarrow =
      bind(VanillaSymbol,'\\downarrow ','&darr;');

    LatexCmds.dArr = LatexCmds.dnArr = LatexCmds.dnArrow = LatexCmds.Downarrow =
      bind(VanillaSymbol,'\\Downarrow ','&dArr;');

    LatexCmds.diverges = LatexCmds.uarr = LatexCmds.uparrow =
      bind(VanillaSymbol,'\\uparrow ','&uarr;');

    LatexCmds.uArr = LatexCmds.Uparrow = bind(VanillaSymbol,'\\Uparrow ','&uArr;');

    LatexCmds.to = bind(BinaryOperator,'\\to ','&rarr;');

    LatexCmds.rarr = LatexCmds.rightarrow = bind(VanillaSymbol,'\\rightarrow ','&rarr;');

    LatexCmds.implies = bind(BinaryOperator,'\\Rightarrow ','&rArr;');

    LatexCmds.rArr = LatexCmds.Rightarrow = bind(VanillaSymbol,'\\Rightarrow ','&rArr;');

    LatexCmds.gets = bind(BinaryOperator,'\\gets ','&larr;');

    LatexCmds.larr = LatexCmds.leftarrow = bind(VanillaSymbol,'\\leftarrow ','&larr;');

    LatexCmds.impliedby = bind(BinaryOperator,'\\Leftarrow ','&lArr;');

    LatexCmds.lArr = LatexCmds.Leftarrow = bind(VanillaSymbol,'\\Leftarrow ','&lArr;');

    LatexCmds.harr = LatexCmds.lrarr = LatexCmds.leftrightarrow =
      bind(VanillaSymbol,'\\leftrightarrow ','&harr;');

    LatexCmds.iff = bind(BinaryOperator,'\\Leftrightarrow ','&hArr;');

    LatexCmds.hArr = LatexCmds.lrArr = LatexCmds.Leftrightarrow =
      bind(VanillaSymbol,'\\Leftrightarrow ','&hArr;');

    LatexCmds.Re = LatexCmds.Real = LatexCmds.real = bind(VanillaSymbol,'\\Re ','&real;');

    LatexCmds.Im = LatexCmds.imag =
    LatexCmds.image = LatexCmds.imagin = LatexCmds.imaginary = LatexCmds.Imaginary =
      bind(VanillaSymbol,'\\Im ','&image;');

    LatexCmds.part = LatexCmds.partial = bind(VanillaSymbol,'\\partial ','&part;');

    LatexCmds.inf = LatexCmds.infin = LatexCmds.infty = LatexCmds.infinity =
      bind(VanillaSymbol,'\\infty ','&infin;');

    LatexCmds.alef = LatexCmds.alefsym = LatexCmds.aleph = LatexCmds.alephsym =
      bind(VanillaSymbol,'\\aleph ','&alefsym;');

    LatexCmds.xist = //LOL
    LatexCmds.xists = LatexCmds.exist = LatexCmds.exists =
      bind(VanillaSymbol,'\\exists ','&exist;');
    */
    LatexCmds.and = LatexCmds.land = LatexCmds.wedge =
        bind(VanillaSymbol, '\\wedge ', '&and;');

    LatexCmds.or = LatexCmds.lor = LatexCmds.vee = bind(VanillaSymbol, '\\vee ', '&or;');
    /*
    LatexCmds.o = LatexCmds.O =
    LatexCmds.empty = LatexCmds.emptyset =
    LatexCmds.oslash = LatexCmds.Oslash =
    LatexCmds.nothing = LatexCmds.varnothing =
      bind(BinaryOperator,'\\varnothing ','&empty;');

    LatexCmds.cup = LatexCmds.union = bind(BinaryOperator,'\\cup ','&cup;');

    LatexCmds.cap = LatexCmds.intersect = LatexCmds.intersection =
      bind(BinaryOperator,'\\cap ','&cap;');

    LatexCmds.deg = LatexCmds.degree = bind(VanillaSymbol,'^\\circ ','&deg;');

    LatexCmds.ang = LatexCmds.angle = bind(VanillaSymbol,'\\angle ','&ang;');
    */
    // Parser MathCommand
    var latexMathParser = (function() {
        function commandToBlock(cmd) {
            var block = MathBlock();
            cmd.adopt(block, 0, 0);
            return block;
        }

        function joinBlocks(blocks) {
            var firstBlock = blocks[0] || MathBlock();

            for (var i = 1; i < blocks.length; i += 1) {
                blocks[i].children().adopt(firstBlock, firstBlock.lastChild, 0);
            }

            return firstBlock;
        }

        var string = Parser.string;
        var regex = Parser.regex;
        var letter = Parser.letter;
        var any = Parser.any;
        var optWhitespace = Parser.optWhitespace;
        var succeed = Parser.succeed;
        var fail = Parser.fail;

        // Parsers yielding MathCommands
        var variable = letter.map(Variable);
        var symbol = regex(/^[^${}\\_^]/).map(VanillaSymbol);

        var controlSequence =
            regex(/^[^\\]/)
            .or(string('\\').then(
                regex(/^[a-z]+/i)
                .or(regex(/^\s+/).result(' '))
                .or(any)
            )).then(function(ctrlSeq) {
                var cmdKlass = LatexCmds[ctrlSeq];

                if (cmdKlass) {
                    return cmdKlass(ctrlSeq).parser();
                } else {
                    return fail('unknown command: \\' + ctrlSeq);
                }
            });

        var command =
            controlSequence
            .or(variable)
            .or(symbol);

        // Parsers yielding MathBlocks
        var mathGroup = string('{').then(function() { return mathSequence; }).skip(string('}'));
        var mathBlock = optWhitespace.then(mathGroup.or(command.map(commandToBlock)));
        var mathSequence = mathBlock.many().map(joinBlocks).skip(optWhitespace);

        var optMathBlock =
            string('[').then(
                mathBlock.then(function(block) {
                    return block.join('latex') !== ']' ? succeed(block) : fail();
                })
                .many().map(joinBlocks).skip(optWhitespace)
            ).skip(string(']'));

        var latexMath = mathSequence;

        latexMath.block = mathBlock;
        latexMath.optBlock = optMathBlock;
        return latexMath;
    })();
    /********************************************
     * Cursor and Selection "singleton" classes
     *******************************************/

    /* The main thing that manipulates the Math DOM. Makes sure to manipulate the
    HTML DOM to match. */

    /* Sort of singletons, since there should only be one per editable math
    textbox, but any one HTML document can contain many such textboxes, so any one
    JS environment could actually contain many instances. */

    //A fake cursor in the fake textbox that the math is rendered in.
    var Cursor = P(function(_) {
        _.init = function(root) {
            this.parent = this.root = root;
            var jQ = this.jQ = this._jQ = $('<span class="mq-cursor"><span class="mq-line">&zwj;</span></span>');

            //closured for setInterval
            this.blink = function() { jQ.toggleClass('mq-blink'); }

            this.upDownCache = {};

            this.handle = $('<span class="mq-handle"></span>');
            this.handleAnchor = $('<span class="mq-handle-anchor" ' +
                    'style="display:none"></span>')
                .append(this.handle).insertAfter(root.jQ);
            this.handleAnchor.top = this.handleAnchor.left = 0;
        };

        _.prev = 0;
        _.next = 0;
        _.parent = 0;
        _.showHandle = function() {
            //temporary: remove handle
            return this;

            if (!this.handleAnchor.visible) {
                this.handleAnchor.show();
                this.repositionHandle(this.jQ[0].getBoundingClientRect());
                this.handleAnchor.visible = true;
            }
            return this;
        };
        _.hideHandle = function() {
            //temporary: remove handle
            return this;

            if (this.handleAnchor.visible) {
                this.handleAnchor.hide();
                delete this.handleAnchor.visible;
            }
            return this;
        };
        _.repositionHandle = function(cursorRect) {
            //temporary: remove handle
            return;

            var anchor = this.handleAnchor;
            var anchorRect = anchor[0].getBoundingClientRect();
            anchor.css({
                top: anchor.top += cursorRect.bottom - anchorRect.bottom,
                left: anchor.left += cursorRect.left - anchorRect.left
            });
        };
        _.show = function(keepHandle) {
            if (!keepHandle) this.hideHandle();
            this.jQ = this._jQ.removeClass('mq-blink');
            if ('intervalId' in this) //already was shown, just restart interval
                clearInterval(this.intervalId);
            else { //was hidden and detached, insert this.jQ back into HTML DOM
                if (this.next) {
                    if (this.selection && this.selection.first.prev === this.prev)
                        this.jQ.insertBefore(this.selection.jQ);
                    else
                        this.jQ.insertBefore(this.next.jQ.first());
                } else
                    this.jQ.appendTo(this.parent.jQ);
                this.parent.focus();
            }
            this.intervalId = setInterval(this.blink, 500);
            return this;
        };
        _.hide = function() {
            this.hideHandle();
            if ('intervalId' in this)
                clearInterval(this.intervalId);
            delete this.intervalId;
            this.jQ.detach();
            this.jQ = $();
            return this;
        };
        _.insertAt = function(parent, prev, next) {
            var old_parent = this.parent;

            this.parent = parent;
            this.prev = prev;
            this.next = next;

            old_parent.blur(); //blur may need to know cursor's destination
        };
        _.insertBefore = function(el) {
            this.insertAt(el.parent, el.prev, el)
            this.parent.jQ.addClass('mq-hasCursor');
            this.jQ.insertBefore(el.jQ.first());
            return this;
        };
        _.insertAfter = function(el) {
            this.insertAt(el.parent, el, el.next);
            this.parent.jQ.addClass('mq-hasCursor');
            this.jQ.insertAfter(el.jQ.last());
            return this;
        };
        _.prependTo = function(el) {
            this.insertAt(el, 0, el.firstChild);
            this.jQ.prependTo(el.jQ);
            el.focus();
            return this;
        };
        _.appendTo = function(el) {
            this.insertAt(el, el.lastChild, 0);
            this.jQ.appendTo(el.jQ);
            el.focus();
            return this;
        };
        _.hopLeft = function() {
            this.jQ.insertBefore(this.prev.jQ.first());
            this.next = this.prev;
            this.prev = this.prev.prev;
            return this;
        };
        _.hopRight = function() {
            this.jQ.insertAfter(this.next.jQ.last());
            this.prev = this.next;
            this.next = this.next.next;
            return this;
        };
        _.moveLeftWithin = function(block) {
            if (this.prev) {
                // FIXME HACK: when moving right to left, want to go into NthRoot's body,
                // which is its lastChild.
                if (this.prev instanceof NthRoot) this.appendTo(this.prev.lastChild);
                else if (this.prev.up instanceof MathBlock) this.appendTo(this.prev.up);
                else if (this.prev.firstChild) this.appendTo(this.prev.firstChild)
                else this.hopLeft();
            } else {
                // unless we're at the beginning of the containing block, escape left
                if (this.parent !== block) this.insertBefore(this.parent.parent);
                else if (block.moveOutOf) block.moveOutOf('left', this);
            }
        };
        _.moveRightWithin = function(block) {
            if (this.next) {
                if (this.next.up instanceof MathBlock) this.prependTo(this.next.up);
                else if (this.next.firstChild) this.prependTo(this.next.firstChild)
                else this.hopRight();
            } else {
                // unless we're at the beginning of the containing block, escape left
                if (this.parent !== block) this.insertAfter(this.parent.parent);
                else if (block.moveOutOf) block.moveOutOf('right', this);
            }
        };
        _.moveLeft = function() {
            clearUpDownCache(this);

            if (this.selection) {
                this.insertBefore(this.selection.first).clearSelection();
                //hack by eli: move all the way past subscripts
            } else if (this.prev instanceof SupSub && this.prev.ctrlSeq === '_') {
                this.moveLeftWithin(this.root);
                while (this.isInSubscript()) this.moveLeftWithin(this.root);
            } else {
                this.moveLeftWithin(this.root);
            }

            this.root.triggerSpecialEvent('cursorMoved');
            return this.show();
        };
        _.moveRight = function() {
            clearUpDownCache(this);

            if (this.selection) {
                this.insertAfter(this.selection.last).clearSelection();
                //hack by eli: move all the way past subscripts
            } else if (this.next instanceof SupSub && this.next.ctrlSeq === '_') {
                this.moveRightWithin(this.root);
                while (this.isInSubscript()) this.moveRightWithin(this.root);
            } else {
                this.moveRightWithin(this.root);
            }
            this.root.triggerSpecialEvent('cursorMoved');
            return this.show();
        };

        /**
         * moveUp and moveDown have almost identical algorithms:
         * - first check next and prev, if so prepend/appendTo them
         * - else check the parent's 'up'/'down' property - if it's a function,
         *   call it with the cursor as the sole argument and use the return value.
         *
         *   Given undefined, will bubble up to the next ancestor block.
         *   Given false, will stop bubbling.
         *   Given a MathBlock,
         *     + moveUp will appendTo it
         *     + moveDown will prependTo it
         *
         */
        _.moveUp = function() { return moveUpDown(this, 'up'); };
        _.moveDown = function() { return moveUpDown(this, 'down'); };

        function moveUpDown(self, dir) {
            if (self.next[dir]) self.prependTo(self.next[dir]);
            else if (self.prev[dir]) self.appendTo(self.prev[dir]);
            else {
                var ancestorBlock = self.parent;
                do {
                    var prop = ancestorBlock[dir];
                    if (prop) {
                        if (typeof prop === 'function') prop = ancestorBlock[dir](self);
                        if (prop === false || prop instanceof MathBlock) {
                            self.upDownCache[ancestorBlock.id] = { parent: self.parent, prev: self.prev, next: self.next };

                            if (prop instanceof MathBlock) {
                                var cached = self.upDownCache[prop.id];

                                if (cached) {
                                    if (cached.next) {
                                        self.insertBefore(cached.next);
                                    } else {
                                        self.appendTo(cached.parent);
                                    }
                                } else {
                                    var coords = self.jQ[0].getBoundingClientRect();
                                    var cachedClientRect = cachedClientRectFnForNewCache();
                                    cachedClientRect.scrollLeft = 0; // only used in this event thread
                                    prop.seek(self, coords.left, coords.bottom, prop, cachedClientRect);
                                }
                            }
                            break;
                        }
                    }
                    ancestorBlock = ancestorBlock.parent.parent;
                } while (ancestorBlock);
            }

            return self.clearSelection().show();
        }

        _.seek = function(target, clientX, clientY, clientRect, keepHandle) {
            clearUpDownCache(this);
            var cursor = this.clearSelection().show(keepHandle);

            var nodeId = target.attr(mqBlockId) || target.attr(mqCmdId);
            if (!nodeId) {
                var targetParent = target.parent();
                nodeId = targetParent.attr(mqBlockId) || targetParent.attr(mqCmdId);
            }
            var node = nodeId ? MathElement[nodeId] : cursor.root;
            pray('nodeId is the id of some Node that exists', node);

            var dx = clientRect.scrollLeft = this.root.jQ.scrollLeft();
            node.seek(cursor, clientX + dx, clientY, cursor.root, clientRect);
            delete clientRect.scrollLeft; // be defensive: was only valid in this event
            // thread, unlike the cache of clientRect's

            this.root.scrollHoriz(); // before .selectFrom when mouse-selecting, so
            // always hits no-selection case in scrollHoriz and scrolls slower

            return cursor;
        };

        function offset(self) {
            //in Opera 11.62, .getBoundingClientRect() and hence jQuery::offset()
            //returns all 0's on inline elements with negative margin-right (like
            //the cursor) at the end of their parent, so temporarily remove the
            //negative margin-right when calling jQuery::offset()
            //Opera bug DSK-360043
            //http://bugs.jquery.com/ticket/11523
            //https://github.com/jquery/jquery/pull/717
            var offset = self.jQ.removeClass('mq-cursor').offset();
            self.jQ.addClass('mq-cursor');
            return offset;
        }
        _.writeLatex = function(latex) {
            var self = this;
            clearUpDownCache(self);
            self.show().deleteSelection();

            var all = Parser.all;
            var eof = Parser.eof;

            var block = latexMathParser.skip(eof).or(all.result(false)).parse(latex);

            if (block && !block.isEmpty()) {
                block.children().adopt(self.parent, self.prev, self.next);
                var html = block.join('html');
                var jQ = MathElement.jQize(html);
                jQ.insertBefore(self.jQ);
                self.prev = block.lastChild;
                block.finalizeInsert();
                self.parent.bubble('redraw');
            }

            return this;
        };

        _.isInSubscript = function() {
            if (!this.parent || !this.parent.parent) return false;
            var p = this.parent.parent;
            if (!(p instanceof SupSub)) return false;
            return (p.ctrlSeq === '_' && p.firstChild === this.parent);
        };

        _.write =
            _.insertCh = function(ch) {
                //Hack by Eli: don't exponentiate if there's nothing before the cursor
                if ((ch == '^' || ch == '_') && !this.prev) return;

                //Hack #2 by Eli: break out of the end of exponents
                if (
                    "+=-<>~".indexOf(ch) >= 0 && this.parent.parent.ctrlSeq === '^' &&
                    !this.next && this.prev
                ) this.moveRight();

                //Hack #2.5 by Eli: break out of the end of subscripts. Be a little more aggressive about breaking out down there
                if (
                    "+=-<>~*".indexOf(ch) >= 0 && this.parent.parent.ctrlSeq === '_' &&
                    !this.next && this.prev
                ) this.moveRight();

                //Hack #3 by Eli: if you type "^" just after a superscript, behave as though you just pressed up
                if (ch === '^' && this.prev instanceof SupSub &&
                    //note: need both of these, because if it's a superscript and subscript,
                    //those could appear in either order
                    (this.prev.ctrlSeq === '^' || this.prev.prev.ctrlSeq === '^')) {
                    this.moveUp();
                    return;
                }

                //Hack #3.5 by Eli: if you type "_" just after a subscript, return early
                if (ch === '_' && this.prev instanceof SupSub &&
                    //note: need both of these, because if it's a superscript and subscript,
                    //those could appear in either order
                    (this.prev.ctrlSeq === '_' || this.prev.prev.ctrlSeq === '_')) {
                    return;
                }


                //Hack #4 by Eli: if you type "^" just _before_ a superscript, behave as though you just pressed up
                if (ch === '^' && this.next instanceof SupSub &&
                    //note: need both of these, because if it's a superscript and subscript,
                    //those could appear in either order
                    (this.next.ctrlSeq === '^' || (this.next.next && this.next.next.ctrlSeq === '^'))) {
                    this.moveUp();
                    return;
                }

                //Hack #5 by Eli: typing a number after a variable subscripts it
                if (!this.isInSubscript() &&
                    !this.selection &&
                    !(this.next && this.next instanceof SupSub) &&
                    '0123456789'.indexOf(ch) >= 0 &&
                    (
                        (this.prev && this.prev.isVariable) ||
                        (this.prev instanceof SupSub && this.prev.ctrlSeq === '_' && this.prev.prev.ctrlSeq !== '^')
                    )
                ) {
                    if (this.prev instanceof SupSub) {
                        this.moveDown();
                    } else {
                        this.insertNew(LatexCmds['_']('_'));
                    }
                    this.insertNew(VanillaSymbol(ch));
                    this.moveUp();
                    return;
                }

                //hack #6: don't allow nested subscripts
                if (ch === "_" && this.isInSubscript()) return;

                //hack #7: break out of subscripts for division & exponentiation
                if (ch === '/' || ch === '^') {
                    while (this.isInSubscript()) this.moveRightWithin()
                }

                clearUpDownCache(this);
                this.show();

                var cmd;
                if (ch.match(/^[a-z]$/i))
                    cmd = Variable(ch);
                else if (cmd = CharCmds[ch] || LatexCmds[ch])
                    cmd = cmd(ch);
                else
                    cmd = VanillaSymbol(ch);

                if (this.selection) {
                    this.prev = this.selection.first.prev;
                    this.next = this.selection.last.next;
                    cmd.replaces(this.selection);
                    delete this.selection;
                }

                return this.insertNew(cmd);
            };
        _.insertNew = function(cmd) {
            cmd.createBefore(this);
            return this;
        };
        _.insertCmd = function(latexCmd, replacedFragment) {
            clearUpDownCache(this);
            this.show();

            var cmd = LatexCmds[latexCmd];
            if (cmd) {
                cmd = cmd(latexCmd);
                if (replacedFragment) cmd.replaces(replacedFragment);
                this.insertNew(cmd);
            } else {
                cmd = TextBlock();
                cmd.replaces(latexCmd);
                cmd.firstChild.focus = function() { delete this.focus; return this; };
                this.insertNew(cmd).insertAfter(cmd);
                if (replacedFragment)
                    replacedFragment.remove();
            }
            return this;
        };
        _.unwrapGramp = function() {
            var gramp = this.parent.parent;
            var greatgramp = gramp.parent;
            var next = gramp.next;
            var cursor = this;

            var prev = gramp.prev;
            gramp.disown().eachChild(function(uncle) {
                if (uncle.isEmpty()) return;

                uncle.children()
                    .adopt(greatgramp, prev, next)
                    .each(function(cousin) {
                        cousin.jQ.insertBefore(gramp.jQ.first());
                    });

                prev = uncle.lastChild;
            });

            if (!this.next) { //then find something to be next to insertBefore
                if (this.prev)
                    this.next = this.prev.next;
                else {
                    while (!this.next) {
                        this.parent = this.parent.next;
                        if (this.parent)
                            this.next = this.parent.firstChild;
                        else {
                            this.next = gramp.next;
                            this.parent = greatgramp;
                            break;
                        }
                    }
                }
            }
            if (this.next)
                this.insertBefore(this.next);
            else
                this.appendTo(greatgramp);

            gramp.jQ.remove();

            if (gramp.prev)
                gramp.prev.respace();
            if (gramp.next)
                gramp.next.respace();
        };
        _.backspace = function() {
            clearUpDownCache(this);
            this.show();

            if (this.deleteSelection()); // pass
            else if (this.prev) {
                if (this.prev.isEmpty()) {
                    if (this.prev.ctrlSeq === '\\le ') var ins = LatexCmds['<']('<');
                    else if (this.prev.ctrlSeq === '\\ge ') var ins = LatexCmds['>']('>');
                    this.prev = this.prev.remove().prev;
                    if (ins) this.insertNew(ins);
                } else if (this.prev instanceof Bracket) {
                    return this.appendTo(this.prev.firstChild).deleteForward();
                } else if (this.prev instanceof SupSub && this.prev.ctrlSeq === '_' && this.prev.prev.ctrlSeq !== '^') {
                    this.moveDown()
                    this.backspace()
                        //extra hack to clear out subscript altogether when it's empty (takes two backspaces)
                    if (!this.prev && !this.next) {
                        this.backspace()
                    } else {
                        this.moveUp()
                    }
                } else {
                    this.selectLeft();
                }
            } else if (this.parent !== this.root) {
                if (this.parent.parent.isEmpty())
                    return this.insertAfter(this.parent.parent).backspace();
                else if (this.next instanceof Bracket)
                    return this.prependTo(this.next.firstChild).backspace();
                else
                    this.unwrapGramp();
            } else this.root.triggerSpecialEvent('backspacePressed');

            if (this.prev)
                this.prev.respace();
            if (this.next)
                this.next.respace();
            this.parent.bubble('redraw');

            return this;
        };
        _.deleteForward = function() {
            clearUpDownCache(this);
            this.show();

            if (this.deleteSelection()); // pass
            else if (this.next) {
                if (this.next.isEmpty())
                    this.next = this.next.remove().next;
                else
                    this.selectRight();
            } else if (this.parent !== this.root) {
                if (this.parent.parent.isEmpty())
                    return this.insertBefore(this.parent.parent).deleteForward();
                else
                    this.unwrapGramp();
            } else this.root.triggerSpecialEvent('delPressed');

            if (this.prev)
                this.prev.respace();
            if (this.next)
                this.next.respace();
            this.parent.bubble('redraw');

            return this;
        };
        _.selectFrom = function(anticursor) {
            //find ancestors of each with common parent
            var oneA = this,
                otherA = anticursor; //one ancestor, the other ancestor
            loopThroughAncestors: do {
                for (var oneI = this; oneI !== oneA.parent.parent; oneI = oneI.parent.parent) //one intermediate, the other intermediate
                    if (oneI.parent === otherA.parent) {
                        left = oneI;
                        right = otherA;
                        break loopThroughAncestors;
                    }

                for (var otherI = anticursor; otherI !== otherA.parent.parent; otherI = otherI.parent.parent)
                    if (oneA.parent === otherI.parent) {
                        left = oneA;
                        right = otherI;
                        break loopThroughAncestors;
                    }

                if (oneA.parent.parent)
                    oneA = oneA.parent.parent;
                if (otherA.parent.parent)
                    otherA = otherA.parent.parent;
            } while (oneA.parent.parent || otherA.parent.parent || oneA.parent === otherA.parent);
            // the only way for this condition to fail is if A and B are in separate
            // trees, which should be impossible, but infinite loops must never happen,
            // even under error conditions.
            pray('cursor and anticursor are in the same tree',
                oneA.parent.parent || otherA.parent.parent || oneA.parent === otherA.parent);

            //figure out which is left/prev and which is right/next
            var left, right, leftRight;
            if (left.next !== right) {
                for (var next = left; next; next = next.next) {
                    if (next === right.prev) {
                        leftRight = true;
                        break;
                    }
                }
                if (!leftRight) {
                    leftRight = right;
                    right = left;
                    left = leftRight;
                }
            }
            this.hide().selection = Selection(left.prev.next || left.parent.firstChild, right.next.prev || right.parent.lastChild);
            this.insertAfter(right.next.prev || right.parent.lastChild);
            this.root.selectionChanged();
        };
        _.selectLeft = function() {
            clearUpDownCache(this);
            if (this.selection) {
                if (this.selection.first === this.next) { //if cursor is at left edge of selection;
                    if (this.prev) //then extend left if possible
                        this.hopLeft().selection.extendLeft();
                    else if (this.parent !== this.root) //else level up if possible
                        this.insertBefore(this.parent.parent).selection.levelUp();
                } else { //else cursor is at right edge of selection, retract left if possible
                    this.hopLeft();
                    if (this.selection.first === this.selection.last) {
                        this.clearSelection().show(); //clear selection if retracting to nothing
                        return; //skip this.root.selectionChanged(), this.clearSelection() does it anyway
                    }
                    this.selection.retractLeft();
                }
            } else {
                if (this.prev)
                    this.hopLeft();
                else //end of a block
                if (this.parent !== this.root)
                    this.insertBefore(this.parent.parent);
                else
                    return;

                this.hide().selection = Selection(this.next);
            }
            this.root.selectionChanged();
        };
        _.selectRight = function() {
            clearUpDownCache(this);
            if (this.selection) {
                if (this.selection.last === this.prev) { //if cursor is at right edge of selection;
                    if (this.next) //then extend right if possible
                        this.hopRight().selection.extendRight();
                    else if (this.parent !== this.root) //else level up if possible
                        this.insertAfter(this.parent.parent).selection.levelUp();
                } else { //else cursor is at left edge of selection, retract right if possible
                    this.hopRight();
                    if (this.selection.first === this.selection.last) {
                        this.clearSelection().show(); //clear selection if retracting to nothing
                        return; //skip this.root.selectionChanged(), this.clearSelection() does it anyway
                    }
                    this.selection.retractRight();
                }
            } else {
                if (this.next)
                    this.hopRight();
                else //end of a block
                if (this.parent !== this.root)
                    this.insertAfter(this.parent.parent);
                else
                    return;

                this.hide().selection = Selection(this.prev);
            }
            this.root.selectionChanged();
        };

        function clearUpDownCache(self) {
            self.upDownCache = {};
        }

        _.prepareMove = function() {
            clearUpDownCache(this);
            return this.show().clearSelection();
        };

        _.prepareEdit = function() {
            clearUpDownCache(this);
            return this.show().deleteSelection();
        }

        _.clearSelection = function() {
            if (this.selection) {
                this.selection.clear();
                delete this.selection;
                this.root.selectionChanged();
            }
            return this;
        };
        _.deleteSelection = function() {
            if (!this.selection) return false;

            this.prev = this.selection.first.prev;
            this.next = this.selection.last.next;
            this.selection.remove();
            this.root.selectionChanged();
            return delete this.selection;
        };
    });

    var Selection = P(MathFragment, function(_, _super) {
        _.init = function() {
            var frag = this;
            _super.init.apply(frag, arguments);

            frag.jQwrap(frag.jQ);
        };
        _.jQwrap = function(children) {
            this.jQ = children.wrapAll('<span class="mq-selection"></span>').parent();
            //can't do wrapAll(this.jQ = $(...)) because wrapAll will clone it
        };
        _.adopt = function() {
            this.jQ.replaceWith(this.jQ = this.jQ.children());
            return _super.adopt.apply(this, arguments);
        };
        _.clear = function() {
            this.jQ.replaceWith(this.jQ.children());
            return this;
        };
        _.levelUp = function() {
            var seln = this,
                gramp = seln.first = seln.last = seln.last.parent.parent;
            seln.clear().jQwrap(gramp.jQ);
            return seln;
        };
        _.extendLeft = function() {
            this.first = this.first.prev;
            this.first.jQ.prependTo(this.jQ);
        };
        _.extendRight = function() {
            this.last = this.last.next;
            this.last.jQ.appendTo(this.jQ);
        };
        _.retractRight = function() {
            this.first.jQ.insertBefore(this.jQ);
            this.first = this.first.next;
        };
        _.retractLeft = function() {
            this.last.jQ.insertAfter(this.jQ);
            this.last = this.last.prev;
        };
    });
    /*********************************************************
     * The actual jQuery plugin and document ready handlers.
     ********************************************************/

    //The publicy exposed method of jQuery.prototype, available (and meant to be
    //called) on jQuery-wrapped HTML DOM elements.
    $.fn.mathquill = function(cmd, latex) {
        switch (cmd) {
            case 'focus':
            case 'blur':
                return this.each(function() {
                    var blockId = $(this).attr(mqBlockId),
                        block = blockId && MathElement[blockId];
                    if (block && block.textareaManager)
                        block.textareaManager[cmd]()
                });
            case 'onKey':
            case 'onText':
                return this.each(function() {
                    var blockId = $(this).attr(mqBlockId),
                        block = blockId && MathElement[blockId],
                        cursor = block && block.cursor;

                    if (cursor) {
                        cursor.parent.bubble(cmd, latex, { preventDefault: noop });
                        if (block.blurred) cursor.hide().parent.blur();
                    }
                });
            case 'redraw':
                return this.each(function() {
                    var blockId = $(this).attr(mqBlockId),
                        rootBlock = blockId && MathElement[blockId];
                    if (rootBlock) {
                        (function postOrderRedraw(el) {
                            el.eachChild(postOrderRedraw);
                            if (el.redraw) el.redraw();
                        }(rootBlock));
                    }
                });
            case 'revert':
                return this.each(function() {
                    var blockId = $(this).attr(mqBlockId),
                        block = blockId && MathElement[blockId];
                    if (block && block.revert)
                        block.revert();
                });
            case 'sliderLatex':
                return this.each(function() {
                    var blockId = $(this).attr(mqBlockId),
                        block = blockId && MathElement[blockId];
                    if (block) {

                        //fixes bug with highlighting everything and then setting state with latex
                        //https://github.com/desmosinc/knox/issues/1115
                        cursor = block && block.cursor;
                        if (cursor) cursor.clearSelection();
                        block.renderSliderLatex(latex);
                        block.triggerSpecialEvent('render');
                    }
                });
            case 'latex':
                if (arguments.length > 1) {
                    return this.each(function() {
                        var blockId = $(this).attr(mqBlockId),
                            block = blockId && MathElement[blockId];
                        if (block) {
                            //fixes bug with highlighting everything and then setting state with latex
                            //https://github.com/desmosinc/knox/issues/1115
                            cursor = block && block.cursor;
                            if (cursor) cursor.clearSelection();
                            block.renderLatex(latex);
                            block.triggerSpecialEvent('render');
                        }
                    });
                }

                var blockId = $(this).attr(mqBlockId),
                    block = blockId && MathElement[blockId];
                return block && block.latex();
            case 'text':
                var blockId = $(this).attr(mqBlockId),
                    block = blockId && MathElement[blockId];
                return block && block.text();
            case 'html':
                return this.children('.mathquill-root-block').html().replace(/ ?mq-hasCursor|mq-hasCursor /, '')
                    .replace(/ class=(""|(?= |>))/g, '')
                    .replace(/<span class="?mq-cursor( mq-blink)?"?>.?<\/span>/i, '');
            case 'write':
                if (arguments.length > 1)
                    return this.each(function() {
                        var blockId = $(this).attr(mqBlockId),
                            block = blockId && MathElement[blockId],
                            cursor = block && block.cursor;

                        if (cursor) {
                            cursor.writeLatex(latex)
                            if (block.blurred) cursor.hide().parent.blur();
                        }
                    });
            case 'cmd':
                if (arguments.length > 1)
                    return this.each(function() {
                        var blockId = $(this).attr(mqBlockId),
                            block = blockId && MathElement[blockId],
                            cursor = block && block.cursor;

                        if (cursor) {
                            if (/^\\[a-z]+$/i.test(latex)) {
                                var selection = cursor.selection;
                                if (selection) {
                                    cursor.prev = selection.first.prev;
                                    cursor.next = selection.last.next;
                                    delete cursor.selection;
                                }
                                cursor.insertCmd(latex.slice(1), selection);
                            } else
                                cursor.insertCh(latex);
                            if (block.blurred) cursor.hide().parent.blur();
                        }
                    });
            case 'touchtap':
                var touchstartTarget = arguments[1],
                    x = arguments[2],
                    y = arguments[3];
                return this.each(function() {
                    var blockId = $(this).attr(mqBlockId),
                        block = blockId && MathElement[blockId],
                        cursor = block && block.cursor;
                    if (cursor && touchstartTarget !== cursor.handle[0]) {
                        var wasBlurred = block.blurred;
                        block.textareaManager.focus()
                        cursor.seek($(touchstartTarget), x, y, cachedClientRectFnForNewCache(), true);
                        if (!wasBlurred) cursor.showHandle();
                    }
                });
            case 'ignoreNextMousedown':
                var time = arguments[1];
                return this.each(function() {
                    var blockId = $(this).attr(mqBlockId),
                        block = blockId && MathElement[blockId];
                    if (block) {
                        block.ignoreMousedownTimeout = setTimeout(function() {
                            block.ignoreMousedownTimeout = undefined;
                        }, time);
                    }
                });
            case 'moveStart':
                var blockId = $(this).attr(mqBlockId),
                    block = blockId && MathElement[blockId];
                if (block && block.cursor)
                    block.cursor.prependTo(block);
                break;
            case 'moveEnd':
                var blockId = $(this).attr(mqBlockId),
                    block = blockId && MathElement[blockId];
                if (block && block.cursor)
                    block.cursor.appendTo(block);
                break;
            case 'isAtStart':
                var blockId = $(this).attr(mqBlockId),
                    block = blockId && MathElement[blockId],
                    cursor = block && block.cursor;
                if (cursor) return cursor.parent === cursor.root && !cursor.prev;
                break;
            case 'isAtEnd':
                var blockId = $(this).attr(mqBlockId),
                    block = blockId && MathElement[blockId],
                    cursor = block && block.cursor;
                if (cursor) return cursor.parent === cursor.root && !cursor.next;
                break;
            case 'selection':
                var blockId = $(this).attr(mqBlockId),
                    block = blockId && MathElement[blockId],
                    cursor = block && block.cursor;
                if (!cursor) return;
                return cursor.selection ? '$' + cursor.selection.latex() + '$' : '';
            case 'clearSelection':
                return this.each(function() {
                    var blockId = $(this).attr(mqBlockId),
                        block = blockId && MathElement[blockId],
                        cursor = block && block.cursor;
                    if (cursor) {
                        cursor.clearSelection();
                        if (block.blurred) cursor.hide().parent.blur();
                    }
                });
            default:
                var textbox = cmd === 'textbox',
                    editable = textbox || cmd === 'editable',
                    RootBlock = textbox ? RootTextBlock : RootMathBlock;
                return this.each(function() {
                    var container = $(this),
                        root = RootBlock();
                    createRoot(container, root, textbox, editable);
                    var cursor = root.cursor;
                    setupTextarea(editable, container, root, cursor);
                    root.editable = editable;
                    mouseEvents(container);
                    setupTouchHandle(editable, root, cursor);
                    if (!editable) return;
                    rootCSSClasses(container, textbox);
                    focusBlurEvents(root, cursor);
                    desmosCustomEvents(container, root, cursor);
                });
        }
    };

    //NOTE desmos doesn't want auto-render functionality because we want to avoid
    //interfering with clients' mathquill in our api
    //
    //on document ready, mathquill-ify all `<tag class="mathquill-*">latex</tag>`
    //elements according to their CSS class.
    // $(function() {
    //   $('.mathquill-editable:not(.mathquill-rendered-math)').mathquill('editable');
    //   $('.mathquill-textbox:not(.mathquill-rendered-math)').mathquill('textbox');
    //   $('.mathquill-embedded-latex:not(.mathquill-rendered-math)').mathquill();
    // });


}());

define("mathquill", function() {});

define('template!expression_item', ['underscore'], function(_) {
    return function(obj) {
        var __p = '';
        var print = function() { __p += Array.prototype.join.call(arguments, '') };
        with(obj || {}) {
            __p += '';
            if (renderShell) {;
                __p += '\n\n<div class="dcg-do-not-blur dcg-expressionitem dcg-shell">\n  <div class=\'dcg-shell\'></div>\n</div>\n\n';
            } else {;
                __p += '\n\n<div class="dcg-do-not-blur dcg-expressionitem">\n  <div class=\'dcg-fade-container\'>\n\n    <div class="dcg-fadeout-left"></div>\n\n    <span class="dcg-main">\n      <span class="dcg-transient-mathquill"></span>\n      <span class="dcg-template-mathquill"></span>\n    </span>\n\n    <span class="dcg-fadeout"></span>\n    <i class="dcg-icon-remove dcg-top-level-delete dcg-action-delete" handleEvent="true"></i>\n\n    <div class="dcg-slider-speed-container dcg-do-not-blur" handleEvent="true">\n      <span class="dcg-action-slower" >&laquo;</span>\n      <span class="dcg-variable-speed"></span>\n      <span class="dcg-action-faster">&raquo;</span>\n    </div>\n\n    <div class="dcg-template-bottom-container dcg-fixed-width-element">\n      <div class="dcg-template-bottom"></div>\n    </div>\n  </div>\n\n  <span class="dcg-tab dcg-action-drag dcg-action-icon-touch"\n        handleevent="true"\n        tapboundary="true"\n        disablescroll="true"\n  >\n    <span class="dcg-num dcg-variable-index"></span>\n    <span class="dcg-tab-interior dcg-action-icon-mouse">\n      <span class="template-expricon"></span>\n    </span>\n  </span>\n\n\n  <span class="dcg-exp-actions">\n    <span class="dcg-graphic" handleEvent="true"></span>\n    <nobr>\n      <span class="dcg-action-delete dcg-delete-btn dcg-tooltip" handleEvent="true" tooltip="' +
                    (t('Delete')) +
                    '"><i class=\'dcg-icon-remove\'></i></span>\n      <span class="dcg-action-duplicate dcg-duplicate-btn dcg-tooltip" handleEvent="true" tooltip="' +
                    (t('Duplicate')) +
                    '"><i class=\'dcg-icon-duplicate\'></i></span>\n      <span class="dcg-action-createtable dcg-tooltip" tooltip="' +
                    (t('Convert to Table')) +
                    '" handleEvent="true">\n        <i class=\'dcg-icon-table\'></i>\n      </span>\n    </nobr>\n  </span>\n</div>\n\n';
            };
            __p += '\n';
        }
        return __p;
    };
});
define('expressions/abstractitem_view', ['require', 'pjs', 'jquery', 'underscore_view', 'conditional_blur'], function(require) {
    var P = require('pjs');
    var $ = require('jquery');
    var UnderscoreView = require('underscore_view');
    var conditionalBlur = require('conditional_blur');

    var AbstractItemView = P(UnderscoreView, function(view, _super) {
        view.init = function(model, listView) {
            _super.init.call(this);

            this.model = model;
            this.listView = listView;

            // do this now instead of letting renderSelected do this. If we wait
            // for renderSelected to do it, we'll end up calling rerender within a
            // already started render loop. That'll cause events to get bound twice
            // and other weird stuff will happen.
            if (this.model.selected) {
                this.model.renderShell = false;
            }
            //always render the first 15 equations (unless they're in folders)
            if (this.model.index < 15 && !this.model.inCollapsedFolder) {
                this.model.renderShell = false;
            }


            this.model.observe('index.itemview', this.renderIndex.bind(this));
            this.model.observe('selected.itemview', this.renderSelected.bind(this));
            this.model.observe('renderShell.itemview', this.rerender.bind(this));
            this.model.observe('renderShell.itemview', this.setMinWidth.bind(this));
            this.model.observe('folder.itemview', this.renderFolder.bind(this));
            this.model.observe('inCollapsedFolder.itemview', this.renderCollapsedFolder.bind(this));
        };

        //clear focus at the list level if the list has focus
        view.clearListFocus = function() {
            if (this.listView && this.listView.model) {
                this.listView.model.setSelected(null);
            }
        };

        //triggered from list_view when projector mode is changed
        //override from the different item type views. right now, just text_view overrides
        view.onProjectorModeChange = function() {};

        view.destruct = function() {
            this.model.unobserve('.itemview');
            this.setProperty('transient', false);
        };

        view.getTemplateParams = function() {
            return {
                renderShell: this.model.renderShell,
                inCollapsedFolder: this.model.inCollapsedFolder
            };
        };

        //this is called before the animation begins. The goal:
        // if an animation is in process (i.e. dcg-do-animate class is present)
        //   get out of here
        // otherwise, set the height to where it's supposed to start then wait
        // a frame and add dcg-do-animate class. Subsequent calls to set the height
        // will animate through css
        view.setInitialAnimationHeight = function(height) {
            if (this.$templateBottomContainer.hasClass('dcg-do-animate')) return;

            this.$templateBottomContainer.css('height', height);
            var self = this;
            setTimeout(function() {
                self.$templateBottomContainer.addClass('dcg-do-animate');
            });
        };

        //this is called once an animation is already in process, to animate
        //the height of the template bottom
        view.animateHeightTimeout = null;
        view.clearHeightTimeout = null;
        view.animateHeightTo = function(height) {
            var self = this;

            //step 1: animate to the new height. add the faded-in / faded-out class
            // this is in a timeout so that rapid typing doesn't make the bottom see-saw
            clearTimeout(this.animateHeightTimeout);
            this.animateHeightTimeout = setTimeout(function() {
                self.$templateBottomContainer.css('height', height);
                self.$templateBottom.toggleClass('dcg-faded-in', (height > 0));
            }, 250);

            //step 2: wait for the last possible animation to have finished (250ms + time for the animation to run)
            //then remove the animation class and remove the fixed height.
            //this means that subsequent changes to the size of the bottom of the expression will just let the page
            //reflow normally
            clearTimeout(this.clearHeightTimeout);
            this.clearHeightTimeout = setTimeout(function() {
                self.$templateBottomContainer.css('height', 'auto');
                self.$templateBottomContainer.removeClass('dcg-do-animate');
            }, 550);
        };

        view.templateBottomItems = 0;

        view.addViewToBottom = function(view) {
            //TODO: this is for api usage with expressions: false.
            //Ideally, this method should never be reached if we have no expression views
            if (!this.$templateBottom) return;

            this.templateBottomItems++;
            //short-circuit if we're not animating
            //
            //this also shortcuts the case where another bottom item is present
            //this can happen if this new bottom item is added before an existing one is removed.
            //for example: a*b, add sliders for both. then delete the slider for b.
            //The "add sliders:" option is added before the evaluation is removed
            //between this and the above, we just swap out this item.

            if (!this.doAnimate || this.templateBottomItems > 1) {
                this.$templateBottom.addClass('dcg-faded-in');
                view.appendTo(this.$templateBottom);
                return;
            }

            //set the height to zero
            this.setInitialAnimationHeight(0);
            //append the view
            view.appendTo(this.$templateBottom);
            //update the height of the bottom region
            this.animateHeightTo(view.$().height());
        };

        view.removeViewFromBottom = function(view) {
            //TODO: this is for api usage with expressions: false.
            //Ideally, this method should never be reached if we have no expression views
            if (!this.$templateBottom) return;

            this.templateBottomItems--;

            //second half of the shortcutted logic if we're swapping in a bottom element
            if (this.templateBottomItems > 0) {
                view.remove();
                return;
            }

            //short circuit if we're not animating
            if (!this.doAnimate) {
                this.$templateBottom.removeClass('dcg-faded-in');
                view.remove();
                return;
            }

            //set the initial animation height to the full height of the bottom
            this.setInitialAnimationHeight(this.$templateBottom.height());
            //remove the view
            view.remove();
            //animate to zero
            this.animateHeightTo(0);
        };

        view.renderIndex = function() {
            var index = this.model.index;
            this.$().attr('index', index);
            this.$('.dcg-variable-index').text(index + 1);
        };

        view.renderFolder = function() {
            this.$().toggleClass('dcg-inFolder', !!this.model.folder);
        };

        view.renderCollapsedFolder = function() {
            this.$().toggleClass('dcg-inCollapsedFolder', !!this.model.inCollapsedFolder);
        };

        view.renderSelected = function() {
            if (this.model.selected) {
                if (this.model.renderShell) {
                    this.model.setProperty('renderShell', false);
                }
            }

            this.$().toggleClass('dcg-selected', !!this.model.selected);
        };

        view.setMinWidth = function() {
            this.$('.dcg-fixed-width-element').css('width', this.listView.minWidth - this.listView.scrollbarWidth);
        };

        view.didCreateElement = function() {
            this.setMinWidth();
            this.$templateBottom = this.$('.dcg-template-bottom');
            this.$templateBottomContainer = this.$('.dcg-template-bottom-container');
        };

        view.didInsertElement = function() {
            _super.didInsertElement.call(this);

            var self = this;
            this.$().on('tap tapstart', function(evt) {
                // when using mouse, fire on 'tapStart' and when on touch we
                // fire on the 'tap' event.
                if (evt.type === 'tap' && evt.device === 'mouse') return;
                if (evt.type === 'tapstart' && evt.device === 'touch') return;

                self.onMouseSelect(evt);
            });

            this.$('.dcg-action-drag').on('tapstart', this.onDragPending.bind(this));
            this.$('.dcg-action-delete').on('tap', this.onDelete.bind(this));

            this.$().attr('expr-id', this.model.id);
            this.renderIndex();
            this.renderSelected();
            this.renderFolder();
            this.renderCollapsedFolder();
        };

        view.triggerDelete = function() {};
        view.triggerEnterPressed = function() {};
        view.triggerUpPressed = function() {};
        view.triggerDownPressed = function() {};
        view.triggerBackspacePressed = function() {};
        view.triggerDelPressed = function() {};
        view.onMouseSelect = function() {};

        view.sendTapToMathQuill = function(evt, mq) {
            // stop the mathquill from losing focus immediately. Only do this when
            // using mouse. When on ipad, this stops you from being able to put
            // cursor. And when on ipad, focus doesn't get lost anyways.
            if (evt.device === 'mouse') {
                evt.preventDefault();
            }

            /*
             * This will simualte a mousedown on the mathquill itself so that
             * you can start a mouse selection from outside of mathquill. But,
             * this doesn't make much sense for ipad because we don't do selection on
             * mousedown for ipad, we do it on click. That's because we want scroll
             * to work. We also don't want to pass the event into mathquill if it
             * originally started in mathquill.
             */
            if (evt.device === 'mouse') {
                // let mathquill handle the event
                if ($.contains(mq[0], evt.target)) return;

                // the event we're looking at is of type 'tapstart' and that means
                // nothing to mathquill. We need to turn this back into a 'mousedown'
                // so that it can handle it normally.
                var fakeEvent = $.event.fix(evt.originalEvent);

                // pass into mathquill so it can act like it happened within mathquill
                mq.triggerHandler(fakeEvent);
            }

            // on ipad, use MathQuill API
            else {
                var touch = evt.originalEvent.changedTouches[0];
                mq.mathquill('touchtap', touch.target, touch.clientX, touch.clientY)
                    .mathquill('ignoreNextMousedown', 1000);
            }
        };

        view.onDelete = function() {
            this.triggerDelete();
        };

        view.convertTo = function(cls, state) {

            var obj = cls(state);
            var index = this.model.index;
            var list = this.model.list;
            var folder = this.model.folder;

            obj.setProperty('list', list);

            list.undoRedo.oneTransaction(function() {
                list.removeItemAt(index);
                list.insertItemAt(index, obj);
                if (folder) folder.addItem(obj);
            });

            return obj;
        };

        view.getBounds = function() {
            var dom = this.$();
            var offset = dom.offset();
            if (!offset) return null;

            var top = offset.top;
            var height = dom.height();

            return {
                top: top,
                bottom: top + height
            };
        };

        // override in subclass
        view.allowDragDrop = function() {
            return true;
        };

        view.onDragPending = function(evt) {
            // clear focus when clicking expression handle
            conditionalBlur();

            // don't start dragging if we're not allowed to
            if (!this.allowDragDrop()) return;
            var self = this;
            this.mouseMovedTo = null;

            //if timeout happens or mouse moves sufficiently far, we will start dragging
            //if mouseup, then this was a tap, and we should let it do its thing

            //Start after 500ms
            var dragStartTimeout = setTimeout(function() {
                $(document).off('.dragpending');
                self.onDragStart(evt);
            }, 500);

            //Start after moving
            $(document).on('tapmove.dragpending', function(new_evt) {
                // mouse has moved since tapstart. record this in case we actually do start dragging
                self.mouseMovedTo = new_evt.touches[0];

                var dx = evt.touches[0].x - self.mouseMovedTo.x;
                var dy = evt.touches[0].y - self.mouseMovedTo.y;

                // must have moved more than 3px away from tapstart position to immediately trigger drag
                if (Math.sqrt(dx * dx + dy * dy) > 3) {
                    clearTimeout(dragStartTimeout);
                    $(document).off('.dragpending');
                    self.onDragStart(evt);
                }
            });

            //Cancel on mouseup
            $(document).on('tapend.dragpending', function(new_evt) {
                clearTimeout(dragStartTimeout);
                $(document).off('.dragpending');
            });
        };

        view.onDragStart = function(evt) {
            // don't start dragging if we're not allowed to
            if (!this.allowDragDrop()) return;
            this.listView.dragdrop_expressions.start(evt, this);

            // we've moved our mouse since the initial tapstart. drag the expression to that point
            if (this.mouseMovedTo) {
                this.hideContextMenu();
                this.listView.dragdrop_expressions.drag(this.mouseMovedTo.x, this.mouseMovedTo.y);
            }
        };

        view.hideContextMenu = function() {
            this.triggerEvent('hideContextMenu');
        };

        view.processMissedKeyEvent = function(evt) {};
        view.addFocus = function(where) {};
        view.isFocused = function() { return false };
    });

    return AbstractItemView;
});

define('expressions/expression_view', ['require', 'jquery', 'pjs', './expression_icon_view', 'expressions/evaluation', 'expressions/unresolved', 'expressions/domain_view', 'expressions/regression_view', 'expressions/slider_view', 'expressions/promptslider_view', './expression', 'graphing/columnmode', 'i18n', 'conditional_blur', './text', './table', 'mathquill', 'jquery.handleevent', 'keys', 'template!expression_item', 'expressions/abstractitem_view'], function(require) {
    var $ = require('jquery');
    var P = require('pjs');
    var ExpressionIconView = require('./expression_icon_view');
    var EvaluationView = require('expressions/evaluation');
    var UnresolvedView = require('expressions/unresolved');
    var DomainView = require('expressions/domain_view');
    var RegressionView = require('expressions/regression_view');
    var SliderView = require('expressions/slider_view');
    var PromptSliderView = require('expressions/promptslider_view');
    var ExpressionObject = require('./expression');
    var COLUMNMODE = require('graphing/columnmode');
    var i18n = require('i18n');
    var conditionalBlur = require('conditional_blur');

    //For convert-to text and convert-to-table
    var TextObject = require('./text');
    var TableObject = require('./table');

    require('mathquill');
    require('jquery.handleevent');
    var Keys = require('keys');

    var template = require('template!expression_item');

    var AbstractItemView = require('expressions/abstractitem_view');

    var ExpressionView = P(AbstractItemView, function(view, _super) {
        view.template = template;

        view.init = function(model, listView, toastView) {
            _super.init.call(this, model, listView);
            this.toastView = toastView;
            this.model.observe('formula.exprview', this.onFormulaChange.bind(this));
            this.model.observe('selected.exprview', this.onSelectedChange.bind(this));
            this.model.observe('latex.exprview', this.onLatexChange.bind(this));
            this.model.observe('dependent.exprview', this.renderDependent.bind(this));
            this.model.observe('isTableable.exprview', this.renderIsTableable.bind(this));
            this.model.observe('unresolved.exprview', this.renderUnresolved.bind(this));
            this.model.observe('loading.exprview', this.onLoadingChange.bind(this));
        };

        // enable animations on the frame after the expression is loaded
        view.onLoadingChange = function() {
            if (!this.model.loading) {
                var self = this;
                setTimeout(function() {
                    self.setProperty('doAnimate', true);
                });
            }
        };

        view.renderIsTableable = function() {
            this.$('.dcg-action-createtable').toggleClass('dcg-disabled', !this.model.isTableable);
        };

        view.destruct = function() {
            _super.destruct.call(this);

            this.model.unobserve('.exprview');

            if (this.iconView) {
                this.iconView.remove();
                this.iconView = null;
            }

            if (this.sliderView) {
                // Trigger our removal from the slider timer.
                this.sliderView.remove();
                this.sliderView = null;
            }

            if (this.promptSliderView) {
                this.promptSliderView.remove();
                this.promptSliderView = null;
            }

            if (this.domainView) {
                this.domainView.remove();
                this.domainView = null;
            }

            if (this.regressionView) {
                this.regressionView.remove();
                this.regressionView = null;
            }

            if (this.evaluationView) {
                this.evaluationView.remove();
                this.evaluationView = null;
            }

            if (this.unresolvedView) {
                this.unresolvedView.remove();
                this.unresolvedView = null;
            }
        };

        view.onLatexChange = function() {
            if (this.sliderView && this.sliderView.slider.transient) {
                this.updateTransientValue();
                return;
            }

            var latex = this.model.latex;
            if (latex === '"' || latex === "'") {
                this.convertTo(TextObject, { selected: true });
                this.listView.getSelectedView().addFocus();
                return;
            }
            //call up to list_view, so that other listeners can listen
            this.listView.onLatexChange(latex);

            this.updateMathquill();
        };

        view.updateMathquill = function() {
            if (!this.mathquill) return;

            var latex = this.model.latex;

            if (latex !== undefined && this.mathquill.mathquill('latex') !== latex)
                this.mathquill.mathquill('latex', latex);
        };

        view.updateTransientValue = function() {
            if (!this.$transientValue || !this.$transientValue.length) return;
            this.$transientValue[0].innerHTML = (
                this.model.slider.computeSnappedValue(this.model.slider.value)
                .toString()
                .replace('-', '<span class="unary-operator">\u2212</span>')
            );
        };

        // OVERRIDE TO CREATE APPROPRIATE CHILD VIEW. IF NOT OVERRIDDEN, THE
        // VIEW WILL SIMPLY NOT BE CREATED AT RUNTIME.
        view.createIconView = function() {
            return ExpressionIconView(this);
        };
        view.createSliderView = function() {
            return SliderView(this.model.slider, this);
        };
        view.createPromptSliderView = function() {
            return PromptSliderView(this);
        };
        view.createDomainView = function() {
            return DomainView(this.model.domain);
        };
        view.createRegressionView = function() {
            return RegressionView(this.model.formula.regression, this.listView);
        };
        view.createEvaluationView = function() {
            return EvaluationView(this);
        };

        view.onFormulaChange = function() {
            /* jshint maxcomplexity:20 */
            // Skip this while we are rendering shell. Without this catch, we'd
            // create the child views while rendring the shells and throw them
            // away when we render fully.
            if (this.model.renderShell) return;

            var formula = this.model.formula;

            // closes stale context menus
            this.hideContextMenu();

            var showSlider = formula.is_slidable;
            if (this.sliderView && !showSlider) {
                this.sliderView.slider.unobserve('.expressionView');
                this.removeViewFromBottom(this.sliderView);
                this.sliderView = null;
                this.$().removeClass('dcg-hasSlider');
            } else if (!this.sliderView && showSlider) {
                this.sliderView = this.createSliderView();
                if (this.sliderView) {
                    this.addViewToBottom(this.sliderView);
                    this.sliderView.setProperty('dependentLabel', this.getDependentLabel());
                    this.$().addClass('dcg-hasSlider');
                    this.sliderView.slider.observe(
                        'transient.expressionView',
                        this.updateTransient.bind(this)
                    );
                    this.updateTransient();
                }
            }
            var promptCreateSlider = formula.variables && formula.variables.length > 0;
            if (this.promptSliderView && !promptCreateSlider) {
                this.removeViewFromBottom(this.promptSliderView);
                this.promptSliderView = null;
            } else if (!this.promptSliderView && promptCreateSlider) {
                this.promptSliderView = this.createPromptSliderView();
                if (this.promptSliderView) {
                    this.addViewToBottom(this.promptSliderView);
                }
            }

            var showDomain = formula.is_parametric;
            if (this.domainView && !showDomain) {
                this.removeViewFromBottom(this.domainView);
                this.domainView = null;
                this.$().removeClass('dcg-hasDomain');
            } else if (!this.domainView && showDomain) {
                this.domainView = this.createDomainView();
                if (this.domainView) {
                    this.addViewToBottom(this.domainView);
                    this.$().addClass('dcg-hasDomain');
                }
            }

            var showRegression = formula.is_regression;
            if (this.regressionView && !showRegression) {
                this.removeViewFromBottom(this.regressionView);
                this.regressionView = null;
                this.$().removeClass('dcg-hasRegression');
            } else if (!this.regressionView && showRegression) {
                this.regressionView = this.createRegressionView();
                this.addViewToBottom(this.regressionView);
                this.$().addClass('dcg-hasRegression');
            }

            var showEvaluation = formula.is_evaluable;
            if (this.evaluationView && !showEvaluation) {
                this.removeViewFromBottom(this.evaluationView);
                this.evaluationView = null;
            } else if (!this.evaluationView && showEvaluation) {
                this.evaluationView = this.createEvaluationView();
                if (this.evaluationView) {
                    this.addViewToBottom(this.evaluationView);
                    this.$().addClass('.dcg-hasEvaluation');
                    this.evaluationView.setProperty('dependentLabel', this.getDependentLabel());
                }
            }

            if (this.sliderView && !this.sliderView.slider.transient) {
                this.model.slider.setProperty('value', formula.constant_value);
            }

            if (this.promptSliderView) {
                this.promptSliderView.setProperty('variables', formula.variables);
            }

            if (this.evaluationView) {
                this.evaluationView.setProperty('evaluations', formula.zero_values);
            }

            if (this.regressionView) {
                this.regressionView.setProperty('regression', formula.regression);
            }
        };

        view.renderDependent = function() {
            if (this.sliderView) {
                this.sliderView.setProperty('dependentLabel', this.getDependentLabel());
            }
            if (this.evaluationView) {
                this.evaluationView.setProperty('dependentLabel', this.getDependentLabel());
            }
        };

        view.renderUnresolved = function() {
            var unresolved = this.model.unresolved;

            if (!unresolved && this.unresolvedView) {
                this.unresolvedView.remove();
                this.unresolvedView = null;
            }

            if (unresolved && !this.unresolvedView) {
                this.unresolvedView = UnresolvedView();
                this.addViewToBottom(this.unresolvedView);
            }
        };

        // NOTE: this will get called once with model.renderShell = true and once
        // with model.renderShell = false. The first time, the template will
        // shortcircuit and render the bare minimum. The second time the entire
        // dom will get destroyed and rebuilt. We don't want to add any nested
        // views when model.renderShell = false because the views' dom elements will
        // get wiped out as soon as we render with model.renderShell = false. And,
        // the whole point of renderShell=true is that we want as little as
        // possible to happen at startup as possible.
        view.didInsertElement = function() {
            _super.didInsertElement.call(this);
            if (this.model.renderShell) return;

            this.mathquill = this.$('.dcg-template-mathquill').mathquill('editable');
            this.$transientLhs =
                this.$('.dcg-transient-mathquill').mathquill('editable');
            this.$transientLhs.hide();
            this.$transientValue = $('<span>');

            this.mathquill.on(
                'render upPressed downPressed enterPressed backspacePressed delPressed keydown focusin focus',
                this.onMathquillEvent.bind(this)
            );
            this.$transientLhs.on('tapstart', this.onSelectTransient.bind(this));
            this.mathquill.mathquill('latex', this.model.latex || "");

            this.iconView = this.createIconView();
            if (this.iconView) {
                this.iconView.replace(this.$('.template-expricon'));
            }

            this.$('.dcg-action-duplicate').on('tap', this.onDuplicateWithoutFocus.bind(this));
            this.$('.dcg-action-createtable').on('tap', this.onCreateTable.bind(this));

            this.$('.dcg-action-faster').on('tap', this.animateFaster.bind(this));
            this.$('.dcg-action-slower').on('tap', this.animateSlower.bind(this));

            this.renderIsTableable();
            this.onFormulaChange();
        };

        view.animateFaster = function() {
            if (this.sliderView) this.sliderView.animateFaster();
        };
        view.animateSlower = function() {
            if (this.sliderView) this.sliderView.animateSlower();
        };

        view.onSelectedChange = function() {
            if (!this.model.selected && this.mathquill) {
                // take focus out of mathquill
                this.mathquill.mathquill('clearSelection').mathquill('blur');
            }
        };

        view.onSelectTransient = function() {
            this.stopTransient();
            this.mathquill.mathquill('focus');
        };

        view.onMathquillEvent = function(evt) {
            /* jshint maxcomplexity:14 */
            switch (evt.type) {
                case "render":
                    this.model.setProperty('latex', this.mathquill.mathquill('latex'));
                    return;

                case "focus":
                case "focusin":
                    if (this.sliderView) this.sliderView.slider.setProperty('isPlaying', false);
                    this.model.setProperty('selected', true);
                    return;

                case "upPressed":
                    this.triggerUpPressed();
                    return;

                case "downPressed":
                    this.triggerDownPressed();
                    return;

                case "enterPressed":
                    this.triggerEnterPressed();
                    return;

                case "backspacePressed":
                    if (!this.model.isEmpty()) return;
                    this.triggerBackspacePressed();
                    return;

                case "delPressed":
                    if (!this.model.isEmpty()) return;
                    this.triggerDelPressed();
                    return;

                case "keydown":
                    if (Keys.lookup(evt) === Keys.ESCAPE) conditionalBlur();
                    return;
            }
        };

        view.onDuplicateWithoutFocus = function() {

            var index = this.model.index;
            var state = this.model.getState();
            state.selected = false;
            delete state.id;

            var list = this.model.list;
            var folder = this.model.folder;
            var obj = ExpressionObject(state, list);

            list.undoRedo.oneTransaction(function() {
                list.insertItemAt(index + 1, obj);
                if (folder) folder.addItem(obj);
            });

            return obj;
        };

        view.onMouseSelect = function(evt) {
            if (this.listView.editListMode) return;

            if (evt.wasHandled()) return;
            evt.handle();

            this.model.setProperty('selected', true);

            this.sendTapToMathQuill(evt, this.mathquill);
        };

        view.getDependentLabel = function() {
            var dependent = this.model.dependent;
            if (!dependent) return '';

            //reformat to add back in brackets if we have a subscript
            if (dependent.match(/(.*)_(.+)/)) {
                dependent = dependent.replace(/(.*)_(.+)/, "$1_{$2}");
            }

            // ask mathquill for an html version of itself
            // note: this will break for things like parentheses, which need to be
            // inserted into the dom to know their correct size we should probably
            // be passing around mathquill objects instead of strings, but this
            // works for uncomplicated mathquill
            dependent = $(
                "<span>" +
                dependent +
                "</span>"
            ).mathquill('editable').mathquill('html');

            // surround it in the right class so that it can pull in mathquill
            // stylings
            dependent = (
                "<span class='mathquill-rendered-math'>" +
                dependent +
                "</span>"
            );

            return dependent;
        };

        var lhs = function(latex) {
            return latex.replace(RegExp("=[^=]+$"), "=");
        };

        view.startTransient = function() {
            this.setProperty('transient', true);
            this.updateTransientValue();
            this.$transientLhs.show();
            this.mathquill.hide();
            this.$transientLhs.mathquill('latex', lhs(this.model.latex));
            this.$transientLhs
                .children('.mathquill-root-block')
                .append(this.$transientValue);
        };

        view.stopTransient = function() {
            this.setProperty('transient', false);
            this.$transientValue.remove();
            this.$transientLhs.hide();
            this.mathquill.show();
            this.updateMathquill();
        };

        view.updateTransient = function() {
            if (!this.$transientValue || !this.$transientValue.length) return;

            if (this.sliderView.slider.transient) {
                this.startTransient();
            } else {
                this.stopTransient();
            }
        };

        view.isFocused = function() {
            return $(document.activeElement).closest(this.mathquill).length !== 0;
        };

        view.addFocus = function(where) {
            if (!this.mathquill) return;

            this.mathquill.mathquill('focus');

            if (where === 'start') {
                this.mathquill.mathquill('moveStart');
            } else if (where === 'end') {
                this.mathquill.mathquill('moveEnd');
            }
        };

        view.onCreateTable = function() {

            var formula = this.model.formula;

            if (!this.model.isTableable) return;

            var table_info = formula.table_info;
            var index = this.model.index;
            var state = { selected: true };

            var columnMode = COLUMNMODE.POINTS_AND_LINES;
            if (formula.is_point_list || this.model.hidden)
                columnMode = COLUMNMODE.POINTS;

            var i;
            var independent_values = [];
            var dependent_values = [];
            if (table_info.values) {
                for (i = 0; i < table_info.values.length; i++) {
                    independent_values.push(table_info.values[i][0]);
                    dependent_values.push(table_info.values[i][1]);
                }
            } else {
                for (i = -2; i <= 2; i++) {
                    independent_values.push(i);
                    dependent_values.push('');
                }
            }

            state.columns = [{
                latex: table_info.independent_variable,
                values: independent_values
            }, {
                latex: table_info.dependent_column,
                color: this.model.color,
                hidden: false,
                columnMode: columnMode,
                values: dependent_values
            }];

            var list = this.model.list;
            var listView = this.listView;
            var folderId = (this.model.folder ? this.model.folder.id : null);
            listView.setProperty('editListMode', false);

            list.undoRedo.oneTransaction(function() {
                if (!table_info.by_reference) {
                    list.removeItemAt(index);
                    index--;
                }

                var obj = TableObject(state, list);
                list.insertItemAt(index + 1, obj);
                if (folderId !== null) list.getItemById(folderId).addItem(obj);
            });

            var undoCallback = function() {
                listView.setProperty('editListMode', true);
            };
            this.listView.toastView.show(i18n.t("Table created."), { undoCallback: undoCallback });
        };
    });

    return ExpressionView;
});

define('template!text', ['underscore'], function(_) {
    return function(obj) {
        var __p = '';
        var print = function() { __p += Array.prototype.join.call(arguments, '') };
        with(obj || {}) {
            __p += '';
            if (renderShell) {;
                __p += '\n\n<div class="dcg-do-not-blur dcg-expressionitem dcg-expressiontext dcg-shell">\n  <div class=\'dcg-shell\'></div>\n</div>\n\n';
            } else {;
                __p += '\n\n<div class="dcg-do-not-blur dcg-expressiontext dcg-expressionitem">\n  <div class=\'dcg-fade-container\'>\n\n    <span class="dcg-main">\n      <div class="dcg-smart-textarea-placeholder"></div>\n    </span>\n    <i class="dcg-icon-remove dcg-top-level-delete dcg-action-delete" handleEvent="true"></i>\n\n  </div>\n\n  <span class="dcg-tab dcg-action-drag"\n        handleevent="true"\n        tapboundary="true"\n        disablescroll="true"\n  >\n    <span class=\'dcg-num dcg-variable-index\'></span>\n    <div class=\'dcg-tab-interior\'></div>\n    <i class=\'dcg-icon-text\'></i>\n  </span>\n\n  <span class=\'dcg-exp-actions\'>\n    <span\n      class="dcg-action-delete dcg-delete-btn dcg-tooltip"\n      handleEvent="true"\n      tooltip="' +
                    (t('Delete')) +
                    '"\n    >\n      <i class=\'dcg-icon-remove\'></i>\n    </span>\n  </span>\n\n</div>\n\n';
            };
            __p += '';
        }
        return __p;
    };
});
define('loadcss!css/smart_textarea', function() {});
define('template!smart_textarea', ['underscore'], function(_) {
    return function(obj) {
        var __p = '';
        var print = function() { __p += Array.prototype.join.call(arguments, '') };
        with(obj || {}) {
            __p += '<div class="dcg-smart-textarea-container">\n  <div class="dcg-displayTextarea dcg-fixed-width-element"></div>\n  <textarea class="dcg-do-blur dcg-fixed-width-element dcg-smart-textarea" placeholder="' +
                (t('enter a note...')) +
                '"></textarea>\n</div>';
        }
        return __p;
    };
});
/*
 *  This is a utility that is used in folders and text views
 *  It takes a textarea and a div that's supposed to cover the textarea
 *  It updates the div to match the textarea, including swapping in links
 *  It resizes the textarea to match the div
 */

define('expressions/smart_textarea', ['require', 'loadcss!css/smart_textarea', 'jquery', 'pjs', 'underscore_view', 'browser', 'jquery.handleevent', 'keys', 'conditional_blur', 'template!smart_textarea'], function(require) {
    require('loadcss!css/smart_textarea');
    var $ = require('jquery');
    var P = require('pjs');
    var UnderscoreView = require('underscore_view');
    var Browser = require('browser');
    require('jquery.handleevent');
    var Keys = require('keys');
    var conditionalBlur = require('conditional_blur');

    var template = require('template!smart_textarea');

    var SmartTextarea = P(UnderscoreView, function(view, _super) {
        view.template = template;
        view.init = function(text) {
            _super.init.call(this);

            this.$textarea = null;
            this.$displayText = null;
            this.setProperty('text', text || '');
        };

        view.didCreateElement = function() {
            _super.didCreateElement.call(this);

            this.$textarea = this.$('.dcg-smart-textarea');
            this.$displayText = this.$('.dcg-displayTextarea');
            this.observe('text', this.renderText.bind(this));

            this.$textarea.on('input propertychange change', function(evt) {
                this.setProperty('text', this.$textarea.val());
            }.bind(this));
            this.$textarea.on('keydown', this.onKeydownEvent.bind(this));

            this.$displayText.on('touchend', function(evt) {
                evt.preventDefault();
            });

            // We are going to stop clicks on links and let the rest filter through to the focus() handler below.
            this.$displayText.on('tap tapstart', 'a', function(evt) {
                evt.handle();
            });

            // FF has an issue where focus is lost of we change the '.selected' class while clicking. Instead of
            // allowing the "onMouseSelect" code to run, we just expect that the expression will get focus. And that
            // will also cause this to become selected. The difference is that by doing "evt.handle()" here we focus
            // then select (rather than select then focus). FF simply prefers it that way.
            this.$textarea.on('tapstart', function(evt) {
                evt.handle();
            }.bind(this));

            this.$textarea.focus(function() {
                this.setProperty('focused', true);
            }.bind(this));
            this.$textarea.blur(function() {
                this.setProperty('focused', false);
            }.bind(this));
        };

        view.didInsertElement = function() {
            _super.didInsertElement.call(this);
            this.renderText();
        };

        view.onKeydownEvent = function(evt) {
            /* jshint maxcomplexity:12 */
            if (!this.$textarea) return;

            var ta = this.$textarea[0];
            var key = Keys.lookup(evt);

            // pressing enter inside textarea creates a new expression underneath
            if (key === Keys.ENTER) {
                evt.preventDefault();
                this.triggerEvent('enterPressed');
                // pressing escape removes focus
            } else if (key === Keys.ESCAPE) {
                conditionalBlur();
                // pressing up while at start of textarea selects expression above
            } else if (key === Keys.UP) {
                if (ta.selectionStart === 0 && ta.selectionEnd === 0) {
                    evt.preventDefault();
                    this.triggerEvent('upPressed');
                }
                // pressing down while at end of textarea selects expression below
            } else if (key === Keys.DOWN) {
                if (ta.selectionStart === ta.value.length && ta.selectionEnd === ta.value.length) {
                    evt.preventDefault();
                    this.triggerEvent('downPressed');
                }
                // pressing backspace when completely empty should delete textarea
            } else if (key === Keys.BACKSPACE) {
                if (ta.value.length === 0) {
                    evt.preventDefault();
                    this.triggerEvent('backspacePressed');
                }
                // pressing delete when completely empty should delete textarea
            } else if (key === Keys.DELETE) {
                if (ta.value.length === 0) {
                    evt.preventDefault();
                    this.triggerEvent('delPressed');
                }
            }
        };

        view.destruct = function() {
            this.blur();
        };

        view.markedUpText = function() {
            var marked_up_text = this.text || '';
            // converts '<' and '>' to html entity
            marked_up_text = marked_up_text.replace(/</g, '&lt;').replace(/>/g, '&gt;');

            // wraps links in <a> tags
            var exp = /(\b(https?|ftp):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])/ig;
            marked_up_text = marked_up_text.replace(exp, "<a href='$1' target ='_blank'>$1</a>");

            return marked_up_text;
        };

        view.renderText = function() {
            if (!this.$textarea) return;

            this.$textarea.val(this.text);
            this.$displayText.html(this.markedUpText());
            this.fitText();
            this.$textarea.toggleClass('dcg-empty', !this.text);
            setTimeout(this.fitText.bind(this), 1); //TODO - do we still need this?
        };

        view.fitText = function() {
            if (!this.$displayText) return;

            var height = this.$displayText.outerHeight();
            if (height > 0) this.$textarea.css('height', height);
        };

        view.isFocused = function() {
            return $(document.activeElement).closest(this.$()).length !== 0;
        };

        view.blur = function() {
            if (this.$textarea) this.$textarea.blur();
        };

        view.addFocus = function(where) {
            // Can't reliably focus textarea programatically from within iframe on ipad
            // see #3106
            if (Browser.IS_IPAD && Browser.IS_IN_IFRAME) {
                return;
            }
            var textarea = this.$textarea[0];
            textarea.focus();
            if (where === 'end') {
                textarea.selectionStart = textarea.selectionEnd = textarea.value.length;
            } else if (where === 'start') {
                textarea.selectionStart = textarea.selectionEnd = 0;
            }
        };
    });

    return SmartTextarea;
});

define('expressions/text_view', ['require', 'jquery', 'pjs', './abstractitem_view', 'template!text', './smart_textarea', 'jquery.handleevent'], function(require) {
    var $ = require('jquery');
    var P = require('pjs');
    var AbstractItemView = require('./abstractitem_view');
    var template = require('template!text');
    var SmartTextarea = require('./smart_textarea');
    require('jquery.handleevent');

    var TextView = P(AbstractItemView, function(view, _super) {
        view.template = template;

        view.init = function(model, listView) {
            _super.init.call(this, model, listView);

            this.model.observe('selected.textview', this.onSelectedChange.bind(this));

            //sync up smart_textarea and this.model
            this.smartTextarea = SmartTextarea(this.model.text);
            this.model.observe('text.textview', function() {
                this.smartTextarea.setProperty('text', this.model.text);
            }.bind(this));
            this.smartTextarea.observe('text', function() {
                this.model.setProperty('text', this.smartTextarea.text);
            }.bind(this));

            // fitText doesn't work when we're hidden. Must do it when being shown.
            this.model.observe('inCollapsedFolder.textview', function() {
                if (!this.model.inCollapsedFolder) {
                    this.smartTextarea.fitText();
                }
            }.bind(this));
        };

        view.destruct = function() {
            this.model.unobserve('.textview');
            this.smartTextarea.destruct();
        };

        view.onProjectorModeChange = function() {
            this.smartTextarea.fitText();
        };

        view.didInsertElement = function() {
            _super.didInsertElement.call(this);

            if (this.model.renderShell) return;
            this.smartTextarea.replace(this.$('.dcg-smart-textarea-placeholder'));

            this.smartTextarea.observe('focused', function() {
                if (this.smartTextarea.focused) this.model.setProperty('selected', true);
            }.bind(this));

            this.smartTextarea.observeEvent('enterPressed', this.triggerEnterPressed.bind(this));
            this.smartTextarea.observeEvent('upPressed', this.triggerUpPressed.bind(this));
            this.smartTextarea.observeEvent('downPressed', this.triggerDownPressed.bind(this));
            this.smartTextarea.observeEvent('backspacePressed', this.triggerBackspacePressed.bind(this));
            this.smartTextarea.observeEvent('delPressed', this.triggerDelPressed.bind(this));
            //need to include smart-textarea in minWidth
            this.setMinWidth();
        };

        view.onSelectedChange = function() {
            if (!this.model.selected) {
                this.smartTextarea.blur();
            }
        };

        view.onMouseSelect = function(evt) {
            if (evt.wasHandled()) return;
            evt.handle();

            this.model.setProperty('selected', true);
        };

        view.isFocused = function() {
            return $(document.activeElement).closest(this.$()).length !== 0;
        };

        view.addFocus = function(where) {
            this.smartTextarea.addFocus(where);
        };
    });

    return TextView;
});

define('loadcss!css/expressions.table', function() {});
define('template!table_icon', ['underscore'], function(_) {
    return function(obj) {
        var __p = '';
        var print = function() { __p += Array.prototype.join.call(arguments, '') };
        with(obj || {}) {
            __p += '<span class="dcg-icon-box dcg-variable-errortooltip tipsy-sticky dcg-action-icon dcg-do-not-blur" \n      handleevent="true"\n      disablescroll="true"\n>\n  <span class="dcg-icon dcg-graph-icon dcg-variable-colorcss">\n    <i class=\'dcg-icon-hidden\'></i>\n  </span>\n</span>';
        }
        return __p;
    };
});
define('template!table_column_menu', ['underscore'], function(_) {
    return function(obj) {
        var __p = '';
        var print = function() { __p += Array.prototype.join.call(arguments, '') };
        with(obj || {}) {
            __p += '<div class=\'dcg-table-column-menu dcg-options-menu\'>\n  <div class=\'dcg-triangle\'></div>\n  <div class=\'dcg-styles-div\'>\n    <div class=\'dcg-title\'>' +
                (t('style:')) +
                '</div>\n    <div>\n      <span class=\'dcg-columnmode-option dcg-graph-icon dcg-table-points dcg-variable-colorcss\' mode="POINTS"></span>\n      <span class=\'dcg-columnmode-option dcg-graph-icon dcg-table-lines dcg-variable-colorcss\' mode="LINES"></span>\n      <span class=\'dcg-columnmode-option dcg-graph-icon dcg-table-points-and-lines dcg-variable-colorcss\' mode="POINTS_AND_LINES"></span>\n    </div>\n  </div>\n  <div class=\'dcg-colors-div\'>\n    <div class=\'dcg-title\'>' +
                (t('color:')) +
                '</div>\n    <div class="template-colorsview"></div>\n  </div>\n</div>';
        }
        return __p;
    };
});
define('expressions/table_column_menu_view', ['require', 'pjs', 'underscore_view', 'template!table_column_menu', 'jquery', './color_menu_view'], function(require) {
    var P = require('pjs');
    var UnderscoreView = require('underscore_view');
    var template = require('template!table_column_menu');
    var $ = require('jquery');
    var ColorMenuView = require('./color_menu_view');

    var TableColorMenuView = P(UnderscoreView, function(view, _super) {
        view.template = template;

        view.init = function(parentView, column) {
            _super.init.call(this);
            this.column = column;
            this.parentView = parentView;

            this.column.observe('color.columnmenuview', this.renderColorCSS.bind(this));
            this.column.observe('columnMode.columnmenuview', this.renderSelectedColumnMode.bind(this));
            this.column.observe('shouldGraph.columnmenuview', this.renderSelectedColumnMode.bind(this));
        };

        view.destruct = function() {
            this.column.unobserve('.columnmenuview');
        };

        view.renderColorCSS = function() {
            var color = this.column.color;
            this.$('.dcg-variable-colorcss').css({
                'border-color': color,
                'background-color': color
            });
        };

        view.renderSelectedColumnMode = function() {
            this.$('.dcg-columnmode-option').removeClass('dcg-selected');

            if (this.column.shouldGraph) {
                var columnMode = this.column.columnMode;
                this.$('.dcg-columnmode-option[mode="' + columnMode + '"]').addClass('dcg-selected');
            }
        };

        view.didInsertElement = function() {
            this.$().on('tap tapstart', '.dcg-columnmode-option', this.onSelectColumnMode.bind(this));
            this.renderColorCSS();
            this.renderSelectedColumnMode();

            // this view has a nested template. We instantiate the color picker
            // and replace a placeholder element within the html.
            var colorsView = ColorMenuView(this.column);
            colorsView.replace(this.$('.template-colorsview'));
        };

        view.onSelectColumnMode = function(evt) {
            // when using mouse, fire on 'tapStart' and when on touch we
            // fire on the 'tap' event.
            if (evt.type === 'tap' && evt.device === 'mouse') return;
            if (evt.type === 'tapstart' && evt.device === 'touch') return;

            var columnMode = $(evt.target).closest('.dcg-columnmode-option').attr('mode');

            // the column is visible and we've clicked the same columnMode again; hide the column and return
            if (!this.column.hidden && this.column.columnMode === columnMode) {
                this.column.setProperty('hidden', true);
                return;
            }

            this.column.setProperty('columnMode', columnMode);
            this.column.setProperty('hidden', false);

            // making column visible should make folder visible
            var folder = this.column.table.folder;
            if (folder) {
                folder.setProperty('hidden', false);
            }
        };

    });

    return TableColorMenuView;
});

define('expressions/table_icon_view', ['require', './abstract_icon', 'pjs', 'template!table_icon', 'graphing/columnmode', './table_column_menu_view', 'jquery.handleevent', 'conditional_blur'], function(require) {
    var AbstractIconView = require('./abstract_icon');
    var P = require('pjs');
    var template = require('template!table_icon');
    var COLUMNMODE = require('graphing/columnmode');
    var TableColumnMenuView = require('./table_column_menu_view');
    require('jquery.handleevent');
    var conditionalBlur = require('conditional_blur');

    var TableIconView = P(AbstractIconView, function(view, _super) {
        view.template = template;

        view.init = function(parentView) {
            _super.init.call(this, parentView);
            this.column = this.model;
            this.tableView = parentView.tableView;
            this.listView = this.tableView.listView;
            this.column.observe('color.iconview', this.renderColorCSS.bind(this));
            this.column.observe('error.iconview', this.onDisplayChange.bind(this));
            this.column.observe('columnMode.iconview', this.onDisplayChange.bind(this));
            this.column.observe('shouldGraph.iconview', this.onDisplayChange.bind(this));
            this.tableView.observeEvent('hideContextMenu.iconview', this.hideOptions.bind(this));
        };

        view.destruct = function() {
            _super.destruct.call(this);
            this.column.unobserve('.iconview');
            this.tableView.unobserve('.iconview');
        };

        view.renderErrorShown = function() {
            this.$('.dcg-icon').toggleClass('dcg-error', !!this.errorShown);
            this.$().closest('.dcg-cell').toggleClass('dcg-error', !!this.errorShown);
        };

        view.renderColorCSS = function() {
            this.$('.dcg-variable-colorcss').css('border-color', this.column.color);
            this.$('.dcg-variable-colorcss').css('background', this.column.color);
        };

        view.toggleGraphShown = function() {
            if (!this.column.isGraphable) return;
            if (this.errorShown) return;

            // Trying to edit whether a graph is shown in a hidden folder should
            // show the folder.
            if (this.model.table.folder && this.model.table.folder.hidden) {
                this.model.table.folder.setProperty('hidden', false);
                this.column.setProperty("hidden", false);
                return;
            }

            this.column.setProperty("hidden", !this.column.hidden);
        };

        view.didInsertElement = function() {
            _super.didInsertElement.call(this);
            var self = this;

            function handleIconTap(evt) {
                if (evt.wasLongheld()) return;
                if (self.optionsShown) {
                    self.hideOptions();
                    return;
                }
                if (self.listView.editListMode) {
                    self.toggleOptions();
                } else {
                    self.toggleGraphShown();
                }
            }

            function handleIconLongHold(evt) {
                if (self.optionsShown) return;
                self.toggleOptions(); // will create TableColumnMenuView
            }

            function handleIconTapStart(evt_orig) {
                if (self.optionsShown) return;
                if (evt_orig.touches.length !== 1) return;

                conditionalBlur();
            }

            this.$('.dcg-action-icon').on('tap', handleIconTap);
            this.$('.dcg-action-icon').on('longhold', handleIconLongHold);
            this.$('.dcg-action-icon').on('tapstart', handleIconTapStart);

            this.renderColorCSS();
            this.onDisplayChange();

            this.$icon = this.$('.dcg-icon');
        };

        view.createOptionsMenuView = function() {
            var optionsView = TableColumnMenuView(this, this.column);
            optionsView.appendTo(this.listView.$());

            // putting the column menu view at the topLeft of the .dcg-icon-box
            // it's up to the column menu view's css to position it beyond that
            var placeholder = this.$('.dcg-icon-box');
            var placeholderOffset = placeholder.offset();
            var listViewOffset = this.listView.$().offset();
            optionsView.$().css({
                position: 'absolute',
                top: placeholderOffset.top - listViewOffset.top + 'px',
                left: placeholderOffset.left - listViewOffset.left + 'px',
                display: 'block' //wait until we know where it is to show it. fixes #3154
            });

            return optionsView;
        };

        view.onDisplayChange = function() {
            _super.onDisplayChange.call(this);
            if (!this.$icon) return;

            var shouldGraph = this.column.shouldGraph;
            var columnMode = this.column.columnMode;
            var isGraphable = this.column.isGraphable;
            var icon_class = '';

            if (this.error || !isGraphable) {
                icon_class = '';
            } else {

                if (!shouldGraph) {
                    icon_class = 'dcg-graph-hidden';
                } else if (columnMode === COLUMNMODE.POINTS) {
                    icon_class = 'dcg-table-points';
                } else if (columnMode === COLUMNMODE.LINES) {
                    icon_class = 'dcg-table-lines';
                } else if (columnMode === COLUMNMODE.POINTS_AND_LINES) {
                    icon_class = 'dcg-table-points-and-lines';
                }

            }

            // efficently changes the class of the icon
            if (this.rendered_icon_class === icon_class) return;
            if (this.rendered_icon_class) {
                this.$icon.removeClass(this.rendered_icon_class);
            }
            this.rendered_icon_class = icon_class;
            if (icon_class) {
                this.$icon.addClass(icon_class);
            }

        };
    });

    return TableIconView;
});
define('template!table', ['underscore'], function(_) {
    return function(obj) {
        var __p = '';
        var print = function() { __p += Array.prototype.join.call(arguments, '') };
        with(obj || {}) {
            __p += '';
            if (renderShell) {;
                __p += '\n\n<div class="dcg-expressionitem dcg-expressiontable dcg-shell">\n  <div class=\'dcg-shell\'></div>\n</div>\n\n';
            } else {;
                __p += '\n\n<div class="dcg-expressionitem dcg-expressiontable">\n\n  <div class=\'dcg-fade-container dcg-disable-horizontal-scroll-to-cursor\'>\n\n    <span class="dcg-main">\n      <div class="dcg-tabledata">\n\n        ';
                _.each(columns, function(column, c) {;
                    __p += '\n          <div class="dcg-column">\n\n            ';

                    print(templates.table_cell_header());

                    _.each(columns[0].cells, function(junk, r) {
                        print(templates.table_cell_body())
                    });

                    ;
                    __p += '\n\n          </div>\n        ';
                });;
                __p += '\n\n      </div>\n    </span>\n\n    ';
                //covers up the right hand side of an overflowing table
                ;
                __p += '\n    <span class="dcg-fadeout"></span>\n    <i class="dcg-icon-remove dcg-top-level-delete dcg-action-delete" handleEvent="true"></i>\n  </div>\n\n  <span class="dcg-tab dcg-action-drag"\n        handleevent="true"\n        tapboundary="true"\n        disablescroll="true"\n  >\n    <span class=\'dcg-num dcg-variable-index\'></span>\n    <div class=\'dcg-tab-interior\'></div>\n  </span>\n\n  <span class=\'dcg-exp-actions\'>\n\n    <span\n      class="dcg-action-delete dcg-delete-btn dcg-tooltip"\n      handleEvent="true"\n      tooltip="' +
                    (t('Delete')) +
                    '"\n    >\n      <i class=\'dcg-icon-remove\'></i></span>\n    </span>\n</div>\n\n';
            };
            __p += '\n';
        }
        return __p;
    };
});
define('template!table_cell_body', ['underscore'], function(_) {
    return function(obj) {
        var __p = '';
        var print = function() { __p += Array.prototype.join.call(arguments, '') };
        with(obj || {}) {
            __p += '<div class="dcg-non-editable dcg-empty dcg-cell">\n  <div class="dcg-inner-border"></div>\n  <span class="dcg-error-indicator dcg-do-not-blur tipsy-sticky" handleevent="true">\n  </span>\n\n  <span class=\'mathquill-rendered-math\'></span>\n  <div class="dcg-empty-line"></div>\n</div>\n';
        }
        return __p;
    };
});
define('template!table_cell_header', ['underscore'], function(_) {
    return function(obj) {
        var __p = '';
        var print = function() { __p += Array.prototype.join.call(arguments, '') };
        with(obj || {}) {
            __p += '<div class="dcg-cell dcg-table-header">\n  <div class="dcg-inner-border"></div>\n  <span class="template-icon"></span>\n  <span class="mathquill-rendered-math"></span>\n  <span class="dcg-fadeout"></span>\n  <span class="dcg-action-removecolumn dcg-icon-remove dcg-do-not-blur" handleevent="true"></span>\n  <div class="dcg-empty-line"></div>\n</div>\n';
        }
        return __p;
    };
});
define('expressions/table_view', ['require', 'loadcss!css/expressions.table', 'jquery', 'underscore', 'pjs', 'underscore_view', 'mathquill', 'jquery.handleevent', 'keys', 'conditional_blur', 'i18n', './abstractitem_view', './table_icon_view', 'template!table', 'template!table_cell_body', 'template!table_cell_header'], function(require) {
    require('loadcss!css/expressions.table');
    var $ = require('jquery');
    var _ = require('underscore');
    var P = require('pjs');
    var UnderscoreView = require('underscore_view');
    require('mathquill');
    require('jquery.handleevent');
    var Keys = require('keys');
    var conditionalBlur = require('conditional_blur');
    var i18n = require('i18n');

    var AbstractItemView = require('./abstractitem_view');
    var TableIconView = require('./table_icon_view');

    var templates = {};

    templates.table = require('template!table');
    templates.table_cell_body = require('template!table_cell_body');
    templates.table_cell_header = require('template!table_cell_header');

    var TableView = P(AbstractItemView, function(view, _super) {

        view.template = templates.table;

        view.init = function(model, listView) {
            _super.init.call(this, model, listView);

            this.model.triggerRowRemoved = this.onRowRemoved.bind(this);
            this.model.triggerRowAdded = this.onRowAdded.bind(this);
            this.model.triggerColumnAdded = this.onColumnAdded.bind(this);
            this.model.triggerColumnRemoved = this.onColumnRemoved.bind(this);
            this.model.triggerColumnMoved = this.onColumnMoved.bind(this);
            this.model.observe('changingMultipleCells.' + this.guid, this.onChangingMultipleCells.bind(this));
            this.model.observe('selectedCell.' + this.guid, this.onSelectedCellChange.bind(this));
            this.model.observe('inCollapsedFolder.' + this.guid, function() {
                if (!this.model.inCollapsedFolder) {
                    //even though we render initially when you open a collapsed folder,
                    //I think we still need this for the following (absurd) edge case:
                    //* open folder
                    //* close folder
                    //* toggle projector mode
                    //* open folder
                    this.recomputeAllRowHeights();
                }
            }.bind(this));
        };

        view.destruct = function() {
            this.model.unobserve('.' + this.guid);

            function noop() {}
            this.model.triggerRowRemoved = noop;
            this.model.triggerRowAdded = noop;
            this.model.triggerColumnAdded = noop;
            this.model.triggerColumnRemoved = noop;
            this.model.triggerColumnMoved = noop;
        };

        view.getTemplateParams = function() {
            return {
                columns: this.model.columns,
                renderShell: this.model.renderShell,
                templates: templates
            };
        };

        view.onChangingMultipleCells = function() {
            // we're done making multiple changes. check if any cell changes
            // requested a syncRow
            if (!this.model.changingMultipleCells) {
                if (this.__syncRowRequestedDuringBatchedUpdate) {
                    this.__syncRowRequestedDuringBatchedUpdate = false;
                    this.syncAllRowHeights();
                }
            }
        };

        view.onRowRemoved = function(index) {
            if (!this.columnViews) return;

            // index starts at 0 for row under headers. columnViews starts at 0
            // including header. Make the adjustment here.
            var r = index + 1;

            // remove the cells
            for (var c = 0; c < this.columnViews.length; c++) {
                var cellView = this.columnViews[c].splice(r, 1)[0];
                cellView.remove();
            }

            // update which cell is selected
            this.model.notifyPropertyChange('selectedCell');
        };

        view.onRowAdded = function(index) {
            if (!this.columnViews) return;

            // index starts at 0 for row under headers. columnViews starts at 0
            // including header. Make the adjustment here.
            var r = index + 1;
            var cell;
            var cellView;
            var columns = this.model.columns;
            var columnCount = this.columnViews.length;
            var $columns = this.$('.dcg-column');

            for (var c = 0; c < columnCount; c++) {
                cell = columns[c].cells[index];

                // insert new cells into columns to form a row
                cellView = CellView(cell, this);
                cellView.insertAfter($columns.eq(c).find('.dcg-cell:nth-of-type(' + r + ')'));

                this.columnViews[c].splice(r, 0, cellView);
            }

            this.syncRowHeight(r);

            this.listView.model.updateDrawOrder();

            // update which cell is selected
            this.model.notifyPropertyChange('selectedCell');
        };

        view.onColumnRemoved = function(index) {
            if (!this.columnViews) return;

            // remove the cells and then the entire column
            var columnCellViews = this.columnViews.splice(index, 1)[0];
            for (var i = 0; i < columnCellViews.length; i++) {
                columnCellViews[i].remove();
            }
            this.$('.dcg-column:nth-child(' + (index + 1) + ')').remove();

            var cell = this.selectedCell;

            if (cell && cell.column > index) {
                // selection was after the deleted column, so decrease selected
                // column.
                this.setProperty('selectedCell', { row: cell.row, column: cell.column - 1 });
            } else if (cell && cell.column === index) {
                // deleted column was selected, so we need to try to select another
                // one.

                if (this.columns.length <= index) {
                    // we just deleted the last column, so we have to select the one
                    // to the left of where we just deleted
                    this.selectCell(cell.row, cell.column - 1);
                } else {
                    // we can put focus back in the column that just slid into the
                    // deleteded one's place.
                    this.selectCell(cell.row, cell.column);
                }
            } else {
                // don't need to do anything because the deleted column was after the
                // selected column. Or, there was no selected column.
            }

            this.syncAllRowHeights();

            this.listView.model.updateDrawOrder();

            // update which cell is selected
            this.model.notifyPropertyChange('selectedCell');
        };

        view.onColumnAdded = function(index) {
            if (!this.columnViews) return;

            var column = this.model.columns[index];
            var cells = column.cells;
            var i, views = [];

            // create header
            views.push(HeaderView(column, this));

            // create each cell for each row
            for (i = 0; i < cells.length - 1; i++) {
                views.push(CellView(cells[i], this));
            }

            // add bottom cell
            views.push(BottomCellView(cells[i], this));

            this.columnViews.splice(index, 0, views);

            // add a column to the table
            var $column = $('<div class="dcg-column"></div>').insertAfter(this.$('.dcg-column:nth-child(' + index + ')'));

            // add each cell view to the column
            views.forEach(function(view, i) {
                view.appendTo($column);
            });

            this.syncAllRowHeights();

            this.listView.model.updateDrawOrder();

            // update which cell is selected
            this.model.notifyPropertyChange('selectedCell');
        };

        view.onColumnMoved = function(from, to) {
            if (!this.columnViews) return;
            var columnView = this.columnViews.splice(from, 1)[0];
            this.columnViews.splice(to, 0, columnView);

            // remove the column and insert somewhere else
            var $movedColumn = this.$('.dcg-column:nth-child(' + (from + 1) + ')').detach();
            $movedColumn.insertAfter(this.$('.dcg-column:nth-child(' + (to) + ')'));
        };

        view.onProjectorModeChange = function() {
            this.recomputeAllRowHeights();
        };

        view.didCreateElement = function() {
            var self = this;
            this.$().on('focusin', function() {
                setTimeout(self.onFocusChange.bind(self), 0);
            });
            this.$().on('keydown', this.onMathQuillKeydownEvent.bind(this));
            this.$().on(
                'upPressed downPressed leftPressed rightPressed enterPressed backspacePressed delPressed',
                this.onMathQuillSpecialEvent.bind(this)
            );
        };

        view.didInsertElement = function() {
            _super.didInsertElement.call(this);
            if (this.model.renderShell) return;

            this.columnViews = [];

            // all the cells are placed in the dom, but they aren't setup yet.
            // optimization: could walk through the table more efficiently to access
            // the cell's dom element rather than doing a this.findCell(r,c) every
            // time. Could walk left to right, top to bottom.
            var columns = this.model.columns;
            var columnCount = columns.length;
            var rowCount = columns[0].cells.length;
            var r, c, cell, cellView;

            // setup header cells
            for (c = 0; c < columnCount; c++) {
                cell = columns[c];

                if (c + 1 < columnCount) {
                    cellView = HeaderView(cell, this);
                } else {
                    cellView = RightHeaderView(cell, this);
                }

                cellView.setDomNode(this.findCell(0, c));
                this.columnViews[c] = [cellView];
            }

            // setup body cells
            var bottomRow = rowCount;

            for (r = 1; r <= rowCount; r++) {
                for (c = 0; c < columnCount; c++) {
                    cell = columns[c].cells[r - 1];

                    if (r === bottomRow) {
                        cellView = BottomCellView(cell, this);
                    } else {
                        cellView = CellView(cell, this);
                    }

                    cellView.setDomNode(this.findCell(r, c));

                    this.columnViews[c].push(cellView);
                }
            }

            this.syncAllRowHeights();
            this.onSelectedCellChange();
        };

        view.measureRowHeight = function(row) {
            var maxCollapsedHeight = 0;

            for (var i = 0; i < this.columnViews.length; i++) {
                var cellView = this.columnViews[i][row];

                // make sure we've measured this cell before. Newly created cells are collapsed but unmeasured
                if (cellView.collapsedHeight === undefined) {
                    cellView.measureHeight();
                }

                if (cellView.collapsedHeight > maxCollapsedHeight) {
                    maxCollapsedHeight = cellView.collapsedHeight;
                }
            }

            return maxCollapsedHeight;
        };

        view.setRowHeight = function(row, height) {
            for (var i = 0; i < this.columnViews.length; i++) {
                var cellView = this.columnViews[i][row];
                cellView.setHeight(height);
                cellView.setMathquillTop();
            }
        };

        view.recomputeAllRowHeights = function() {
            if (!this.columnViews) return;
            // must collapse all cells first
            for (var i = 0; i < this.columnViews.length; i++) {
                var views = this.columnViews[i];
                for (var j = 0; j < views.length; j++) {
                    views[j].collapseHeight();
                }
            }

            this.syncAllRowHeights();
        };

        // is called when entire table needs updated
        view.syncAllRowHeights = function() {
            if (this.model.inCollapsedFolder) return;

            var row;
            var rows = this.columnViews[0].length;
            var heights = [];

            for (row = 0; row < rows; row++) {
                heights.push(this.measureRowHeight(row));
            }

            for (row = 0; row < rows; row++) {
                this.setRowHeight(row, heights[row]);
            }
        };

        view.syncRowHeight = function(row) {
            // optimizes the case that multiple cells are being updated at once.
            // instead of measuring row heights for each value update, we wait until
            // the last cell is changed and measure all rows once.
            if (this.model.changingMultipleCells) {
                this.__syncRowRequestedDuringBatchedUpdate = true;
            } else {
                this.setRowHeight(row, this.measureRowHeight(row));
            }
        };

        view.onSelectedCellChange = function() {
            if (!this.columnViews) return;

            // could optimize by remembering what cell last had selected class
            this.$('.dcg-tabledata .dcg-selected').removeClass('dcg-selected');

            var cell = this.model.selectedCell;

            // TODO - set selectedCell = null at time the cell is deleted rather than
            // catch it here. This is a bit hacky.
            // make sure cell isn't out of range
            if (cell) {
                if (cell.column >= this.columnViews.length || cell.row >= this.columnViews[0].length) {
                    this.model.selectedCell = null; //silently overwrite the property. won't fire observers
                    return;
                }
            }

            if (cell) {
                var cellView = this.columnViews[cell.column][cell.row];
                cellView.$().addClass('dcg-selected');

                this.model.setProperty('selected', true);
            }

            // if the cell with focus isn't selected, then remove focus
            var caret = this.getCaretPosition();
            if (caret && !_.isEqual(caret, cell)) {
                if (document.activeElement) {
                    conditionalBlur();
                }
            }

            // need to do this manually if the cell that's focused is not editable.
            // these handlers are what hide/show keypad.
            if (cell) {
                var input = this.findCellInput(cell.row, cell.column)[0];
                this.listView.onFocusIn({ target: input });
            } else {
                this.listView.onFocusOut();
            }

            var no_faded_h = cell && cell.column + 1 === this.model.columns.length;
            var no_faded_v = cell && cell.row === this.model.columns[0].cells.length;
            this.$().toggleClass('dcg-no-faded-h', !!no_faded_h);
            this.$().toggleClass('dcg-no-faded-v', !!no_faded_v);

            this.hideContextMenu();

            var lastRowSelected = (
                this.model.selectedCell &&
                this.model.selectedCell.row === this.model.columns[0].cells.length
            );

            this.setProperty('lastRowSelected', lastRowSelected);
        };

        view.onMouseSelect = function(evt) {
            if (evt.wasHandled()) return;
            evt.handle();

            // use .originalEvent.target to ignore the bounds-checking stuff that
            // touchtracking.js does, because the cursor handle can (and in fact
            // usually does) stick out of the td's bounding box
            var td = $(evt.originalEvent.target).closest('.dcg-cell');
            var editable = td.find('.mathquill-editable');
            if (editable.length) {
                this.sendTapToMathQuill(evt, editable);
                return;
            }

            var target = $(evt.target);
            var table = target.closest('.dcg-tabledata')[0];

            // if we're clicking on the table itself, we don't know which cell
            // we meant to click. We'll just act like we clicked the outer padding.
            // that's not terrible, because for us to reach this point, we must
            // have clicked in seemingly blank space anyways.
            if (table && evt.target === table) {
                table = null;
            }

            if (!table) {
                if (document.activeElement) conditionalBlur();

                this.model.setProperty('selectedCell', null);
                this.model.setProperty('selected', true);
                return;
            }

            //select the uneditable cell
            var cell = this.getNodesCellPosition(target);
            this.selectCell(cell.row, cell.column);
        };

        view.getNodesCellPosition = function(node) {
            var c = node.closest('.dcg-column').prevAll('.dcg-column').length;
            var r = node.closest('.dcg-cell').prevAll('.dcg-cell').length;
            return { row: r, column: c };
        };

        view.getCaretPosition = function() {
            if (this.$().find(document.activeElement).length) {
                return this.getNodesCellPosition($(document.activeElement));
            } else {
                return null;
            }
        };

        view.findCell = function(r, c) {
            return this.$('.dcg-column:nth-of-type(' + (c + 1) + ') .dcg-cell:nth-of-type(' + (r + 1) + ')');
        };

        view.findCellInput = function(r, c) {
            return this.findCell(r, c).find('.mathquill-rendered-math');
        };

        view.selectCell = function(r, c, selectEnd) {
            if (r < 0 || c < 0) return;

            var mathquill = this.findCellInput(r, c);
            if (!mathquill.length) return;

            var newSelectedCell = { row: r, column: c };
            this.model.setProperty('selectedCell', newSelectedCell);

            if (mathquill.hasClass('mathquill-editable')) {
                mathquill.mathquill('focus');
                if (selectEnd) {
                    mathquill.mathquill('moveEnd');
                } else {
                    mathquill.triggerHandler('select_all');
                }
            } else {
                conditionalBlur();
            }
        };

        view.unfocus = function() {
            var active = document.activeElement;
            if (this.$().find(active).length) {
                active.blur();
            }
        };

        view.processMissedKeyEvent = function(evt) {
            this.doKeyAction(Keys.lookup(evt), evt);
        };

        view.onMathQuillKeydownEvent = function(evt) {
            var key = Keys.lookup(evt);
            if (key === Keys.Tab || key === Keys.ESCAPE) {
                this.doKeyAction(key, evt);
            }
        };

        view.onMathQuillSpecialEvent = function(evt) {
            var evt_type = evt.type;
            var key = evt_type.slice(0, -('Pressed'.length));
            key = key.charAt(0).toUpperCase() + key.slice(1);
            this.doKeyAction(key, evt);
        };

        view.doKeyAction = function(key, evt) {
            /* jshint maxcomplexity:24 */
            // it's possible this came from a fake key event (keypad for example)
            // just create a dumby event so that evt.preventDefault() is callable.
            if (!evt) evt = $.Event();

            var list = this.listView.model;

            var selectedCell = this.model.selectedCell;
            var r_orig = selectedCell ? selectedCell.row : -1;
            var c_orig = selectedCell ? selectedCell.column : -1;

            var columns = this.model.columns;
            var totalRows = columns[0].cells.length;
            var totalCols = columns.length;

            var _move = function(r, c) {

                // try to wrap it around up one row and to the very right.
                if (r === -1) {
                    this.triggerUpPressed();
                } else if (r > totalRows) {
                    this.triggerDownPressed();
                } else {

                    // wrap around the left side. goes up a row and to the far right.
                    if (c === -1) {
                        c = totalCols - 1;
                        r--;

                        // wrap around the right side. goes down a row and to the far left.
                    } else if (c === totalCols) {
                        r++;
                        c = 0;
                    }

                    this.selectCell(r, c);
                    evt.preventDefault();
                }
            }.bind(this);

            var _deleteRow = function(r) {

                // don't delete the last row
                if (totalRows <= 1) return;

                // remove the old row
                this.model.removeRow(r_orig - 1);

                this.selectCell(r, c_orig);
                evt.preventDefault();
            }.bind(this);

            var _deleteColumn = function(c) {
                // don't delete the first col, and don't delete one of last two cols
                if (c_orig === 0 || totalCols <= 2) return;

                // remove the old row
                this.model.removeColumn(c_orig);

                this.selectCell(r_orig, c);
                evt.preventDefault();
            }.bind(this);

            switch (key) {

                case Keys.LEFT:
                    _move(r_orig, c_orig - 1);
                    break;
                case Keys.RIGHT:
                    _move(r_orig, c_orig + 1);
                    break;
                case Keys.UP:
                    _move(r_orig - 1, c_orig);
                    break;
                case Keys.DOWN:
                    _move(r_orig + 1, c_orig);
                    break;

                case Keys.ENTER:
                    //at the end, we add a new expression underneath
                    if (r_orig >= totalRows) return this.triggerEnterPressed();

                    //in later columns, we just move down
                    if (c_orig > 0) return _move(r_orig + 1, c_orig);

                    //in the last row of the first column, we auto-populate
                    if (r_orig === totalRows - 1) {
                        this.model.insertRow(r_orig, this.model.getAutofillValues(r_orig));
                        return this.selectCell(r_orig + 1, c_orig);
                    }

                    //default in first column: insert blank row
                    this.model.insertRow(r_orig, c_orig);
                    this.selectCell(r_orig + 1, c_orig);
                    break;

                case Keys.ESCAPE:
                    conditionalBlur();
                    this.model.setProperty('selectedCell', null);
                    break;

                case Keys.TAB:

                    // if focus isn't within the table, then prevent tab default.
                    if ($(document.activeElement).closest(this.$()).length === 0) {
                        evt.preventDefault();
                        return;
                    }
                    break;

                case Keys.BACKSPACE:
                    if (r_orig === 0) {
                        if (c_orig === 0) { //backspace in empty top-left cell removes whole table
                            this.triggerBackspacePressed();
                            list.undoRedo.triggerFlash();
                        }

                        // move left if you're the rightmost column or in only column after the first
                        else if (c_orig === totalCols - 1 || c_orig === 1 && totalCols === 3) {
                            _move(0, c_orig - 1);
                        } else {
                            _deleteColumn(c_orig - 1);
                        }

                    } else if (c_orig !== 0) {
                        _move(r_orig, c_orig - 1);
                    } else if (r_orig === totalRows) {
                        // backspace in bottom row simply moves up a row.
                        _move(r_orig - 1, c_orig);
                    } else {
                        _deleteRow(r_orig - 1);
                    }
                    break;

                case Keys.DELETE:
                    if (r_orig === 0) {
                        if (c_orig === 0) {
                            this.triggerDelPressed();
                            list.undoRedo.triggerFlash();
                        }

                        // only delete column if its not on the far right
                        else if (c_orig < totalCols - 1) {
                            _deleteColumn(c_orig);
                        }

                    } else if (r_orig >= totalRows) {
                        // can't delete last row
                    } else {
                        _deleteRow(r_orig);
                    }
                    break;
            }
        };

        view.onFocusChange = function() {
            if (!this.model) return;
            this.model.setProperty('selectedCell', this.getCaretPosition());
            if (!this.model.list) return;
            //changing selection within a table should be treated like other instances of selection changing
            //for example: we want to ensureActiveChildIsVisible in list_view
            this.model.list.notifyPropertyChange('selectedItem');
        };


        view.isFocused = function() {
            return !!this.model.selectedCell;
        };

        view.addFocus = function(where, r, c) {
            if (where === 'cell') {
                this.selectCell(r, c);
            } else if (where !== 'end') {
                this.selectCell(0, 0);
            } else {
                this.selectCell(this.model.columns[0].cells.length, 0);
            }
        };

    });


    // a view that will be a cell within a div-based table. it contains machinery to measure and set the cell's
    // height. That's important for syncing the heights of all cells in a 'row'
    var DivCellView = P(UnderscoreView, function(divCellView, _super) {

        divCellView.init = function() {
            _super.init.call(this);

            this.collapsedHeight = undefined;
            this.renderedHeight = undefined;
            this.mathquillTop = 0;
        };

        // overridden by subclass
        divCellView.lookupCellPosition = function() {};

        divCellView.handleHeightUpdate = function() {
            this.collapseHeight();
            this.tableView.syncRowHeight(this.lookupCellPosition().row);
        };

        // removes the height style of the cell. It'll collapse down to the size of the contents
        // NOTE: this.collapsedHeight and this.renderedHeight will be invalid after this
        //       it's up to whomever calls this to make sure measureHeight is called
        //       at an appropriate time. The two have been split for potential performance reasons.
        divCellView.collapseHeight = function() {
            this.$().css('height', '');
            this.collapsedHeight = undefined;
            this.renderedHeight = undefined;
        };

        // measures the current height. It's assumed that the cell is collapsed; otherwise you
        // could have just read this.renderedHeight directly
        divCellView.measureHeight = function() {
            this.collapsedHeight = this.$().outerHeight();
            this.renderedHeight = this.collapsedHeight;
        };

        // sets the new height of the cell
        divCellView.setHeight = function(height) {
            if (this.renderedHeight !== height) {
                this.renderedHeight = height;
                this.$().css('height', height);
            }
        };

        // moves mathquill to the bottom of the cell
        divCellView.setMathquillTop = function() {
            var mathquillTop = this.renderedHeight - this.collapsedHeight;
            if (mathquillTop !== this.mathquillTop) {
                this.mathquillTop = mathquillTop;
                this.$('.mathquill-rendered-math').css('top', mathquillTop);
            }
        };
    });

    var RightHeaderView = P(DivCellView, function(headerView, _super) {
        headerView.template = templates.table_cell_header;

        headerView.init = function(model, tableView) {
            _super.init.call(this);

            this.model = model;
            this.tableView = tableView;
        };

        headerView.lookupCellPosition = function() {
            return {
                row: 0,
                column: this.model.index
            };
        };

        headerView.didInsertElement = function() {
            _super.didInsertElement.call(this);

            // it's the right side
            this.$().addClass('dcg-right');
            this.$().append('<span class="dcg-fade-right"></span>');

            this.$mathquill = this.$('.mathquill-rendered-math').mathquill('editable');

            var self = this;
            this.$().on('blur focusout', '.mathquill-rendered-math', function() {
                self.$mathquill.mathquill('clearSelection');
            });

            this.$().on('render', '.mathquill-rendered-math', function() {
                var latex = $(this).mathquill('latex');
                if (!latex) return;

                // set latex back to blank
                $(this).mathquill('latex', '');

                var index = self.model.index;
                self.model.table.insertColumn(index, { latex: latex });

                // select the new cell and put focus at end
                self.tableView.selectCell(0, index, true);
            });
        };

    });

    var HeaderView = P(DivCellView, function(headerView, _super) {
        headerView.template = templates.table_cell_header;

        headerView.init = function(model, tableView) {
            _super.init.call(this);
            this.__renderedLatex = '';
            this.__renderedBefore = false;

            this.model = model;
            this.tableView = tableView;

            // TODO - get rid of a need to put index in html
            this.model.observe('index.headerview', this.updateIndex.bind(this));
            this.model.observe('latex.headerview', this.onLatexChange.bind(this));
            this.model.observe('selected.headerview', this.onSelectedChange.bind(this));
        };

        // it's possible to select the headers during trace, so we need
        // to make sure we focus the header too
        headerView.onSelectedChange = function() {
            if (this.model.selected) {
                var tableView = this.tableView;
                if (!tableView) return;

                tableView.selectCell(0, this.model.index);
            }
        };

        headerView.lookupCellPosition = function() {
            return {
                row: 0,
                column: this.model.index
            };
        };

        headerView.destruct = function() {
            this.model.unobserve('.headerview');
        };

        headerView.updateIndex = function() {
            this.$().attr('index', this.model.index);
        };

        headerView.onLatexChange = function() {
            if (!this.$mathquill) return;

            if (this.__renderedLatex !== this.model.latex) {
                this.__renderedLatex = this.model.latex;
                this.$mathquill.mathquill('latex', this.model.latex);
            }

            if (this.__renderedBefore) this.handleHeightUpdate();
            this.__renderedBefore = true;
        };

        headerView.didInsertElement = function() {
            _super.didInsertElement.call(this);

            if (this.model.index === 0) {
                this.$().addClass('dcg-left');
            }

            this.$mathquill = this.$('.mathquill-rendered-math').mathquill('editable');
            // TODO - move these mathquill handlers up to the table view instead of
            // assigning them on each table cell individually
            var self = this;
            this.$().on('blur focusout', '.mathquill-rendered-math', function() {
                self.$mathquill.mathquill('clearSelection');
            });
            this.$().on('tap', '.dcg-action-removecolumn', function() {
                self.model.table.removeColumn(self.model.index);
            });
            this.$().on('render', '.mathquill-rendered-math', function() {
                var oldLatex = self.model.latex;
                var newLatex = $(this).mathquill('latex');
                if (oldLatex === newLatex) return;

                self.__renderedLatex = newLatex;
                self.model.setProperty('latex', newLatex);
            });

            this.iconView = TableIconView(this);
            this.iconView.replace(this.$('.template-icon'));

            this.onLatexChange();
            this.updateIndex();
        };

    });


    var BaseCellView = P(DivCellView, function(cellView, _super) {
        cellView.template = templates.table_cell_body;

        cellView.init = function(model, tableView) {
            _super.init.call(this);

            this.model = model;
            this.tableView = tableView;

            this.__renderedDisabled = true;
            this.__renderedValue = '';
            this.__renderedError = '';
            this.__renderedBefore = false;
        };

        cellView.didInsertElement = function() {
            _super.didInsertElement.call(this);

            if (this.model.column === _.first(this.model.column.table.columns)) {
                this.$().addClass('dcg-left');
            }

            if (this.model.column === _.last(this.model.column.table.columns)) {
                this.$().addClass('dcg-right');
                this.$().append('<span class="dcg-fade-right"></span>');
            }

            if (this.model === _.last(this.model.column.cells)) {
                this.$().addClass('dcg-bottom');
                this.$().append('<span class="dcg-fade-bottom"></span>');
            }
        };

        cellView.lookupCellPosition = function() {
            var cells = this.model.column.cells;
            var cell = this.model;

            return {
                row: _.indexOf(cells, cell) + 1, //because there is a header above it
                column: this.model.column.index
            };
        };

        cellView.onValueChange = function() {
            var oldValue = this.model.getOldProperty('value');
            var value = this.model.value;
            this.$().toggleClass('dcg-empty', !value);

            if (!this.$mathquill) return;

            if (this.__renderedValue !== value) {
                this.__renderedValue = value;

                // disabled mathquill can only have simple numerical values. Just
                // set the text. Ideally .mathquill('latex', ...) would work for
                // non-editable mathquill, but it doesn't. So we can hack this
                // together by simply setting the inner contents directly.
                if (this.__renderedDisabled) {
                    this.$mathquill.text(value).mathquill();
                } else {
                    this.$mathquill.mathquill('latex', value);
                }
            }

            // we were a single line and are still a single line if the oldValue and new value
            // are both (a simple number OR empty). If this has happened, we don't need to
            // update the height of this cell. It hasn't changed.
            var stillSingleLine = (!oldValue || isFinite(oldValue)) && (!value || isFinite(value));
            if (this.__renderedBefore && !stillSingleLine) this.handleHeightUpdate();
            this.__renderedBefore = true;
        };

        cellView.onDisabledChange = function() {
            var disabled = !!this.model.column.disabled;
            if (!this.$mathquill || this.__renderedDisabled === disabled) return;
            this.__renderedDisabled = disabled;

            this.$().toggleClass('dcg-non-editable', !!disabled);

            // revert mathquill to not editable
            if (disabled) {
                // Ideally we'd use .mathquill('revert') but that doesn't do what
                // you'd expect. It completely gets rid of mathquill. It doesn't turn
                // an editable mathquill back to non-editable. So, we destroy the
                // mathquill and replace it with an non-editable one.
                var $newMathquill = $('<span class="mathquill-rendered-math">' + this.model.value + '</span>');
                this.$mathquill.replaceWith($newMathquill);
                this.$mathquill = $newMathquill;

                // created a new mathquill, so mark that it's not shifted down at all
                this.mathquillTop = 0;
            }

            // make mathquill editable
            else {

                // TODO - The empty underline is the wrong size if we make
                // mathquill editable in the same code loop as when the td
                // is added to the dom. Not sure how to fix that.
                this.$mathquill.mathquill('editable');
            }
        };

        cellView.onErrorChange = function() {
            var error = this.model.error ? i18n.unpack(this.model.error) : '';

            if (!this.$error || this.__renderedError === error) return;
            this.__renderedError = error;

            this.$error.attr('tooltip', error);
            this.$().toggleClass('dcg-error', !!error);
        };
    });

    var BottomCellView = P(BaseCellView, function(cellView, _super) {

        cellView.init = function(model, tableView) {
            _super.init.call(this, model, tableView);

            this.model.column.observe('disabled.cellview', this.onDisabledChange.bind(this));
        };

        cellView.destruct = function() {
            this.model.column.unobserve('.cellview');
        };

        cellView.didInsertElement = function() {
            _super.didInsertElement.call(this);

            this.$mathquill = this.$('.mathquill-rendered-math');

            this.onDisabledChange();

            var self = this;
            this.$().on('blur focusout', '.mathquill-rendered-math', function() {
                self.$mathquill.mathquill('clearSelection');
            });

            this.$().on('render', '.mathquill-rendered-math', function() {
                var latex = $(this).mathquill('latex');
                if (latex === '') return;

                // add a row
                $(this).mathquill('latex', '');
                var position = self.lookupCellPosition();

                var table = self.model.column.table;

                var rowValues = [];
                for (var i = 0; i < table.columns.length; i++) {
                    rowValues[i] = '';
                }

                rowValues[position.column] = latex;
                table.insertRow(position.row - 1, rowValues);
                self.tableView.selectCell(position.row, position.column, true);
            });
        };
    });

    var CellView = P(BaseCellView, function(cellView, _super) {

        cellView.template = templates.table_cell_body;
        cellView.init = function(model, tableView) {
            _super.init.call(this, model, tableView);

            this.model.observe('value.cellview', this.onValueChange.bind(this));
            this.model.observe('error.cellview', this.onErrorChange.bind(this));
            this.model.column.observe('disabled.' + this.guid, this.onDisabledChange.bind(this));
        };

        cellView.destruct = function() {
            this.model.unobserve('.cellview');
            this.model.column.unobserve('disabled.' + this.guid);
        };

        cellView.didInsertElement = function() {
            _super.didInsertElement.call(this);

            this.$error = this.$('.dcg-error-indicator');
            this.$mathquill = this.$('.mathquill-rendered-math');

            this.onDisabledChange();
            this.onValueChange();
            this.onErrorChange();

            // TODO - move these mathquill handlers up to the table view instead of
            // assigning them on each table cell individually
            var self = this;
            this.$().on('blur focusout', '.mathquill-rendered-math', function() {
                self.$mathquill.mathquill('clearSelection');
            });

            // TODO - should move to model. Without this, the model won't have Undo/Redo
            this.$().on('render', '.mathquill-rendered-math', function() {
                var oldValue = self.model.value;
                var newValue = $(this).mathquill('latex');
                if (oldValue === newValue) return;
                self.__renderedValue = newValue;

                var id = self.model.column.table.id;
                var position = self.lookupCellPosition();
                var list = self.tableView.listView.model; //TODO ick
                function getCell() {
                    var table = list.getItemById(id);
                    var column = table.columns[position.column];
                    return column.cells[position.row - 1];
                }

                list.undoRedo.addTransaction({
                    type: list.undoRedo.CAUSE_OF_CHANGE,
                    undo: function() {
                        var cell = getCell();
                        cell.setProperty('value', oldValue);
                        cell.column.table.requestParse();
                    },
                    redo: function() {
                        var cell = getCell();
                        cell.setProperty('value', newValue);
                        cell.column.table.requestParse();
                    }
                });

            });
        };
    });

    return TableView;
});

define('template!folder', ['underscore'], function(_) {
    return function(obj) {
        var __p = '';
        var print = function() { __p += Array.prototype.join.call(arguments, '') };
        with(obj || {}) {
            __p += '';
            if (renderShell) {;
                __p += '\n\n<div class="dcg-do-not-blur dcg-expressionitem dcg-expressionfolder dcg-shell">\n  <div class="dcg-shell"></div>\n</div>\n\n';
            } else {;
                __p += '\n\n<div class="dcg-do-not-blur dcg-expressionfolder dcg-expressionitem">\n  <div class="dcg-fade-container">\n\n    <span class="dcg-main">\n      <div class="dcg-caret-container dcg-action-toggle-folder-collapsed dcg-do-not-blur" handleEvent="true">\n        <i class="dcg-icon-caret-down" ></i>\n      </div>\n\n      <div class="dcg-smart-textarea-placeholder"></div>\n    </span>\n    <i class="dcg-icon-remove dcg-top-level-delete dcg-action-delete" handleEvent="true"></i>\n\n  </div>\n\n  <span class="dcg-tab dcg-action-drag"\n        handleEvent="true"\n        tapboundary="true"\n        disablescroll="true"\n  >\n    <span class="dcg-num dcg-variable-index"></span>\n    <div class="dcg-tab-interior">\n    <span class="dcg-action-toggle-folder-hidden dcg-graph-icon dcg-folder dcg-icon">\n      <i class="dcg-icon-hidden"></i>\n      <i class="dcg-icon-folder"></i>\n    </span>\n    </div>\n  </span>\n\n  <span class="dcg-exp-actions">\n    <span\n      class="dcg-action-delete dcg-delete-btn dcg-tooltip"\n      handleEvent="true"\n      tooltip="' +
                    (t('Delete')) +
                    '"\n    >\n      <i class=\'dcg-icon-remove\'></i></span>\n    </span>\n  </span>\n\n</div>\n\n';
            };
            __p += '\n';
        }
        return __p;
    };
});
define('expressions/folder_view', ['require', 'pjs', 'expressions/abstractitem_view', 'template!folder', './smart_textarea', 'jquery.handleevent'], function(require) {
    var P = require('pjs');
    var AbstractItemView = require('expressions/abstractitem_view');
    var template = require('template!folder');
    var SmartTextarea = require('./smart_textarea');
    require('jquery.handleevent');

    var FolderView = P(AbstractItemView, function(view, _super) {
        view.template = template;

        view.init = function(model, listView) {
            _super.init.call(this, model, listView);
            this.model = model;
            model.observe('hidden.folderView', this.onHiddenChanged.bind(this));
            model.observe('collapsed.folderView', this.onCollapsedChanged.bind(this));
            model.observe('selected.folderView', this.onSelectedChange.bind(this));
            model.observe('count.folderView', this.onMemberIdsChange.bind(this));

            this.smartTextarea = SmartTextarea(this.model.title);
            this.model.observe('title.folderView', function() {
                this.smartTextarea.setProperty('text', this.model.title);
            }.bind(this));
            this.smartTextarea.observe('text', function() {
                this.model.setProperty('title', this.smartTextarea.text);
            }.bind(this));
        };

        view.destruct = function() {
            this.model.unobserve('.folderView');
            this.smartTextarea.destruct();
        };

        view.didInsertElement = function() {
            _super.didInsertElement.call(this);
            if (this.model.renderShell) return;

            this.smartTextarea.replace(this.$('.dcg-smart-textarea-placeholder'));

            this.smartTextarea.observe('focused', function() {
                if (this.smartTextarea.focused) this.model.setProperty('selected', true);
            }.bind(this));
            this.smartTextarea.observeEvent('enterPressed', this.triggerEnterPressed.bind(this));
            this.smartTextarea.observeEvent('upPressed', this.triggerUpPressed.bind(this));
            this.smartTextarea.observeEvent('downPressed', this.triggerDownPressed.bind(this));
            this.smartTextarea.observeEvent('backspacePressed', this.triggerBackspacePressed.bind(this));
            this.smartTextarea.observeEvent('delPressed', this.triggerDelPressed.bind(this));
            //need to include smart-textarea in minWidth
            this.setMinWidth();

            this.$('.dcg-action-toggle-folder-collapsed').on(
                'tap',
                this.toggleCollapsed.bind(this)
            );
            this.$('.dcg-action-toggle-folder-hidden').on(
                'tap',
                this.toggleHidden.bind(this)
            );

            this.onCollapsedChanged();
            this.onHiddenChanged();
            this.onMemberIdsChange();
        };

        view.onSelectedChange = function() {
            if (!this.selected && this.$title) {
                this.smartTextarea.blur();
            }
        };

        view.onMemberIdsChange = function() {
            this.$().toggleClass('dcg-has-items', this.model.count > 0);
        };

        view.onProjectorModeChange = function() {
            this.smartTextarea.fitText();
        };

        view.onMouseSelect = function(evt) {
            if (evt.wasHandled()) return;
            evt.handle();

            this.model.setProperty('selected', true);
        };

        view.toggleHidden = function() {
            this.model.setProperty('hidden', !this.model.hidden);
        };

        view.toggleCollapsed = function() {
            this.model.setProperty('collapsed', !this.model.collapsed);
        };

        view.onHiddenChanged = function() {
            this.$().toggleClass('dcg-hidden', !!this.model.hidden);
        };

        view.onCollapsedChanged = function() {
            this.$().toggleClass('dcg-collapsed', !!this.model.collapsed);

            if (!this.model.collapsed) {
                this.listView.triggerFolderOpened();
            }
        };

        view.addFocus = function(where) {
            this.smartTextarea.addFocus();
        };
    });

    return FolderView;
});

define('loadcss!css/expressions.image', function() {});
define('loadcss!css/image_opacity_menu', function() {});
define('template!image_options_menu', ['underscore'], function(_) {
    return function(obj) {
        var __p = '';
        var print = function() { __p += Array.prototype.join.call(arguments, '') };
        with(obj || {}) {
            __p += '<div class=\'dcg-exp-options-menu dcg-image-options-menu dcg-options-menu\'>\n  <div class=\'dcg-triangle\'></div>\n  <div class=\'dcg-opacities-div\'>\n    <div class=\'dcg-opacities-menu\'>\n      <div class=\'dcg-title\'>opacity:</div>\n      <div class=\'dcg-opacities-menu\'>\n      ';
            _.each([.2, .4, .6, .8, 1], function(opacity) {;
                __p += '\n        <span class="dcg-opacity-option dcg-graph-icon"\n          image-opacity="' +
                    (opacity) +
                    '"\n          handleevent="true">\n            <span class="dcg-image-thumb"\n              style="opacity: ' +
                    (opacity) +
                    '">\n            </span>\n            <i class=\'dcg-icon-check\'></i>\n        </span>\n      ';
            });
            __p += '\n      </div>\n    </div>\n  </div>\n</div>\n';
        }
        return __p;
    };
});
define('expressions/image_options_view', ['require', 'loadcss!css/image_opacity_menu', 'pjs', 'jquery', 'underscore_view', 'template!image_options_menu'], function(require) {
    require('loadcss!css/image_opacity_menu');

    var P = require('pjs');
    var $ = require('jquery');
    var UnderscoreView = require('underscore_view');
    var template = require('template!image_options_menu');


    var ImageOptionsMenuView = P(UnderscoreView, function(view, _super) {
        view.template = template;

        view.init = function(image) {
            this.image = image;
            this.image.observe('opacity.' + this.guid, this.renderSelectedOpacity.bind(this));
            this.image.observe('hidden.' + this.guid, this.renderSelectedOpacity.bind(this));
            this.image.observe('image_url.' + this.guid, this.renderImageURL.bind(this));
        };

        view.destruct = function() {
            this.image.unobserve('.' + this.guid);
        };

        view.onSelectOpacity = function(evt) {
            // when using mouse, fire on 'tapStart' and when on touch we
            // fire on the 'tap' event.
            if (evt.type === 'tap' && evt.device === 'mouse') return;
            if (evt.type === 'tapstart' && evt.device === 'touch') return;

            var opacity = parseFloat($(evt.target).closest('.dcg-opacity-option').attr('image-opacity'));
            this.image.setProperty('hidden', false);
            this.image.setProperty('opacity', opacity);

            //if we're in a folder, show it.
            if (this.image.folder) this.image.folder.setProperty('hidden', false);
        };

        view.renderSelectedOpacity = function() {
            var opacity = this.image.opacity;
            this.$('.dcg-opacity-option').removeClass('dcg-selected');
            if (!this.image.hidden) {
                this.$('.dcg-opacity-option[image-opacity="' + opacity + '"]').addClass('dcg-selected');
            }
        };

        view.renderImageURL = function() {
            if (this.image.image_url) {
                this.$('.dcg-image-thumb').css('background-image', 'url(' + encodeURI(this.image.image_url) + ')');
            }
        };

        view.didInsertElement = function() {
            this.$().on('tap tapstart', '.dcg-opacity-option', this.onSelectOpacity.bind(this));
            this.renderSelectedOpacity();

            this.renderImageURL();
        };

    });

    return ImageOptionsMenuView;
});

define('template!image_icon', ['underscore'], function(_) {
    return function(obj) {
        var __p = '';
        var print = function() { __p += Array.prototype.join.call(arguments, '') };
        with(obj || {}) {
            __p += '<span class="dcg-icon dcg-graph-icon dcg-variable-errortooltip tipsy-sticky">\n  <span class="dcg-image-thumb"></span>\n  <i class="dcg-icon-hidden"></i>\n</span>\n';
        }
        return __p;
    };
});
define('expressions/image_icon_view', ['require', 'pjs', 'expressions/abstract_icon', './image_options_view', 'template!image_icon', 'jquery.handleevent'], function(require) {
    var P = require('pjs');
    var AbstractIconView = require('expressions/abstract_icon');
    var ImageOptionsMenuView = require('./image_options_view');
    var template = require('template!image_icon');
    require('jquery.handleevent');

    var ImageIconView = P(AbstractIconView, function(view, _super) {
        view.template = template;

        view.init = function(parentView) {
            _super.init.call(this, parentView);
            this.expression = this.model;
            this.image = this.model;

            this.image.observe('opacity.' + this.guid, this.onDisplayChange.bind(this));
            this.image.observe('shouldGraph.' + this.guid, this.onDisplayChange.bind(this));
            this.image.observe('loaded.' + this.guid, this.onDisplayChange.bind(this));
            this.image.observe('error.' + this.guid, this.onDisplayChange.bind(this));
            this.image.observe('image_url.' + this.guid, this.renderImageURL.bind(this));

            this.parentView.observeEvent('hideContextMenu.' + this.guid, this.hideOptions.bind(this));
        };

        view.destruct = function() {
            _super.destruct.call(this);

            this.image.unobserve('.' + this.guid);
            this.parentView.unobserve('.' + this.guid);
        };

        view.renderImageURL = function() {
            if (this.image.image_url) {
                this.$imgThumb.css('background-image', 'url(' + encodeURI(this.image.image_url) + ')');
            }
        };

        view.didInsertElement = function() {
            var self = this;
            _super.didInsertElement.call(this);
            this.$icon = this.$('.dcg-icon');
            this.$imgThumb = this.$icon.find('.dcg-image-thumb');

            this.renderImageURL();
            this.onDisplayChange();

            var handleIconTapped = function(evt, device) {
                if (evt.wasHandled('dragdrop')) return; //Don't toggle if we were handled by dragdrop
                if (evt.wasLongheld()) return;
                if (evt.device !== device) return;

                if (self.optionsShown) {
                    self.toggleOptions();
                    return false;
                }

                if (self.parentView.listView.editListMode) {
                    self.toggleOptions();
                } else {
                    if (self.errorShown) return;

                    if (self.image.folder && self.image.folder.hidden) {
                        self.image.setProperty('hidden', false);
                        self.image.folder.setProperty('hidden', false);
                    } else {
                        self.image.setProperty('hidden', !self.image.hidden);
                    }
                }
            };

            var handleIconLongHold = function(evt, device) {
                if (evt.device !== device) return;

                evt.handle('longhold');
                self.toggleOptions();
            };

            this.$().closest('.dcg-action-icon-mouse').on('tap', function(evt) {
                handleIconTapped(evt, 'mouse');
            });

            this.$().closest('.dcg-action-icon-touch').on('tap', function(evt) {
                handleIconTapped(evt, 'touch');
            });

            this.$().closest('.dcg-action-icon-mouse').on('longhold', function(evt) {
                handleIconLongHold(evt, 'mouse');
            });

            this.$().closest('.dcg-action-icon-touch').on('longhold', function(evt) {
                handleIconLongHold(evt, 'touch');
            });
        };

        view.createOptionsMenuView = function() {
            var listView = this.parentView.listView;
            var optionsView = ImageOptionsMenuView(this.expression);
            optionsView.appendTo(listView.$());

            // putting the ImagenOptionsView at the topLeft of the .dcg-icon
            // it's up to the ImageOptionsView's css to position it beyond that
            var placeholder = this.$('.dcg-icon');
            var placeholderOffset = placeholder.offset();
            var listViewOffset = listView.$().offset();
            optionsView.$().css({
                position: 'absolute',
                top: placeholderOffset.top - listViewOffset.top + 'px',
                left: placeholderOffset.left - listViewOffset.left + 'px',
                display: 'block' //wait until we know where it is to show it. fixes #3154
            });
            return optionsView;
        };

        view.onDisplayChange = function() {
            _super.onDisplayChange.call(this);
            if (!this.$icon) return;

            var icon_class = '';

            if (!this.image.loaded) {
                icon_class = 'dcg-loading-image';
            } else if (this.error) {
                icon_class = '';
            } else if (!this.image.shouldGraph) {
                icon_class = 'dcg-hidden';
            }

            // efficently changes the class of the icon
            if (this.rendered_icon_class !== icon_class) {
                if (this.rendered_icon_class) {
                    this.$icon.removeClass(this.rendered_icon_class);
                }
                this.rendered_icon_class = icon_class;
                if (icon_class) {
                    this.$icon.addClass(icon_class);
                }
            }
            if (!icon_class) {
                this.$imgThumb.css('opacity', this.image.opacity);
            }
        };
    });

    return ImageIconView;
});
define('template!image', ['underscore'], function(_) {
    return function(obj) {
        var __p = '';
        var print = function() { __p += Array.prototype.join.call(arguments, '') };
        with(obj || {}) {
            __p += '';
            if (renderShell) {;
                __p += '\n\n<div class="dcg-do-not-blur dcg-expressionitem expressionimage dcg-shell">\n  <div class=\'dcg-shell\'></div>\n</div>\n\n';
            } else {;
                __p += '\n\n<div class="dcg-do-not-blur dcg-expressionimage dcg-expressionitem">\n  <div class=\'dcg-fade-container\'>\n\n    <span class="dcg-main">\n      <div class="dcg-image-loading">Loading image...</div>\n      <div class="dcg-image-loaded">\n\n          <div class="dcg-smart-textarea-placeholder"></div>\n\n          <div class="dcg-do-blur" handleEvent="true">\n            <div class="dcg-edit-image dcg-variable-invalid dcg-desmos-input-container">\n              <div class="dcg-center-inputs">\n                ' +
                    (t('center:')) +
                    '\n                <span class="dcg-image-center">\\left(\\MathQuillMathField[dcg-image-input-x]{} , \\MathQuillMathField[dcg-image-input-y]{}\\right)</span>\n              </div>\n              <div class="dcg-size-inputs">\n                ' +
                    (t('size:')) +
                    '\n                <span class="dcg-image-size">\\MathQuillMathField[dcg-image-input-width]{} &times; \\MathQuillMathField[dcg-image-input-height]{}</span>\n              </div>\n            </div>\n          </div>\n\n      </div>\n    </span>\n    <span class="dcg-fadeout"></span>\n\n    <i class="dcg-icon-remove dcg-top-level-delete dcg-action-delete" handleEvent="true"></i>\n\n    <div class="dcg-template-bottom-container dcg-fixed-width-element">\n      <div class="dcg-template-bottom"></div>\n    </div>\n  </div>\n\n  <span class="dcg-tab dcg-action-drag dcg-action-icon-touch" handleEvent="true">\n    <span class=\'dcg-num dcg-variable-index\'></span>\n    <div class=\'dcg-tab-interior dcg-action-icon-mouse\'>\n      <span class="template-imageicon"></span>\n    </div>\n  </span>\n\n  <span class=\'dcg-exp-actions\'>\n    <span class="dcg-graphic" handleEvent="true"></span>\n    <span class="dcg-action-delete dcg-delete-btn" handleEvent="true"><i class=\'dcg-icon-remove\'></i></span>\n  </span>\n\n</div>\n\n';
            };
            __p += '\n';
        }
        return __p;
    };
});
define('expressions/image_view', ['require', 'loadcss!css/expressions.image', 'jquery', 'pjs', 'keys', './abstractitem_view', './image_icon_view', 'expressions/promptslider_view', 'conditional_blur', './smart_textarea', 'jquery.handleevent', 'template!image'], function(require) {
    require('loadcss!css/expressions.image');
    var $ = require('jquery');
    var P = require('pjs');
    var Keys = require('keys');
    var AbstractItemView = require('./abstractitem_view');
    var ImageIconView = require('./image_icon_view');
    var PromptSliderView = require('expressions/promptslider_view');
    var conditionalBlur = require('conditional_blur');
    var SmartTextarea = require('./smart_textarea');
    require('jquery.handleevent');

    var template = require('template!image');

    var ImageView = P(AbstractItemView, function(view, _super) {

        view.template = template;

        view.init = function(model, listView) {
            _super.init.call(this, model, listView);
            this.model = model;

            // enable animations on the frame after the helpers are evaluated.
            // Only need to watch for a single helper because they'll all be batched.
            var self = this;
            this.model.helpers.x.observe('formula.' + this.guid, function() {
                setTimeout(function() {
                    self.setProperty('doAnimate', true);
                });
            });
            this.smartTextarea = SmartTextarea(this.model.name);
            this.model.observe('name.' + this.guid, function() {
                this.smartTextarea.setProperty('text', this.model.name);
            }.bind(this));
            this.smartTextarea.observe('text', function() {
                this.model.setProperty('name', this.smartTextarea.text);
            }.bind(this));
        };

        view.addFocus = function(where) {
            this.smartTextarea.addFocus();
        };

        view.onSelectedChange = function() {
            if (!this.model.selected) {
                // find the focused mathquill (if there is one)
                var focused = $(document.activeElement).closest('.mathquill-editable');

                // check if the focused mathquill is within this view
                if (focused.closest(this.$()).length) {
                    focused.mathquill('blur');
                }
            }
        };

        view.handleLeftPressed = function(evt) {
            var input = $(evt.target).closest('.dcg-math-input')[0];
            if (this.$y[0] === input) {
                this.$x.mathquill('focus');
            } else if (this.$height[0] === input) {
                this.$width.mathquill('focus');
            }
        };

        view.handleRightPressed = function(evt) {
            var input = $(evt.target).closest('.dcg-math-input')[0];
            if (this.$x[0] === input) {
                this.$y.mathquill('focus');
            } else if (this.$width[0] === input) {
                this.$height.mathquill('focus');
            }
        };

        view.handleDownPressed = function(evt) {
            var input = $(evt.target).closest('.dcg-math-input')[0];
            if (this.$x[0] === input) {
                this.$width.mathquill('focus');
            } else if (this.$y[0] === input) {
                this.$height.mathquill('focus');
            }
        };

        view.handleUpPressed = function(evt) {
            var input = $(evt.target).closest('.dcg-math-input')[0];
            if (this.$width[0] === input) {
                this.$x.mathquill('focus');
            } else if (this.$height[0] === input) {
                this.$y.mathquill('focus');
            }
        };

        view.handleKeydown = function(evt) {
            var key = Keys.lookup(evt);
            if (key === Keys.ESCAPE) conditionalBlur();
        };

        // blur input when enter pressed
        view.handleMathquillInput = function(evt) {
            var input = this.$(evt.target).closest('.dcg-math-input');
            var value = input.mathquill('latex');
            var limit = input.attr('limit');
            this.model.setProperty(limit, value);
        };

        view.didFocusIn = false;
        view.focusInMathquill = function(evt) {
            var input = this.$(evt.target).closest('.dcg-math-input');

            //focusin is triggered always, even when reclicking into a selected mathquill
            //we don't want to reselect in that case.
            if (!input.hasClass('dcg-focus')) {
                input.addClass('dcg-focus');
                input.triggerHandler('select_all');
                //on iPad/iPhone select_all isn't working synchronously. gross hack to make sure that we select all
                //TODO: remove this when we update mathquill, which fixes lots of focus issues
                setTimeout(function() {
                    if (!input.find('.mq-selection').length) {
                        input.triggerHandler('select_all');
                    }
                }, 1);
            }

            this.model.setProperty('selected', true);

            //focusIn is called before focusOut, but we want this to happen after
            this.didFocusIn = true;
            this.$().addClass('dcg-input-focused');
            var self = this;
            setTimeout(function() {
                self.didFocusIn = false;
            });
        };

        view.focusOutMathquill = function(evt) {
            var input = this.$(evt.target).closest('.mathquill-editable');
            input.removeClass('dcg-focus');
            input.mathquill('clearSelection');

            if (!this.didFocusIn) this.$().removeClass('dcg-input-focused');
        };

        view.didInsertElement = function() {
            _super.didInsertElement.call(this);
            if (this.model.renderShell) return;

            this.smartTextarea.replace(this.$('.dcg-smart-textarea-placeholder'));
            this.smartTextarea.observe('focused', function() {
                if (this.smartTextarea.focused) this.model.setProperty('selected', true);
            }.bind(this));
            this.smartTextarea.observeEvent('enterPressed', this.triggerEnterPressed.bind(this));
            this.smartTextarea.observeEvent('upPressed', this.triggerUpPressed.bind(this));
            this.smartTextarea.observeEvent('downPressed', this.triggerDownPressed.bind(this));
            this.smartTextarea.observeEvent('backspacePressed', this.triggerBackspacePressed.bind(this));
            this.smartTextarea.observeEvent('delPressed', this.triggerDelPressed.bind(this));

            //need to include smart-textarea in minWidth
            this.setMinWidth();

            this.iconView = ImageIconView(this);
            this.iconView.replace('.template-imageicon');

            // create and select for the \MathQuillMathField's
            var containingMathquill = this.$('.dcg-image-center,.dcg-image-size').mathquill();
            this.$x = containingMathquill.find('.dcg-image-input-x').attr('limit', 'x');
            this.$y = containingMathquill.find('.dcg-image-input-y').attr('limit', 'y');
            this.$width = containingMathquill.find('.dcg-image-input-width').attr('limit', 'width');
            this.$height = containingMathquill.find('.dcg-image-input-height').attr('limit', 'height');

            // listen to the mathquill inputs
            var editables = containingMathquill.find('.mathquill-editable');
            var self = this;
            editables.on('focusin', this.focusInMathquill.bind(this))
                .on('focusout', this.focusOutMathquill.bind(this))
                .on('render', this.handleMathquillInput.bind(this))
                .on('leftPressed', this.handleLeftPressed.bind(this))
                .on('upPressed', this.handleUpPressed.bind(this))
                .on('downPressed', this.handleDownPressed.bind(this))
                .on('rightPressed', this.handleRightPressed.bind(this))
                .on('keydown', this.handleKeydown.bind(this))
                .on('tap', function(evt) {
                    // self = the ImageView
                    // this = the editable mathquill that was clicked
                    self.sendTapToMathQuill(evt, $(this));
                })
                .addClass('dcg-math-input');

            // add these observers after the element is fully instantiated. Only after that
            // point is the dom fully in place for these renders to work. If the model updates
            // while the shell is still visible, we'll either get an error thrown (renderInvalids)
            // or we'll miss the dom update completely (renderVariables).
            this.renderX();
            this.renderY();
            this.renderWidth();
            this.renderHeight();
            this.renderInvalids();
            this.renderLoaded();
            this.renderVariables();
            this.model.observe('loaded.' + this.guid, this.renderLoaded.bind(this));
            this.model.observe('variables.' + this.guid, this.renderVariables.bind(this));
            this.model.observe('selected.' + this.guid, this.onSelectedChange.bind(this));
            this.model.observe('x.' + this.guid, this.renderX.bind(this));
            this.model.observe('y.' + this.guid, this.renderY.bind(this));
            this.model.observe('width.' + this.guid, this.renderWidth.bind(this));
            this.model.observe('height.' + this.guid, this.renderHeight.bind(this));
            this.model.observe('errors.' + this.guid, this.renderInvalids.bind(this));
        };

        view.renderLoaded = function() {
            var loaded = this.model.loaded;
            this.$().toggleClass('dcg-loading', !loaded);

            // must redraw the mathquill when loaded because it can't render correctly when display:none
            if (loaded) {
                this.$('.dcg-image-center,.dcg-image-size').mathquill('redraw');
                this.smartTextarea.renderText();
            }
        };

        view.destruct = function() {
            this.model.unobserve('.' + this.guid);
            this.model.helpers.x.unobserve('formula.' + this.guid);
            this.smartTextarea.destruct();

            if (this.optionsView) {
                this.optionsView.remove();
                this.optionsView = null;
            }
            if (this.promptSliderView) {
                this.promptSliderView.remove();
                this.promptSliderView = null;
            }
        };

        view.renderInvalids = function() {
            this.$x.toggleClass('dcg-invalid', !!this.model.errors.x);
            this.$y.toggleClass('dcg-invalid', !!this.model.errors.y);
            this.$width.toggleClass('dcg-invalid', !!this.model.errors.width);
            this.$height.toggleClass('dcg-invalid', !!this.model.errors.height);
        };

        view.renderX = function() {
            var value = this.model.x;
            if (this.$x.mathquill('latex') !== value) {
                this.$x.mathquill('latex', value);
            }
        };

        view.renderY = function() {
            var value = this.model.y;
            if (this.$y.mathquill('latex') !== value) {
                this.$y.mathquill('latex', value);
            }
        };

        view.renderWidth = function() {
            var value = this.model.width;
            if (this.$width.mathquill('latex') !== value) {
                this.$width.mathquill('latex', value);
            }
        };

        view.renderHeight = function() {
            var value = this.model.height;
            if (this.$height.mathquill('latex') !== value) {
                this.$height.mathquill('latex', value);
            }
        };

        view.renderVariables = function() {
            if (!this.model.variables) return;

            var promptCreateSlider = this.model.variables.length > 0;
            if (this.promptSliderView && !promptCreateSlider) {
                this.removeViewFromBottom(this.promptSliderView);
                this.promptSliderView = null;
            } else if (!this.promptSliderView && promptCreateSlider) {
                this.promptSliderView = this.createPromptSliderView();
                this.addViewToBottom(this.promptSliderView);
            }

            if (this.promptSliderView) {
                this.promptSliderView.setProperty('variables', this.model.variables);
            }
        };

        view.createPromptSliderView = function() {
            return PromptSliderView(this);
        };

        view.onMouseSelect = function(evt) {
            if (evt.wasHandled()) return;
            evt.handle();

            this.model.setProperty('selected', true);
        };

        view.isFocused = function() {
            return $(document.activeElement).closest(this.$()).length !== 0;
        };
    });

    return ImageView;
});

define('template!list', ['underscore'], function(_) {
    return function(obj) {
        var __p = '';
        var print = function() { __p += Array.prototype.join.call(arguments, '') };
        with(obj || {}) {
            __p += '<div>\n\n<div class=\'dcg-show-expressions-tab\'>\n  <a\n    class=\'dcg-resize-list-btn dcg-action-showexpressions dcg-tooltip\'\n    tooltip="' +
                (t('Show List')) +
                '"\n  >\n    <i class=\'dcg-icon-show\'></i>\n  </a>\n</div>\n\n\n<div class="dcg-exppanel-outer">\n  <div class="dcg-exppanel-container">\n    <div class="dcg-expression-top-bar">\n      <a class=\'dcg-btn dcg-btn-medium dcg-pull-left dcg-hide-in-edit dcg-add-expression-btn dcg-action-add-expression dcg-tooltip dcg-do-not-blur\' handleEvent="true" tooltip="' +
                (t('Add Item')) +
                '"><i class=\'dcg-icon-plus\'></i><i class=\'dcg-icon-caret-down\'></i></a>\n\n      <a class=\'dcg-btn dcg-btn-red dcg-btn-medium dcg-pull-left dcg-show-in-edit dcg-action-clearall\'> ' +
                (t('Delete All')) +
                '</a>\n      <span class=\'dcg-center-aligned dcg-show-in-edit\'>\n        <a class=\'dcg-action-undo dcg-tooltip\' tooltip="' +
                (t('Undo (ctrl+z)')) +
                '"><i class=\'dcg-icon-undo\'></i></a>\n        <a class=\'dcg-action-redo dcg-tooltip\' tooltip="' +
                (t('Redo (ctrl+y)')) +
                '"><i class=\'dcg-icon-redo\'></i></a>\n      </span>\n\n      <a class=\'dcg-resize-list-btn dcg-hide-in-edit dcg-action-hideexpressions dcg-tooltip\' tooltip="' +
                (t('Hide List')) +
                '"><i class=\'dcg-icon-hide\'></i></a>\n\n      <a\n        class=\'dcg-btn dcg-btn-medium dcg-pull-right dcg-action-toggle-edit dcg-hide-in-edit dcg-tooltip dcg-do-not-blur\' handleEvent="true" tooltip="' +
                (t('Edit List')) +
                '">\n        <i class=\'dcg-icon-settings\' />\n      </a>\n      <a\n        class=\'dcg-btn dcg-btn-blue dcg-btn-medium dcg-pull-right dcg-action-toggle-edit dcg-show-in-edit dcg-do-not-blur\'\n        handleEvent="true">\n          ' +
                (t('Done')) +
                '\n      </a>\n    </div>\n\n    <div class="dcg-exppanel dcg-disable-horizontal-scroll-to-cursor">\n\n      <div class=\'dcg-drop-image\'>\n        <span>' +
                (t('Drop Image Here')) +
                '</span>\n      </div>\n\n      <div class="dcg-expressionlist">\n        <span class="dcg-template-expressioneach"></span>\n        <div class="template-newexpression"></div>\n\n</div>\n    </div>\n  </div>\n</div>\n\n\n</div> <!-- close container div-->\n';
        }
        return __p;
    };
});
define('expressions/list_view', ['require', 'loadcss!css/expression_top_bar', 'loadcss!css/expressions', 'loadcss!css/expressions.icon', 'jquery', 'underscore', 'pjs', 'tipsy', 'underscore_view', 'touchtracking', 'expressions/dragdrop_expressions', './add_expression', 'conditional_blur', 'keys', 'browser', 'scroll_helpers', 'jquery.handleevent', './new_expression', './expression', './expression_view', './text_view', './table_view', './folder_view', './image_view', 'template!list'], function(require) {
    require('loadcss!css/expression_top_bar');
    require('loadcss!css/expressions');
    require('loadcss!css/expressions.icon');

    var $ = require('jquery');
    var _ = require('underscore');
    var P = require('pjs');
    require('tipsy');
    var UnderscoreView = require('underscore_view');
    var touchtracking = require('touchtracking');
    var DragDropExpressions = require('expressions/dragdrop_expressions');
    var AddExpressionView = require('./add_expression');
    var conditionalBlur = require('conditional_blur');
    var Keys = require('keys');
    var Browser = require('browser');

    var scrollHelpers = require('scroll_helpers');
    require('jquery.handleevent');
    var NewExpressionView = require('./new_expression');
    var ExpressionObject = require('./expression');
    var ExpressionView = require('./expression_view');
    var TextView = require('./text_view');
    var TableView = require('./table_view');
    var FolderView = require('./folder_view');
    var ImageView = require('./image_view');

    var template = require('template!list');

    var ExpressionListView = P(UnderscoreView, function(view, _super) {
        view.__itemViews = {};
        view.__latexChangeCallbacks = [];
        view.isTransient = false;
        view.transientChildren = [];
        view.template = template;

        // Overridden by Calc.
        // TODO: copied and pasted over from list_view_tablet, but this feels really dirty
        // There's got to be a better way to do this.
        view.triggerClearGraph = function() {};

        view.onLatexChange = function(latex) {
            _.each(this.__latexChangeCallbacks, function(cb) { cb(latex); });
        };

        view.init = function(model, $root, toastView, graphSettings) {
            _super.init.call(this);

            this.$root = $root || $('body');
            this.setProperty('scrollbarWidth', 0);
            this.setProperty('minWidth', 356);

            this.toastView = toastView;
            this.graphSettings = graphSettings;
            this.model = model;
            this.model.triggerItemInserted = this.onItemInserted.bind(this);
            this.model.triggerItemRemoved = this.onItemRemoved.bind(this);
            this.model.triggerItemMoved = this.onItemMoved.bind(this);
            this.model.triggerSetState = this.onSetState.bind(this);

            this.observe('itemFocused', this.renderItemFocused.bind(this));
            this.observe('editListMode', this.renderEditListMode.bind(this));

            // ensure selected expression is visible on selection change and focused
            // expression is visible on keypress
            this.model.observe('selectedItem', this.ensureActiveChildIsVisible.bind(this));

            this.dragdrop_expressions = DragDropExpressions(this);
            this.createAllItemViews();
        };

        view.computeTransient = function() {
            this.setProperty('transient', this.transientChildren.length > 0);
        };

        //when sliding a slider, we want to temporarily pad the bottom enough that things don't move around
        view.padLastExpression = function(padding) {
            var $lastExp = this.$('.dcg-expressionitem.dcg-new-expression');
            $lastExp.css('margin-bottom', +padding + 'px');
        };

        view.unpadLastExpression = function() {
            var $lastExp = this.$('.dcg-expressionitem.dcg-new-expression');
            $lastExp.css('margin-bottom', '0');
            this.recalculateScrollbarWidth();
        };

        view.padLastExpressionUntilTapEnd = function(padding) {
            var self = this;
            this.padLastExpression(padding);
            $(document).on('tap.animating-bottom', function() {
                if (self.$('.dcg-exp-options-menu').length === 0) {
                    self.unpadLastExpression();
                    $(document).off('tap.animating-bottom');
                }
            });
        };

        //we need to set minWidth at least once, because otherwise
        //we never set the css property, which caused: https://github.com/desmosinc/knox/issues/3878
        //we also don't want to set the css every time, because that'll be a performance burden
        //finally, we need to set it *initially* or else we get a weird slide-in animation
        //because layout_controller doesn't call this until after everything's all instantiated.
        //solution: just store some state recording whether we should ignore our no-op trap
        view.minWidthHasBeenSet = false;
        view.setMinWidth = function(newWidth) {
            if (!this.$exps) return;
            if (newWidth === this.minWidth && this.minWidthHasBeenSet) return;
            this.minWidthHasBeenSet = true;
            this.setProperty('minWidth', newWidth);
            var newCss = { minWidth: newWidth };
            if (!this.itemFocused) newCss.maxWidth = newWidth;
            this.$exppanelContainer.css(newCss);
        };

        view.updateAllViewWidths = function() {
            _.each(this.__itemViews, function(view) { view.setMinWidth(); });
        };

        view.recalculateScrollbarWidth = function() {
            var scrollbarWidth = this.$('.dcg-exppanel').width() - this.$('.dcg-expressionlist').width();
            scrollbarWidth = Math.max(scrollbarWidth, 0);
            this.setProperty('scrollbarWidth', scrollbarWidth);
        };

        view.updateWidth = function() {
            if (!this.$exps) return;
            var exppanel = this.$exppanelContainer;
            var maxWidth = 0;
            //don't update width if we're full-width (i.e. on a smallscreen)
            if (exppanel.css('min-width') === '100%') return;

            var minWidth = this.minWidth;

            this.$('.dcg-disable-horizontal-scroll-to-cursor').scrollLeft(0);

            function includeWidth($element) {
                var main = $element.find('.dcg-main');
                if (!main.length) return;

                var width = main.outerWidth() + main.offset().left;
                if (width > maxWidth) maxWidth = width;
            }
            var selected = this.getSelectedView();
            if (selected && (this.itemFocused || selected.model.isTable)) {
                includeWidth(selected.$());
            }

            if (this.editListMode) {
                this.$('.dcg-expressiontable').each(function() {
                    includeWidth($(this));
                });
            }

            if (maxWidth < minWidth) {
                maxWidth = minWidth;
            }

            exppanel.css('max-width', maxWidth);
            this.recalculateScrollbarWidth();
        };


        view.onItemInserted = function(index, item) {
            //update index for newExpressionView
            if (this.newExpressionView) {
                this.newExpressionView.setProperty('index', this.model.getItemCount() + 1);
            }

            // if we've started adding items to dom, add this item. Otherwise,
            // the view will be created when the ExpressionListView is inserted
            // into the dom
            if (this.$items) {
                var view = this.createItemView(item);
                if (view) {
                    if (index === 0) {
                        view.prependTo(this.$items); // beginning
                    } else if (index === this.model.getItemCount() - 1) {
                        view.appendTo(this.$items); //end
                    } else { //somewhere in the middle
                        view.insertAfter(this.$items.children(':nth-child(' + index + ')'));
                    }

                    //in edit list mode, we animate new items
                    if (this.editListMode) {
                        view.$().css({
                            transform: 'scale(0,0)',
                            opacity: 0
                        });

                        //wait one frame, or the 0,0 won't catch
                        setTimeout(function() {
                            view.$().css({
                                transition: '.2s',
                                opacity: 1,
                                transform: ''
                            });
                        }, 1);
                        //remove our transition after the animation's done
                        setTimeout(function() {
                            view.$().css({
                                transition: 'none'
                            });
                        }, 300);
                    }
                }

                var len = this.model.getItemCount();
                for (var i = index; i < len; i++) {
                    this.model.getItemByIndex(i).setProperty('index', i);
                }

                this.updateWidth();
                this.ensureActiveChildIsVisible();
            }
        };

        view.onItemRemoved = function(index, item) {
            var item_id = String(item.id);

            item.unobserve('.listview');

            // update index on newExpressionView
            if (this.newExpressionView) {
                this.newExpressionView.setProperty('index', this.model.getItemCount() + 1);
            }

            // remove item view from dom
            var view = this.__itemViews[item_id];
            if (view) {
                view.remove();
                delete this.__itemViews[item_id];

                var len = this.model.getItemCount();
                for (var i = index; i < len; i++) {
                    this.model.getItemByIndex(i).setProperty('index', i);
                }
            }

            this.updateWidth();
        };

        view.onItemMoved = function(from, to) {
            // update index of each affected item
            var min_affected = Math.min(from, to);
            var max_affected = Math.max(from, to);
            for (var i = min_affected; i <= max_affected; i++) {
                this.model.getItemByIndex(i).setProperty('index', i);
            }

            // move view to correct spot
            var view = this.getItemView(this.model.getItemByIndex(to).id);
            if (view) {
                var $items = this.$items;
                // put at beginning
                if (to === 0) {
                    $items.prepend(view.$());
                }

                // put at end
                else if (to === this.model.getItemCount() - 1) {
                    $items.append(view.$());
                }

                // put somewhere in middle
                else {

                    // must add 1 to index if to > from. This is because the from spot will
                    // get plucked out and inserted after the to spot. Means we need to
                    // search one deeper into sibling list to find the correct node to
                    // insert after.
                    var child_index = to + (to > from ? 1 : 0);
                    view.$().insertAfter($items.children(':nth-child(' + child_index + ')'));
                }
            }
        };

        view.onSetState = function(list) {
            // destroy item views
            //TODO - could do a destruct() and remove all at once from dom for optimization.
            for (var id in this.__itemViews) {
                if (this.__itemViews.hasOwnProperty(id)) this.__itemViews[id].remove();
            }

            this.__itemViews = {};

            // update index on newExpressionView
            if (this.newExpressionView) {
                this.newExpressionView.setProperty('index', this.model.getItemCount() + 1);
            }

            // make all the views at once and insert one large structure
            this.createAllItemViews();
            this.appendAllItemViews();
        };

        view.renderItemFocused = function() {
            this.$root.toggleClass('dcg-ITEM-FOCUSED', !!this.itemFocused);
        };

        view.instantiateItemView = function(item) {
            if (item.isExpression) {
                return ExpressionView(item, this);
            } else if (item.isText) {
                return TextView(item, this);
            } else if (item.isTable) {
                return TableView(item, this);
            } else if (item.isFolder) {
                return FolderView(item, this);
            } else if (item.isImage) {
                return ImageView(item, this);
            }
        };

        view.createItemView = function(item) {
            var view = this.instantiateItemView(item);
            var item_id = String(item.id);

            if (view) {
                this.__itemViews[item_id] = view;

                // add some triggers to the view
                var self = this;
                view.triggerDelete = function() { self.onDelete(view) };
                view.triggerEnterPressed = function() { self.onEnterPressed(view) };
                view.triggerUpPressed = function() { self.onUpPressed(view) };
                view.triggerDownPressed = function() { self.onDownPressed(view) };
                view.triggerBackspacePressed = function() { self.onBackspacePressed(view) };
                view.triggerDelPressed = function() { self.onDelPressed(view) };
                view.observe('transient', function(prop, view) {
                    if (view.transient) {
                        self.transientChildren.push(view);
                    } else {
                        self.transientChildren = _(self.transientChildren).without(view);
                    }
                    self.computeTransient();
                });
            }

            return view;
        };

        view.createAllItemViews = function() {
            var len = this.model.getItemCount();
            for (var i = 0; i < len; i++) {
                var item = this.model.getItemByIndex(i);
                this.createItemView(item);
            }
        };

        //this method is for large graphs with lots of unrendered shells
        //previously split between timermoduels and renderviewport.
        //
        //first, it finds the first visible expression.
        //then, starting there, it renders all of the expressions there and below.
        view.renderVisibleExpressions = function() {
            var anyUnrendered = this.model.__items.some(function(item) {
                return item.renderShell;
            });
            if (!anyUnrendered) return;
            var expPanelTop = this.$('.dcg-exppanel').offset().top;
            var first = this.expressionAtPoint(5, expPanelTop);
            if (!first) return;

            //if the user set that we should use shells offscreen (for perf), do
            var last = null;
            if (this.graphSettings.config.useShellsOffscreen) {
                var scrollHeight = this.$('.dcg-exppanel').height();
                last = this.expressionAbovePoint(5, expPanelTop + scrollHeight);
            }

            this.renderExpression(first.index, last);
        };

        //called from a folder when it uncollapses
        view.triggerFolderOpened = function() {
            this.renderVisibleExpressions();
        };

        // render expressions on a loop, starting from first.index (above)
        //
        // notes:
        //   * this only updates expressions *below* where you are. We don't
        // want to have what you're looking at move.
        //   * if "last" is provided, we don't update expressions beyond it
        view.renderExpressionTimeout = null;
        view.renderExpression = function(index, last) {
            clearTimeout(this.renderExpressionTimeout);

            var item = this.model.getItemByIndex(index);
            while (item && (!item.renderShell || item.inCollapsedFolder)) {
                index++;
                item = this.model.getItemByIndex(index);
            }

            if (last && index > last.index) return;

            var self = this;
            if (item) {
                item.setProperty('renderShell', false);
                this.renderExpressionTimeout = setTimeout(function() {
                    self.renderExpression(index + 1, last);
                }, 1);
            }
        };

        view.appendAllItemViews = function() {
            if (!this.$items) return;
            var len = this.model.getItemCount();
            for (var i = 0; i < len; i++) {
                var item = this.model.getItemByIndex(i);
                var view = this.getItemView(item.id);
                view.appendTo(this.$items);
            }

            this.updateWidth();
            this.renderVisibleExpressions();
        };

        // holds a copy of the each item's view for later reference

        view.getItemView = function(id) {
            return this.__itemViews[String(id)];
        };

        view.onDelete = function(view) {
            var self = this;
            var animationDuration = 0.2;
            view.$().css({
                'transition': animationDuration + 's',
                'opacity': '0',
                'transform': "scale(.1, .1)"
            });
            setTimeout(function() {
                self.model.undoRedo.oneTransaction(function() {
                    self.model.removeItemAt(view.model.index);
                    if (self.model.getItemCount() === 0) {
                        var new_exp = ExpressionObject(undefined, self.model);
                        self.model.insertItemAt(0, new_exp);
                    }
                });
            }, 1000 * animationDuration);
        };

        view.onUpPressed = function(view) {
            // nothing above
            if (view.model.index === 0) return;

            this.selectPrevExpression(view.model);
            this.getSelectedView().addFocus('end');
        };

        view.onDownPressed = function(view) {
            this.selectNextExpression(view.model);
            this.getSelectedView().addFocus('start');
        };

        view.onBackspacePressed = function(view) {
            var wasText = view.model.isText;

            //if you press backspace from the last element of a folder, it
            //delete -- it removes you from the folder
            var nextItem = this.model.getItemByIndex(view.model.index + 1);
            if (view.model.folder && (!nextItem || !nextItem.folder)) {
                view.model.folder.removeItem(view.model);
                return;
            }

            this.upwardDeleteExpression(view.model);

            // having issues in iframe on ipad. backspace deletes the textbox
            // but doesn't focus into the expression above
            // see #3106
            if (wasText && Browser.IS_IPAD && Browser.IS_IN_IFRAME) {
                this.model.setSelected(null);
                return;
            }

            this.getSelectedView().addFocus('end');
        };

        view.onDelPressed = function(view) {
            this.downwardDeleteExpression(view.model);
            this.getSelectedView().addFocus('start');
        };

        view.onEnterPressed = function(view) {
            // having issues in iframe on ipad. make enter work like escape
            // see #3106
            if (view.model.isText && Browser.IS_IPAD && Browser.IS_IN_IFRAME) {
                conditionalBlur();
                this.model.setSelected(null);
                return;
            }

            var obj = ExpressionObject({ selected: true }, this.model);
            var self = this;
            var insertIndex = view.model.index + 1;
            //insert below the last element of a collapsed folder
            if (view.model.isFolder && view.model.collapsed) {
                insertIndex += _(view.model.memberIds).keys().length;
            }

            self.model.undoRedo.oneTransaction(function() {
                self.model.insertItemAt(insertIndex, obj);
                if (view.model.isFolder && !view.model.collapsed) {
                    view.model.addItem(obj);
                }
                if (view.model.folder) view.model.folder.addItem(obj);
            });
            this.getSelectedView().addFocus();
        };

        view.expressionsVisible = true;
        view.hideExpressions = function() {
            // deselect expression
            this.model.setSelected(null);
            conditionalBlur();
            //note: the above 2 lines should do this, and this next call should be a no-op. Adding in one last
            //line of defense. See: https://github.com/desmosinc/knox/issues/4580
            this.setProperty('needsFakeKeypad', false);
            this.setProperty('expressionsVisible', false);
        };

        view.showExpressions = function() {
            this.setProperty('expressionsVisible', true);
            conditionalBlur();
        };

        view.renderEditListMode = function() {
            var $root = this.$root;
            var self = this;

            if (this.editListMode) {
                $root.addClass('dcg-EDIT-LIST-MODE');
                this.model.setSelected(null);
                // listen for a tapstart event to close edit-list-mode
                $(document).on('tapstart.edit-list-mode', function(evt) {
                    if (
                        $(evt.target).closest('.dcg-exppanel').length === 0 &&
                        $(evt.target).closest('.dcg-options-menu').length === 0 &&
                        $(evt.target).closest('.dcg-expression-top-bar').length === 0
                    ) {
                        self.setProperty('editListMode', false);
                    }
                });
            } else {
                $root.removeClass('dcg-EDIT-LIST-MODE');
                // don't listen for the event to close edit-list-mode anymore
                $(document).off('.edit-list-mode');
            }
        };

        /*
         * EVENTS
         */
        view.handleFocusChange = function(focused) {
            var target = $(focused);
            var inMathquill = target.closest('.mathquill-rendered-math').length !== 0;
            var inEditableMathquill = target.closest('.mathquill-editable').length !== 0;
            var inMathquillWithMathField = target.closest('.mathquill-rendered-math:not(.mathquill-editable)')
                .find('.mathquill-editable').length !== 0;
            var inMathInput = target.closest('.dcg-math-input').length !== 0;
            var inText = target.closest('.dcg-expressiontext').length !== 0;
            var inFolder = target.closest('.dcg-expressionfolder').length !== 0;

            // clicking in the uneditable part of a mathquill that has \MathQuillMathFields embedded
            // still sends a focusIn event. Let's correct that by acting like mathquill isn't focused.
            if (!inEditableMathquill && inMathquill && inMathquillWithMathField) {
                inMathquill = false;
                inEditableMathquill = false;
                inMathInput = false;
            }

            // in case we're in list mode, get out of it!
            if (!inMathInput && (inMathquill || inEditableMathquill || inText || inFolder)) {
                this.setProperty('editListMode', false);
            }

            //itemFocused should only trigger when we're editing mathquill.
            //that shows us when the keypad is up, the list is expanded, etc.
            //none of those actions occur in text or folders
            this.setProperty('itemFocused', inMathquill || inEditableMathquill);
            this.setProperty('needsFakeKeypad', inMathquill && inEditableMathquill);
        };
        view.onFocusIn = function(evt) {

            //it's possible to add focus to an expression even when the expressions are hidden.
            // Most prominently: if you click a curve to select it and then type
            // If that happens, we want to show the expression that's being edited, so pop back out the expressions list
            if (!this.expressionsVisible) {
                this.showExpressions();
            }

            // sometimes mathquill notifies of focusin before the focus is set. So we have to
            // pass in where focus is about to be rather than simply use document.activeElement.
            this.handleFocusChange(evt.target);

            clearTimeout(this.fakeKeypadTimeout);
        };

        view.onFocusOut = function() {
            clearTimeout(this.fakeKeypadTimeout);
            // setTimeout here is used to coalesce calls to onFocusOut and onFocusIn
            // that happen in the same tick. This happens, e.g. when a new
            // expression is created, and we move focus from the previous expression
            // to it.
            this.fakeKeypadTimeout = setTimeout(function() {

                // Mathquill does something weird where it triggers a focusout on
                // render, but nothing actually happens to focus. To combat that, and
                // anything else similar, we check what's actually focused
                this.handleFocusChange(document.activeElement);

            }.bind(this), 0);
        };

        view.offset = function() {
            return this.$exps.offset();
        };

        view.setBottom = function(bottom) {
            if (!this.$exps) return;
            var oldBottom = parseFloat(this.$exps.css('bottom').slice(0, -2));
            if (!isFinite(oldBottom)) oldBottom = 0;
            this.$exps.css('bottom', bottom + 'px');

            //If the user is currently in a mouse interaction and the height
            //is increasing, pad the last expression until they end their interaction to
            //prevent things from moving under them
            if (bottom === 0 && touchtracking.isTapActive()) {
                this.padLastExpressionUntilTapEnd(oldBottom);
            }
            this.recalculateScrollbarWidth();
        };

        view.didCreateElement = function() {
            var self = this;
            var list = this.model;

            _super.didCreateElement.call(this);

            this.$exps = this.$('.dcg-exppanel-outer');

            this.addExpressionView = AddExpressionView(this, this.$root, this.graphSettings, this.toastView);
            this.addExpressionView.appendTo(this.$exps);
            this.addExpressionView.setupOpenButton(this.$('.dcg-action-add-expression'), 'tap');
            this.observe('scrollbarWidth minWidth', this.updateAllViewWidths.bind(this));

            this.$exps.tipsy({
                fade: 'fast',
                title: 'tooltip',
                wait: 500,
                delegate: '.dcg-tooltip'
            });

            this.$exppanelContainer = this.$('.dcg-exppanel-container');
            this.$exppanel = this.$('.dcg-exppanel');
            this.$items = this.$('.dcg-template-expressioneach');

            this.appendAllItemViews();

            //
            //listen for scroll. add class when scrolled, and set renderShells=false
            //

            var debouncedScroll = _.debounce(function(evt) {
                if (evt) this.$('.dcg-expression-top-bar').toggleClass(
                    'dcg-expressions-scrolled',
                    $(evt.target).scrollTop() > 0
                );
                this.renderVisibleExpressions();
            }.bind(this), 200);

            this.$exppanel.scroll(function(evt) {
                //stop rendering offscreen things immediately -- don't wait for debounce
                clearTimeout(self.renderExpressionTimeout);
                debouncedScroll(evt);
            });

            //
            // for iPad & nexus, listen for taps in the empty area underneath an expression and defocus
            // because that doesn't happen automatically. The way I'm detecting such a tap is by checking if the
            // event is within an .expressionitem. If it's not, we're assuming the tap is within empty space.
            //
            this.$exppanel.on('tapstart', function(evt) {
                // avoids losing focus when on desktop and we mouseDown on the scrollbar. If we want to lose foucs in
                // that case, this line is perfect to remove. If we want something more robust to detect that we're
                // on the scrollbar, we might be able to check x position of the event compared to the width of the
                // inner content.
                if (evt.device === 'mouse') return;

                if ($(evt.target).closest('.dcg-expressionitem').length === 0) {
                    conditionalBlur();
                }
            });

            this.$exppanel.on('keypress', this.ensureActiveChildIsVisible.bind(this));

            //the below should happen automatically, but doesn't on iPad / android
            //this lets you defocus the currently focused expression by clicking the 'Expressions' header
            this.$('.dcg-expression-top-bar').on('tapstart', function(evt) {
                if (evt.wasHandled()) return;
                list.setSelected(null);
            });


            this.$exps.on('tap', '.dcg-action-clearall', function() {
                self.triggerClearGraph();
                var undoCallback = function() {
                    self.setProperty('editListMode', true);
                };
                self.toastView.show("Graph cleared.", { undoCallback: undoCallback });
            });

            this.$exps.on('tap', '.dcg-action-undo', function() {
                list.undoRedo.undo();
            });

            this.$exps.on('tap', '.dcg-action-redo', function() {
                list.undoRedo.redo();
            });

            this.$exps.on('focusout', this.onFocusOut.bind(this));
            this.$exps.on('focusin', this.onFocusIn.bind(this));
            this.$('.dcg-action-toggle-edit').on('tap', function() {
                self.setProperty('editListMode', !self.editListMode);
            });
            this.$('.dcg-action-hideexpressions').on('tap', this.hideExpressions.bind(this));
            this.$('.dcg-action-showexpressions').on('tap', this.showExpressions.bind(this));
            // Relies on handleKeyDown returning early if no expression is selected for
            // correctness when there are multiple calculators in the page. This means
            // we want to have the invariant that only one list_view can have a selected
            // item at a time.
            $(document.documentElement).on('keydown', this.handleKeyDown.bind(this));

            this.renderItemFocused();
            this.renderEditListMode();

            this.newExpressionView = NewExpressionView(this);
            this.newExpressionView.replace(this.$('.template-newexpression'));
            this.newExpressionView.setProperty('index', this.model.getItemCount() + 1);

            // whenever mathquill renders
            this.$exps.on('render', function(evt) {
                self.updateWidth();
            });

            // these things all factor into how wide the expression list is, so we watch them
            this.model.observe('selectedItem', function() {
                self.updateWidth();
            });
            this.observe('editListMode itemFocused', function() {
                self.updateWidth();
            });

            // any time that focus changes we need to make sure that a part of the page doesn't
            // scroll in order show the cursor. this is specifically important for IE9 and tables.
            // In IE9 there will be a quick flash when the expression list is scrolled back to 0,0
            // but I can't find anything that happens synchronously. I've tried:
            //    1) Listening to changes to selectedCell of the selected table
            //    2) Listening for 'scroll' event on the element that gets scrolled
            //
            // both of those still show a quick flash, so this is the chosen method since it's
            // the simplest and most general.
            this.$exps.on('focusin', function() {
                setTimeout(function() {
                    self.updateWidth();
                }, 0);
            });
        };

        view.didInsertElement = function() {
            this.updateWidth();
            this.$exppanelContainer.addClass('dcg-do-animate');
        };

        view.getFirstVisibleItem = function() {
            var top = this.$exppanel.offset().top;
            var el = this.expressionAtPoint(0, top);

            if (!el) {
                return this.model.getItemByIndex(0);
            }
            //make sure it's fully visible
            if (this.getItemView(el.id).$().offset().top < top - 2) { //Allow for overlapping borders
                el = this.model.getItemByIndex(el.index + 1);
            }
            return el;
        };

        view.appendBlankExpression = function() {
            this.newExpressionView.newMath();
        };

        // Find the view for the selected expression and scroll that expression
        // into view. If the expression doesn't have a view yet, we'll let the
        // view call this once it's inserted into the dom. If there is no selected
        // view, then check if there's a focused view. If so, scroll that until
        // it's visible
        view.ensureActiveChildIsVisible = function() {
            if (!this.$exps || !this.$exps.is(':visible')) return;

            // if an item is selected, try to force it into view
            if (this.model.selectedItem) {
                var selectedView = this.getItemView(this.model.selectedItem.id);
                if (selectedView) {

                    var active = $(document.activeElement);
                    var mathquill = active.closest('.mathquill-editable');

                    //scroll the specific mathquill if we're in one (i.e. focused in a table or exp)
                    if (mathquill.length) {
                        var padding = (selectedView.model.isTable ? 60 : 90);
                        return scrollHelpers.scrollVisible(mathquill, this.$exppanel, padding);
                    }
                    //scroll the activeElement if it exists (i.e. focus is in a textarea or folder title)
                    if (active.closest('.dcg-expressionitem').length) {
                        return scrollHelpers.scrollVisible(active, this.$exppanel, 90);
                    }
                    //scroll the whole view
                    scrollHelpers.scrollVisible(selectedView.$(), this.$exppanel, 90);
                }
            }
        };

        view.handleKeyDown = function(evt) {
            /* jshint maxcomplexity:26 */
            // make sure nothing has focus
            if ($.contains(document.body, document.activeElement)) {
                return;
            }

            // make sure event didn't happen from within expression list
            if ($(evt.target).closest('.dcg-exppanel').length) {
                return;
            }

            // make sure target is still in dom. fixes #3282
            if (!$.contains(document.documentElement, evt.target)) {
                return;
            }

            var selected = this.getSelectedView();
            if (selected && selected.isFocused()) {
                selected.processMissedKeyEvent(evt);
                return;
            }
            var key = Keys.lookup(evt);

            if (!selected) return;

            switch (key) {
                case Keys.UP:
                    evt.preventDefault();
                    this.selectPrevExpression(selected.model);
                    break;

                case Keys.DOWN:
                    evt.preventDefault();
                    this.selectNextExpression(selected.model, true);
                    break;
                case Keys.ESCAPE:
                    evt.preventDefault();
                    this.model.setSelected(null);
                    break;

                case Keys.RIGHT:
                case Keys.TAB:
                    evt.preventDefault();
                    if (selected) {
                        if (selected.model.isTable) {
                            selected.addFocus('cell', 0, 0);
                        } else {
                            selected.addFocus('start');
                        }
                    }
                    break;

                case Keys.LEFT:
                    evt.preventDefault();
                    if (selected) {
                        if (selected.model.isTable) {
                            selected.addFocus('cell', 0, selected.model.columns.length - 1);
                        } else {
                            selected.addFocus('end');
                        }
                    }
                    break;

                case Keys.BACKSPACE:
                    evt.preventDefault();
                    if (selected) {
                        this.upwardDeleteExpression(selected.model);
                    }
                    break;

                case Keys.DELETE:
                    evt.preventDefault();
                    if (selected) {
                        this.downwardDeleteExpression(selected.model);
                    }
                    break;

                case Keys.ENTER:
                    evt.preventDefault();
                    if (selected) this.onEnterPressed(selected);
                    break;

                default:
                    //ignore things like ctrl-copy, ctrl-paste, alt-tab, shift
                    if (evt.metaKey ||
                        evt.ctrlKey ||
                        key === Keys.SHIFT ||
                        key === Keys.SPACEBAR
                    ) {
                        return;
                    }

                    if (selected) {
                        if (selected.model.isTable) {
                            // do nothing since we don't know where to type
                        } else {
                            selected.addFocus('end');
                        }
                    }
            }
        };

        /*
         * PUBLIC METHODS
         */
        view.getSelectedView = function() {
            var selected = this.model.getSelected();
            if (selected) {
                var view = this.getItemView(selected.id);
                return view;
            }

            return null;
        };

        view.upwardDeleteExpression = function(expression) {
            var index = expression.index;
            var prev = this.model.getItemByIndex(this.findPrevSelectableIndex(index));
            var self = this;
            var list = this.model;

            list.undoRedo.oneTransaction(function() {
                // remove this item
                list.removeItemAt(index);

                // if list is now empty, add a blank expression
                if (list.getItemCount() === 0) {
                    prev = ExpressionObject(undefined, list);
                    list.insertItemAt(0, prev);
                }

                // if there isn't an item before us, select the item that was after us
                if (!prev) {
                    prev = list.getItemByIndex(self.findNextSelectableIndex(index - 1));
                }

                if (prev) {
                    prev.setProperty('selected', true);
                }
            });
        };

        view.findPrevSelectableIndex = function(index) {
            var item;

            do {
                index--;
                item = this.model.getItemByIndex(index);
            } while (item && item.inCollapsedFolder);

            return item ? index : undefined;
        };

        view.findNextSelectableIndex = function(index) {
            var item;

            do {
                index++;
                item = this.model.getItemByIndex(index);
            } while (item && item.inCollapsedFolder);

            return item ? index : undefined;
        };

        view.downwardDeleteExpression = function(expression) {
            var index = expression.index;
            var next = this.model.getItemByIndex(this.findNextSelectableIndex(index));
            var list = this.list;

            if (next) {
                list.setSelected(next);
                list.removeItemAt(index);
            }

            // last, but not only expression
            else if (this.model.getItemCount() > 1) {
                list.setSelected(index - 1);
                list.removeItemAt(index);
            }

            // only expression
            else {
                list.undoRedo.oneTransaction(function() {
                    list.removeItemAt(0);
                    list.insertItemAt(0, ExpressionObject(undefined, list));
                    list.setSelected(0);
                });
            }
        };

        view.selectPrevExpression = function(expression) {
            if (!expression) return;

            var index = expression.index;
            var prev = this.model.getItemByIndex(this.findPrevSelectableIndex(index));

            if (prev) {
                prev.setProperty('selected', true);

                // check if this was an empty last expression
                // if so, remove it
                if (index === this.model.getItemCount() - 1 && expression.isEmpty()) {
                    this.model.removeItemAt(index);
                }
            }
        };

        view.selectNextExpression = function(expression, dontCreateNew) {
            if (!expression) return;

            var index = expression.index;
            var next = this.model.getItemByIndex(this.findNextSelectableIndex(index));

            if (next) {
                next.setProperty('selected', true);
            } else if (!dontCreateNew) {
                var obj = ExpressionObject({ selected: true }, this.model);
                this.model.insertItemAt(this.model.getItemCount(), obj);
            }
        };

        /*
         * Returns a list of visible expression views, ordered by index.
         */
        view._getVisibleViews = function() {
            var visibleViews = [];

            for (var i = 0; i < this.model.getItemCount(); i++) {
                var exp = this.model.getItemByIndex(i);
                var view = this.getItemView(exp.id);
                if (view && view.$().is(':visible')) visibleViews.push(view);
            }

            return visibleViews;
        };

        /*
         * Does a binary search to find the .expressionitem that is at the point
         */
        view.expressionAtPoint = function(x, y) {
            var visibleViews = this._getVisibleViews();
            var lo = 0;
            var hi = visibleViews.length - 1;

            while (lo <= hi) {
                var mid = lo + Math.floor((hi - lo) / 2);
                var view = visibleViews[mid];
                var rect = view.getBounds();

                if (rect.top > y) {
                    hi = mid - 1;
                } else if (rect.bottom < y) {
                    lo = mid + 1;
                } else {
                    return view.model;
                }
            }

            return null;
        };

        /*
         * Finds the first expression at or above the point
         */
        view.expressionAbovePoint = function(x, y) {
            var visibleViews = this._getVisibleViews();
            var lo = 0;
            var hi = visibleViews.length - 1;
            var found = null;

            while (lo <= hi) {
                var mid = lo + Math.floor((hi - lo) / 2);
                var view = visibleViews[mid];
                var rect = view.getBounds();

                if (rect.top > y) {
                    hi = mid - 1;
                } else {
                    lo = mid + 1;
                    found = view.model;
                }
            }

            return found;
        };

        view.onProjectorModeChange = function() {
            for (var id in this.__itemViews) {
                if (this.__itemViews.hasOwnProperty(id)) {
                    this.__itemViews[id].onProjectorModeChange();
                }
            }
        };

        // keypad sends a message to the list_view if a key is pressed but
        // no mathquill is currently focused. It's up to the list_view to
        // figure out what to do with the key. The time that this happens
        // is when a disabled table cell is highlighted. We need the arrow
        // keys to still work.
        view.handleUnfocusedKeypadAction = function(key) {
            var selectedView = this.getSelectedView();
            if (selectedView && selectedView.model.isTable) {
                if (selectedView.model.selectedCell) {
                    selectedView.doKeyAction(key);
                }
            }
        };

        view.addFocusForKeypad = function() {
            //use currently selected expression if one is selected (no-op if it's also focused)
            var selected = this.model.getSelected();
            if (selected && selected.isExpression) {
                this.getItemView(selected.id).addFocus();
                return;
            }

            //if currently selected is a table, return early if it already has focus
            if (selected && selected.isTable && this.itemFocused) {
                return;
            }

            //if not, get the element at the top of the list
            var item = this.getFirstVisibleItem();

            //search downward until we find an expression that we can focus
            while (item && !item.isExpression) {
                item = this.model.getItemByIndex(item.index + 1);
            }

            //if we found an item: focus it!
            if (item) {
                this.getItemView(item.id).addFocus();
                return;
            }

            //append a blank expression at the bottom of the list, and focus that
            this.appendBlankExpression();
        };

    });

    return ExpressionListView;
});

define('loadcss!css/keypad', function() {});
define('template!keypad', ['underscore'], function(_) {
    return function(obj) {
        var __p = '';
        var print = function() { __p += Array.prototype.join.call(arguments, '') };
        with(obj || {}) {
            __p += '<div class=\'dcg-keypad\'>\n  <div class=\'dcg-keys-container dcg-retracted\'>\n    <div class=\'dcg-keys-background dcg-do-not-blur\'>\n      <div class=\'dcg-keys\'>\n\n        <div class=\'dcg-functions-popover dcg-popover dcg-top\'>\n          <div class=\'dcg-popover-interior\'>\n            <div class=\'dcg-popover-header\'>\n              <table><tr>\n              ';
            _.each(popups.functionsPopup, function(contents, section) {;
                __p += '\n                <td>\n                  <span key="' +
                    (contents.tab.id) +
                    '" class="dcg-heading dcg-tappable dcg-btn dcg-btn-gray' +
                    ((section == "trig" ? " dcg-selected" : "")) +
                    '">\n                    ' +
                    (contents.tab.html) +
                    '\n                  </span>\n                </td>\n              ';
            });
            __p += '\n              </tr></table>\n            </div>\n\n            ';
            _.each(popups.functionsPopup, function(contents, section) {;
                __p += '\n              <table class=\'dcg-interior-buttons\' section=\'' +
                    (section) +
                    '\'>\n                ';
                if (section == "trig") {;
                    __p += '\n                  <tr class=\'dcg-section-headings\'>\n                    <td>trig</td>\n                    <td>inverse</td>\n                    <td>hyperb</td>\n                  </tr>\n                ';
                };
                __p += '\n                <tr>\n\n                ';

                var i = 0;
                _.each(contents.funcs, function(func) {

                    ;
                    __p += '\n                  ' +
                        ((i % 3 == 0 ? "</tr><tr>" : "")) +
                        '\n                  ';
                    i++;
                    __p += '\n                  <td>\n                    <span\n                      class="dcg-option dcg-btn dcg-tappable' +
                        (func.aClass ? " " + func.aClass : "") +
                        ' dcg-' +
                        (func.id) +
                        '-key"\n                      key="' +
                        (func.id) +
                        '"\n                    >\n                      ' +
                        (func.html) +
                        '\n                    </span>\n                  </td>\n              ';
                });
                __p += '\n              </tr></table>\n            ';
            });
            __p += '\n          </div>\n          <div class=\'dcg-arrow\'></div>\n        </div>\n\n        ';
            _.each(buttons, function(keypad, keypadID) {;
                __p += '\n         <div class="dcg-' +
                    (keypadID) +
                    ' dcg-main-keypad-section">\n           ';
                _.each(keypad, function(row) {;
                    __p += '\n             <div class="dcg-row">\n               ';
                    _.each(row['keys'], function(key) {;
                        __p += '<div\n                   class="dcg-cell ' +
                            (key.cellClass ? key.cellClass : "") +
                            '"\n                 >\n                   ';
                        if (key.html) {;
                            __p += '\n                     <a\n                       class="dcg-btn ' +
                                (key.aClass ? key.aClass : "") +
                                ' dcg-' +
                                (key.id) +
                                '-key"\n                       key="' +
                                (key.id) +
                                '"\n                     >\n                       ' +
                                (t(key.html)) +
                                '\n                     </a>\n                   ';
                        };
                        __p += '\n                 </div>';
                    });
                    __p += '\n               <div style=\'clear:both\'></div>\n             </div>\n           ';
                });
                __p += '\n         </div>\n        ';
            });
            __p += '\n        <div style=\'clear:both\'></div>\n      </div>\n\n      <div class=\'dcg-minimize-keypad dcg-tooltip\' tooltip="' +
                (t('Hide Keypad').replace(' ', '&nbsp;')) +
                '">\n        <i class=\'dcg-icon-keyboard\'></i>\n        <i class=\'dcg-icon-caret-down\'></i>\n      </div>\n\n      <div class=\'dcg-minimize-keypad dcg-tooltip dcg-inline-minimize-keypad\' tooltip="' +
                (t('Hide Keypad').replace(' ', '&nbsp;')) +
                '">\n        <i class=\'dcg-icon-remove\'></i>\n      </div>\n    </div>\n  </div>\n\n  <div class="dcg-show-keypad dcg-do-not-blur dcg-tooltip" tooltip="' +
                (t('Show Keypad').replace(' ', '&nbsp;')) +
                '">\n    <i class=\'dcg-icon-keyboard\'></i>\n    <i class="dcg-icon-caret-up dcg-do-not-blur"></i>\n  </div>\n</div>\n';
        }
        return __p;
    };
});
define('text!data/keypad_keys.json', [], function() { return '{\n"trigFuncs":        ["sin","cos","tan","csc","sec","cot"],\n\n"oneArgFuncs":      ["ceil","floor","round","abs","ln","log","exp"],\n\n"twoArgFuncs":      ["min","max","lcm","gcd","mod", "nCr", "nPr"],\n\n"tabs":             ["trig","calc","misc"],\n\n"staticKeys": {\n  "unknown":          {"display":{"html":"?"},\n                      "action":{"cmd":"?"}},\n  "pi":               {"display":{"html":"&pi;"},\n                      "action":{"cmd":"\\\\pi"}},\n  "tau":               {"display":{"html":"&tau;"},\n                      "action":{"cmd":"\\\\tau"}},\n  "leftparen":        {"display":{"html":"("},\n                      "action":{"cmd":"("}},\n  "rightparen":       {"display":{"html":")"},\n                      "action":{"cmd":")"}},\n  "sqrt":             {"display":{"html":"&radic;"},\n                      "action":{"cmd":"\\\\sqrt"}},\n  "cuberoot":         {"display":{"html":"3&radic;"},\n                      "action":{"custom": "cuberoot"}},\n  "lt":               {"display":{"html":"&lt;"},\n                      "action":{"cmd":"<"}},\n  "gt":               {"display":{"html":"&gt;"},\n                      "action":{"cmd":">"}},\n  "le":               {"display":{"html":"&le;"},\n                      "action":{"cmd":"\\\\le"}},\n  "ge":               {"display":{"html":"&ge;"},\n                      "action":{"cmd":"\\\\ge"}},\n\n  "squared":          {"display":{"aClass":"dcg-exponent", "html":"a^2"},\n                      "action":{"custom":"squared"}},\n\n  "exponent":         {"display":{"aClass":"dcg-exponent", "html":"a^b"},\n                      "action":{"cmd":"^"}},\n  "subscript":        {"display":{"html":"a_b"},\n                      "action":{"cmd":"_"}},\n  "fact":             {"display":{"html":"a!"},\n                      "action":{"cmd":"!"}},\n  "theta":            {"display":{"html":"&theta;"},\n                      "action":{"cmd":"\\\\theta"}},\n\n  "brackets":        {"display":{"html":"{ }", "noMQ":true},\n                      "action":{"custom":"brackets"}},\n  "squarebrackets":        {"display":{"html":"[ ]", "noMQ":true},\n                      "action":{"custom":"squarebrackets"}},\n  "colon":            {"display":{"html":":"},\n                      "action":{"cmd":":"}},\n  "pipes":            {"display":{"html":"|a|"},\n                      "action":{"cmd":"|"}},\n  "comma":            {"display":{"html":","},\n                      "action":{"cmd":","}},\n\n  "times":            {"display":{"html":"&times;"},\n                      "action":{"cmd":"*"}},\n  "plus":             {"display":{"html":"+"},\n                      "action":{"cmd":"+"}},\n  "divide":           {"display":{"html":"&divide;"},\n                      "action":{"cmd":"/"}},\n  "minus":            {"display":{"html":"&ndash;"},\n                      "action":{"cmd":"-"}},\n  "equals":           {"display":{"html":"="},\n                      "action":{"cmd":"="}},\n  "twiddle":           {"display":{"html":"~"},\n                      "action":{"cmd":"~"}},\n  "decimal":          {"display":{"html":"."},\n                      "action":{"cmd":"."}},\n\n  "backspace":        {"display":{"aClass":"dcg-btn-gray",\n                                  "html":"<i class=\\"dcg-icon-delete\\"></i>",\n                                "colspan": 1.5\n                               },\n                      "action":{"key":"Backspace"}},\n  "enter":            {"display":{"aClass":"dcg-btn-gray",\n                                  "html":"<i class=\\"dcg-icon-arrow-enter\\"></i>",\n                                  "colspan": 2\n                                },\n                      "action":{"key":"Enter"}},\n  "toggleLetters":    {"display":{"aClass":"dcg-btn-gray",\n                                  "html":"A B C",\n                                  "colspan":2},\n                      "action":{"changeLayout": "letters"}},\n  "toggleNumbers":    {"display":{"aClass":"dcg-btn-gray",\n                                "html":"1 2 3",\n                                "colspan":2\n                               },\n                      "action":{"changeLayout":"mainNumbers"}},\n\n  "popupFunctions":  {"display":{"aClass":"dcg-btn-gray", "html":"func<span class=\'dcg-hide-on-narrow\'>tion</span>s", "colspan":2},\n                      "action":{"popup": "functions"}},\n\n  "blank":            {"display":{},\n                      "action":{}},\n\n  "halfBlank":        {"display":{"colspan":0.5},\n                      "action":{}},\n\n  "left":             {"display":{"html":"<i class=\\"dcg-icon-arrow-left\\"></i>"},\n                      "action":{"key":"Left"}},\n  "up":               {"display":{"html":"&uarr;"},\n                      "action":{"key":"Up"}},\n  "right":            {"display":{"html":"<i class=\\"dcg-icon-arrow-right\\"></i>"},\n                      "action":{"key":"Right"}},\n  "down":             {"display":{"html":"&darr;"},\n                      "action":{"key":"Down"}},\n\n\n  "toggleCapital":    {"display":{"aClass":"dcg-btn-gray",\n                                  "html":"<i class=\\"dcg-icon-shift\\"></i>",\n                                  "colspan":1.5},\n                                  "action":{"changeLayout": "capitalLetters"}},\n  "toggleLowercase":    {"display":{"aClass":"dcg-btn-gray dcg-active",\n                                  "html":"<i class=\\"dcg-icon-shift\\"></i>",\n                                  "colspan":1.5},\n                                  "action":{"changeLayout": "letters"}},\n  "loga":             {"display":{"html":"log_a"},\n                      "action":{"custom":"loga"}},\n  "ddx":              {"display":{"html":"d/dx"},\n                      "action":{"custom":"d/dx"}},\n  "sum":              {"display":{"html":"\\\\sum"},\n                      "action":{"cmd":"\\\\sum"}},\n  "prod":             {"display":{"html":"\\\\prod"},\n                      "action":{"cmd":"\\\\prod"}},\n  "highlightedX":     {"display":{"html":"x", "aClass":"dcg-highlighted"},\n                      "action":{"cmd":"x"}},\n  "highlightedY":     {"display":{"html":"y", "aClass": "dcg-highlighted"},\n                      "action":{"cmd":"y"}}\n  }\n}\n'; });

define('main/keypad_keys', ['require', 'jquery', 'underscore', 'i18n', 'mathquill', 'text!data/keypad_keys.json'], function(require) {
    var $ = require('jquery');
    var _ = require('underscore');
    var i18n = require('i18n');
    require('mathquill');
    var keypad_data = JSON.parse(require('text!data/keypad_keys.json'));
    var i;

    //Start with explicitly defined keys
    var keys = keypad_data.staticKeys;

    //Queue i18n to translate strings that show up in keyboard
    i18n.t('functions');
    i18n.t('A B C');
    i18n.t('more');
    i18n.t('enter');

    //Expand summary-form data from JSON to create input structure for keypad
    _.each(keypad_data.tabs, function(t) {
        keys[t + 'Tab'] = { display: { html: t }, action: { tab: t } };
    });

    _.each(keypad_data.oneArgFuncs, function(f) {
        keys[f] = { display: { html: f }, action: { func: f } };
    });

    _.each(keypad_data.twoArgFuncs, function(f) {
        keys[f] = { display: { html: f }, action: { func: f, args: 2 } };
    });

    _.each(keypad_data.trigFuncs, function(fn) {
        _.each([fn, 'arc' + fn, fn + 'h'], function(f) {
            keys[f] = { display: { html: f }, action: { func: f } };
        });
    });

    var ch;
    for (i = 0; i < 26; i++) { // A-F
        ch = String.fromCharCode(65 + i);
        keys[ch] = { display: { html: ch }, action: { cmd: ch } };
    }

    for (i = 0; i < 26; i++) { // a-f
        ch = String.fromCharCode(97 + i);
        keys[ch] = { display: { html: ch }, action: { cmd: ch } };
    }

    for (i = 0; i < 10; i++) { // 0-9
        var num = String.fromCharCode(48 + i);
        keys[num] = { display: { html: num }, action: { cmd: num } };
    }

    var genButton = function(key, buttonId) {
        var display = key.display;
        var action = key.action;

        display.id = buttonId;

        if (!('cellClass' in display)) display.cellClass = '';

        if (!('aClass' in display)) display.aClass = '';

        if (display.colspan) {

            if (display.cellClass) display.cellClass += ' ';

            switch (display.colspan) {
                case 0.5:
                    display.cellClass += 'dcg-halfwide';
                    break;
                case 2:
                    display.cellClass += 'dcg-twowide';
                    break;
                case 1.5:
                    display.cellClass += 'dcg-onepointfivewide';
                    break;
            }
        }

        if (display.html) {
            display.aClass = (display.aClass ? display.aClass + ' dcg-key' : 'dcg-key');
            display.aClass += ' dcg-tappable';
        }

        if (!(action.tab || action.key || action.popup || action.changeLayout) &&
            !display.noMQ && display.html
        ) {
            display.mathquill = true;

            // ask mathquill for an html version of itself
            // note: this will break for things like parentheses with contents,
            // which need to be inserted into the dom to know their correct size.
            // but works for uncomplicated mathquill
            // WARNING - if run multiple times, this will modify this.keys in breaking ways
            display.html = $('<span>' + display.html + '</span>').mathquill().mathquill('html');
            display.aClass += ' mathquill-rendered-math';
        }
    };

    _.each(keys, genButton);

    return keys;
});

define('main/keypad_view', ['require', 'console', 'loadcss!css/keypad', 'jquery', 'underscore', 'browser', 'main/cookie', 'template!keypad', 'underscore_view', 'pjs', 'tipsy', 'main/cookie', 'main/keypad_keys'], function(require) {
    var console = require('console');
    require('loadcss!css/keypad');

    var $ = require('jquery');
    var _ = require('underscore');
    var Browser = require('browser');
    var Cookie = require('main/cookie');
    var template = require('template!keypad');
    var UnderscoreView = require('underscore_view');
    var P = require('pjs');
    require('tipsy');

    require('main/cookie');
    var KEYS = require('main/keypad_keys');

    var KeypadView = P(UnderscoreView, function(view, _super) {

        view.template = template;

        view.init = function() {
            _super.init.call(this);
            this.keys = KEYS;
            this.setupKeypad();
            this.setLayout('mainNumbers');
            this.setProperty('functionsOpen', false);
            this.setProperty('isOpen', false);
            // Flag for whether the user has minimized the keypad with the minimize
            // button. In this case, we keep it minimized unless the user opens it with
            // the open keypad button.
            this.userMinimized = false;

            this.editableViews = [];
        };

        view.getEditableViewThatNeedsKeypad = function() {
            for (var i = 0; i < this.editableViews.length; i++) {
                if (this.editableViews[i].needsFakeKeypad) {
                    return this.editableViews[i];
                }
            }

            return null;
        };

        view.getActiveMathquill = function() {
            var mathquill = $(document.activeElement).closest('.mathquill-editable');
            return mathquill.length ? mathquill : null;
        };

        view.registerEditableView = function(editableView) {
            this.editableViews.push(editableView);

            editableView.observe('needsFakeKeypad', this.onNeedsFakeKeypad.bind(this));
        };

        view.onNeedsFakeKeypad = function() {
            this.requestSetIsOpen(!!this.getEditableViewThatNeedsKeypad());
        };

        view.didCreateElement = function() {
            var self = this;
            self.setLayout(self.layout);

            //handles to the various buttons that we're going to use a lot
            self.$hideBtn = self.$('.dcg-minimize-keypad');
            self.$showBtn = self.$('.dcg-show-keypad');
            self.$funcPopover = self.$('.dcg-functions-popover');
            self.$container = self.$('.dcg-keys-container');
            self.$keys = self.$('.dcg-keys');
            self.$funcBtn = self.$('.dcg-popupFunctions-key');
            self.setTab('trig');

            this.observe('functionsOpen', this.renderFunctionsOpen.bind(this));
            this.observe('graphpaperHeight', this.positionFunctionsPopup.bind(this));

            this.$().tipsy({
                fade: 'fast',
                title: 'tooltip',
                wait: 500,
                delegate: '.dcg-tooltip',
                gravity: 's',
                offset: 2
            });

            self.$().on('tap', '.dcg-tappable', function(evt) {
                var button = $(evt.target).closest('.dcg-tappable');
                self.buttonClicked(button);
            });

            self.$showBtn.show();

            //initialize hide & show
            self.$hideBtn.on("tap", function() {
                self.userMinimized = true;
                Cookie.setCookie("keypadMinimized", "true");
                self._hideKeypad();
            });

            self.$showBtn.on("tap", function() {
                self.userMinimized = false;
                Cookie.setCookie("keypadMinimized", "false");
                self._showKeypad();

                // focus is already in a mathquill.
                if (self.getActiveMathquill()) {
                    return;
                }

                // the keypad is going to be maximized, but we have
                // no clear place to put focus. Run through the views
                // and request them to put focus.
                //
                // NOTE: works deterministically because only the
                // expressionsView defines the `.addFocusForKeypad()`
                // function. If we add more views that require the fake
                // keypad we can come up with something better.
                for (var i = 0; i < self.editableViews.length; i++) {
                    if (self.editableViews[i].addFocusForKeypad) {
                        self.editableViews[i].addFocusForKeypad();
                    }
                }

            });

            self.userMinimized = (Cookie.getCookie("keypadMinimized") === "true");
        };

        view._hideKeypad = function() {
            clearTimeout(this.__showHideTimeout);

            var self = this;
            // Timeout is used to avoid keypad flicker when moving between expressions.
            this.__showHideTimeout = setTimeout(function() {
                self.__showHideTimeout = null;
                self.setProperty('isOpen', false);
                self.setProperty('functionsOpen', false);
                self.$container.addClass('dcg-retracted');

                if (Browser.IS_IE8 || Browser.IS_IE9) {
                    // IE<10 doesn't support transitions, so we shouldn't fade the button
                    // in
                    self.$showBtn.show();
                } else {
                    self.$showBtn.fadeIn();
                }
            });
        };

        view._showKeypad = function() {
            clearTimeout(this.__showHideTimeout);
            var self = this;
            this.__showHideTimeout = setTimeout(function() {
                self.__showHideTimeout = null;
                self.setLayout("mainNumbers");
                self.$showBtn.hide();
                self.setProperty('isOpen', true);
                self.$container.removeClass('dcg-retracted');
            });
        };

        view.requestSetIsOpen = function(isOpen) {
            if (this.userMinimized && !this.isOpen) return;
            if (isOpen === this.isOpen && !this.__showHideTimeout) return;

            if (isOpen) {
                this._showKeypad();
            } else {
                this._hideKeypad();
            }
        };

        view.getButton = function(buttonId) {
            if (!this.keys[buttonId])
                buttonId = "unknown";
            return this.keys[buttonId].display;
        };

        view.buttonArray = function(buttonsString) {
            return _.map(buttonsString.split(' '), this.getButton, this);
        };

        view.setupKeypad = function() {

            this.buttons = {
                mainNumbersLeft: [
                    { keys: this.buttonArray('highlightedX highlightedY squared exponent') },
                    { keys: this.buttonArray('leftparen rightparen lt gt') },
                    { keys: this.buttonArray('pipes comma le ge') },
                    { keys: this.buttonArray('toggleLetters sqrt pi') }
                ],

                numbersMiddle: [
                    { keys: this.buttonArray('7 8 9 divide') },
                    { keys: this.buttonArray('4 5 6 times') },
                    { keys: this.buttonArray('1 2 3 minus') },
                    { keys: this.buttonArray('0 decimal equals plus') }
                ],

                numbersRight: [
                    { keys: this.buttonArray('popupFunctions') },
                    { keys: this.buttonArray('left right') },
                    //intentionally leave the last blank off so that enter isn't covered by it
                    { keys: this.buttonArray('halfBlank backspace') },
                    { keys: this.buttonArray('enter') }
                ],

                letters: [
                    { keys: this.buttonArray('q w e r t y u i o p') },
                    { keys: this.buttonArray('halfBlank a s d f g h j k l halfBlank') },
                    { keys: this.buttonArray('toggleCapital z x c v b n m backspace') },
                    {
                        keys: this.buttonArray(
                            'toggleNumbers subscript brackets colon squarebrackets twiddle theta enter'
                        )
                    }
                ],
                capitalLetters: [
                    { keys: this.buttonArray('Q W E R T Y U I O P') },
                    { keys: this.buttonArray('halfBlank A S D F G H J K L halfBlank') },
                    { keys: this.buttonArray('toggleLowercase Z X C V B N M backspace') },
                    {
                        keys: this.buttonArray(
                            'toggleNumbers subscript brackets colon squarebrackets twiddle theta enter'
                        )
                    }
                ]
            };

            this.popups = {
                functionsPopup: {
                    trig: {
                        tab: this.getButton('trigTab'),
                        funcs: this.buttonArray(
                            'sin arcsin sinh cos arccos cosh tan arctan tanh csc arccsc csch sec arcsec sech cot arccot coth'
                        )
                    },

                    calc: {
                        tab: this.getButton('calcTab'),
                        funcs: this.buttonArray('exp ln log loga ddx sum prod fact e')
                    },

                    misc: {
                        tab: this.getButton('miscTab'),
                        funcs: this.buttonArray(
                            'ceil floor round abs min max lcm gcd mod nCr nPr fact sqrt cuberoot pipes brackets'
                        )
                    }
                }
            };
        };

        view.getTemplateParams = function() {
            return { buttons: this.buttons, popups: this.popups };
        };

        view.height = function() {
            return this.isOpen ? this.$container.height() : 0;
        };

        view.setLayout = function(newLayout) {
            this.layout = newLayout;
            this.$().removeClass('dcg-layout-letters dcg-layout-capitalLetters dcg-layout-mainNumbers')
                .addClass('dcg-layout-' + newLayout);
        };

        view.setTab = function(newTab) {
            var tabs = ['trig', 'calc', 'misc'];
            var self = this;
            _.each(tabs, function(tab) {
                self.$('[key=' + tab + 'Tab]').removeClass('dcg-selected');
                self.$('[section=' + tab + ']').hide();
            });
            this.$('[key=' + newTab + 'Tab]').addClass('dcg-selected');
            this.$('[section=' + newTab + ']').show();
        };

        view.renderFunctionsOpen = function() {
            this.$funcBtn.toggleClass("dcg-active", this.functionsOpen);
            this.$funcPopover.toggle(this.functionsOpen);
            this.positionFunctionsPopup();
        };

        view.positionFunctionsPopup = function() {
            if (!this.functionsOpen) return;

            //this just changes which direction the arrowhead is pointing
            var $arrow = this.$funcPopover.find('.dcg-arrow');
            if (this.graphpaperHeight < 525) {
                this.$funcPopover.removeClass("dcg-top").addClass("dcg-left");

                var btnDistanceFromBottom = this.$container.outerHeight() -
                    (this.$funcBtn.offset().top - this.$container.offset().top);

                //subtract off half width and then make 2 adjustments:
                // -2px because popover has bottom: 2px
                // -10px to compensate for the 10px height of the arrow
                var arrowBottom = btnDistanceFromBottom - this.$funcBtn.outerHeight() / 2 - 2 - 10;

                $arrow.css({
                    left: 'auto',
                    bottom: arrowBottom
                });
            } else {
                this.$funcPopover.removeClass("dcg-left").addClass("dcg-top");
                $arrow.css({
                    left: this.$funcPopover.width() - this.$funcBtn.width() / 2,
                    bottom: 'auto',
                });
            }
        };

        view.buttonClicked = function(button) {
            /* jshint maxcomplexity:293 */
            var keyID = this.$(button).attr('key'),
                buttonAction = this.keys[keyID].action;

            if (buttonAction.changeLayout) {
                this.setProperty('functionsOpen', false);
                this.setLayout(buttonAction.changeLayout);
                return;
            }
            if (buttonAction.tab) {
                return this.setTab(buttonAction.tab);
            }
            if (buttonAction.popup === 'functions') {
                return this.setProperty('functionsOpen', !this.functionsOpen);
            }

            //hide popup when any button is pressed (Except a popup or tab button)
            this.setProperty('functionsOpen', false);

            var editor = this.getActiveMathquill();

            if (!editor) {
                var activeView = this.getEditableViewThatNeedsKeypad();
                if (activeView && activeView.handleUnfocusedKeypadAction) {
                    activeView.handleUnfocusedKeypadAction(buttonAction.key);
                }

                return;
            }

            try {
                if (buttonAction.custom) {
                    switch (buttonAction.custom) {
                        case 'brackets':
                            editor.mathquill('cmd', '{');
                            editor.mathquill('cmd', '}');
                            editor.mathquill('onKey', 'Left');
                            break;
                        case 'squarebrackets':
                            editor.mathquill('cmd', '[');
                            editor.mathquill('cmd', ']');
                            editor.mathquill('onKey', 'Left');
                            break;
                        case 'loga':
                            editor.mathquill('write', 'log_{}\\left( \\right)');
                            editor.mathquill('onKey', 'Left');
                            editor.mathquill('onKey', 'Left');
                            editor.mathquill('onKey', 'Left');
                            break;
                        case 'cuberoot':
                            editor.mathquill('write', '\\sqrt[3]{}');
                            editor.mathquill('onKey', 'Left');
                            break;
                        case 'squared':
                            //route as if typed the exponent button, so that we get the
                            //nice behavior where exponentiating in an exponent is treated
                            //as a backspace first
                            editor.mathquill('cmd', '^');
                            editor.mathquill('cmd', '2');
                            editor.mathquill('onKey', 'Right');
                            break;
                        case 'cubed':
                            editor.mathquill('write', '^{3}');
                            break;
                        case 'd/dx':
                            editor.mathquill('write', '\\frac{d}{dx}');
                            break;
                    }
                } else if (buttonAction.key) {
                    editor.mathquill("onKey", buttonAction.key);
                } else if (buttonAction.cmd) {
                    editor.mathquill('cmd', buttonAction.cmd);
                    //if (buttonAction.moveLeft) {
                    //  editor.mathquill("onKey", "Left");
                    //}
                } else if (buttonAction.func) {
                    var suffix = '\\left( \\right)';
                    if (buttonAction.args === 2) {
                        suffix = '\\left({},{}\\right)';
                    }
                    editor.mathquill('write', buttonAction.func + suffix);
                    editor.mathquill('onKey', 'Left');
                    if (buttonAction.args === 2) {
                        editor.mathquill('onKey', 'Left');
                    }
                }
                // after everything is said and done, tell mathquill it rendered. This
                // will update the value stored for the expressions latex. And that
                // will cause this change to go into undo/redo.
                editor.trigger('render');
            } catch (e) {
                console.log(e);
            }
        };
    });

    return KeypadView;
});

//Abstract out getState and setState functionality
//TODO - setState is still pretty gross, but this is better than copy/pasting that grossness

define('main/state_controller', ['require', 'pjs', 'expressions/colors', 'jquery'], function(require) {
    var P = require('pjs');
    var Colors = require('expressions/colors');
    var $ = require('jquery');

    var StateController = P(function(proto) {

        var BLANK_STATE = {
            'graph': {
                'viewport': {
                    'xmin': -10,
                    'xmax': 10,
                    'ymin': -10,
                    'ymax': 10
                },
                'xAxisArrows': 'none',
                'yAxisArrows': 'none',
                'xAxisLabel': '',
                'yAxisLabel': '',
                'xAxisStep': 0,
                'yAxisStep': 0,
                'xAxisNumbers': true,
                'yAxisNumbers': true,
                'polarNumbers': true,
                'showXAxis': true,
                'showYAxis': true,

                'showGrid': true,
                'squareAxes': true,
                'labelXMode': '',
                'labelYMode': ''
            },
            'expressions': { 'list': [{ 'id': 1, 'latex': '' }] }
        };

        proto.init = function(grapher, expressionsModel, graphSettings, evaluator) {
            this.grapher = grapher;
            this.expressionsModel = expressionsModel;
            this.graphSettings = graphSettings;
            this.evaluator = evaluator;
            this.isFirstSetState = true;
        };

        proto.triggerSetState = function() {};

        proto.getState = function() {
            return {
                graph: this.grapher.getState(),
                expressions: this.expressionsModel.getState()
            };
        };

        proto.setState = function(state) {
            //don't set blank state more than once
            if (!this.isFirstSetState &&
                (state === null) &&
                this.expressionsModel.isEmpty()
            ) {
                return;
            }

            var self = this;
            var manipulator = function(state) {
                Colors.reset();
                if (!state) state = BLANK_STATE;
                if (typeof state === 'string') state = JSON.parse(state);

                // Empty the evaluator and the graph so that when we switch to the new
                // viewport, we don't flash a rescaled version of the old state.
                if ('expressions' in state) {
                    self.expressionsModel.setState({ list: [] });
                }

                self.evaluator.batch(function() {
                    self.expressionsModel.setSelected(null);
                    self.grapher.clear();
                    self.grapher.redrawGraphsLayer();

                    if ('graph' in state) {
                        if (!('degreeMode' in state.graph)) state.graph.degreeMode = false;

                        self.grapher.setState(state.graph);
                    }

                    if ('expressions' in state) {
                        self.expressionsModel.setState(state.expressions);
                        self.evaluator.markAsCompleteState();
                    }
                });
            };

            //apply it this first time, but don't add to undo/redo
            if (this.isFirstSetState) {
                manipulator(state);
                this.isFirstSetState = false;
                return;
            }

            var curState = this.getState();
            this.expressionsModel.undoRedo.addTransaction({
                type: this.expressionsModel.undoRedo.CAUSE_OF_CHANGE,
                undo: function() { manipulator(curState); },
                redo: function() { manipulator(state); },

                // we stringify two json objects that come out of the same function.
                // If the objects are the same, then the stringified versions will be
                // exactly the same.
                ensureChangeOccured: function() {
                    var newState = JSON.stringify(self.getState());
                    var oldState = JSON.stringify(curState);

                    return oldState === newState;
                }
            });
        };

        proto.setBlank = function() {
            this.setState(BLANK_STATE);
        };

        proto.setStateFromURL = function(url) {
            return $.getJSON(url).done(function(msg) {
                this.setState(msg.state);
            }.bind(this));
        };
    });

    return StateController;

});

// Listens to expressionsModel and propagates selection changes to the grapher
// and evaluator.
//
// TODO this could be *much* simpler if we had a better model for expressing
// selection within a table.
define('main/propagate_selection', ['require'], function(require) {
    function propagateSelection(expressionsModel, grapher, evaluator) {
        var lastSelectedId;
        var lastSelectedModel;

        // Show pois for the currently selected equation.
        var onSelectedExpressionChange = function() {
            var selected = expressionsModel.getSelected();
            // sets up a listener for changes in selection within tables and folders. It's fine
            // that we add these observers for even non-tables and non-folders.
            if (selected !== lastSelectedModel) {
                if (lastSelectedModel) {
                    lastSelectedModel.unobserve('.propagate_selection');
                }
                if (selected) {
                    selected.observe('selectedCell.propagate_selection', onSelectedExpressionChange);
                    selected.observe('selectedHiddenChild.propagate_selection', onSelectedExpressionChange);
                }
                lastSelectedModel = selected;
            }

            var selectedId = (selected) ? selected.id : undefined;

            if (selected && selected.isTable) {
                var selectedCell = selected.selectedCell;
                if (selectedCell) {
                    var selectedCol = selected.columns[selectedCell.column];
                    selectedId = selectedCol ? selectedCol.id : undefined;
                } else {
                    selectedId = undefined;
                }
            }

            if (selected && selected.isFolder) {
                var selectedChild = selected.selectedHiddenChild;
                if (selectedChild) {
                    selectedId = selectedChild.id;
                } else {
                    selectedId = undefined;
                }
            }

            var idChanged = (selectedId !== lastSelectedId);

            if (idChanged) {
                grapher.select(selectedId);
                var intersectIds = grapher.getOpenIntersectionIds();
                if (typeof selectedId !== "undefined") intersectIds[selectedId] = true;
                evaluator.setIntersectIds(intersectIds);
                // Causes a redraw that will update the grapher appearance.
                evaluator.updateIntersections(selectedId);
            }

            lastSelectedId = selectedId;
        };

        expressionsModel.observe('selectedItem', onSelectedExpressionChange);
    }

    return propagateSelection;
});
define('template!pillboxes', ['underscore'], function(_) {
    return function(obj) {
        var __p = '';
        var print = function() { __p += Array.prototype.join.call(arguments, '') };
        with(obj || {}) {
            __p += '<div class="dcg-pillbox-container">\n\n  <div class="dcg-settings-pillbox">\n    <span\n      class="dcg-tooltip-e dcg-action-settings"\n      tooltip="' +
                (t('Graph Settings')) +
                '"\n      tipsy-offset="5"\n    >\n      <i class="dcg-icon-wrench"></i>\n    </span>\n  </div>\n\n  <div class="dcg-zoom-more-options">\n      <div class="dcg-zoom-options-header dcg-action-moreoptions">\n        <span class="dcg-title">' +
                (t('zoom')) +
                '</span>\n        <i class="dcg-icon dcg-icon-zoom"></i>\n      </div>\n\n      <div class="dcg-zoom-options-menu-container">\n        <div class="dcg-zoom-options-menu">\n          <div class="dcg-option dcg-action-zoomin">\n            ' +
                (t('zoom in')) +
                '\n            <i class="dcg-icon dcg-icon-plus"></i>\n          </div>\n          <div class="dcg-option dcg-action-zoomout">\n            ' +
                (t('zoom out')) +
                '\n            <i class="dcg-icon dcg-icon-minus"></i>\n          </div>\n          <div class="dcg-option dcg-action-zoomsquare">\n            ' +
                (t('square')) +
                '\n            <i class="dcg-icon dcg-icon-square"></i>\n          </div>\n          <div class="dcg-option dcg-action-zoomrestore">\n            ' +
                (t('default')) +
                '\n            <i class="dcg-icon dcg-icon-home"></i>\n          </div>\n        </div>\n      </div>\n  </div>\n\n  <div class="dcg-graphpaper-branding">\n    </div>\n\n<div>';
        }
        return __p;
    };
});
define('loadcss!css/settings', function() {});
define('template!settings', ['underscore'], function(_) {
    return function(obj) {
        var __p = '';
        var print = function() { __p += Array.prototype.join.call(arguments, '') };
        with(obj || {}) {
            __p += '<div class="dcg-settings-container dcg-left dcg-popover dcg-constrained-height-popover">\n    <div class="dcg-popover-interior">\n      <div class="dcg-popover-fixedwidth">\n        <div class="dcg-popover-content">\n          <div class="dcg-modern-btn dcg-action-projectormode">' +
                (t('Projector Mode')) +
                '</div>\n        </div>\n\n        <div class="dcg-popover-content dcg-graph-settings">\n\n          <div class="dcg-section-title">\n            ' +
                (t('Graph Paper')) +
                '\n          </div>\n\n          <div class="dcg-grid-settings">\n            <div class="dcg-polargroup">\n              <div class="dcg-icon dcg-action-cartesian"></div>\n              <div class="dcg-icon dcg-action-polar"></div>\n              <div class="dcg-title">' +
                (t('Grid')) +
                '</div>\n            </div>\n\n            <span class="dcg-checkbox dcg-action-zoomsquare">\n              <span class="dcg-checkbox-box"><i class="dcg-icon-check"></i></span>\n              <span class="dcg-checkbox-label">' +
                (t('Square Grid')) +
                '</span>\n            </span>\n            <div style="clear:both"></div>\n          </div>\n\n          <div class="dcg-collapsable-options dcg-x-axis-options dcg-collapsed">\n            <div class="dcg-icon dcg-x-arrows dcg-display-icon"><i class="dcg-icon-hidden"></i></div>\n\n            <div class="dcg-title-container">\n              <div class="dcg-caret-container"><i class="dcg-icon-caret-down" ></i></div>\n              <div class="dcg-title">' +
                (t('X-Axis')) +
                '</div>\n            </div>\n            <input class="dcg-axis-label dcg-x-axis-label" placeholder="' +
                (t('add label')) +
                '" />\n\n            <div class="dcg-readonly-inputs">\n              <div class="dcg-readonly-mathquill-container">\n                <span class="dcg-readonly-xmin dcg-action-editinput"></span><span class="dcg-interval-interior">\\le x\\le </span><span class="dcg-readonly-xmax dcg-action-editinput"></span>\n              </div>\n              <div class="dcg-readonly-mathquill-container dcg-step-container">\n                <span class="dcg-step-label">' +
                (t('Step:')) +
                '</span>\n                <span class="dcg-readonly-xstep dcg-action-editinput"></span>\n              </div>\n              <div style="clear:both"></div>\n\n            </div>\n\n            <div class="dcg-editable-inputs">\n              <div class="dcg-editable-mathquill-container">\n                <span class="dcg-editable-xmin"></span>\n                <span class="dcg-interval-interior">\\le x\\le </span>\n                <span class="dcg-editable-xmax"></span>\n                <span class="dcg-step-container">\n                  <span class="dcg-step-label">' +
                (t('Step:')) +
                '</span>\n                  <span class="dcg-editable-xstep"></span>\n                </span>\n              </div>\n            </div>\n\n            <div class="dcg-more-options">\n              <span>\n                <div class="dcg-arrows-label">' +
                (t('Arrows:')) +
                '</div>\n                <div class="dcg-icon dcg-x-arrows" dcg-arrows="none"></div>\n                <div class="dcg-icon dcg-x-arrows" dcg-arrows="positive"></div>\n                <div class="dcg-icon dcg-x-arrows" dcg-arrows="both"></div>\n              </span>\n              <span class="dcg-checkbox dcg-action-xaxisnumbers">\n                <span class="dcg-checkbox-box"><i class="dcg-icon-check"></i></span>\n                <span class="dcg-checkbox-label">' +
                (t('Show Numbers')) +
                '</span>\n              </span>\n            </div>\n          </div>\n\n          <div class="dcg-collapsable-options dcg-y-axis-options dcg-collapsed">\n            <div class="dcg-icon dcg-y-arrows dcg-display-icon"><i class="dcg-icon-hidden"></i></div>\n\n            <div class="dcg-title-container">\n              <div class="dcg-caret-container"><i class="dcg-icon-caret-down" ></i></div>\n              <div class="dcg-title">' +
                (t('Y-Axis')) +
                '</div>\n            </div>\n            <input class="dcg-axis-label dcg-y-axis-label" placeholder="' +
                (t('add label')) +
                '" />\n\n            <div class="dcg-readonly-inputs">\n              <div class="dcg-readonly-mathquill-container">\n                <span class="dcg-readonly-ymin dcg-action-editinput"></span><span class="dcg-interval-interior">\\le y\\le </span><span class="dcg-readonly-ymax dcg-action-editinput"></span>\n              </div>\n              <div class="dcg-readonly-mathquill-container dcg-step-container">\n                <span class="dcg-step-label">' +
                (t('Step:')) +
                '</span>\n                <span class="dcg-readonly-ystep dcg-action-editinput"></span>\n              </div>\n              <div style="clear:both"></div>\n            </div>\n\n            <div class="dcg-editable-inputs">\n              <div class="dcg-editable-mathquill-container">\n                <span class="dcg-editable-ymin"></span>\n                <span class="dcg-interval-interior">\\le y\\le </span>\n                <span class="dcg-editable-ymax"></span>\n                <span class="dcg-step-container">\n                  <span class="dcg-step-label">' +
                (t('Step:')) +
                '</span>\n                  <span class="dcg-editable-ystep"></span>\n                </span>\n              </div>\n            </div>\n            \n            <div class="dcg-more-options">\n              <span>\n                <div class="dcg-arrows-label">' +
                (t('Arrows:')) +
                '</div>\n                <div class="dcg-icon dcg-y-arrows" dcg-arrows="none"></div>\n                <div class="dcg-icon dcg-y-arrows" dcg-arrows="positive"></div>\n                <div class="dcg-icon dcg-y-arrows" dcg-arrows="both"></div>\n              </span>\n              <span class="dcg-checkbox dcg-action-yaxisnumbers">\n                <span class="dcg-checkbox-box"><i class="dcg-icon-check"></i></span>\n                <span class="dcg-checkbox-label">' +
                (t('Show Numbers')) +
                '</span>\n              </span>\n            </div>\n          </div>\n\n          <div class="dcg-section-title">\n            ' +
                (t('Angles')) +
                '\n          </div>\n          <div class="dcg-radiangroup">\n            <div class="dcg-action-degreemode dcg-modern-btn">' +
                (t('Degrees')) +
                '</div>\n            <div class="dcg-action-radianmode dcg-modern-btn">' +
                (t('Radians')) +
                '</div>\n\n            <div class="dcg-polarnumbers-container">\n              <span class="dcg-checkbox dcg-action-polarnumbers">\n                <span class="dcg-checkbox-box"><i class="dcg-icon-check"></i></span>\n                <span class="dcg-checkbox-label">' +
                (t('Show Grid Angles')) +
                '</span>\n              </span>\n            </div>\n\n          </div>\n        </div>\n\n      </div>\n      <div class="dcg-arrow"></div>\n    </div>\n</div>';
        }
        return __p;
    };
});
define('main/settings_view', ['require', 'loadcss!css/settings', 'jquery', 'underscore', 'pjs', 'main/popover_view', 'graphing/viewport', 'conditional_blur', 'math/builtinframe', 'parser', 'math/parsenode/constant', 'keys', 'graphing/label', 'template!settings', 'vendor/jquery.html5-placeholder-shim', 'scroll_helpers'], function(require) {
    require('loadcss!css/settings');
    var $ = require('jquery');
    var _ = require('underscore');
    var P = require('pjs');
    var PopoverView = require('main/popover_view');
    var Viewport = require('graphing/viewport');
    var conditionalBlur = require('conditional_blur');
    var BuiltInFrame = require('math/builtinframe');
    var Parser = require('parser');
    var Constant = require('math/parsenode/constant');
    var Keys = require('keys');
    var Label = require('graphing/label');
    var template = require('template!settings');
    require('vendor/jquery.html5-placeholder-shim');
    var scrollHelpers = require('scroll_helpers');

    function formatLatex(num, scale) {
        var label = Label.value(num, scale);
        var latex = '';

        // scientific notation
        if (label.mantissa) {
            latex = label.mantissa.split('Ã—').join('\\cdot') + "^{" + label.superscript + "}";
        } else {
            // fraction
            var frac_parts = label.string.split("/");
            if (frac_parts.length === 2) {
                latex = '\\frac{' + frac_parts[0] + '}{' + frac_parts[1] + '}';
            } else {
                latex = label.string;
            }
        }
        return latex;
    }

    /*
     * view for the settings bar
     */
    var SettingsView = P(PopoverView, function(view, _super) {
        view.viewport = new Viewport();
        view.template = template;
        view.pointToSelector = '.dcg-action-settings i';

        view.init = function(grapher) {
            _super.init.call(this);
            this.grapher = grapher;
            this.settings = this.grapher.settings;
        };

        // don't do anything if we're inside the popover or if we're inside the openButton
        view.eventShouldClosePopover = function(evt) {
            if (this.eventIsWithinPopover(evt)) {
                return false;
            }
            if (this.isMathquillFocused() && $(evt.target).closest('.dcg-keypad').length) {
                return false;
            }
            return true;
        };

        view.renderIsVisible = function() {
            _super.renderIsVisible.call(this);
            if (this.isVisible && $.placeholder) {
                if ($.placeholder) $.placeholder.shim();
            }
        };

        view.setBottom = function(bottom) {
            this.$().css('bottom', bottom);
        };

        view.didCreateElement = function() {
            _super.didCreateElement.call(this);
            var self = this;

            // setup the readonly mathquills
            this.$readonly = {};
            this.$readonly.xmin = this.$('.dcg-readonly-xmin');
            this.$readonly.xmax = this.$('.dcg-readonly-xmax');
            this.$readonly.xstep = this.$('.dcg-readonly-xstep');
            this.$readonly.ymin = this.$('.dcg-readonly-ymin');
            this.$readonly.ymax = this.$('.dcg-readonly-ymax');
            this.$readonly.ystep = this.$('.dcg-readonly-ystep');
            _.each(this.$readonly, function($mathquill, prop) {
                $mathquill.mathquill()
                    .data('dcg-limit', prop);

                // TODO - revisit after new mathquill. For some reason the readonly mathquills
                // actively blur other mathquills on mousedown. We don't want that in this case.
                // see the comment on .dcg-readonly-inputs.tapstart below for more information.
                $mathquill.unbind('mousedown');
            });


            this.$('.dcg-interval-interior').each(function() {
                var html = $('<span>' + $(this).text() + '<span>').mathquill().mathquill('html');
                $(this).html(html).addClass('mathquill-rendered-math');
            });

            // setup the editable mathquills
            this.$editable = {};
            this.$editable.xmin = this.$('.dcg-editable-xmin');
            this.$editable.xmax = this.$('.dcg-editable-xmax');
            this.$editable.xstep = this.$('.dcg-editable-xstep');
            this.$editable.ymin = this.$('.dcg-editable-ymin');
            this.$editable.ymax = this.$('.dcg-editable-ymax');
            this.$editable.ystep = this.$('.dcg-editable-ystep');
            _.each(this.$editable, function($mathquill, prop) {
                $mathquill.mathquill('editable')
                    .data('dcg-limit', prop)
                    .addClass('dcg-math-input')
                    .on('focusin', self.focusInMathquill.bind(self))
                    .on('focusout', self.focusOutMathquill.bind(self))
                    .on('render', self.handleMathquillInput.bind(self))
                    .on('keydown', self.handleKeydown.bind(self))
                    .on('enterPressed', conditionalBlur);
            });

            this.$('.dcg-readonly-inputs').on('tapstart', function(evt) {
                // 1) make sure both the x-axis and y-axis options are collapsed.
                // 2) click in the readonly xmin mathquill. => The x-axis won't expand but the mathquills are editable
                // 3) mousedown in the readonly ymin mathquill.
                //
                // The browser wants to blur the xmin input. If that happens the x-axis inputs will go back
                // to readonly. That'll cause the layout to change. When you mouseup on the readonly ymin input, it may
                // no longer be under your mouse. That'd prevent the tap event from firing and making ymin editable.
                //
                // Solution:
                // preventDefault() on mousedown within this area.
                evt.preventDefault();
            });

            this.$('.dcg-readonly-mathquill-container').on('tap', function(evt) {
                var $container = $(this);
                var $target = $(evt.target);
                var $readonly_mathquill = $target.closest('.dcg-action-editinput');

                if (!$readonly_mathquill.length) {
                    $readonly_mathquill = $container.find('.dcg-action-editinput:first');
                }

                var limit = $readonly_mathquill.data('dcg-limit');
                var $editable_mathquill = self.$editable[limit];

                $editable_mathquill.mathquill('focus');
            });

            this.$('.dcg-action-polarnumbers').on('tap', function() {
                if ($(this).hasClass('dcg-disabled')) return;
                self.settings.setProperty('polarNumbers', !self.settings.polarNumbers);
            });
            this.$('.dcg-action-xaxisnumbers').on('tap', function() {
                if ($(this).hasClass('dcg-disabled')) return;
                self.settings.setProperty('xAxisNumbers', !self.settings.xAxisNumbers);
            });
            this.$('.dcg-action-yaxisnumbers').on('tap', function() {
                if ($(this).hasClass('dcg-disabled')) return;
                self.settings.setProperty('yAxisNumbers', !self.settings.yAxisNumbers);
            });
            this.$('.dcg-x-axis-label').on('change copy paste cut keypress keydown keyup', function() {
                self.settings.setProperty('xAxisLabel', $(this).val());
            });
            this.$('.dcg-y-axis-label').on('change copy paste cut keypress keydown keyup', function() {
                self.settings.setProperty('yAxisLabel', $(this).val());
            });

            this.$('.dcg-action-polar').on('tap', function() {
                if (self.settings.showGrid && self.settings.polarMode) {
                    //break out of polar here, so that we can set step sizes again
                    self.settings.setProperty('polarMode', false);
                    self.settings.setProperty('showGrid', false);
                } else {
                    self.settings.setProperty('showGrid', true);
                    self.settings.setProperty('polarMode', true);
                }
            });
            this.$('.dcg-action-cartesian').on('tap', function() {
                if (self.settings.showGrid && !self.settings.polarMode) {
                    self.settings.setProperty('showGrid', false);
                } else {
                    self.settings.setProperty('showGrid', true);
                    self.settings.setProperty('polarMode', false);
                }
            });

            this.$('.dcg-action-radianmode').on('tap', function() {
                self.settings.setProperty(
                    'degreeMode',
                    false
                );
            });
            this.$('.dcg-action-degreemode').on('tap', function() {
                self.settings.setProperty(
                    'degreeMode',
                    true
                );
            });
            this.$('.dcg-action-projectormode').on('tap', function() {
                self.settings.setProperty(
                    'projectorMode', !self.settings.projectorMode
                );
            });
            this.$('.dcg-x-arrows:not(.dcg-display-icon)').on('tap', function() {
                self.settings.setProperty('showXAxis', true);
                self.settings.setProperty('xAxisArrows', self.$(this).attr('dcg-arrows'));
            });
            this.$('.dcg-y-arrows:not(.dcg-display-icon)').on('tap', function() {
                self.settings.setProperty('showYAxis', true);
                self.settings.setProperty('yAxisArrows', self.$(this).attr('dcg-arrows'));
            });
            this.$('.dcg-x-axis-options .dcg-display-icon').on('tap', function() {
                self.settings.setProperty('showXAxis', !self.settings.showXAxis);
            });
            this.$('.dcg-y-axis-options .dcg-display-icon').on('tap', function() {
                self.settings.setProperty('showYAxis', !self.settings.showYAxis);
            });

            // collapses / expand options
            this.$('.dcg-collapsable-options').find('.dcg-caret-container, .dcg-title').on('tap', function(evt) {
                self.$(evt.target).closest('.dcg-collapsable-options').toggleClass('dcg-collapsed');
            });

            this.addSettingsObserver('projectorMode', this.renderProjectorMode);
            this.addSettingsObserver('xAxisArrows showXAxis', this.renderXArrows);
            this.addSettingsObserver('yAxisArrows showYAxis', this.renderYArrows);
            this.addSettingsObserver('polarNumbers showGrid polarMode', this.renderPolarNumbers);
            this.addSettingsObserver('xAxisNumbers showXAxis', this.renderXAxisNumbers);
            this.addSettingsObserver('yAxisNumbers showYAxis', this.renderYAxisNumbers);
            this.addSettingsObserver('xAxisLabel showXAxis', this.renderXAxisLabel);
            this.addSettingsObserver('yAxisLabel showYAxis', this.renderYAxisLabel);
            this.addSettingsObserver('computedStepSizes xAxisStep', this.renderXStep);
            this.addSettingsObserver('computedStepSizes yAxisStep', this.renderYStep);

            this.addSettingsObserver('degreeMode', this.renderDegreeMode);
            this.addSettingsObserver('squareAxes', this.renderSquareAxes);
            this.addSettingsObserver('showGrid polarMode', this.renderPolarMode);

            this.updateMathquillInputs();
        };

        view.handleKeydown = function(evt) {
            var key = Keys.lookup(evt);

            if (key === Keys.ESCAPE) conditionalBlur();
        };

        function evaluateMathquill($mathquill, useDegrees) {
            var latex = $mathquill.mathquill('latex');

            // TODO avoid duplicating logic for setting degree mode in frame
            var frame = Object.create(BuiltInFrame, {
                trigAngleMultiplier: Constant(useDegrees ? Math.PI / 180 : 1)
            });

            return +Parser.parse(latex).tryGetConcreteTree(frame).constantValue;
        }

        view.handleMathquillInput = function(evt) {
            var degreeMode = !!this.settings.degreeMode;
            var xmin = evaluateMathquill(this.$editable.xmin, degreeMode);
            var xmax = evaluateMathquill(this.$editable.xmax, degreeMode);
            var xstep;
            if (this.$editable.xstep.mathquill('latex') === '') {
                xstep = 0;
            } else {
                xstep = evaluateMathquill(this.$editable.xstep, degreeMode);
            }

            var ymin = evaluateMathquill(this.$editable.ymin, degreeMode);
            var ymax = evaluateMathquill(this.$editable.ymax, degreeMode);
            var ystep;
            if (this.$editable.ystep.mathquill('latex') === '') {
                ystep = 0;
            } else {
                ystep = evaluateMathquill(this.$editable.ystep, degreeMode);
            }

            var invalids = {};

            var isFiniteNumber = function(num) {
                return isFinite(num) && typeof num === 'number';
            };

            var tempViewport = new Viewport(xmin, xmax, ymin, ymax);

            if (isFiniteNumber(xmin) && isFiniteNumber(xmax)) {
                invalids.xmin = !tempViewport.isXValid();
                invalids.xmax = invalids.xmin;
            } else {
                invalids.xmin = !isFiniteNumber(xmin);
                invalids.xmax = !isFiniteNumber(xmax);
            }

            if (isFiniteNumber(ymin) && isFiniteNumber(ymax)) {
                invalids.ymin = !tempViewport.isYValid();
                invalids.ymax = invalids.ymin;
            } else {
                invalids.ymin = !isFiniteNumber(ymin);
                invalids.ymax = !isFiniteNumber(ymax);
            }

            if (isFiniteNumber(xstep)) {
                invalids.xstep = false;
                this.settings.setProperty('xAxisStep', xstep);
            } else {
                invalids.xstep = true;
            }

            if (isFiniteNumber(ystep)) {
                invalids.ystep = false;
                this.settings.setProperty('yAxisStep', ystep);
            } else {
                invalids.ystep = true;
            }

            this.setViewport(tempViewport);

            this.$editable.xmin.toggleClass("dcg-invalid", invalids.xmin);
            this.$editable.xmax.toggleClass("dcg-invalid", invalids.xmax);
            this.$editable.xstep.toggleClass("dcg-invalid", invalids.xstep);
            this.$editable.ymin.toggleClass("dcg-invalid", invalids.ymin);
            this.$editable.ymax.toggleClass("dcg-invalid", invalids.ymax);
            this.$editable.ystep.toggleClass("dcg-invalid", invalids.ystep);

            if (this.grapher && this.grapher.screen) {
                this.settings.setProperty(
                    'squareAxes',
                    tempViewport.isSquare(this.grapher.screen)
                );
            }
        };

        view.updateNeedsFakeKeypad = function() {
            this.setProperty('needsFakeKeypad', this.isMathquillFocused());
        };

        view.focusInMathquill = function(evt) {
            var input = this.$(evt.target).closest('.dcg-math-input');
            var collapsable = this.$(evt.target).closest('.dcg-collapsable-options');

            //focusin is triggered always, even when reclicking into a selected mathquill
            //we don't want to reselect in that case.
            if (input.hasClass('dcg-focus')) return;

            input.addClass('dcg-focus');
            input.triggerHandler('select_all');
            collapsable.addClass('dcg-input-focused');
            this.updateNeedsFakeKeypad();

            //make sure inputs visible, but put it in a 1 frame timeout so that the keypad has time to show
            var container = this.$('.dcg-popover-interior');
            setTimeout(function() {
                scrollHelpers.scrollVisible(input, container, 50);
            }, 0);
        };

        view.focusOutMathquill = function(evt) {
            var input = this.$(evt.target).closest('.mathquill-editable');
            var collapsable = this.$(evt.target).closest('.dcg-collapsable-options');

            input.removeClass('dcg-focus');
            input.mathquill('clearSelection');

            if (collapsable.find('.dcg-focus').length === 0) {
                collapsable.removeClass('dcg-input-focused');
            }

            // Disable reverting mathquills right after a focusout.
            // If the user pressed 'tab' then there will be a focusin
            // event next. If focus goes into an element in the
            // same row, then we should not update the mathquills.
            clearTimeout(this.focusedOutRecentlyTimeout);
            this.focusedOutRecently = true;
            this.focusedOutRecentlyTimeout = setTimeout(function() {
                this.focusedOutRecently = false;
                this.updateMathquillInputs();
            }.bind(this));

            this.updateNeedsFakeKeypad();
        };

        view.addSettingsObserver = function(prop, func) {
            var f = func.bind(this);
            this.settings.observe(prop, f);
            f();
        };

        view.renderProjectorMode = function() {
            var pmode = this.settings.projectorMode;
            this.$('.dcg-action-projectormode').toggleClass('dcg-active', !!pmode);
        };

        view.renderXArrows = function() {
            var arrows = this.settings.xAxisArrows;
            var showAxis = this.settings.showXAxis;

            this.$(".dcg-x-axis-options .dcg-display-icon").attr('dcg-arrows', arrows);
            this.$(".dcg-x-arrows").toggleClass('dcg-active', false);

            if (showAxis) {
                this.$(".dcg-x-arrows[dcg-arrows=" + arrows + "]").toggleClass('dcg-active', true);
            }
        };

        view.renderYArrows = function() {
            var arrows = this.settings.yAxisArrows;
            var showAxis = this.settings.showYAxis;

            this.$(".dcg-y-axis-options .dcg-display-icon").attr('dcg-arrows', arrows);
            this.$(".dcg-y-arrows").toggleClass('dcg-active', false);

            if (showAxis) {
                this.$(".dcg-y-arrows[dcg-arrows=" + arrows + "]").toggleClass('dcg-active', true);
            }
        };

        view.renderDegreeMode = function() {
            var degrees = this.settings.degreeMode;
            this.$(".dcg-action-radianmode").toggleClass('dcg-active', !degrees);
            this.$(".dcg-action-degreemode").toggleClass('dcg-active', !!degrees);
        };

        view.renderSquareAxes = function() {
            var square = this.settings.squareAxes;
            this.$(".dcg-action-zoomsquare")
                .toggleClass("dcg-disabled", !!square)
                .toggleClass("dcg-checked", !!square);
        };

        view.renderPolarNumbers = function() {
            var checked = this.settings.polarNumbers;
            var polarMode = this.settings.polarMode;
            var checkbox = this.$('.dcg-action-polarnumbers');

            checkbox.toggleClass('dcg-checked', checked);
            checkbox.toggle(polarMode); //only show the checkbox if we're in polarMode
        };

        view.renderXAxisNumbers = function() {
            var checked = this.settings.xAxisNumbers;
            var axisShown = this.settings.showXAxis;
            var checkbox = this.$('.dcg-action-xaxisnumbers');

            checkbox.toggleClass('dcg-checked', checked);
            checkbox.toggleClass('dcg-disabled', !axisShown);
        };

        view.renderYAxisNumbers = function() {
            var checked = this.settings.yAxisNumbers;
            var axisShown = this.settings.showYAxis;
            var checkbox = this.$('.dcg-action-yaxisnumbers');

            checkbox.toggleClass('dcg-checked', checked);
            checkbox.toggleClass('dcg-disabled', !axisShown);
        };

        view.renderXAxisLabel = function() {
            var input = this.$('.dcg-x-axis-label');
            var axisShown = this.settings.showXAxis;

            // prevent cursor from moving to end unexpectedly
            if (input.val() !== this.settings.xAxisLabel) {
                input.val(this.settings.xAxisLabel);
            }

            if (!axisShown) {
                input.attr('disabled', 'true');
            } else {
                input.removeAttr('disabled');
            }
        };
        view.renderYAxisLabel = function() {
            var input = this.$('.dcg-y-axis-label');
            var axisShown = this.settings.showYAxis;

            // prevent cursor from moving to end
            if (input.val() !== this.settings.yAxisLabel) {
                input.val(this.settings.yAxisLabel);
            }

            if (!axisShown) {
                input.attr('disabled', 'true');
            } else {
                input.removeAttr('disabled');
            }
        };

        view.renderXStep = function() {
            var userStep = this.settings.xAxisStep;
            var computedStep = this.settings.computedStepSizes && this.settings.computedStepSizes.majorStepX;
            var outOfBounds = !!(userStep && computedStep && userStep !== computedStep && userStep !== Math.PI);

            this.$editable.xstep.toggleClass('dcg-outofbounds', outOfBounds);
            this.$readonly.xstep.toggleClass('dcg-outofbounds', outOfBounds);
            this.updateMathquillInputs();
        };

        view.renderYStep = function() {
            var userStep = this.settings.yAxisStep;
            var computedStep = this.settings.computedStepSizes && this.settings.computedStepSizes.majorStepY;
            var outOfBounds = !!(userStep && computedStep && userStep !== computedStep && userStep !== Math.PI);

            this.$editable.ystep.toggleClass('dcg-outofbounds', outOfBounds);
            this.$readonly.ystep.toggleClass('dcg-outofbounds', outOfBounds);
            this.updateMathquillInputs();
        };

        view.renderPolarMode = function() {
            var showGrid = this.settings.showGrid;
            this.$('.dcg-action-cartesian').toggleClass('dcg-active', !this.settings.polarMode && showGrid);
            this.$('.dcg-action-polar').toggleClass('dcg-active', !!this.settings.polarMode && showGrid);

            // hide "steps" when in polar mode
            this.$('.dcg-step-container').toggle(!this.settings.polarMode);
        };

        // NOTE: because focusin happens before focusout, we temporarily have two
        // editable mathquills with .dcg-focus when switching between mathquills.
        view.isMathquillFocused = function() {
            return this.$('.mathquill-editable.dcg-focus').length > 0;
        };

        view.isXRangeFocused = function() {
            return this.$('.dcg-x-axis-options .dcg-editable-inputs .dcg-focus').length > 0;
        };

        view.isYRangeFocused = function() {
            return this.$('.dcg-y-axis-options .dcg-editable-inputs .dcg-focus').length > 0;
        };

        view.updateMathquillInputs = function() {
            if (this.focusedOutRecently) return;
            if (!this.$editable) return;

            function setLatexIfChanged($mathquill) {
                var limit = $mathquill.data('dcg-limit');
                var latex = limits[limit];
                if ($mathquill.mathquill('latex') !== latex) {
                    $mathquill.mathquill('latex', latex);
                }
            }

            var limits = {};
            var viewport = this.viewport;
            limits.xmin = formatLatex(viewport.xmin, viewport.xmax - viewport.xmin);
            limits.xmax = formatLatex(viewport.xmax, viewport.xmax - viewport.xmin);
            limits.ymin = formatLatex(viewport.ymin, viewport.ymax - viewport.ymin);
            limits.ymax = formatLatex(viewport.ymax, viewport.ymax - viewport.ymin);

            if (this.settings.xAxisStep) {
                limits.xstep = formatLatex(this.settings.xAxisStep, viewport.xmax - viewport.xmin);
            } else {
                limits.xstep = '';
            }

            if (this.settings.yAxisStep) {
                limits.ystep = formatLatex(this.settings.yAxisStep, viewport.ymax - viewport.ymin);
            } else {
                limits.ystep = '';
            }
            var unfocusedEditable = [];

            // only update x-mathquills if no x-mathquill is focused.
            // aids in range modification when passing through invalid
            // states.
            if (this.isXRangeFocused() === false) {
                unfocusedEditable.push(this.$editable.xmin);
                unfocusedEditable.push(this.$editable.xmax);
                unfocusedEditable.push(this.$editable.xstep);
            }

            // only update y-mathquills if no y-mathquill is focused.
            // aids in range modification when passing through invalid
            // states.
            if (this.isYRangeFocused() === false) {
                unfocusedEditable.push(this.$editable.ymin);
                unfocusedEditable.push(this.$editable.ymax);
                unfocusedEditable.push(this.$editable.ystep);
            }
            _.each(unfocusedEditable, setLatexIfChanged);

            var computedSteps = this.settings.computedStepSizes;
            if (limits.xstep === '' && computedSteps && computedSteps.majorStepX) {
                limits.xstep = formatLatex(computedSteps.majorStepX, viewport.xmax - viewport.xmin);
            }

            if (limits.ystep === '' && computedSteps && computedSteps.majorStepY) {
                limits.ystep = formatLatex(computedSteps.majorStepY, viewport.ymax - viewport.ymin);
            }

            _.each(this.$readonly, setLatexIfChanged);
        };

        view.setViewport = function(newViewport) {
            if (newViewport.equals(this.viewport)) return;
            if (!newViewport.isValid()) return;

            this.viewport = newViewport.clone();

            // set lastChangedAxis
            var oldViewport = this.grapher.viewportController.getViewport();
            if (oldViewport.ymax !== newViewport.ymax || oldViewport.ymin !== newViewport.ymin)
                this.settings.lastChangedAxis = 'y';
            if (oldViewport.xmax !== newViewport.xmax || oldViewport.xmin !== newViewport.xmin)
                this.settings.lastChangedAxis = 'x';

            this.updateMathquillInputs();
            this.grapher.viewportController.setViewport(newViewport);
        };

    });

    return SettingsView;
});

define('loadcss!css/pillboxes', function() {});
define('main/pillbox_view', ['require', 'jquery', 'pjs', 'underscore_view', 'template!pillboxes', 'main/settings_view', 'conditional_blur', 'tipsy', 'loadcss!css/pillboxes'], function(require) {
    var $ = require('jquery');
    var P = require('pjs');
    var UnderscoreView = require('underscore_view');
    var template = require('template!pillboxes');
    var SettingsView = require('main/settings_view');
    var conditionalBlur = require('conditional_blur');

    require('tipsy');

    require('loadcss!css/pillboxes');

    var ZoomView = P(UnderscoreView, function(view, _super) {
        view.init = function(viewportController) {
            _super.init.call(this);
            this.template = template;
            this.viewportController = viewportController;

            this.settingsView = SettingsView(viewportController.grapher);
            this.settingsView.headerView = this;

            // an easing function for the options menu animation. It does a little bounce.
            $.easing.dcg_open_options = function(t, msSince, startValue, endValue, totalDuration) {
                //we need a 5th order equation to ensure that we go through 1,1, and are flat at 0,0 and 1,1
                //(with 1 degree of freedom left for delight)
                var tPer = msSince / totalDuration;
                var a = 0.6;
                var b = 4;
                var c = -2 - 3 * a - 2 * b;
                var d = 1 - a - b - c;
                var valPercent = a * Math.pow(tPer, 5) + b * Math.pow(tPer, 4) + c * Math.pow(tPer, 3) + d * tPer * tPer;

                if (tPer === 1) {
                    valPercent = 1;
                }

                return valPercent;
            };
        };

        view.didCreateElement = function() {
            var self = this;

            view = this.settingsView;
            view.appendTo(this.$());

            this.settingsView.setupOpenButton(this.$('.dcg-action-settings'), 'tap');

            this.$('.dcg-action-zoomin').on('tap', this.zoomIn.bind(this));
            this.$('.dcg-action-zoomrestore').on('tap', this.zoomRestore.bind(this));
            this.$('.dcg-action-zoomout').on('tap', this.zoomOut.bind(this));
            this.$('.dcg-action-zoomsquare').on('tap', this.zoomSquare.bind(this));
            this.$('.dcg-action-moreoptions').on('tap', this.clickToggleOptions.bind(this));

            this.$().tipsy({
                fade: 'fast',
                title: 'tooltip',
                wait: 500,
                delegate: '.dcg-tooltip-e',
                gravity: 'e'
            });

            this.$more_options = this.$('.dcg-zoom-more-options');
            this.$more_options.on('tipsyshow tipsyhide', function(evt) {

                //don't open zoom btns on hover if the settings panel is open
                if (self.settingsView.isVisible) return;

                var hovered = self.$more_options.hasClass('dcg-hovered');
                if (self.animationInfo.isHovered !== hovered) {
                    self.animationInfo.isHovered = hovered;
                    self.hoverToggleOptions();
                }
            });

            this.viewportController.grapher.settings.observe('squareAxes', this.renderSquareAxes.bind(this));
            this.viewportController.grapher.settings.observe('zoomedDefault', this.renderZoomDefault.bind(this));
        };

        //each of the dropdowns (share_options, graph_settings, help)
        //queries this to find out how tall it should (max)
        //
        // graphpaperHeight is set externally by layout system
        view.popoverHeight = function() {
            return this.graphpaperHeight - 12; //10 px padding on top and 2px on the bottom
        };

        view.computeAnimationSize = function() {
            if (this.animationInfo.openHeight) return;

            var dropDownWidth = this.$more_options.find('.dcg-zoom-options-menu').outerWidth();
            var titleWidth = this.$more_options.find('.dcg-title').outerWidth();

            this.animationInfo.openWidth = Math.max(dropDownWidth, titleWidth);
            this.animationInfo.openHeight = this.$more_options.find('.dcg-zoom-options-menu').outerHeight();
            this.$().addClass('dcg-size-loaded');
        };

        view.didInsertElement = function() {
            this.animationInfo = {
                closedWidth: this.$more_options.outerWidth(),
                closedHeight: this.$more_options.outerHeight(),

                durationX: 200,
                durationY: 400,
                isOpen: false,
                isAnimating: false,

                wasClickedOpen: false,
                isHovered: false
            };

            this.renderSquareAxes();
            this.renderZoomDefault();
            this.computeAnimationSize();
        };

        view.renderSquareAxes = function() {
            var squareAxes = this.viewportController.grapher.settings.squareAxes;
            this.$('.dcg-zoom-options-menu .dcg-action-zoomsquare').toggleClass('dcg-disabled', squareAxes);
        };

        view.renderZoomDefault = function() {
            var isDefault = this.viewportController.grapher.settings.zoomedDefault;
            this.$('.dcg-action-zoomrestore').toggleClass('dcg-disabled', isDefault);
        };

        view.zoomIn = function() {
            this.viewportController.zoom("in");
        };

        view.zoomRestore = function() {
            this.viewportController.zoom("default");
        };

        view.zoomOut = function() {
            this.viewportController.zoom("out");
        };

        view.zoomSquare = function() {
            this.viewportController.grapher.settings.setProperty('squareAxes', true);
        };


        view.cancelAnimation = function() {
            this.$more_options.stop(true, false);
            this.isAnimating = false;

            $(document).off('tapstart.' + this.guid);
        };

        view.hoverToggleOptions = function() {
            if (this.animationInfo.wasClickedOpen) return;
            if (this.animationInfo.isHovered === this.animationInfo.isOpen) return;

            // stop the queued animations
            this.cancelAnimation();

            if (!this.animationInfo.isOpen) {
                this.openOptions();
            } else {
                this.closeOptions();
            }
        };

        view.clickToggleOptions = function() {
            //for touch devices
            conditionalBlur();

            // we've clicked the icon shortly after hovering and opening it. Act like we clicked it to open it.
            if (this.animationInfo.isOpen && this.animationInfo.isAnimating && !this.animationInfo.wasClickedOpen) {
                this.animationInfo.wasClickedOpen = true;
                return;
            }

            if (this.animationInfo.isAnimating) return;

            if (!this.animationInfo.isOpen) {
                this.animationInfo.wasClickedOpen = true;
                this.openOptions();
            } else if (this.animationInfo) {
                this.closeOptions();
            }
        };

        view.openOptions = function() {
            this.cancelAnimation();

            var $options = this.$more_options;
            var animationInfo = this.animationInfo;
            animationInfo.isOpen = true;
            animationInfo.isAnimating = true;

            var self = this;
            $(document).on('tapstart.' + this.guid, function(evt) {
                if ($options.find(evt.target).length === 0) {
                    self.closeOptions();
                }
            });

            //no op if we've already computed
            //try again, in case the element wasn't visible when we measured before
            this.computeAnimationSize();

            $options.animate({ width: animationInfo.openWidth }, animationInfo.durationX, function() {
                $options.addClass('dcg-full-width');
                $options.animate({ height: animationInfo.openHeight }, animationInfo.durationY, 'dcg_open_options', function() {
                    animationInfo.isAnimating = false;
                });
            });
        };

        view.closeOptions = function() {
            this.cancelAnimation();

            var $options = this.$more_options;
            var animationInfo = this.animationInfo;
            animationInfo.isOpen = false;
            animationInfo.isAnimating = true;

            $options.animate({ height: animationInfo.closedHeight }, animationInfo.durationY / 2, function() {
                $options.removeClass('dcg-full-width');

                $options.animate({ width: animationInfo.closedWidth }, animationInfo.durationX / 2, function() {
                    animationInfo.isAnimating = false;
                    animationInfo.wasClickedOpen = false;
                });
            });
        };

    });

    return ZoomView;
});


define('main/layout_controller', ['require', 'console', 'pjs', 'jquery'], function(require) {
    var console = require('console');
    var P = require('pjs');
    var $ = require('jquery');

    return P(function(proto) {

        proto.init = function(views, $root, graphSettings) {
            this.views = views;
            this.$root = $root;
            // stores the current screen size at all times
            this.currentScreen = {};

            this.isAnimating = false;
            this.minExpressionWidth = 290;

            this.$grapher = this.views.grapher.$;
            this.graphSettings = graphSettings;

            this.monitorWindowSize();
            // We call the monitorWindowSize() function every 200ms because the
            // window::onResize event just isn't reliable enough. In some browsers
            // (e.g. mobile safari) the event randomly gets dropped.
            if (graphSettings.config.resizeLoop) {
                var resizeLoop = function() {
                    this.monitorWindowSize();
                    setTimeout(resizeLoop, 200);
                }.bind(this);
                resizeLoop();
            }

            // We call the monitorWindowSize() function on window resize
            // this is triggered even for embedded calculator instances
            // it's a no-op if size hasn't changed
            $(window).resize(this.monitorWindowSize.bind(this));

            if (this.views.expressionsView) {
                this.views.expressionsView.observe('expressionsVisible', function() {
                    if (this.views.expressionsView.expressionsVisible) {
                        this.$root.removeClass('dcg-fullscreen');
                    } else {
                        this.$root.addClass('dcg-fullscreen');
                    }
                    this.resize();
                }.bind(this));
            }

            if (this.views.keypadView) this.views.keypadView.observe('isOpen', this.resize.bind(this));
        };

        proto.resize = function() {
            /* jshint maxcomplexity:12 */
            if (this.views.keypadView) {
                this.$root.toggleClass('dcg-keypad-open', !!this.views.keypadView.isOpen);
            }

            //isAnimating is set by animateSlidingInterior
            //when we either show or hide the expressions list
            if (this.isAnimating) return;

            var h = this.$grapher.height();
            var w = this.$root.width();
            var isFullscreen = (!this.views.expressionsView || !this.views.expressionsView.expressionsVisible);

            this.$root.toggleClass('dcg-narrow', this.isNarrow(w));
            this.$root.toggleClass('dcg-wide', this.isWide(w));
            this.$root.toggleClass('dcg-short', this.isShort(h));

            if (this.views.keypadView && this.views.keypadView.height) {
                var keypad_height = this.views.keypadView.height();
                this.views.expressionsView.setBottom(keypad_height);

                if (this.views.pillboxView && this.views.pillboxView.settingsView) {
                    this.views.pillboxView.settingsView.setBottom(keypad_height);
                }
            }

            if (this.views.expressionsView) this.views.expressionsView.setProperty('calcIsNarrow', this.isNarrow(w));

            var newWidth = this.isNarrow(w) ? w : w < 356 / 0.45 ? Math.floor(0.45 * w) : 356;
            if (newWidth < this.minExpressionWidth) newWidth = this.minExpressionWidth;
            //since our open/close animations use the half-width and we don't want odd numbers
            if (!this.isNarrow(w)) newWidth = 2 * Math.floor(0.5 * newWidth);

            if (this.views.expressionsView) this.views.expressionsView.setMinWidth(newWidth);

            if (this.views.pillboxView) this.views.pillboxView.setProperty('graphpaperHeight', h);
            if (this.views.keypadView) this.views.keypadView.setProperty('graphpaperHeight', h);

            //on narrow screens, ignore offset
            var leftOffset = (this.isNarrow(w) || isFullscreen) ? 0 : newWidth;

            this.views.grapher.$.css({
                'left': leftOffset + 'px',
                //get rid of any transform, in case this was called after doing an animation
                'transform': null
            });

            this.views.grapher.updateScreenSize(w - leftOffset, h);

            //make sure that active expression is scrolled into view
            if (this.views.expressionsView) this.views.expressionsView.ensureActiveChildIsVisible();
        };

        proto.animationIsRunning = function() {
            return this.runningAnimations !== 0;
        };

        proto.isNarrow = function(width) {
            return width < 450;
        };

        proto.isWide = function(width) {
            return width >= 900;
        };

        proto.isShort = function(height) {
            return height <= 480; //small iphone in portrait
        };

        proto.animateSlidingInterior = function() {
            if (this.isAnimating) return;
            this.isAnimating = true;

            setTimeout(function() {
                this.isAnimating = false;
                this.resize();
            }.bind(this), this.parseTransitionDuration('.dcg-sliding-interior'));
        };

        proto.parseTransitionDuration = function(target) {
            var $target = $(target);
            var durationString = $target.css('transition-duration');
            if (durationString[durationString.length - 1] !== 's') {
                console.warn(
                    'Unexpected transition-duration format. ' +
                    'Expected a number followed by \'s\' but saw ' + durationString
                );
                return 0;
            }

            return 1000 * parseFloat(durationString.slice(0, -1));
        };

        proto.defocusMobile = function() {
            var focused = $(document.activeElement);
            // Only want to do this when we have to, since it can cause some bouncing.
            if (focused.filter('input, textarea').length === 0) return;
            // hack to get jquery to remove focus from hidden input.
            // the following steps work for all tested mobile devices.
            //
            // step 1) add an input textbox to body and focus it.
            // step 2) make that textbox disabled and readonly.
            // step 3) blur the textbox and remove from the dom.
            $('<input />').prependTo('body').focus()
                .attr({
                    readonly: 'readonly',
                    disabled: 'true'
                })
                .blur().remove();
        };

        proto.monitorWindowSize = function() {
            // check if anything actually updated
            var w = this.$root.width() + this.$root.scrollLeft();
            var h = this.$root.height() + this.$root.scrollTop();

            if (w === this.currentScreen.width && h === this.currentScreen.height) return;

            this.currentScreen.width = w;
            this.currentScreen.height = h;

            this.resize();
        };
    });
});

// Defines a simple API used by our screenshot service.
define('lib/external_screenshot', ['require', 'pjs'], function(require) {
    var P = require('pjs');

    var Screenshot = P(function(proto) {
        proto.init = function($root, expressionsView, grapher, evaluator, stateController) {
            this.$root = $root;
            this.expressionsView = expressionsView;
            this.grapher = grapher;
            this.evaluator = evaluator;
            this.stateController = stateController;
        };

        proto.initialize = function(options, cb) {
            this.$root.addClass('dcg-external-screenshot');
            // Allow expression list to overflow for screenshoting.
            document.styleSheets[0].insertRule(
                '* {overflow: visible !important;}',
                document.styleSheets[0].cssRules.length
            );
            cb();
        };

        function getClipRect(elt) {
            var clientRect = elt.getBoundingClientRect();
            return {
                top: clientRect.top,
                left: clientRect.left,
                width: clientRect.width,
                height: clientRect.height
            };
        }

        function waitFor(pred, cb) {
            if (pred) {
                setTimeout(cb);
            } else {
                setTimeout(function() {
                    waitFor(pred, cb);
                }, 100);
            }
        }

        proto.load = function(obj, cb) {
            this.stateController.setState(obj.state);

            var self = this;
            this.evaluator.notifyWhenSynced(function() {
                waitFor(function() {
                    return !self.expressionsView || self.expressionsView.$('.dcg-shell.dcg-expressionitem').length === 0;
                }, function() {
                    // TODO, after jumping through all these hoops, still need an arbitrary timeout to wait
                    // for the expression icons to load. Ugh.
                    setTimeout(function() {
                        var boxes = {};
                        boxes.graphpaper = getClipRect(self.grapher.$[0]);
                        if (self.expressionsView) {
                            boxes.expressions = getClipRect(self.expressionsView.$('.dcg-expressionlist')[0]);
                        }
                        cb({ boxes: boxes });
                    }, 100);
                });
            });
        };
    });

    return Screenshot;
});

/*
 *  Modified (heavily) by Eli for the following reasons:
 *    - keep Trip out of the global namespace
 *    - work with our click events
 *    - pass jshint
 *    - get rid of unused methods
 *    - get rid of the other methods too
 *
 *  Trip.js - A jQuery plugin that can help you customize your tutorial trip easily
 *  Version : 1.2.2
 *
 *  Author : EragonJ <eragonj@eragonj.me>
 *  Blog : http://eragonj.me
 */

define('trip', ['require', 'jquery', 'pjs'], function(require) {
    var $ = require('jquery');
    var P = require('pjs');

    var Trip = P({

        init: function(settings) {
            this.settings = settings;
            this.__cachedStepName = null;
        },

        ensureTripBlock: function() {
            if (this.$tripBlock) return;

            var html = [
                '<div class="trip-block">',
                '<div class="trip-interior">',
                '<a class="trip-close">&times;</a>',
                '<div class="trip-content"></div>',
                '</div>',
                '<div class="trip-arrow"></div>',
                '</div>'
            ].join('');

            var that = this;
            var $tripBlock = this.$tripBlock = $(html);

            $tripBlock.css({ top: '-100px' });

            $('body').append($tripBlock);

            $tripBlock.find('.trip-close').on("tap", function(e) {
                e.preventDefault();
                that.stop();
            });

            this.bindKeyEvents();
        },

        cleanup: function() {
            this.unbindKeyEvents();

            this.hideTripBlock();
            return false;
        },

        bindKeyEvents: function() {
            var that = this;
            $(document).on({
                'keydown.Trip': function(e) {
                    // `this` will be bound to #document DOM element here
                    that.keyEvent.call(that, e);
                }
            });
        },

        unbindKeyEvents: function() {
            $(document).off('keydown.Trip');
        },

        keyEvent: function(e) {
            if (e.which === 27) this.stop(); //ESC key
        },

        stop: function() {
            this.hideTripBlock();
            this.settings.onTripStop();
            this.__cachedStepName = null;
        },

        showTripBlock: function(o) {
            this.ensureTripBlock();

            //soft update will, in general, change neither the contents nor the position
            //the contents can be force updated by setting o.forceTextUpdate=true
            var softUpdate = (o.stepName && o.stepName === this.__cachedStepName);
            this.__cachedStepName = o.stepName;

            if (typeof o.sel === 'string') {
                o.sel = $(o.sel);
            }
            o.sel = o.sel.filter(':visible');

            var $tripBlock = this.$tripBlock;

            if (!softUpdate || o.forceTextUpdate) {
                $tripBlock.find('.trip-content')
                    .html(o.content);
                var $math = $tripBlock.find('.trip-math:not(.mathquill-rendered-math)');
                if ($math.mathquill) {
                    $math.mathquill();
                }
            }

            //get out of here before repositioning
            if (softUpdate) return;

            $tripBlock.toggleClass('trip-hidden', !!o.hidden);

            var $sel = o.sel,
                selWidth = $sel.outerWidth(),
                selHeight = $sel.outerHeight(),
                blockWidth = $tripBlock.outerWidth(),
                blockHeight = $tripBlock.outerHeight(),
                arrowHeight = 10,
                arrowWidth = 10;

            // Take off e/s/w/n classes
            $tripBlock.removeClass('trip-e trip-s trip-w trip-n');

            var horizontalShift = 0;

            switch (o.position) {
                case 'e':
                    $tripBlock.addClass('trip-e');
                    $tripBlock.css({
                        left: $sel.offset().left + selWidth + arrowWidth,
                        top: $sel.offset().top - ((blockHeight - selHeight) / 2)
                    });
                    break;
                case 's':
                    $tripBlock.addClass('trip-s');
                    var left = $sel.offset().left + ((selWidth - blockWidth) / 2);
                    $tripBlock.css({
                        left: left,
                        top: $sel.offset().top + selHeight + arrowHeight
                    });

                    if (left + blockWidth > $(window).width() - 1) {
                        horizontalShift = $(window).width() - 1 - left - blockWidth;
                    }
                    if (left < 1) {
                        horizontalShift = 1 - left;
                    }

                    break;
                case 'w':
                    $tripBlock.addClass('trip-w');
                    $tripBlock.css({
                        left: $sel.offset().left - (arrowWidth + blockWidth),
                        top: $sel.offset().top - ((blockHeight - selHeight) / 2)
                    });
                    break;
                default:
                    $tripBlock.addClass('trip-n');
                    $tripBlock.css({
                        left: $sel.offset().left + ((selWidth - blockWidth) / 2),
                        top: $sel.offset().top - arrowHeight - blockHeight
                    });

                    break;
            }

            $tripBlock.find('.trip-interior')
                .css('transform', 'translate(' + horizontalShift + 'px, 0)');

            $tripBlock.css({
                display: 'inline-block'
            });
        },

        fadeInTripBlock: function() {
            this.ensureTripBlock();

            var $tripBlock = this.$tripBlock;
            //need this on the next cycle so that the animation works
            setTimeout(function() {
                $tripBlock.addClass('trip-is-loaded');
            }, 0);
        },

        hideTripBlock: function() {
            if (this.$tripBlock) this.$tripBlock.removeClass('trip-is-loaded');
        },
    });
    return Trip;
});

define('template!toast', ['underscore'], function(_) {
    return function(obj) {
        var __p = '';
        var print = function() { __p += Array.prototype.join.call(arguments, '') };
        with(obj || {}) {
            __p += '<div class="dcg-toast-container">\n  <span class="dcg-toast">\n    <i class="dcg-icon-error"></i>\n    <i class="dcg-icon-remove dcg-action-hide"></i>\n    <span class="dcg-msg dcg-variable-msg"></span>\n    <a class="dcg-undo dcg-action-toast-undo">' +
                (t('Undo')) +
                '</a>\n    <a class="dcg-learn-more-link" target="_blank">' +
                (t('Learn more')) +
                '</a>\n  </span>\n</div>';
        }
        return __p;
    };
});
define('loadcss!css/toast', function() {});
//generates a toast (little message near the top of the page)
// lets you do things like switch back into edit-list mode
define('main/toast', ['require', 'pjs', 'underscore_view', 'template!toast', 'loadcss!css/toast'], function(require) {

    var P = require('pjs');
    var UnderscoreView = require('underscore_view');
    var template = require('template!toast');
    require('loadcss!css/toast');

    var ToastView = P(UnderscoreView, function(toast, _super) {
        toast.template = template;

        toast.init = function(undoRedo) {
            _super.init.call(this);
            this.undoRedo = undoRedo;
        };

        toast.didCreateElement = function() {
            var self = this;

            // hide toast when UndoRedo
            self.undoRedo.changesCallbacks.push(function() {
                self.hide();
            });

            this.$('.dcg-action-toast-undo').on('tap', function() {
                self.undoRedo.undo();

                if (self.undoCallback) {
                    self.undoCallback();
                }
                self.hide();
            });

            this.$('.dcg-action-hide').on('tap', this.hide.bind(this));
            // start off hidden
            this.$().toggle(false);
        };

        // str: string in the toast message
        // options:
        //   undoCallback: a function that gets called if the "undo" button is pressed.
        //      Note: "undo" is only shown if this is present
        //   hideAfter: integer # of ms (never hide if set to 0)
        //   style: class that we'll add (error is the only option so far)
        //   learnMoreLink: a link that we'll show with the "learn more" text
        toast.show = function(str, options) {
            options = options || {};

            clearTimeout(this.hideTimeout);
            this.$('.dcg-toast-container').fadeOut('fast');
            this.$('.dcg-toast').toggleClass('dcg-show-undo', options.hasOwnProperty('undoCallback'));
            //note: because of how jquery works, this'll strip off the style attr if options.style is undefined
            this.$('.dcg-toast').attr('style', options.style || null);

            if (options.hasOwnProperty('learnMoreLink')) {
                this.$('.dcg-learn-more-link').attr('href', options.learnMoreLink).show();
            } else {
                this.$('.dcg-learn-more-link').hide();
            }

            this.$().fadeIn('fast');

            this.$('.dcg-variable-msg').text(str);
            this.undoCallback = options.undoCallback;

            // hide after (default) 6 seconds
            var hideAfter = (options.hasOwnProperty('hideAfter') ? options.hideAfter : 6000);

            if (hideAfter > 0) {
                var self = this;
                this.hideTimeout = setTimeout(function() {
                    self.hide();
                }, hideAfter);
            }
        };

        toast.hide = function() {
            clearTimeout(this.hideTimeout);
            this.$().fadeOut('fast');
        };
    });

    return ToastView;
});

define('undoredo', ['require', 'underscore', 'pjs'], function(require) {
    var _ = require('underscore');
    var P = require('pjs');

    var UndoRedoManager = P(function(manager, _super) {

        manager.CAUSE_OF_CHANGE = 1;
        manager.RESPONSE_TO_CHANGE = 2;

        manager.triggerFlash = function() {};

        manager.init = function() {
            this.undos = [];
            this.redos = [];
            this.changesCallbacks = [];
            this.__isApplyingTransaction = 0;
            this.batchedWrapper = function(cb) { cb() };
        };

        manager.clear = function() {
            this.undos = [];
            this.redos = [];
        };

        manager.pushUndo = function(transaction) {
            this.undos.push(transaction);
            this.triggerChanges();
        };

        manager.pushRedo = function(transaction) {
            this.redos.push(transaction);
            this.triggerChanges();
        };

        manager.canUndo = function() {
            return this.undos.length > 0;
        };

        manager.canRedo = function() {
            return this.redos.length > 0;
        };

        manager.undo = function() {
            if (!this.canUndo()) return;

            var action = this.undos.pop();
            this.applyTransaction(action, true);
            this.pushRedo(action);
        };

        manager.redo = function() {
            if (!this.canRedo()) return;

            var action = this.redos.pop();
            this.applyTransaction(action);
            this.pushUndo(action);
        };

        manager.isApplyingTransaction = function() {
            return !!this.__isApplyingTransaction;
        };

        manager.__applyTransaction = function(transaction, doUndo) {
            var i;
            var batched = transaction.__batched__ ? transaction.__batched__ : [];
            var self = this;

            if (doUndo) {

                if (batched.length) {
                    this.batchedWrapper(function() {
                        // apply batched transactions in reverse
                        for (i = batched.length - 1; i >= 0; i--) {
                            self.__applyTransaction(batched[i], doUndo);
                        }

                        transaction.undo();
                    });
                } else {
                    transaction.undo();
                }
            }

            // apply transactions the way they happened the first time
            else {
                if (batched.length) {
                    this.batchedWrapper(function() {
                        transaction.redo();
                        for (i = 0; i < batched.length; i++) {
                            self.__applyTransaction(batched[i], doUndo);
                        }
                    });
                } else {
                    transaction.redo();
                }
            }
        };

        manager.applyTransaction = function(transaction, doUndo) {
            this.__isApplyingTransaction++;

            try {
                this.__applyTransaction(transaction, doUndo);
            } finally {
                this.__isApplyingTransaction--;
            }
        };

        // sometimes, we want to just do multiple things, and we want them to all
        // be grouped into a single transaction. We want to just do stuff, and all
        // that stuff gets grouped together. It's important to note that oneTransaction
        // requires that all side effects happen synchronously.
        manager.oneTransaction = function(func) {
            if (!this.__oneTransactionDepth) {
                this.__oneTransactionDepth = 0;
            }

            this.__oneTransactionDepth++;
            this.batchedWrapper(func);
            this.__oneTransactionDepth--;

            if (!this.__oneTransactionDepth) {
                this.__oneTransaction = null;
            }
        };

        manager.isApplyingOneTransaction = function() {
            return this.__oneTransactionDepth > 0;
        };

        manager.addTransaction = function(transaction) {
            var batched;

            //don't accept changes that are sideffects of applying a transaction.
            //the transaction should've been written in such a way that chained
            //reactions are accounted for.
            if (this.isApplyingTransaction()) {

                // TODO - this exception looks pretty nasty and I'm worried that it's going
                // to change behavior in other places. I don't know why I originally didn't
                // allow addTransaction()'s within other addTransaction()'s. One thought
                // is that doing the first transaction automatically calls the other, so
                // the child transactions would end up getting called multiple times.
                //
                // we do play out the action if it's a CAUSE_OF_CHANGE. We just don't
                // add it to undo/redo.
                if (transaction.type === this.CAUSE_OF_CHANGE) {
                    transaction.redo();
                }

                return;
            }

            //automatically apply this if it's what's going to cause the initial
            //change.
            if (transaction.type === this.CAUSE_OF_CHANGE)
                this.applyTransaction(transaction);

            //if nothing really changed, then stop.
            if (transaction.ensureChangeOccured && transaction.ensureChangeOccured())
                return;

            // was this.redos.clear() in the Dark days. this.redos = [] would be
            // simpler, but has different semantics if someone else has a handle to
            // this array.
            this.redos.splice(0);

            if (this.isApplyingOneTransaction()) {
                if (!this.__oneTransaction) {
                    this.__oneTransaction = transaction;
                } else {
                    batched = this.__oneTransaction.__batched__;
                    if (!batched) batched = this.__oneTransaction.__batched__ = [];
                    batched.push(transaction);
                    return;
                }
            }

            this.pushUndo(transaction);
        };

        manager.triggerChanges = function() {
            _.each(this.changesCallbacks, function(cb) { cb() });
        };

    });


    return UndoRedoManager;
});

/*
 * The ipad has some quirky scrolling behavior. This module fixes them.
 * NOTE: this module is only for vertical scrolling. Horizontal page scroll
 *       can be turned off by an html setting. If we want, we can enable
 *       this module to monitor horizontal scrolling as well.
 *
 * On the ipad you can scroll an entire page by:
 *     a) Sliding your finger on a non scrollable object.
 *     b) Sliding your finger on a scrollable object in a direction
 *        that the scrollable object is already maxed out.
 *
 * You can preventDefault() the 'touchMove' event and that will prevent
 *  the ipad from scrolling the entire page. The only problem is that this
 *  also prevents any scrollable area from scrolling.
 *
 * The solution is to monitor the 'touchStart' event to predict what will
 *  happen when the user moves their finger. It predicts both movements up
 *  and down. If it predicts that the entire page will be scrolled, it
 *  makes that movement as invalid. If it predicts that a scrollable area
 *  will be scrolled, it makes the movement as valid.
 *
 * On 'touchMove', this module looks up the prediction for the direction the
 *  user moved. If the movement was valid, it lets the movement continue on
 *  and scroll the scrollable area. If the movement was invalid, it does a
 *  preventDefault() on the 'touchMove' event to prevent the entire page from
 *  scrolling.
 *
 * Also important to know is that once you grab a scrollable area and start
 *  scrolling, you're safe. The page won't scroll even if you max the
 *  scrollable area out and keep dragging in that direction.
 *
 * The prediction routine runs up the ancestors of the evt.target and finds
 * the first that:
 *
 *  1) has overflow and overflow-y properties that allow scrolling
 *                 AND
 *    2) has scrollTop != 0 (can be scrolled downward)
 *                          AND/OR
 *    3) has scrollTop that can be incremented (can be scrolled upward)
 */

// TODO - it seems very likely that someone will want to limit scrolling on multiple elements within the page.
// I haven't wrapped my brain aroudn that situation fully, but it seems likely that we'll want to namespace
// the '.scrollfix' events independently per element. Maybe we don't want to try to handle the case where mutliple
// touches are down on multiple elements. Maybe this still works when that happens. But, it isn't obvious to me that
// things will work since we're turning off all events with the '.scrollfix' namespace when a touchend event happens.
define('ipad.scrollfix', ['require', 'jquery'], function(require) {
    /* jshint bitwise: false */

    var $ = require('jquery');

    //some constants
    var NONE = 0;
    var UP = 1;
    var DOWN = 2;

    var limitingScrollOnDocument = false;
    var limitScrollOnDocument = function() {
        limitScrollOnElement(document);
        limitingScrollOnDocument = true;
    };

    //pass in a valid jQuery selector or element
    //this will limit scrolling that occurs inside of that element
    //preventing, for example, full page scrolling
    var limitScrollOnElement = function(el) {

        // if the entire page is being limited, don't apply
        // scrollfix behavior on this element. We aren't sure
        // how multiple listeners within the same dom area
        // will behave.
        //
        // NOTE: This early return requires that
        // the entire document be scrollfixed before any
        // specific elements are.
        if (limitingScrollOnDocument) return;

        //decides which directions an element can be scrolled
        $(el).bind('touchstart', function(evt) {
            /* jshint maxcomplexity:11 */
            var dom = $(evt.target);
            var validMoveDirections = NONE;
            var startTouches = null;

            // some elements (like the slider) can disable scrolling on tapStart.
            // if we're not automatically prevented from scrolling, then let's iterate
            // up the dom to find if we're inside an element that can be scrolled. If so,
            // we'll mark the scroll directions as valid.
            if (!dom.closest('[disablescroll]').length) {
                while (validMoveDirections === NONE && dom.length) {

                    //mobile safari throws error if you try to do normal
                    //.css() on the top most element
                    if (dom[0].tagName === undefined) {
                        break;
                    }

                    var overflow = dom.css('overflow');
                    var overflow_y = dom.css('overflow-y');

                    //check if overflow allows it to be scrolled
                    if (overflow !== "hidden" && overflow !== "visible" &&
                        overflow_y !== "hidden" && overflow_y !== "hidden") {

                        //can be scrolled downward if it isn't scrolled to the very top
                        var scrollTop = dom.scrollTop();
                        if (scrollTop !== 0) {
                            validMoveDirections = DOWN;
                        }

                        //can be scrolled upward if we try to scroll it upward and
                        //it succeeds
                        dom.scrollTop(scrollTop + 1);
                        if (dom.scrollTop() !== scrollTop) {

                            //mark up as a valid scroll
                            validMoveDirections = UP | validMoveDirections;

                            //move it back to where it was
                            dom.scrollTop(scrollTop);
                        }
                    }

                    dom = dom.parent();
                }
            }

            //if any scroll is valid, lets save the original touchStart event
            //so that we can compare it with the touchMove event later to decide
            //which direction the user scrolled.
            if (validMoveDirections !== NONE) {
                startTouches = [];

                //We must clone the original touchStart event instead of simply
                //saving a reference to it. For some reason, the original touchStart
                //event updates it's pageY, screenY, etc properties as you scroll.
                //That means that touchStart.screenY will always equal the
                //touchMove.screenY event when you compare them.
                var origTouches = evt.originalEvent.touches;
                for (var i = 0; i < origTouches.length; i++) {
                    var clonedTouch = {};
                    for (var j in origTouches[i]) {
                        if (origTouches[i].hasOwnProperty(j)) {
                            clonedTouch[j] = origTouches[i][j];
                        }
                    }
                    startTouches.push(clonedTouch);
                }
            }

            //decides if the the movement is in a valid direction.
            $(document).on('touchmove.scrollfix', function(evt) {

                //makes sure this is the first touchmove after touchstart
                if (startTouches) {

                    //get positions of the touch and move events
                    var startTouch = startTouches[0];
                    var moveTouch = evt.originalEvent.touches[0];

                    //find the direction we moved our finger
                    //var deltaX = moveTouch.screenX - startTouch.screenX;
                    var deltaY = moveTouch.screenY - startTouch.screenY;

                    //check if any of the movements weren't allowed
                    //and if not, say that NO move is allowed. Will
                    //get caught later at bottom of the function.
                    if (deltaY > 0 && !(validMoveDirections & DOWN)) {
                        validMoveDirections = NONE;
                    } else if (deltaY < 0 && !(validMoveDirections & UP)) {
                        validMoveDirections = NONE;
                    }

                    //first touchmove has been processed
                    if (deltaY) {
                        startTouches = null;
                    }
                }

                //don't scroll the entire screen
                if (validMoveDirections === NONE) {
                    evt.preventDefault();
                }
            });

            //resets the state
            $(document).on('touchend.scrollfix', function() {
                $(document).off('.scrollfix');
            });
        });

    };

    return {
        limitScrollOnElement: limitScrollOnElement,
        limitScrollOnDocument: limitScrollOnDocument
    };

});


/*
  Papa Parse
  v3.1.2
  https://github.com/mholt/PapaParse

  modified by @eluberoff to make it a valid require module, and remove all worker references
*/


define('vendor/papaparse', ['require', 'jquery'], function(require) {


    var $ = require('jquery');

    // A configuration object from which to draw default settings
    var DEFAULTS = {
        delimiter: "", // empty: auto-detect
        header: false,
        dynamicTyping: false,
        preview: 0,
        step: undefined,
        encoding: "", // browser should default to "UTF-8"
        comments: false,
        complete: undefined,
        error: undefined,
        download: false,
        chunk: undefined,
        keepEmptyRows: false
    };

    var Papa = {};

    Papa.parse = CsvToJson;
    Papa.unparse = JsonToCsv;

    Papa.RECORD_SEP = String.fromCharCode(30);
    Papa.UNIT_SEP = String.fromCharCode(31);
    Papa.BYTE_ORDER_MARK = "\ufeff";
    Papa.BAD_DELIMITERS = ["\r", "\n", "\"", Papa.BYTE_ORDER_MARK];

    // Configurable chunk sizes for local and remote files, respectively
    Papa.LocalChunkSize = 1024 * 1024 * 10; // 10 MB
    Papa.RemoteChunkSize = 1024 * 1024 * 5; // 5 MB
    Papa.DefaultDelimiter = ","; // Used if not specified and detection fails

    // Exposed for testing and development only
    Papa.Parser = Parser;
    Papa.ParserHandle = ParserHandle;
    Papa.NetworkStreamer = NetworkStreamer;
    Papa.FileStreamer = FileStreamer;

    if (true) {
        $.fn.parse = function(options) {
            var config = options.config || {};
            var queue = [];

            this.each(function(idx) {
                var supported = $(this).prop('tagName').toUpperCase() == "INPUT" &&
                    $(this).attr('type').toLowerCase() == "file" &&
                    window.FileReader;

                if (!supported || !this.files || this.files.length == 0)
                    return true; // continue to next input element

                for (var i = 0; i < this.files.length; i++) {
                    queue.push({
                        file: this.files[i],
                        inputElem: this,
                        instanceConfig: $.extend({}, config)
                    });
                }
            });

            parseNextFile(); // begin parsing
            return this; // maintains chainability


            function parseNextFile() {
                if (queue.length == 0)
                    return;

                var f = queue[0];

                if (isFunction(options.before)) {
                    var returned = options.before(f.file, f.inputElem);

                    if (typeof returned === 'object') {
                        if (returned.action == "abort") {
                            error("AbortError", f.file, f.inputElem, returned.reason);
                            return; // Aborts all queued files immediately
                        } else if (returned.action == "skip") {
                            fileComplete(); // parse the next file in the queue, if any
                            return;
                        } else if (typeof returned.config === 'object')
                            f.instanceConfig = $.extend(f.instanceConfig, returned.config);
                    } else if (returned == "skip") {
                        fileComplete(); // parse the next file in the queue, if any
                        return;
                    }
                }

                // Wrap up the user's complete callback, if any, so that ours also gets executed
                var userCompleteFunc = f.instanceConfig.complete;
                f.instanceConfig.complete = function(results) {
                    if (isFunction(userCompleteFunc))
                        userCompleteFunc(results, f.file, f.inputElem);
                    fileComplete();
                };

                Papa.parse(f.file, f.instanceConfig);
            }

            function error(name, file, elem, reason) {
                if (isFunction(options.error))
                    options.error({ name: name }, file, elem, reason);
            }

            function fileComplete() {
                queue.splice(0, 1);
                parseNextFile();
            }
        }
    }


    function CsvToJson(_input, _config) {
        var config = copyAndValidateConfig(_config);

        if (typeof _input === 'string') {
            if (config.download) {
                var streamer = new NetworkStreamer(config);
                streamer.stream(_input);
            } else {
                var ph = new ParserHandle(config);
                var results = ph.parse(_input);
                return results;
            }
        } else if (_input instanceof File) {
            if (config.step || config.chunk) {
                var streamer = new FileStreamer(config);
                streamer.stream(_input);
            } else {
                var ph = new ParserHandle(config);

                reader = new FileReader();
                reader.onload = function(event) {
                    var ph = new ParserHandle(config);
                    var results = ph.parse(event.target.result);
                };
                reader.onerror = function() {
                    if (isFunction(config.error))
                        config.error(reader.error, _input);
                };
                reader.readAsText(_input, config.encoding);
            }
        }
    }

    function JsonToCsv(_input, _config) {
        var _output = "";
        var _fields = [];

        // Default configuration
        var _quotes = false; // whether to surround every datum with quotes
        var _delimiter = ","; // delimiting character
        var _newline = "\r\n"; // newline character(s)

        unpackConfig();

        if (typeof _input === 'string')
            _input = JSON.parse(_input);

        if (_input instanceof Array) {
            if (!_input.length || _input[0] instanceof Array)
                return serialize(null, _input);
            else if (typeof _input[0] === 'object')
                return serialize(objectKeys(_input[0]), _input);
        } else if (typeof _input === 'object') {
            if (typeof _input.data === 'string')
                _input.data = JSON.parse(_input.data);

            if (_input.data instanceof Array) {
                if (!_input.fields)
                    _input.fields = _input.data[0] instanceof Array ?
                    _input.fields :
                    objectKeys(_input.data[0]);

                if (!(_input.data[0] instanceof Array) && typeof _input.data[0] !== 'object')
                    _input.data = [_input.data]; // handles input like [1,2,3] or ["asdf"]
            }

            return serialize(_input.fields || [], _input.data || []);
        }

        // Default (any valid paths should return before this)
        throw "exception: Unable to serialize unrecognized input";


        function unpackConfig() {
            if (typeof _config !== 'object')
                return;

            if (typeof _config.delimiter === 'string' &&
                _config.delimiter.length == 1 &&
                Papa.BAD_DELIMITERS.indexOf(_config.delimiter) == -1) {
                _delimiter = _config.delimiter;
            }

            if (typeof _config.quotes === 'boolean' ||
                _config.quotes instanceof Array)
                _quotes = _config.quotes;

            if (typeof _config.newline === 'string')
                _newline = _config.newline;
        }


        // Turns an object's keys into an array
        function objectKeys(obj) {
            if (typeof obj !== 'object')
                return [];
            var keys = [];
            for (var key in obj)
                keys.push(key);
            return keys;
        }

        // The double for loop that iterates the data and writes out a CSV string including header row
        function serialize(fields, data) {
            var csv = "";

            if (typeof fields === 'string')
                fields = JSON.parse(fields);
            if (typeof data === 'string')
                data = JSON.parse(data);

            var hasHeader = fields instanceof Array && fields.length > 0;
            var dataKeyedByField = !(data[0] instanceof Array);

            // If there a header row, write it first
            if (hasHeader) {
                for (var i = 0; i < fields.length; i++) {
                    if (i > 0)
                        csv += _delimiter;
                    csv += safe(fields[i], i);
                }
                if (data.length > 0)
                    csv += _newline;
            }

            // Then write out the data
            for (var row = 0; row < data.length; row++) {
                var maxCol = hasHeader ? fields.length : data[row].length;

                for (var col = 0; col < maxCol; col++) {
                    if (col > 0)
                        csv += _delimiter;
                    var colIdx = hasHeader && dataKeyedByField ? fields[col] : col;
                    csv += safe(data[row][colIdx], col);
                }

                if (row < data.length - 1)
                    csv += _newline;
            }

            return csv;
        }

        // Encloses a value around quotes if needed (makes a value safe for CSV insertion)
        function safe(str, col) {
            if (typeof str === "undefined" || str === null)
                return "";

            str = str.toString().replace(/"/g, '""');

            var needsQuotes = (typeof _quotes === 'boolean' && _quotes) ||
                (_quotes instanceof Array && _quotes[col]) ||
                hasAny(str, Papa.BAD_DELIMITERS) ||
                str.indexOf(_delimiter) > -1 ||
                str.charAt(0) == ' ' ||
                str.charAt(str.length - 1) == ' ';

            return needsQuotes ? '"' + str + '"' : str;
        }

        function hasAny(str, substrings) {
            for (var i = 0; i < substrings.length; i++)
                if (str.indexOf(substrings[i]) > -1)
                    return true;
            return false;
        }
    }



    // TODO: Many of the functions of NetworkStreamer and FileStreamer are similar or the same. Consolidate?
    function NetworkStreamer(config) {
        config = config || {};
        if (!config.chunkSize)
            config.chunkSize = Papa.RemoteChunkSize;

        var start = 0,
            fileSize = 0;
        var aggregate = "";
        var partialLine = "";
        var xhr, nextChunk;
        var handle = new ParserHandle(copy(config));

        this.stream = function(url) {
            nextChunk = function() {
                readChunk();
            };

            nextChunk(); // Starts streaming


            function readChunk() {
                xhr = new XMLHttpRequest();

                xhr.onload = chunkLoaded;
                xhr.onerror = chunkError;
                //last argument was !worker
                xhr.open("GET", url, true);
                if (config.step) {
                    var end = start + config.chunkSize - 1; // minus one because byte range is inclusive
                    if (fileSize && end > fileSize) // Hack around a Chrome bug: http://stackoverflow.com/q/24745095/1048862
                        end = fileSize;
                    xhr.setRequestHeader("Range", "bytes=" + start + "-" + end);
                }
                xhr.send();
                start += config.chunkSize;
            }

            function chunkLoaded() {
                if (xhr.readyState != 4)
                    return;

                if (xhr.status < 200 || xhr.status >= 400) {
                    chunkError();
                    return;
                }

                // Rejoin the line we likely just split in two by chunking the file
                aggregate += partialLine + xhr.responseText;
                partialLine = "";

                var finishedWithEntireFile = !config.step || start > getFileSize(xhr);

                if (!finishedWithEntireFile) {
                    var lastLineEnd = aggregate.lastIndexOf("\n");

                    if (lastLineEnd < 0)
                        lastLineEnd = aggregate.lastIndexOf("\r");

                    if (lastLineEnd > -1) {
                        partialLine = aggregate.substring(lastLineEnd + 1); // skip the line ending character
                        aggregate = aggregate.substring(0, lastLineEnd);
                    } else {
                        // For chunk sizes smaller than a line (a line could not fit in a single chunk)
                        // we simply build our aggregate by reading in the next chunk, until we find a newline
                        nextChunk();
                        return;
                    }
                }

                var results = handle.parse(aggregate);
                aggregate = "";

                if (isFunction(config.chunk)) {
                    config.chunk(results);
                    results = undefined;
                }

                if (!finishedWithEntireFile && !results.meta.paused)
                    nextChunk();
            }

            function chunkError() {
                if (isFunction(config.error))
                    config.error(xhr.statusText);
            }

            function getFileSize(xhr) {
                var contentRange = xhr.getResponseHeader("Content-Range");
                return parseInt(contentRange.substr(contentRange.lastIndexOf("/") + 1));
            }
        };
    }









    function FileStreamer(config) {
        config = config || {};
        if (!config.chunkSize)
            config.chunkSize = Papa.LocalChunkSize;

        var start = 0;
        var aggregate = "";
        var partialLine = "";
        var reader, nextChunk, slice;
        var handle = new ParserHandle(copy(config));

        // FileReader is better than FileReaderSync (even in worker) - see http://stackoverflow.com/q/24708649/1048862
        // But Firefox is a pill, too - see issue #76: https://github.com/mholt/PapaParse/issues/76
        var usingAsyncReader = typeof FileReader === 'function';

        this.stream = function(file) {
            var slice = file.slice || file.webkitSlice || file.mozSlice;

            if (usingAsyncReader) {
                reader = new FileReader(); // Preferred method of reading files, even in workers
                reader.onload = chunkLoaded;
                reader.onerror = chunkError;
            } else
                reader = new FileReaderSync(); // Hack for running in a web worker in Firefox

            nextChunk(); // Starts streaming

            function nextChunk() {
                if (start < file.size)
                    readChunk();
            }

            function readChunk() {
                var end = Math.min(start + config.chunkSize, file.size);
                var txt = reader.readAsText(slice.call(file, start, end), config.encoding);
                if (!usingAsyncReader)
                    chunkLoaded({ target: { result: txt } }); // mimic the async signature
            }

            function chunkLoaded(event) {
                // Very important to increment start each time before handling results
                start += config.chunkSize;

                // Rejoin the line we likely just split in two by chunking the file
                aggregate += partialLine + event.target.result;
                partialLine = "";

                var finishedWithEntireFile = start >= file.size;

                if (!finishedWithEntireFile) {
                    var lastLineEnd = aggregate.lastIndexOf("\n");

                    if (lastLineEnd < 0)
                        lastLineEnd = aggregate.lastIndexOf("\r");

                    if (lastLineEnd > -1) {
                        partialLine = aggregate.substring(lastLineEnd + 1); // skip the line ending character
                        aggregate = aggregate.substring(0, lastLineEnd);
                    } else {
                        // For chunk sizes smaller than a line (a line could not fit in a single chunk)
                        // we simply build our aggregate by reading in the next chunk, until we find a newline
                        nextChunk();
                        return;
                    }
                }

                var results = handle.parse(aggregate);
                aggregate = "";

                if (isFunction(config.chunk)) {
                    config.chunk(results, file);
                    results = undefined;
                }

                if (!finishedWithEntireFile && !results.meta.paused)
                    nextChunk();
            }

            function chunkError() {
                if (isFunction(config.error))
                    config.error(reader.error, file);
            }
        };
    }

    // Use one ParserHandle per entire CSV file or string
    function ParserHandle(_config) {
        // One goal is to minimize the use of regular expressions...
        var FLOAT = /^\s*-?(\d*\.?\d+|\d+\.?\d*)(e[-+]?\d+)?\s*$/i;

        var self = this;
        var _input; // The input being parsed
        var _parser; // The core parser being used
        var _paused = false; // Whether we are paused or not
        var _delimiterError; // Temporary state between delimiter detection and processing results
        var _fields = []; // Fields are from the header row of the input, if there is one
        var _results = { // The last results returned from the parser
            data: [],
            errors: [],
            meta: {}
        };
        _config = copy(_config);

        this.parse = function(input) {
            _delimiterError = false;
            if (!_config.delimiter) {
                var delimGuess = guessDelimiter(input);
                if (delimGuess.successful)
                    _config.delimiter = delimGuess.bestDelimiter;
                else {
                    _delimiterError = true; // add error after parsing (otherwise it would be overwritten)
                    _config.delimiter = Papa.DefaultDelimiter;
                }
                _results.meta.delimiter = _config.delimiter;
            }

            if (isFunction(_config.step)) {
                var userStep = _config.step;
                _config.step = function(results) {
                    _results = results;
                    if (needsHeaderRow())
                        processResults();
                    else
                        userStep(processResults(), self);
                };
            }

            if (_config.preview && _config.header)
                _config.preview++; // to compensate for header row

            _input = input;
            _parser = new Parser(_config);
            _results = _parser.parse(_input);
            processResults();
            if (isFunction(_config.complete) && !_paused)
                _config.complete(_results);
            return _paused ? { meta: { paused: true } } : _results;
        };

        this.pause = function() {
            _paused = true;
            _parser.abort();
            _input = _input.substr(_parser.getCharIndex());
        };

        this.resume = function() {
            _paused = false;
            _parser = new Parser(_config);
            _parser.parse(_input);
            if (isFunction(_config.complete) && !_paused)
                _config.complete(_results);
        };

        this.abort = function() {
            _parser.abort();
            if (isFunction(_config.complete))
                _config.complete(_results);
            _input = "";
        }

        function processResults() {
            if (_results && _delimiterError) {
                addError("Delimiter", "UndetectableDelimiter", "Unable to auto-detect delimiting character; defaulted to '" + Papa.DefaultDelimiter + "'");
                _delimiterError = false;
            }

            if (needsHeaderRow())
                fillHeaderFields();

            return applyHeaderAndDynamicTyping();
        }

        function needsHeaderRow() {
            return _config.header && _fields.length == 0;
        }

        function fillHeaderFields() {
            if (!_results)
                return;
            for (var i = 0; needsHeaderRow() && i < _results.data.length; i++)
                for (var j = 0; j < _results.data[i].length; j++)
                    _fields.push(_results.data[i][j]);
            _results.data.splice(0, 1);
        }

        function applyHeaderAndDynamicTyping() {
            if (!_results || (!_config.header && !_config.dynamicTyping))
                return _results;

            for (var i = 0; i < _results.data.length; i++) {
                var row = {};
                for (var j = 0; j < _results.data[i].length; j++) {
                    if (_config.dynamicTyping) {
                        var value = _results.data[i][j];
                        if (value == "true")
                            _results.data[i][j] = true;
                        else if (value == "false")
                            _results.data[i][j] = false;
                        else
                            _results.data[i][j] = tryParseFloat(value);
                    }

                    if (_config.header) {
                        if (j >= _fields.length) {
                            if (!row["__parsed_extra"])
                                row["__parsed_extra"] = [];
                            row["__parsed_extra"].push(_results.data[i][j]);
                        } else
                            row[_fields[j]] = _results.data[i][j];
                    }
                }

                if (_config.header) {
                    _results.data[i] = row;
                    if (j > _fields.length)
                        addError("FieldMismatch", "TooManyFields", "Too many fields: expected " + _fields.length + " fields but parsed " + j, i);
                    else if (j < _fields.length)
                        addError("FieldMismatch", "TooFewFields", "Too few fields: expected " + _fields.length + " fields but parsed " + j, i);
                }
            }

            if (_config.header && _results.meta)
                _results.meta.fields = _fields;

            return _results;
        }

        function guessDelimiter(input) {
            var delimChoices = [",", "\t", "|", ";", Papa.RECORD_SEP, Papa.UNIT_SEP];
            var bestDelim, bestDelta, fieldCountPrevRow;

            for (var i = 0; i < delimChoices.length; i++) {
                var delim = delimChoices[i];
                var delta = 0,
                    avgFieldCount = 0;
                fieldCountPrevRow = undefined;

                var preview = new Parser({
                    delimiter: delim,
                    preview: 10
                }).parse(input);

                for (var j = 0; j < preview.data.length; j++) {
                    var fieldCount = preview.data[j].length;
                    avgFieldCount += fieldCount;

                    if (typeof fieldCountPrevRow === 'undefined') {
                        fieldCountPrevRow = fieldCount;
                        continue;
                    } else if (fieldCount > 1) {
                        delta += Math.abs(fieldCount - fieldCountPrevRow);
                        fieldCountPrevRow = fieldCount;
                    }
                }

                avgFieldCount /= preview.data.length;

                if ((typeof bestDelta === 'undefined' || delta < bestDelta) &&
                    avgFieldCount > 1.99) {
                    bestDelta = delta;
                    bestDelim = delim;
                }
            }

            _config.delimiter = bestDelim;

            return {
                successful: !!bestDelim,
                bestDelimiter: bestDelim
            }
        }

        function tryParseFloat(val) {
            var isNumber = FLOAT.test(val);
            return isNumber ? parseFloat(val) : val;
        }

        function addError(type, code, msg, row) {
            _results.errors.push({
                type: type,
                code: code,
                message: msg,
                row: row
            });
        }
    }











    function Parser(config) {
        var EMPTY = /^\s*$/;

        var _input; // The input text being parsed
        var _delimiter; // The delimiting character
        var _comments; // Comment character (default '#') or boolean
        var _step; // The step (streaming) function
        var _callback; // The callback to invoke when finished
        var _preview; // Maximum number of lines (not rows) to parse
        var _ch; // Current character
        var _i; // Current character's positional index
        var _inQuotes; // Whether in quotes or not
        var _lineNum; // Current line number (1-based indexing)
        var _data; // Parsed data (results)
        var _errors; // Parse errors
        var _rowIdx; // Current row index within results (0-based)
        var _colIdx; // Current col index within result row (0-based)
        var _runningRowIdx; // Cumulative row index, used by the preview feature
        var _aborted = false; // Abort flag

        // Unpack the config object
        config = config || {};
        _delimiter = config.delimiter;
        _comments = config.comments;
        _step = config.step;
        _preview = config.preview;

        // Delimiter integrity check
        if (typeof _delimiter !== 'string' ||
            _delimiter.length != 1 ||
            Papa.BAD_DELIMITERS.indexOf(_delimiter) > -1)
            _delimiter = ",";

        // Comment character integrity check
        if (_comments === true)
            _comments = "#";
        else if (typeof _comments !== 'string' ||
            _comments.length != 1 ||
            Papa.BAD_DELIMITERS.indexOf(_comments) > -1 ||
            _comments == _delimiter)
            _comments = false;


        this.parse = function(input) {
            if (typeof input !== 'string')
                throw "Input must be a string";
            reset(input);
            return parserLoop();
        };

        this.abort = function() {
            _aborted = true;
        };

        this.getCharIndex = function() {
            return _i;
        };

        function parserLoop() {
            while (_i < _input.length) {
                if (_aborted) break;
                if (_preview > 0 && _runningRowIdx >= _preview) break;

                if (_ch == '"')
                    parseQuotes();
                else if (_inQuotes)
                    parseInQuotes();
                else
                    parseNotInQuotes();

                nextChar();
            }

            return finishParsing();
        }

        function nextChar() {
            _i++;
            _ch = _input[_i];
        }

        function finishParsing() {
            if (_aborted)
                addError("Abort", "ParseAbort", "Parsing was aborted by the user's step function");
            if (_inQuotes)
                addError("Quotes", "MissingQuotes", "Unescaped or mismatched quotes");
            endRow(); // End of input is also end of the last row
            if (!isFunction(_step))
                return returnable();
        }

        function parseQuotes() {
            if (quotesOnBoundary() && !quotesEscaped())
                _inQuotes = !_inQuotes;
            else {
                saveChar();
                if (_inQuotes && quotesEscaped())
                    _i++
                    else
                        addError("Quotes", "UnexpectedQuotes", "Unexpected quotes");
            }
        }

        function parseInQuotes() {
            if (twoCharLineBreak(_i) || oneCharLineBreak(_i))
                _lineNum++;
            saveChar();
        }

        function parseNotInQuotes() {
            if (_ch == _delimiter)
                newField();
            else if (twoCharLineBreak(_i)) {
                newRow();
                nextChar();
            } else if (oneCharLineBreak(_i))
                newRow();
            else if (isCommentStart())
                skipLine();
            else
                saveChar();
        }

        function isCommentStart() {
            if (!_comments)
                return false;

            var firstCharOfLine = _i == 0 ||
                oneCharLineBreak(_i - 1) ||
                twoCharLineBreak(_i - 2);
            return firstCharOfLine && _input[_i] === _comments;
        }

        function skipLine() {
            while (!twoCharLineBreak(_i) &&
                !oneCharLineBreak(_i) &&
                _i < _input.length) {
                nextChar();
            }
        }

        function saveChar() {
            _data[_rowIdx][_colIdx] += _ch;
        }

        function newField() {
            _data[_rowIdx].push("");
            _colIdx = _data[_rowIdx].length - 1;
        }

        function newRow() {
            endRow();

            _lineNum++;
            _runningRowIdx++;
            _data.push([]);
            _rowIdx = _data.length - 1;
            newField();
        }

        function endRow() {
            trimEmptyLastRow();
            if (isFunction(_step)) {
                if (_data[_rowIdx])
                    _step(returnable());
                clearErrorsAndData();
            }
        }

        function trimEmptyLastRow() {
            if (_data[_rowIdx].length == 1 && EMPTY.test(_data[_rowIdx][0])) {
                if (config.keepEmptyRows)
                    _data[_rowIdx].splice(0, 1); // leave row, but no fields
                else
                    _data.splice(_rowIdx, 1); // cut out row entirely
                _rowIdx = _data.length - 1;
            }
        }

        function twoCharLineBreak(i) {
            return i < _input.length - 1 &&
                ((_input[i] == "\r" && _input[i + 1] == "\n") ||
                    (_input[i] == "\n" && _input[i + 1] == "\r"))
        }

        function oneCharLineBreak(i) {
            return _input[i] == "\r" || _input[i] == "\n";
        }

        function quotesEscaped() {
            // Quotes as data cannot be on boundary, for example: ,"", are not escaped quotes
            return !quotesOnBoundary() && _i < _input.length - 1 && _input[_i + 1] == '"';
        }

        function quotesOnBoundary() {
            return (!_inQuotes && isBoundary(_i - 1)) || isBoundary(_i + 1);
        }

        function isBoundary(i) {
            if (typeof i != 'number')
                i = _i;

            var ch = _input[i];

            return (i <= -1 || i >= _input.length) ||
                (ch == _delimiter ||
                    ch == "\r" ||
                    ch == "\n");
        }

        function addError(type, code, msg) {
            _errors.push({
                type: type,
                code: code,
                message: msg,
                line: _lineNum,
                row: _rowIdx,
                index: _i
            });
        }

        function reset(input) {
            _input = input;
            _inQuotes = false;
            _i = 0, _runningRowIdx = 0, _lineNum = 1;
            clearErrorsAndData();
            _data = [
                [""]
            ]; // starting parsing requires an empty field
            _ch = _input[_i];
        }

        function clearErrorsAndData() {
            _data = [];
            _errors = [];
            _rowIdx = 0;
            _colIdx = 0;
        }

        function returnable() {
            return {
                data: _data,
                errors: _errors,
                meta: {
                    lines: _lineNum,
                    delimiter: _delimiter,
                    aborted: _aborted,
                    truncated: _preview > 0 && _i < _input.length
                }
            };
        }
    }

    // Replaces bad config values with good, default ones
    function copyAndValidateConfig(origConfig) {
        if (typeof origConfig !== 'object')
            origConfig = {};

        var config = copy(origConfig);

        if (typeof config.delimiter !== 'string' ||
            config.delimiter.length != 1 ||
            Papa.BAD_DELIMITERS.indexOf(config.delimiter) > -1)
            config.delimiter = DEFAULTS.delimiter;

        if (typeof config.header !== 'boolean')
            config.header = DEFAULTS.header;

        if (typeof config.dynamicTyping !== 'boolean')
            config.dynamicTyping = DEFAULTS.dynamicTyping;

        if (typeof config.preview !== 'number')
            config.preview = DEFAULTS.preview;

        if (typeof config.step !== 'function')
            config.step = DEFAULTS.step;

        if (typeof config.complete !== 'function')
            config.complete = DEFAULTS.complete;

        if (typeof config.error !== 'function')
            config.error = DEFAULTS.error;

        if (typeof config.encoding !== 'string')
            config.encoding = DEFAULTS.encoding;

        if (typeof config.download !== 'boolean')
            config.download = DEFAULTS.download;

        if (typeof config.keepEmptyRows !== 'boolean')
            config.keepEmptyRows = DEFAULTS.keepEmptyRows;

        return config;
    }

    function copy(obj) {
        if (typeof obj !== 'object')
            return obj;
        var cpy = obj instanceof Array ? [] : {};
        for (var key in obj)
            cpy[key] = copy(obj[key]);
        return cpy;
    }

    function isFunction(func) {
        return typeof func === 'function';
    }


    return Papa;
});

define('main/data_helpers', ['require', 'vendor/papaparse', 'underscore', 'i18n'], function(require) {
    var PapaParse = require('vendor/papaparse');
    var _ = require('underscore');
    var i18n = require('i18n');

    var parse = function(unparsedData) {
        var res = PapaParse.parse(unparsedData, { preview: 50 });
        var parsedData = [],
            val, i, j;

        if (res && res.data && res.data.length) {
            for (j = 0; j < 2; j++) {
                parsedData.push([]);
            }

            for (i = 0; i < res.data.length; i++) {
                if (i === 0 && !parseFloat(res.data[i][0])) continue;
                if (res.data[i].length < 2) return null;

                //skip over empty lines
                if (!res.data[i][0] && !res.data[i][1]) continue;

                for (j = 0; j < 2; j++) {
                    val = res.data[i][j].replace(/,/g, '');
                    if (val && isNaN(parseFloat(val))) return {
                        error: i18n.t(
                            "Error: Row __rowNum__, Column __colNum__ isn't a number.", { rowNum: i + 1, colNum: j + 1 }
                        )
                    };
                    parsedData[j].push(val);
                }
            }
            if (parsedData[0].length < 3) return null;
        }
        return { data: parsedData };
    };

    //goal of this fn: ensure that all data is visible in the new viewport with reasonable
    //padding (at least 10%, not more than 20%)
    //make sure the origin, likewise, is visible with padding
    //only update currentMin and/or currentMax if that's necessary
    var _findNewRange = function(rawData, currentMin, currentMax) {
        //add zero in so that the origin remains visible
        var data = _.map(rawData, function(datum) { return parseFloat(datum) });
        data = _.filter(data, function(datum) { return isFinite(datum) });
        data.push(0);

        var max = _.max(data);
        var min = _.min(data);

        var estimatedRange = Math.max(max, currentMax) - Math.min(min, currentMin);

        var recommendedMax = currentMax,
            recommendedMin = currentMin;
        //override the new max is too tight (has less than 10% buffer)
        if ((max + 0.1 * estimatedRange) > currentMax) {
            recommendedMax = max + 0.2 * estimatedRange; //give us a 20% buffer
        }
        if ((min - 0.1 * estimatedRange) < currentMin) {
            recommendedMin = min - 0.2 * estimatedRange;
        }

        return [recommendedMin, recommendedMax];
    };

    //chooses a new viewport that ensures that all data is visible with at last 20% padding
    //for now, we only consider the first two columns (because those are the only ones that get imported)
    var computeNewViewport = function(viewport, data) {
        var recommendedX = _findNewRange(data[0], viewport.xmin, viewport.xmax);
        var recommendedY = _findNewRange(data[1], viewport.ymin, viewport.ymax);

        return {
            xmin: recommendedX[0],
            xmax: recommendedX[1],
            ymin: recommendedY[0],
            ymax: recommendedY[1]
        };
    };

    return {
        parse: parse,
        computeNewViewport: computeNewViewport
    };
});

define('main/calc_embed', ['require', 'console', 'jquery', 'pjs', 'main/evaluator', 'graphing/grapher', 'main/graph_settings', 'graphing/viewport', 'expressions/list', 'expressions/list_view', 'main/keypad_view', 'main/state_controller', 'main/propagate_selection', 'i18n', 'main/pillbox_view', 'main/layout_controller', 'lib/external_screenshot', 'main/toast', 'undoredo', 'ipad.scrollfix', 'main/data_helpers'], function(require) {
    var console = require('console');
    var $ = require('jquery');
    var P = require('pjs');
    var Evaluator = require('main/evaluator');
    var Grapher = require('graphing/grapher');
    var GraphSettings = require('main/graph_settings');
    var Viewport = require('graphing/viewport');
    var ExpressionList = require('expressions/list');
    var ExpressionListView = require('expressions/list_view');
    var KeypadView = require('main/keypad_view');
    var StateController = require('main/state_controller');
    var propagateSelection = require('main/propagate_selection');
    //To do: render something for unsupported browsers here
    //var Browser = require('browser');

    var i18n = require('i18n');

    var PillboxView = require('main/pillbox_view');
    var LayoutController = require('main/layout_controller');
    var Screenshot = require('lib/external_screenshot');
    var ToastView = require('main/toast');
    var UndoRedo = require('undoredo');

    var ScrollFix = require('ipad.scrollfix');
    var DataHelpers = require('main/data_helpers');

    var Calc = P(function(proto) {
        proto.init = function(elt, workerPool, config) {
            /* jshint maxcomplexity:20 */

            var graphSettings = GraphSettings();
            //populate graphSettings config
            for (var key in config) {
                graphSettings.config.setProperty(key, config[key]);
            }

            //disable onscreen keypad, iff:
            // * the expression list is enabled (otherwise doesn't matter)
            // * the keypad is enabled (otherwise, it's a feature to have an onscreen)
            // * the user hasn't set nativeOnscreenKeypad to true
            //
            //note: this is undoable -- if you invoke for one calculator, it'll be
            //true for all subsequent ones. Ideally, new mathquill will allow us to
            //set this kind of thing on a mathquill-by-mathquill basis
            if (
                graphSettings.config.keypad &&
                graphSettings.config.expressions &&
                !graphSettings.config.nativeOnscreenKeypad
            ) {
                window.overrideNativeOnscreenKeypad = true;
            }

            var containerClasses = ['dcg-container', 'dcg-tap-container'];
            if (!graphSettings.config.settingsMenu) containerClasses.push('dcg-no-settings-menu');
            if (!graphSettings.config.expressionsTopbar) containerClasses.push('dcg-no-expression-topbar');
            if (!graphSettings.config.zoomButtons) containerClasses.push('dcg-no-zoom');
            if (!graphSettings.config.branding) containerClasses.push('dcg-no-branding');
            if (graphSettings.config.border) containerClasses.push('dcg-default-border');
            var $embedContainer = $('<div class="' + containerClasses.join(' ') + '">');
            var $graphpaper = $('<div class="dcg-grapher">');

            ScrollFix.limitScrollOnElement($embedContainer);

            var undoRedo = UndoRedo();

            // make sure that anything that is batched within undo/redo is also batched in the evaluator
            undoRedo.batchedWrapper = function(cb) {
                evaluator.batch(cb);
            };

            var toastView = ToastView(undoRedo);
            var evaluator = Evaluator(workerPool);
            var keypadView;
            var expressionsModel = ExpressionList(undoRedo);
            var expressionsView;

            if (!graphSettings.config.expressions || graphSettings.config.expressionsCollapsed) {
                $embedContainer.addClass('dcg-fullscreen');
            }

            if (graphSettings.config.expressions) {
                expressionsView = ExpressionListView(expressionsModel, $embedContainer, toastView, graphSettings);
            }

            $graphpaper.appendTo($embedContainer);
            toastView.appendTo($embedContainer);

            // TODO - what happens when we want a keypad but not the expressionsView? Is that
            // a valid usecase, or is this catch fine?
            if (graphSettings.config.keypad && expressionsView) {
                keypadView = KeypadView();
                keypadView.appendTo($embedContainer);
            }
            if (!graphSettings.config.graphpaper) {
                $embedContainer.addClass('dcg-no-graphpaper');
            }
            $embedContainer.appendTo(elt);
            var grapher = new Grapher($graphpaper, graphSettings, $embedContainer);

            graphSettings.registerCallbacks(grapher, expressionsView, $embedContainer);

            graphSettings.observe('degreeMode', function() {
                evaluator.setDegreeMode(graphSettings.degreeMode);
            });

            var pillboxView = PillboxView(grapher.viewportController);
            pillboxView.appendTo($embedContainer);

            var stateController = StateController(
                grapher,
                expressionsModel,
                graphSettings,
                evaluator
            );

            this.Screenshot = Screenshot($embedContainer, expressionsView, grapher, evaluator, stateController);

            if (!graphSettings.config.redrawSlowly) {
                grapher.redrawSlowly = grapher.redrawAllLayers;
            }

            var onChangeCallbacks = [];
            var notifyChange = function() {
                for (var i = 0; i < onChangeCallbacks.length; i++) {
                    onChangeCallbacks[i]();
                }
            };
            var addChangeCallback = function(cb) {
                onChangeCallbacks.push(cb);
            };

            undoRedo.changesCallbacks.push(notifyChange);
            graphSettings.stateProperties.forEach(function(prop) {
                graphSettings.observe(prop, notifyChange);
            });

            grapher.viewportController.triggerViewportStable = function() {
                if (!grapher.screen) return;
                var projection = grapher.createProjection();
                evaluator.setViewState({
                    viewport: projection.viewport.toObject(),
                    screen: projection.screen
                });

                // if we've set it back to square, keep it square on changes
                if (grapher.viewport.isSquare(grapher.screen)) {
                    grapher.settings.setProperty('squareAxes', true);
                }

                grapher.settings.setProperty('zoomedDefault', grapher.viewportController.isZoomRestored());
                pillboxView.settingsView.setViewport(grapher.viewportController.getViewport());

                notifyChange();
            };

            evaluator.triggerStatusChange = function(changes) {
                expressionsModel.onChange(changes);
            };
            evaluator.triggerGraphComputed = function(id, graphData) {
                grapher.updateSketch(id, graphData);
                expressionsModel.onGraphComputed(id, graphData);
            };

            evaluator.triggerRemove = function(id) { grapher.hide(id); };

            evaluator.triggerUpdateIntersections = function(id, intersections) {
                grapher.updateIntersections(id, intersections);
                grapher.redrawPOILayer();
            };

            evaluator.triggerRender = function() {
                grapher.poiController.handleTraceUpdate(); //Needed for updating trace with animation
                grapher.redrawContentLayers();
            };
            evaluator.triggerRenderSlowly = function() { grapher.redrawSlowly(); };

            expressionsModel.triggerAddExp = function(obj) {
                if (!obj) return;
                // if we've completely erased the contents of this expression, then
                // we need to act like it's a new expression. We remove the old sketch
                // so that we don't remember POI information.
                if (obj.latex === '' && this.type !== 'table') {
                    grapher.removeGraphSketch(obj.id);
                }

                evaluator.addStatement(obj);
            };

            expressionsModel.triggerRemoveExp = function(id) {
                evaluator.removeStatement(id);
            };
            expressionsModel.triggerRemoveExps = function(ids) {
                evaluator.removeStatements(ids);
            };

            expressionsModel.observe('drawOrder', function() {
                grapher.setSketchOrder(expressionsModel.getProperty('drawOrder'));
            });

            expressionsModel.batchEvaluation = evaluator.batch.bind(evaluator);

            if (expressionsView) {
                expressionsView.triggerClearGraph = function() {
                    stateController.setBlank();
                    expressionsModel.setSelected(0);
                    expressionsView.getSelectedView().addFocus();
                };
            }

            expressionsModel.triggerAddImage = function(image) {
                // add the image only when it's loaded
                if (image.imageObj.width && image.imageObj.height) {
                    grapher.addGraphImage(image);
                    grapher.redrawImageLayer();
                } else {
                    $(image.imageObj).on('load.calc_load', function() {
                        grapher.addGraphImage(image);
                        grapher.redrawImageLayer();
                    });
                }
            };
            expressionsModel.triggerRemoveImage = function(image) {
                $(image.imageObj).off('load.calc_load');
                grapher.removeGraphImage(image.id);
                grapher.redrawImageLayer();
            };
            expressionsModel.triggerRedrawImages = function() {
                grapher.redrawImageLayer();
            };

            propagateSelection(expressionsModel, grapher, evaluator);

            if (keypadView && expressionsView) {
                keypadView.registerEditableView(expressionsView);
            }

            if (keypadView && pillboxView && pillboxView.settingsView) {
                keypadView.registerEditableView(pillboxView.settingsView);
            }

            var layoutController = LayoutController({
                    expressionsView: expressionsView,
                    keypadView: keypadView,
                    pillboxView: pillboxView,
                    grapher: grapher
                },
                $embedContainer,
                graphSettings
            );

            grapher.poiController.triggerStartMovingPoint = function(id) {
                expressionsModel.onStartMovingPoint(id);
            };

            grapher.poiController.triggerMovePoint = function(id, screen_pt, projection) {
                expressionsModel.onMovePoint(id, screen_pt, projection);
            };

            grapher.poiController.triggerStopMovingPoint = function(id) {
                expressionsModel.onStopMovingPoint(id);
            };

            grapher.poiController.triggerSelectExpression = function(id) {
                expressionsModel.setSelected(expressionsModel.getItemById(id));
            };

            if (expressionsView) {
                expressionsView.appendTo($embedContainer);
            }

            //blur if there's a click outside of our container.
            //note: has a special catch for if you click on dcg-shell, because as part of our handlers
            //for clicking on that, we remove the dcg-shell from the DOM
            $(window).on('tapstart', function(evt) {
                var $target = $(evt.target);
                if (!$target.closest($embedContainer).length && !$target.hasClass('dcg-shell')) {
                    expressionsModel.setSelected(null);
                }
            });

            //Setup undo-redo listeners -- only if globalKeyboardUndo was enabled
            //TODO: verify naming
            if (graphSettings.config.globalKeyboardUndo) {
                $(document).bind('keydown', function(evt) {

                    // TODO - a different way to listen for z and y keys than hardcoding the numbers
                    //Default ctrl-z, ctrl-y behavior
                    if (evt.ctrlKey || evt.metaKey) {
                        switch (evt.which) {
                            case 90: //z
                                if (evt.shiftKey) {
                                    undoRedo.redo();
                                } else {
                                    undoRedo.undo();
                                }
                                return false;
                            case 89: //y
                                undoRedo.redo();
                                return false;
                        }
                    }
                });
            }

            this.expressionsModel = expressionsModel;

            if (expressionsView) {
                this.expressions = expressionsView;
            }
            this.grapher = grapher;
            this.evaluator = evaluator;
            this.stateController = stateController;
            this.setState = stateController.setState.bind(stateController);
            this.setBlank = stateController.setBlank.bind(stateController);
            this.getState = stateController.getState.bind(stateController);
            this.setStateFromURL = stateController.setStateFromURL.bind(stateController);
            this.expressionsView = expressionsView;
            this.undoRedo = undoRedo;
            this.addChangeCallback = addChangeCallback;
            this.toast = function(str, options) {
                toastView.show(str, options);
            };

            this.setViewport = function(bounds) {
                grapher.viewportController.setViewport(new Viewport(
                    bounds[0], bounds[1], bounds[2], bounds[3]
                ));
            };
            this.resize = function() {
                layoutController.resize();
            };

            this.addFocus = function() {
                if (!expressionsView) return;
                expressionsModel.setSelected(0);
                expressionsView.getSelectedView().addFocus();
            };

            //undocumented (for now) method for adding a data table programatically
            this.createAndPopulateTable = function(parsedData) {

                this.expressionsView.addExpressionView.newTable(parsedData);
                //calc viewport
                var cvp = this.grapher.viewport.toObject();
                //new viewport
                var nvp = DataHelpers.computeNewViewport(cvp, parsedData);
                var self = this;
                if (nvp.xmax > cvp.xmax || nvp.xmin < cvp.xmin || nvp.ymax > cvp.ymax || nvp.ymin < cvp.ymin) {

                    self.undoRedo.addTransaction({
                        type: self.undoRedo.CAUSE_OF_CHANGE,
                        undo: function() {
                            self.setViewport([cvp.xmin, cvp.xmax, cvp.ymin, cvp.ymax]);
                        },
                        redo: function() {
                            self.setViewport([nvp.xmin, nvp.xmax, nvp.ymin, nvp.ymax]);
                        }
                    });
                    this.toast(i18n.t('We zoomed to fit your data.'), { undoCallback: function() {} });
                }
            };

            this.interceptTouch = function() {
                var elts = $graphpaper;
                if (expressionsView) {
                    elts = elts.add(expressionsView.$('.dcg-expression-top-bar'));
                }
                if (keypadView) elts = elts.add(keypadView.$());
                // Don't allow legacy scrolling or legacy clicks on the graphpaper or keypad
                elts.on('touchstart', function(evt) {
                    evt.preventDefault();
                });
                // Since we're preventing default, we need to take responsibility for closing
                // the system keypad, and fixing scroll.
                elts.on('touchend', layoutController.defocusMobile);
            };

            this.setOptions = function(options) {
                var needsResize = false;
                if (options.hasOwnProperty('solutions')) {
                    $embedContainer.toggleClass('dcg-no-solutions', !options.solutions);
                }
                if (options.hasOwnProperty('settingsMenu')) {
                    $embedContainer.toggleClass('dcg-no-settings-menu', !options.settingsMenu);
                }

                if (options.hasOwnProperty('border')) {
                    $embedContainer.toggleClass('dcg-default-border', !!options.border);
                }
                if (options.hasOwnProperty('branding')) {
                    $embedContainer.toggleClass('dcg-no-branding', !options.branding);
                }
                if (options.hasOwnProperty('expressionsTopbar')) {
                    $embedContainer.toggleClass('dcg-no-expression-topbar', !options.expressionsTopbar);
                    needsResize = true;
                }
                if (options.hasOwnProperty('graphpaper')) {
                    $embedContainer.toggleClass('dcg-no-graphpaper', !options.graphpaper);
                    needsResize = true;
                }
                if (options.hasOwnProperty('zoomButtons')) {
                    $embedContainer.toggleClass('dcg-no-zoom', !options.zoomButtons);
                }
                if (options.hasOwnProperty('expressionsCollapsed') && expressionsView) {
                    if (options.expressionsCollapsed) {
                        expressionsView.hideExpressions();
                    } else {
                        expressionsView.showExpressions();
                    }
                }
                if (options.hasOwnProperty('keypad')) {
                    console.warn(
                        'Bad option {keypad: ' +
                        options.keypad +
                        '}. The keypad can only be added or removed at load time, not at runtime.'
                    );
                }
                if (options.hasOwnProperty('expressions')) {
                    console.warn(
                        'Bad option {expressions: ' +
                        options.expressions +
                        '}. The expressions can only be added or removed at load time, not at runtime.'
                    );
                }

                if (needsResize) layoutController.resize();
            };

            layoutController.resize();
            stateController.setBlank();

            if (graphSettings.config.expressionsCollapsed) this.setOptions({ expressionsCollapsed: true });

            grapher.viewportController.triggerViewportStable();
        };
    });

    return Calc;
});


define('api/calculator', ['require', 'console', 'pjs', 'underscore', 'main/calc_embed', 'expressions/helperexpression', 'underscore_model', 'worker/workerpool', 'browser', 'expressions/colors'], function(require) {
    var console = require('console');
    var P = require('pjs');
    var _ = require('underscore');
    var Calc = require('main/calc_embed');
    var HelperExpression = require('expressions/helperexpression');
    var UnderscoreModel = require('underscore_model');
    var WorkerPool = require('worker/workerpool');
    var Browser = require('browser');

    var Colors = require('expressions/colors');

    function _parseExpression(expression) {
        var obj;

        if (typeof expression === 'string') {
            obj = { latex: expression };
        } else if (expression.headings !== undefined) {
            obj = expression;
            obj.headings = obj.headings.map(function(heading) {
                return (typeof heading === 'string') ? { latex: heading } : heading;
            });
        } else {
            obj = expression;
        }

        return obj;
    }


    function validatedOptions(options) {
        var out = {};
        if (!options) options = {};

        var addOption = function(property, defaultValue) {
            if (options.hasOwnProperty(property)) {
                out[property] = options[property];
            } else {
                out[property] = defaultValue;
            }
        };
        addOption('keypad', true);
        addOption('graphpaper', true);
        addOption('settingsMenu', true);
        addOption('expressionsTopbar', true);
        addOption('branding', true);
        //zoomButtons don't make sense w/o graphpaper
        addOption('zoomButtons', out.graphpaper);
        addOption('solutions', true);
        addOption('expressionsCollapsed', false);
        addOption('lockViewport', false);
        addOption('globalKeyboardUndo', false);
        //default to useShellsOffscreen on mobile
        addOption('useShellsOffscreen', Browser.IS_MOBILE);
        addOption('redrawSlowly', false);
        addOption('onlyTraceSelected', false);
        addOption('disableMouseInteractions', false);
        addOption('folders', true);
        //images don't make much sense w/o graphpaper (but aren't strictly disallowed)
        addOption('images', out.graphpaper);
        addOption('expressions', true);
        addOption('border', true);
        addOption('nativeOnscreenKeypad', false);

        //secret option for resizing in a loop
        addOption('resizeLoop', false);

        if (options.hasOwnProperty('menus')) {
            console.warn(
                'As of API version 0.4, the \'menus\' option is deprecated and has been split into ' +
                'settingsMenu (boolean) and expressionsTopbar (boolean).'
            );
            if (!options.hasOwnProperty('settingsMenu')) out.settingsMenu = !!options.menus;
            if (!options.hasOwnProperty('expressionsTopbar')) out.expressionsTopbar = !!options.menus;
        }


        if (!out.graphpaper) {
            if (out.expressionsCollapsed) {
                out.expressionsCollapsed = false;
                console.warn(
                    'Desmos API initialized with bad options. graphpaper: false ' +
                    'and expressionsCollapsed: true are incompatible. Proceeding ' +
                    'with expressionsCollapsed: false.'
                );
            }
            if (out.zoomButtons) {
                out.zoomButtons = false;
                console.warn(
                    'Desmos API initialized with bad options. graphpaper: false ' +
                    'and zoomButtons: true are incompatible. Proceeding ' +
                    'with zoomButtons: false.'
                );
            }
        }

        return out;
    }
    //this always needs to be set on window (for now)
    var nworkers = (window.Desmos.config.hasOwnProperty('nworkers') ? window.Desmos.config.nworkers : 8);
    var workerPool = WorkerPool(window.Desmos.config.workerURL, nworkers);

    var Calculator = P(function(proto) {
        proto.init = function(elt, options, onReady) {
            this._calc = Calc(elt, workerPool, validatedOptions(options));
            this._calc.interceptTouch();
            //let the world know that we're ready
            if (typeof onReady === 'function') onReady(this);
        };

        proto.setExpression = function(expression) {
            var expressions = this._calc.expressionsModel;
            var validatedState = {};
            var id = validatedState.id = expression.id.toString();
            if (!id) return;
            if (expression.hasOwnProperty('latex')) {
                validatedState.latex = expression.latex.toString();
            }
            if (expression.hasOwnProperty('color')) {
                validatedState.color = expression.color.toString();
            }
            if (expression.hasOwnProperty('style')) {
                validatedState.style = expression.style.toString();
            }
            if (expression.hasOwnProperty('hidden')) {
                validatedState.hidden = !!expression.hidden;
            }

            if (expressions.getItemById(id)) {
                //Update
                expressions.updateItemById(id, validatedState);
            } else {
                //Set
                var obj = expressions.fromState(_parseExpression(validatedState));
                expressions.addItem(obj);
            }
        };

        proto.getExpressionsModel = function() {
            return this._calc.expressionsModel;
        }

        proto.setExpressions = function(expressions) {
            expressions.forEach(this.setExpression.bind(this));
        };

        proto.removeExpression = function(expression) {
            var expressions = this._calc.expressionsModel;
            var id = expression.id.toString();
            expressions.removeItemById(id);
        };

        proto.removeExpressions = function(expressions) {
            expressions.forEach(this.removeExpression.bind(this));
        };

        proto.setViewport = function(bounds) {
            if (
                bounds.length == 4 &&
                bounds[1] > bounds[0] &&
                bounds[3] > bounds[2]
            ) {
                this._calc.setViewport(bounds);
            } else {
                console.warn('Invalid viewport.  Expected [xmin, xmax, ymin, ymax].  Got ' + bounds);
            }
        };

        proto.resize = function() {
            this._calc.resize();
        };

        proto.setBlank = function() { return this._calc.setBlank.apply(this._calc, arguments); };
        proto.setState = function() { return this._calc.setState.apply(this._calc, arguments); };
        proto.getState = function() { return this._calc.getState.apply(this._calc, arguments); };

        proto.screenshot = function(opts) {
            opts = opts ? opts : {};
            return this._calc.grapher.screenshot(opts.width, opts.height);
        };

        proto.setOptions = function() { return this._calc.setOptions.apply(this._calc, arguments) };

        proto.HelperExpression = function(obj) {
            var proxy = UnderscoreModel();

            var h = HelperExpression(obj, this._calc.expressionsModel);
            this._calc.expressionsModel.addHelperItem(h);

            proxy.latex = h.latex;

            h.observe('formula', function() {
                // Notify proxy of changed properties at the end so that the externally
                // exposed values are consistent. Might want to make this an optional feature
                // of UnderscoreModel. Maybe model.batchUpdate(function () { /* do updates */ });
                var props = ['numericValue'];
                var oldValues = props.map(function(prop) { return proxy[prop] });

                var formula = h.formula;

                var val;
                if (formula.zero_values && formula.zero_values.length === 1) {
                    val = formula.zero_values[0].val;
                }
                var valType = typeof val;
                proxy.numericValue = valType === 'number' ? val : NaN;

                props.forEach(function(prop) {
                    if (!_.isEqual(proxy[prop], oldValues[prop])) proxy.notifyPropertyChange(prop);
                });
            });

            return proxy;
        };
    });

    // Spelling these out to avoid giving access to Colors.all. This is a
    // mutable array, and changing it would change the colors we cycle through.
    // That might be desirable, but we would want a better API for doing it.
    window.Desmos.Colors = {
        RED: Colors.RED,
        BLUE: Colors.BLUE,
        GREEN: Colors.GREEN,
        ORANGE: Colors.ORANGE,
        PURPLE: Colors.PURPLE,
        BLACK: Colors.BLACK,
        next: Colors.next
    };

    window.Desmos.Calculator = Calculator;

    return Calculator;
});

define('mygraphs/view', ['require', 'loadcss!css/mygraphs', 'jquery', 'underscore', 'pjs', 'i18n', 'keys', 'config', 'underscore_view', './examplegraphitem_view', './savedgraphitem_view', 'template!mygraphs', 'api/calculator', 'scroll_helpers', 'vendor/jquery.html5-placeholder-shim'], function(require) {
    require('loadcss!css/mygraphs');

    var $ = require('jquery');
    var _ = require('underscore');
    var P = require('pjs');
    var i18n = require('i18n');
    var Keys = require('keys');
    var Config = require('config');
    var UnderscoreView = require('underscore_view');
    var ExampleGraphItemView = require('./examplegraphitem_view');
    var SavedGraphItemView = require('./savedgraphitem_view');
    var template = require('template!mygraphs');
    var CalcAPI = require('api/calculator');
    var scrollHelpers = require('scroll_helpers');

    require('vendor/jquery.html5-placeholder-shim');

    var MyGraphsView = P(UnderscoreView, function(view, _super) {
        view.template = template;

        view.init = function(model, Calc, modals) {
            _super.init.call(this);
            this.model = model;
            this.Calc = Calc;
            this.modals = modals;
            this.itemViews = {};

            this.model.triggerItemAdded = this.onItemAdded.bind(this);
            this.model.triggerItemRemoved = this.onItemRemoved.bind(this);
            this.model.observe('selectedItem', this.onSelectedItemChange.bind(this));
            this.model.observe('searchQuery', this.onSearchQueryChange.bind(this));

            this.accountsEnabled = false;

            this.model.observe('isSpinning searchQuery filteredItemCount', this.renderLayout.bind(this));

            this.observe('isOpen', this.renderIsOpen.bind(this));
        };

        view.getTemplateParams = function() {
            return {
                maintenance: Config.get('maintenance'),
                previewMode: Config.get('previewMode'),
                previewFeedbackUrl: Config.get('previewFeedbackUrl'),
                previewMessage: Config.get('previewMessage'),
                accountsEnabled: this.accountsEnabled
            };
        };

        view.createItemView = function(itemModel) {
            if (itemModel.isSavedGraph) {
                return SavedGraphItemView(itemModel);
            } else if (itemModel.isExampleGraph) {
                return ExampleGraphItemView(itemModel);
            }
        };

        view.onItemAdded = function(itemModel, index) {
            if (!this.$()[0]) return; // don't do anything if not in dom

            var itemView = this.createItemView(itemModel);
            this.__itemViews[itemModel.guid] = itemView;

            if (index === 0) {
                itemView.prependTo(this.$('.template-list'));
            } else {
                itemView.insertAfter(this.$('.template-list > :nth-child(' + index + ')'));
            }
        };

        view.onItemRemoved = function(itemModel) {
            if (!this.$()[0]) return; // don't do anything if not in dom

            var itemView = this.__itemViews[itemModel.guid];
            delete this.__itemViews[itemModel.guid];

            itemView.remove();
        };

        view.getViewFromModel = function(itemModel) {
            return itemModel ? this.__itemViews[itemModel.guid] : null;
        };

        view.getSelectedView = function() {
            return this.getViewFromModel(this.model.selectedItem);
        };

        view.getSelectedGraph = function() {
            var selectedItemModel = this.model.selectedItem;
            if (!selectedItemModel) return null;

            return selectedItemModel.graph;
        };

        view.clearSelection = function() {
            var selectedItemModel = this.model.selectedItem;
            if (selectedItemModel) {
                selectedItemModel.setProperty('selected', false);
            }
        };

        view.onSelectedItemChange = function() {
            if (this.getSelectedGraph()) {
                this.showPreview();
            } else {
                this.hidePreview();
            }
        };

        view.focusSearchBar = function() {
            this.$('#search-mygraphs').focus();
        };

        view.toggleVisible = function() {
            if (this.isOpen) {
                this.close();
            } else {
                this.open();
            }
        };

        view.updateSearchQuery = function(evt) {
            //escape pressed -- clear input? just bikeshedding.
            if (Keys.lookup(evt) === Keys.ESCAPE) {
                this.$('#search-mygraphs').attr('value', '');
                this.model.setProperty('searchQuery', '');
            }

            //don't run the filter graphs code on  enter, up, or down
            else if ([Keys.UP, Keys.DOWN, Keys.ENTER].indexOf(Keys.lookup(evt)) === -1) {
                this.model.setProperty('searchQuery', this.$('#search-mygraphs').val());

                // close preview if it's open when typing in search box
                this.clearSelection();
            }

        };

        view.newBlankGraph = function() {
            this.clearSelection();
            this.model.graphsController.clearGraph();

            var self = this;
            var undoCallback = function() {
                self.open();
            };
            this.Calc._calc.toast(i18n.t("New graph created."), { undoCallback: undoCallback });
            this.close();
        };

        view.onSearchQueryChange = function() {
            this.$('.new-blank-graph').toggle(this.model.searchQuery.length === 0);
        };

        view.didCreateElement = function() {
            var self = this;
            var previewDiv = this.$('#preview-calculator')[0];
            var previewOpts = {
                settingsMenu: false,
                expressionsTopbar: false,
                keypad: false,
                zoomButtons: false,
                useShellsOffscreen: true,
                border: false,
                branding: false
            };
            this.previewCalc = new CalcAPI(previewDiv, previewOpts);

            var throttledResize = _.throttle(function() {
                this.positionPreview();
            }.bind(this), 100);
            $(window).on('resize', throttledResize);

            this.$preview = this.$('.graph-preview');
            this.$previewArrow = this.$preview.children('.active-arrow');
            this.$previewTitle = this.$preview.children('.dcg-title');
            this.$scrollable = this.$('.scrollable');

            this.$scrollable.on('scroll', this.hidePreviewIfTooScrolled.bind(this));
            this.$('#search-mygraphs').on('change keypress keyup keydown copy paste cut', this.updateSearchQuery.bind(this));

            this.$('.dcg-action-login').on('tap', this.login.bind(this));
            this.$('.dcg-action-createaccount').on('tap', this.createAccount.bind(this));
            this.$().on('click', 'a', function(evt) {
                if (!$(this).attr('href')) evt.preventDefault();
            });

            this.$().on('tap', '.dcg-action-newblankgraph', this.newBlankGraph.bind(this));
            this.$().on('tap', '.dcg-action-cancel', this.clearSelection.bind(this));

            this.$('.dcg-action-open-graph').on('tap', this.openPreview.bind(this));

            //background cover
            // if clicked and a preview is open, close that preview
            // otherwise, close the resources tab
            this.$('.dcg-action-close-resources').on('tapstart', function(evt) {
                if (self.getSelectedGraph()) {
                    self.clearSelection();
                } else {
                    self.close();
                }
            });

            // add examples to dom
            var list = this.$('.template-list');
            this.__itemViews = {};
            this.model.getItems().forEach(function(itemModel) {
                var itemView = self.createItemView(itemModel);
                self.__itemViews[itemModel.guid] = itemView;

                // TODO - optimize by adding all starting items at once rather than one at a time
                itemView.appendTo(list);
            });

            this.renderLayout();
        };

        view.createAccount = function() {
            //_kmq.push(['record', 'started signup', {
            //  'signup location': 'mygraphs-drawer'
            //}]);
            this.modals.createAccountDialog.show();
        };

        view.login = function() {
            //_kmq.push(['record', 'started login', {'login location': 'mygraphs-drawer'}]);
            this.modals.loginDialog.show();
        };

        view.renderLayout = function() {
            // exit early if the dom isn't created yet
            if (!this.$()[0]) return;

            var userIsLoggedIn = !!(this.accountsEnabled && false);
            var isSpinning = !!this.model.isSpinning;

            //show login options. no-op on tablet because login-reminder doesn't exist in the DOM
            this.$('.login-reminder').toggle(!userIsLoggedIn);
            // only show spinner if user is logged in
            this.$('.template-spinning').toggle(userIsLoggedIn && isSpinning);
            // only show 'no matches' if a search query is entered and the're not matches
            this.$('.no-matches').toggle(this.model.filteredItemCount === 0 && this.model.searchQuery.length !== 0);
        };

        view.openPreview = function() {
            var self = this;
            var selectedGraph = self.getSelectedGraph();
            if (!selectedGraph) return;

            setTimeout(function() {
                self.model.graphsController.loadGraph(selectedGraph.copy());

                var graphTitle;
                if (!selectedGraph.title) {
                    graphTitle = i18n.t("Untitled Graph");
                } else {
                    if (selectedGraph.title.length > 15) {
                        graphTitle = selectedGraph.title.substr(0, 15) + "...";
                    } else {
                        graphTitle = selectedGraph.title;
                    }
                }

                var str = i18n.t("Opened '__graphTitle__'", { graphTitle: graphTitle });
                var undoCallback = function() {
                    self.open();
                };
                self.Calc._calc.toast(str, { undoCallback: undoCallback });
            });
            self.close();
        };

        view.showPreview = function() {
            var selectedGraph = this.getSelectedGraph();
            if (!selectedGraph) return;

            //do all of these things before showing & setState so that it feels more responsive
            $('body').addClass('preview-open');
            this.positionPreview();
            this.$previewTitle.text(selectedGraph.displayTitle);

            //dcg-visible fades in on a slight delay. remove it and re-add it
            //so that the animation is triggered when you switch between graphs
            this.$('.screenshot-clickjack').removeClass('dcg-visible');
            this.$('.dcg-loading-container').show();
            setTimeout(function() {
                this.previewCalc.resize();
                this.previewCalc.setState(selectedGraph.graphData);
                this.$('.dcg-loading-container').hide();
                this.$('.screenshot-clickjack').addClass('dcg-visible');
            }.bind(this), 1);
            this.$preview.show();
        };

        view.hidePreview = function() {
            this.$preview.hide();
            $('body').removeClass('preview-open');
        };

        view.selectUp = function(evt) {
            if (this.model.selectPrev()) {
                evt.preventDefault();
            }
        };

        view.selectDown = function(evt) {
            if (this.model.selectNext()) {
                evt.preventDefault();
            }
        };

        //if we scroll enough that the arrow's not pointing at the list item
        //hide preview
        view.hidePreviewIfTooScrolled = function() {
            var selectedView = this.getSelectedView();
            if (!selectedView) return;

            var $target = selectedView.$();
            if (
                $target.offset().top >= this.$previewArrow.offset().top ||
                $target.offset().top + $target.outerHeight() <= this.$previewArrow.offset().top
            ) {
                this.clearSelection();
            }
        };

        // our strategy is to try to keep the arrow in it's natural
        // position and move the entire preview up or down to line the
        // arrow up. That should be possible unless it'd require the
        // preview to go below the bottom of the screen. In that case,
        // we put the preview on the bottom of the screen and move the
        // arrow.
        view.positionPreview = function() {

            var selectedView = this.getSelectedView();
            if (!selectedView) return;

            var $target = selectedView.$();

            // scroll the target into view.
            var targetHeight = $target.outerHeight();

            scrollHelpers.scrollVisible($target, this.$scrollable, targetHeight);

            // restores the arrow to it's natural position
            this.$previewArrow.css('top', '60px');
            var arrowOffset = 60;

            // check where the arrow *should* point
            var centerArrowY = $target.offset().top + targetHeight / 2;

            // figure out how far down we can move the preview before it is uncomfortably low on the screen
            var previewHeight = this.$preview.outerHeight();
            var maxBottom = $(window).height() - 5;
            var maxPreviewTop = maxBottom - previewHeight;
            var newPreviewTop = centerArrowY - arrowOffset;

            // the preview is too low, we must put the preview at the bottom of the screen
            // and move the arrow itself
            if (newPreviewTop > maxPreviewTop) {
                newPreviewTop = maxPreviewTop;
                this.$previewArrow.css('top', centerArrowY - newPreviewTop);
            }

            // move the preview to where it needs to go
            this.$preview.css('top', newPreviewTop);
        };

        view.renderIsOpen = function() {
            $('body').toggleClass('resources-open', !!this.isOpen);
        };

        view.close = function() {
            this.setProperty('isOpen', false);
            this.clearSelection();


            this.$('#search-mygraphs').blur().attr('value', '');
            this.model.setProperty('searchQuery', '');
            $(document).off('keydown.mygraphs-view');

            // TODO - do we still need this lastRemoved?
            this.model.graphsController.setProperty('lastRemoved', undefined);
        };

        view.open = function() {
            this.setProperty('isOpen', true);
            // update the dates and fix placeholder
            this.model.updateDisplayDates();
            if ($.placeholder) $.placeholder.shim();

            var self = this;
            //listen for arrow keys
            $(document).on('keydown.mygraphs-view', function(evt) {
                var key = Keys.lookup(evt);

                if (key === Keys.UP) {
                    self.selectUp(evt);
                    evt.preventDefault();
                } else if (key === Keys.DOWN) {
                    self.selectDown(evt);
                    evt.preventDefault();
                } else if (key === Keys.ENTER) {
                    self.openPreview();
                } else if (key === Keys.ESCAPE) {
                    self.clearSelection();
                }
            });
        };
    });

    return MyGraphsView;
});

define('template!header_desktop', ['underscore'], function(_) {
    return function(obj) {
        var __p = '';
        var print = function() { __p += Array.prototype.join.call(arguments, '') };
        with(obj || {}) {
            __p += '<div>\n  <div class=\'left-floaters\'>\n      <span class="dcg-header-btn dcg-action-opendrawer dcg-tooltip" tooltip="' +
                (t('Open Graph (ctrl+o)')) +
                '">\n        <i class="dcg-icon-hamburger"></i>\n      </span>\n\n      <span class=\'divider\'></span>\n\n      ';
            if (maintenance) {;
                __p += '\n        <span class="title-div">\n          <span class="dcg-variable-title dcg-tooltip" tooltip="' +
                    (t('Desmos is in maintenance mode, you won\'t be able to save changes to this graph. We\'re so sorry for the inconvenience!')) +
                    '"></span>\n        </span>\n      ';
            } else if (previewMode) {;
                __p += '\n\n      <span class="title-div">\n        <span class="dcg-variable-title dcg-tooltip" tooltip="' +
                    (t('Desmos is in preview mode, so you won\'t be able to save graphs.')) +
                    '"></span>\n      </span>\n\n      ';
            } else {;
                __p += '\n          <span class="title-div">\n            <span class="dcg-variable-title dcg-tooltip dcg-action-savedialog"\n              tooltip="' +
                    (t('Save As or Rename (ctrl+shift+s)')) +
                    '"\n            ></span>\n            ';
                if (user) {;
                    __p += '\n            <span class="dcg-action-save">\n              <span class="save-btn tooltip-offset" tooltip="' +
                        (t('Save (ctrl+s)')) +
                        '">\n                <i class="dcg-icon-save"></i>\n              </span>\n              <span class="saving-notice">\n                <img src="/img/spinner.gif" />\n              </span>\n              <span class="save-success"><i class="dcg-icon-check"></i>' +
                        (t('saved')) +
                        '</span>\n              <span class="save-failure"><i class="dcg-icon-remove"></i>' +
                        (t('error saving')) +
                        '</span>\n            </span>\n            ';
                };
                __p += '\n          </span>\n\n      ';
            };
            __p += '\n  </div>\n\n  <div class=\'right-floaters\'>\n    <!-- reverse order, because these all float right -->\n\n    <span\n      class="dcg-header-btn dcg-action-language dcg-tooltip"\n      tooltip="' +
                (t('Language')) +
                '"\n    >\n        <i class="dcg-icon-world"></i>\n    </span>\n    <span class=\'divider\'></span>\n    <span\n      class="dcg-header-btn dcg-action-help dcg-tooltip"\n      tooltip="' +
                (t('Help')) +
                '"\n    >\n        <i class="dcg-icon-question-sign"></i>\n    </span>\n\n    <span class=\'divider\'></span>\n\n    ';
            if (maintenance || previewMode) {;
                __p += '\n\n    <div class="dcg-toast-container">\n      <span class="dcg-toast dcg-maintenance-toast">\n        <span class="dcg-msg">\n\n          ';
                if (maintenance) {;
                    __p += '\n            ' +
                        (t('Desmos is in Maintenance Mode.')) +
                        '\n          ';
                } else {;
                    __p += '\n            ' +
                        (previewMessage) +
                        '\n          ';
                };
                __p += '\n        </span>\n\n        ';
                if (maintenance) {;
                    __p += '\n          <a class="undo" target=\'_blank\' href=\'http://desmos.zendesk.com/entries/25429616-What-is-Maintenance-Mode-/\'>\n            ' +
                        (t('Learn More')) +
                        '\n          </a>\n        ';
                } else {;
                    __p += '\n          <a class="undo" target=\'_blank\' href=\'' +
                        (previewFeedbackUrl) +
                        '\'>\n            ' +
                        (t('Share your thoughts!')) +
                        '\n          </a>\n        ';
                };
                __p += '\n\n\n      </span>\n    </div>\n\n    ';
            } else if (user) {;
                __p += '\n\n      ';
                if (IS_ANDROID) {;
                    __p += '\n\n        <span \n          class="dcg-share-btn"\n          class=\'android-share dcg-action-share dcg-header-btn\'\n        >\n          <i class="dcg-icon-android-share"></i>\n        </span>\n\n      ';
                } else {;
                    __p += '\n        <span class=\'dcg-btn-group\'>\n        <span\n          class=\'dcg-print-btn tooltip-offset dcg-btn dcg-btn-green dcg-action-print\'\n          tooltip="' +
                        (t('Print')) +
                        '"\n        >\n            <i class="dcg-icon-print"></i>\n        </span>\n        <span\n          class=\'dcg-share-btn tooltip-offset dcg-btn dcg-btn-green dcg-action-share\'\n          tooltip="' +
                        (t('Share Graph')) +
                        '"\n        >\n            <i class="dcg-icon-share"></i>\n        </span>\n      </span>\n\n      ';
                };
                __p += '\n\n      <span class=\'divider\'></span>\n\n      <span class="dcg-account-link">\n        <span class="dcg-edit-acct-success">\n          <i class="dcg-icon-check"></i> ' +
                    (t('saved')) +
                    '\n        </span>\n        <span class="email">\n          ' +
                    (name) +
                    '\n          <i class=\'dcg-icon-caret-down\'></i>\n        </span>\n      </span>\n    ';
            } else {;
                __p += '\n      <span class="dcg-login">\n      <a class="dcg-create-account dcg-btn dcg-btn-green dcg-action-createaccount">' +
                    (t('Create Account')) +
                    '</a> ' +
                    (t('or')) +
                    '\n      <a class="dcg-sign-in dcg-action-login">' +
                    (t('Sign In')) +
                    '</a>\n      </span>\n    ';
            };
            __p += '\n  </div>\n\n  <div class=\'dcg-center\'>\n    <a href="/" target=\'_blank\' class="dcg-home-link-icon" title="dcg-title">\n      <i class="dcg-icon-desmos"></i>\n    </a>\n  </div>\n\n</div>\n';
        }
        return __p;
    };
});
/*
 * this is the row of buttons above the calc on desktop
 */

define('main/header_desktop', ['require', 'console', 'loadcss!css/header_desktop', 'jquery', 'underscore_view', 'pjs', 'browser', 'config', 'i18n', 'tipsy', 'main/share_options', 'main/help_desktop', 'main/language', 'main/account_dropdown', 'mygraphs/examples', 'mygraphs/model', 'mygraphs/view', 'template!header_desktop'], function(require) {
    var console = require('console');
    require('loadcss!css/header_desktop');
    var $ = require('jquery');
    var UnderscoreView = require('underscore_view');
    var P = require('pjs');
    var Browser = require('browser');
    var Config = require('config');
    var i18n = require('i18n');
    require('tipsy');

    var ShareView = require('main/share_options');
    var HelpView = require('main/help_desktop');
    var LanguageView = require('main/language');
    var AccountView = require('main/account_dropdown');
    var myGraphExamples = require('mygraphs/examples');
    var MyGraphsModel = require('mygraphs/model');
    var MyGraphsView = require('mygraphs/view');

    var template = require('template!header_desktop');

    var HeaderView = P(UnderscoreView, function(view, _super) {
        view.template = template;
        view.$saveBtn = null;

        view.init = function(
            graphsController,
            Calc,
            modals
        ) {
            _super.init.call(this);
            this.graphsController = graphsController;
            this.Calc = Calc;
            this.modals = modals;

            this.shareView = ShareView(
                graphsController,
                Calc
            );
            this.helpView = HelpView(
                graphsController,
                Calc,
                modals
            );

            this.languageView = LanguageView(Calc);
            this.myGraphsModel = MyGraphsModel(myGraphExamples, graphsController);
            this.myGraphsView = MyGraphsView(this.myGraphsModel, Calc, modals);


            //needs helpview to be able to open up the feedback box
            this.accountView = AccountView(this.helpView, modals);

            this.childViews = [
                this.shareView,
                this.helpView,
                this.languageView,
                this.accountView
            ];
        };

        view.didCreateElement = function() {
            var self = this;

            this.$saveBtn = this.$('.dcg-action-save');

            this.$().tipsy({
                fade: 'fast',
                title: 'tooltip',
                wait: 500,
                delegate: '.dcg-tooltip'
            });

            //a few need extra offset
            this.$().tipsy({
                fade: 'fast',
                title: 'tooltip',
                wait: 500,
                offset: 7,
                delegate: '.tooltip-offset'
            });

            this.childViews.forEach(function(view) {
                view.setPointTo(self.$(view.pointToSelector));
                view.appendTo('.dcg-sliding-interior');
            });

            this.myGraphsView.appendTo('body');

            //bind to events in the graphs controller
            this.graphsController.startSavingCallbacks.push(this.saveStart.bind(this));
            this.graphsController.saveSuccessCallbacks.push(this.saveSuccess.bind(this));
            this.graphsController.saveErrorCallbacks.push(this.saveFailure.bind(this));

            this.helpView.setupOpenButton(this.$('.dcg-action-help'), 'tap');
            this.languageView.setupOpenButton(this.$('.dcg-action-language'), 'tap');
            this.shareView.setupOpenButton(this.$('.dcg-action-share'), 'tap');
            this.accountView.setupOpenButton(this.$('.dcg-account-link'), 'tap');


            this.$('.dcg-action-opendrawer').on('tap', this.openDrawer.bind(this));
            this.$('.dcg-action-savedialog').on('tap', this.saveDialog.bind(this));
            this.$saveBtn.on('tap', this.simpleSave.bind(this));
            this.$('.dcg-action-print').on('tap', this.print.bind(this));
            this.$('.dcg-action-login').on('tap', this.login.bind(this));
            this.$('.dcg-action-createaccount').on('tap', this.createAccount.bind(this));
            this.updateTitle();

            this.graphsController.observe('currentGraph', function() {
                self.updateTitle();
            });

            this.observe('graphChanged', this.renderGraphChanged.bind(this));
            this.renderGraphChanged();
        };

        view.renderGraphChanged = function() {
            var hasChanges = !!this.graphChanged;
            this.$('.save-btn').attr(
                'tooltip', (hasChanges ? i18n.t("Save Changes (ctrl+s)") : i18n.t("No Unsaved Changes")));
            this.$('.title-div').toggleClass('has-changes', hasChanges);
        };

        view.openDrawer = function() {
            this.myGraphsView.toggleVisible();
        };

        view.getTemplateParams = function() {
            var name = null;
            return {
                IS_ANDROID: Browser.IS_ANDROID,
                name: name,
                maintenance: Config.get('maintenance'),
                previewMode: Config.get('previewMode'),
                previewFeedbackUrl: Config.get('previewFeedbackUrl'),
                previewMessage: Config.get('previewMessage')
            };
        };

        view.updateTitle = function() {
            var graph = this.graphsController.currentGraph;
            var title = (graph && graph.title ? graph.title : i18n.t('Untitled Graph'));
            this.$('.dcg-variable-title').text(title);
        };

        //this can be called by ctrl-S or by clicking the save icon
        //it executes the save, but doesn't pop up the dialog unless it's your first save
        view.simpleSave = function() {
            this.saveDialog();
        };

        // TODO - switch from keyCode to something that identifies which keys we're talking about.
        view.handleKeydown = function(evt) {
            if (evt.ctrlKey || evt.metaKey) {
                if (evt.keyCode == 83) {
                    evt.preventDefault();
                    if (evt.shiftKey) {
                        this.saveDialog();
                    } else {
                        this.simpleSave();
                    }
                } else if (evt.keyCode == 79) {

                    //power user feature: focus search box when you press ctrl-o or cmd-o
                    evt.preventDefault();
                    this.openDrawer();
                    var self = this;

                    if ($('body').hasClass('resources-open')) {
                        setTimeout(function() {
                            self.myGraphsView.focusSearchBar();
                        }, 1);
                    }
                }
            }
        };
        view.saveDialog = function() {
            this.modals.createAccountDialog.showThenSave();
        };

        view.saveStart = function() {
            this.$saveBtn.addClass('saving');
            console.log("start saving animation");
        };
        view.saveSuccess = function() {
            this.$saveBtn.removeClass('saving').addClass('success');

            var self = this;
            setTimeout(function() {
                self.$saveBtn.removeClass('success');
            }, 2000);

        };
        view.saveFailure = function() {
            this.$saveBtn.removeClass('saving').addClass('failure');
            var self = this;
            setTimeout(function() {
                self.$saveBtn.removeClass('failure');
            }, 2000);
        };

        view.print = function(evt) {
            //execute a window.print
            window.print();
            return;
        };

        //
        // right hand tools
        //

        view.login = function() {
            //_kmq.push(['record', 'started login', {'login location': 'header'}]);
            this.modals.loginDialog.show();
        };

        view.createAccount = function() {
            //_kmq.push(['record', 'started signup', {
            //  'signup location': 'header'
            //}]);
            this.modals.createAccountDialog.show();
        };

    });

    return HeaderView;
});

define('lib/urlparser', ['require'], function(require) {

    var UrlParser = {
        //from http://stackoverflow.com/questions/1403888/get-url-parameter-with-javascript-or-jquery
        getParameter: function(name) {
            return decodeURIComponent((new RegExp('[?|&]' + name + '=' + '([^&;]+?)(&|#|;|$)')
                    .exec(location.search) || [, ""])[1]
                .replace(/\+/g, '%20')) || null;
        }
    };

    return UrlParser;
});

// TODO - our calls to Calc.getState() don't work as we expect. The problem is that
// we expect full results immediately. Slider information, for example, isn't populated
// until after the parsing is done in the worker. That means the first .getState() we do will
// not have slider information at all. Every comparison we do between the first state and the
// other states will return not equal. We need to do one of the following:
//
// 1) Parse synchronously (already proven difficult)
// 2) Call .getState() asynchronously after everything is parsed. (tedious and ugly)
// 3) Build a much smarter state comparison function that doesn't need parsing information (redundant)
//
// The solution I'm using right now is brittle and incomplete. I'm simply passing the slider information
// in the setState back out during getState until we do a parse. It greatly improves things, but it'll
// break if you load an old graph that didn't get saved with the latest slider properties. We really
// want a better solution here.
define('main/graph_change_monitor', ['require', 'pjs', 'underscore', 'underscore_model'], function(require) {
    var P = require('pjs');
    var _ = require('underscore');
    var UnderscoreModel = require('underscore_model');

    var GraphChangeMonitor = P(UnderscoreModel, function(model, _super) {

        model.init = function(Calc, graphsController) {
            _super.init.call(this);

            this.Calc = Calc;
            this.graphsController = graphsController;
            this.graphChanged = false;
            this._savedStates = {};


            Calc._calc.stateController.triggerSetState = this._useCurrentStateAsSavedState.bind(this);
            graphsController.observe('currentGraph', this._useCurrentStateAsSavedState.bind(this));
            graphsController.observe('currentGraph', this._markPotentialChange.bind(this));

            Calc._calc.addChangeCallback(this._markPotentialChange.bind(this));
        };

        model._statesAreEqual = function(state1, state2) {

            // creates cloned copies and also strips out undefined values in objects.
            // For instance, the .sliderInterval property can legitamely be set to undefined.
            // The problem with that is when we saved the state, that value would not have
            // been included because JSON.stringify() would have left it out. The _.isEqual()
            // function differentiates 'undefined' because it wasn't set and 'undefined' because
            // it was set to 'undefined' by using the .hasOwnProperty() method. One more reason
            // that we don't want to be doing this stuff manually here. Would be better to be
            // comparing full states here rather than piecing in information that should be here
            // but isn't simply because parsing is asynchronous.
            state1 = JSON.parse(JSON.stringify(state1));
            state2 = JSON.parse(JSON.stringify(state2));

            function ignoreAnimatedSliders(state) {
                var animatedSliders = _.filter(state.expressions.list, function(expr) {
                    return expr.sliderIsPlaying;
                });

                _.each(animatedSliders, function(expr) {
                    delete expr.latex;
                    delete expr.sliderPlayDirection;
                });
            }

            ignoreAnimatedSliders(state1);
            ignoreAnimatedSliders(state2);

            return _.isEqual(state1, state2);
        };

        // It's impossible to directly compare two states. We make changes to
        // our datastructure over time. So, we can't read the currentGraph.graphData
        // directly. Instead, we wait to read the Calc.getState() after setting
        // a state. We only do this the first time we setState for a given hash.
        model._useCurrentStateAsSavedState = function() {
            var hash = this.getSavedHash();
            if (!this.getSavedStateForHash(hash)) {
                this.setSavedStateForHash(hash, this.Calc.getState());
            }
        };

        model.getSavedHash = function() {
            var currentGraph = this.graphsController.currentGraph;
            return (currentGraph && currentGraph.hash) || '';
        };

        model.getSavedStateForHash = function(hash) {
            return this._savedStates[hash];
        };

        model.setSavedStateForHash = function(hash, state) {
            this._savedStates[hash] = state;
        };

        model.getSavedState = function() {
            return this.getSavedStateForHash(this.getSavedHash());
        };

        model.setSavedState = function(state) {
            this.setSavedStateForHash(this.getSavedHash(), state);
        };

        // Collapses multiple changes into a single check. The check happens the next
        // event loop to make sure all changes are processed.
        model._markPotentialChange = function() {
            clearTimeout(this._checkForChangesTimeout);
            this._checkForChangesTimeout = setTimeout(this.checkForChanges.bind(this), 0);
        };

        model.checkForChanges = function() {
            var savedState = this.getSavedStateForHash(this.getSavedHash());
            var unsavedState = this.Calc.getState();
            var graphChanged = !this._statesAreEqual(savedState, unsavedState);

            this.setProperty('graphChanged', graphChanged);
        };
    });

    return GraphChangeMonitor;

});
define('locales/all', ['require'], function(require) { return { "lt": {} }; });
define('text!data/betchacant_graphs.json', [], function() { return '[{\n  "title": "Peg Game",\n  "graphHash": "iqinawqpdc",\n  "state": {"graph":{"viewport":{"xmin":-12.288,"ymin":-13.657,"xmax":13.025,"ymax":6.374},"showLabels":false,"degreeMode":false,"showGrid":false,"polarMode":false,"showAxes":false,"squareAxes":true,"labelXMode":"","labelYMode":""},"expressions":{"list":[{"id":99,"text":"Slide or animate T:"},{"id":19,"latex":"T=0","domain":{"min":0,"max":1},"hidden":false,"color":"#000000","sliderMin":0,"sliderMax":12},{"id":45,"text":"Number of peg rows"},{"id":1,"latex":"N=4","domain":{"min":0,"max":1},"hidden":false,"color":"#C0504D","sliderMin":1,"sliderMax":10,"sliderInterval":1},{"id":47,"text":"Depth of capture coumns"},{"id":36,"latex":"M=5.81","domain":{"min":0,"max":1},"hidden":false,"color":"#8064A2","sliderMin":-10,"sliderMax":10},{"id":51,"text":"Pins"},{"id":79,"latex":"\\\\left(2P_i-P_j+.1\\\\sin\\\\left(\\\\tau tN^2\\\\right)\\\\left\\\\{P_i\\\\le P_j\\\\right\\\\},-1-w-P_j+.1\\\\cos\\\\left(\\\\tau tN^2\\\\right)\\\\right)","domain":{"min":0,"max":1},"hidden": false,"color":"#9BBB59"},{"id":84,"latex":"P_i=\\\\mod\\\\left(\\\\floor\\\\left(N^2t\\\\right),N\\\\right)","domain":{"min":0,"max":1},"hidden":true,"color":"#C0504D"},{"id":85,"latex":"P_j=\\\\floor\\\\left(Nt\\\\right)","domain":{"min":0,"max":1},"hidden":true,"color":"#4F81BD"},{"id":77,"text":"Falling balls"},{"id":78,"latex":"\\\\left(\\\\left\\\\{r\\\\floor\\\\left(t\\\\right)>T-1:X\\\\left(\\\\floor\\\\left(t\\\\right),T\\\\right)+w\\\\sin\\\\left(\\\\tau t\\\\right)\\\\right\\\\},\\\\left\\\\{r\\\\floor\\\\left(t\\\\right)>T-1:Y_f\\\\left(\\\\floor\\\\left(t\\\\right),T\\\\right)+w\\\\cos\\\\left(\\\\tau t\\\\right)\\\\right\\\\}\\\\right)","domain":{"min":0,"max":15},"hidden": false,"color":"#4F81BD"},{"id":53,"text":"Dropped balls"},{"id":90,"latex":"\\\\left(\\\\left\\\\{r\\\\floor\\\\left(t\\\\right)<T-1:X\\\\left(\\\\floor\\\\left(t\\\\right),T\\\\right)+w\\\\sin\\\\left(\\\\tau t\\\\right)\\\\right\\\\},\\\\left\\\\{r\\\\floor\\\\left(t\\\\right)<T-1:Y\\\\left(\\\\floor\\\\left(t\\\\right),T\\\\right)+w\\\\cos\\\\left(\\\\tau t\\\\right)\\\\right\\\\}\\\\right)","domain":{"min":0,"max":15},"hidden": false,"color":"#4F81BD"},{"id":96,"text":"Collection columns"},{"id":97,"latex":"\\\\left(\\\\floor\\\\left(\\\\left(N+1\\\\right)t\\\\right)+.5,-N-\\\\frac{M}{2}-\\\\frac{M}{2}\\\\mod\\\\left(\\\\left(N+1\\\\right)t,1\\\\right)-w\\\\right)","domain":{"min":-1,"max":1},"hidden":true,"color":"#C0504D"},{"id":58,"text":"Direction ball i goes at peg layer j"},{"id":2,"latex":"f\\\\left(i,j\\\\right)=2\\\\floor\\\\left(\\\\mod\\\\left(\\\\frac{1000\\\\sin\\\\left(ai\\\\right)}{2^j},1\\\\right)-.499\\\\right)+1","domain":{"min":0,"max":1},"hidden":false,"color":"#4F81BD"},{"id":89,"latex":"a=2.49","domain":{"min":0,"max":1},"hidden":true,"color":"#000000","sliderMin":-10,"sliderMax":10},{"id":60,"text":"End position of ball i"},{"id":3,"latex":"p\\\\left(i\\\\right)=\\\\sum_{n=1}^Nf\\\\left(i,n\\\\right)","domain":{"min":0,"max":1},"hidden":true,"color":"#9BBB59"},{"id":62,"text":"Horizontal position of ball i at height d"},{"id":4,"latex":"h\\\\left(i,d\\\\right)=\\\\sum_{n=1}^Nf\\\\left(i,n\\\\right)g\\\\left(-d-n\\\\right)","domain":{"min":0,"max":1},"hidden":false,"color":"#8064A2"},{"id":12,"latex":"g\\\\left(x\\\\right)=\\\\frac{\\\\left(\\\\tanh\\\\left(5x\\\\right)+1\\\\right)}{2}","domain":{"min":0,"max":1},"hidden":true,"color":"#F79646"},{"id":65,"text":"Height of ball i at time x"},{"id":66,"latex":"Y\\\\left(i,x\\\\right)=\\\\left\\\\{x<ri:-\\\\frac{2w}{r}\\\\left(x-ri\\\\right),\\\\max\\\\left(N\\\\left(ri-x\\\\right),-\\\\left(N+M\\\\right)+2wc\\\\left(i\\\\right)\\\\right)\\\\right\\\\}","domain":{"min":0,"max":1},"hidden":true,"color":"#F79646"},{"id":92,"latex":"Y_f\\\\left(i,x\\\\right)=\\\\left\\\\{x<ri:-\\\\frac{2w}{r}\\\\left(x-ri\\\\right),N\\\\left(ri-x\\\\right)\\\\right\\\\}","domain":{"min":0,"max":1},"hidden":false,"color":"#9BBB59"},{"id":88,"latex":"r=\\\\frac{1}{\\\\pi}","domain":{"min":0,"max":1},"hidden":true,"color":"#F79646"},{"id":86,"latex":"Y\\\\left(1,x\\\\right)","domain":{"min":0,"max":1},"hidden":true,"color":"#9BBB59"},{"id":87,"latex":"Y\\\\left(2,x\\\\right)","domain":{"min":0,"max":1},"hidden":true,"color":"#8064A2"},{"id":68,"text":"Horizontal position of ball i at time x"},{"id":69,"latex":"X\\\\left(i,x\\\\right)=h\\\\left(i,Y\\\\left(i,x\\\\right)\\\\right)","domain":{"min":0,"max":1},"hidden":false,"color":"#C0504D"},{"id":80,"latex":"\\\\left(X\\\\left(1,t\\\\right),Y\\\\left(1,t\\\\right)\\\\right)","domain":{"min":0,"max":20},"hidden":true,"color":"#8064A2"},{"id":72,"text":"Height of ball in resting column"},{"id":22,"latex":"c\\\\left(x\\\\right)=\\\\sum_{n=0}^{x-1}\\\\left\\\\{p\\\\left(n\\\\right)=p\\\\left(x\\\\right):1,0\\\\right\\\\}","domain":{"min":0,"max":1},"hidden":true,"color":"#9BBB59"},{"id":74,"latex":"w=0.3","domain":{"min":0,"max":1},"hidden":false,"color":"#F79646","sliderMin":0.1,"sliderMax":0.4}]}}\n},\n{\n  "title": "Electric Field Lines",\n  "graphHash": "op7ngl243e",\n  "state": {"graph":{"viewport":{"xmin":-11.25,"ymin":-8.9,"xmax":11.25,"ymax":8.903},"showLabels":true,"degreeMode":false,"showGrid":true,"polarMode":false,"showAxes":true,"squareAxes":true,"labelXMode":"","labelYMode":""},"expressions":{"list":[{"id":32,"text":"Electric field lines generated by two point charges:"},{"id":30,"latex":"\\\\left(x_1,y_1\\\\right)","domain":{"min":0,"max":10},"hidden": false,"color":"#8064A2"},{"id":31,"latex":"\\\\left(x_2,y_2\\\\right)","domain":{"min":0,"max":10},"hidden":false,"color":"#F79646"},{"id":101,"text":"This is the position and charge of the purple point charge"},{"id":24,"latex":"q_1=1","domain":{"min":0,"max":10},"hidden":false,"color":"#8064A2","sliderMin":-10,"sliderMax":10},{"id":26,"latex":"x_1=2","domain":{"min":0,"max":10},"hidden":false,"color":"#000000","sliderMin":-10,"sliderMax":10},{"id":27,"latex":"y_1=0","domain":{"min":0,"max":10},"hidden":false,"color":"#4F81BD","sliderMin":-10,"sliderMax":10},{"id":103,"text":"This is the position and charge of the orange point charge "},{"id":25,"latex":"q_2=-1","domain":{"min":0,"max":10},"hidden":false,"color":"#F79646","sliderMin":-10,"sliderMax":10},{"id":28,"latex":"x_2=-2","domain":{"min":0,"max":10},"hidden":false,"color":"#9BBB59","sliderMin":-10,"sliderMax":10},{"id":29,"latex":"y_2=0","domain":{"min":0,"max":10},"hidden":false,"color":"#C0504D","sliderMin":-10,"sliderMax":10},{"id":105,"text":"The rest of this calculates and draws the field lines"},{"id":6,"latex":"f_x\\\\left(x,y\\\\right)=\\\\frac{q_1\\\\left(x-x_1\\\\right)}{\\\\left(\\\\left(x-x_1\\\\right)^2+\\\\left(y-y_1\\\\right)^2\\\\right)^{\\\\frac{3}{2}}}+\\\\frac{q_2\\\\left(x-x_2\\\\right)}{\\\\left(\\\\left(x-x_2\\\\right)^2+\\\\left(y-y_2\\\\right)^2\\\\right)^{\\\\frac{3}{2}}}","domain":{"min":0,"max":10},"hidden":false,"color":"#9BBB59"},{"id":7,"latex":"f_y\\\\left(x,y\\\\right)=\\\\frac{q_1\\\\left(y-y_1\\\\right)}{\\\\left(\\\\left(x-x_1\\\\right)^2+\\\\left(y-y_1\\\\right)^2\\\\right)^{\\\\frac{3}{2}}}+\\\\frac{q_2\\\\left(y-y_2\\\\right)}{\\\\left(\\\\left(x-x_2\\\\right)^2+\\\\left(y-y_2\\\\right)^2\\\\right)^{\\\\frac{3}{2}}}","domain":{"min":0,"max":10},"hidden":false,"color":"#C0504D"},{"id":16,"latex":"m=0.686","domain":{"min":0,"max":10},"hidden":false,"color":"#F79646","sliderMin":0,"sliderMax":1,"sliderInterval":""},{"id":2,"latex":"n\\\\space=\\\\space10","domain":{"min":0,"max":10},"hidden":false,"color":"#8064A2","sliderMin":4,"sliderMax":20,"sliderInterval":1},{"id":9,"latex":"a\\\\space=\\\\space0","domain":{"min":0,"max":10},"hidden":false,"color":"#F79646","sliderMin":-10,"sliderMax":10},{"id":10,"latex":"b\\\\space=\\\\space0","domain":{"min":0,"max":10},"hidden":false,"color":"#000000","sliderMin":-10,"sliderMax":10},{"id":3,"latex":"x_o=\\\\mod\\\\left(\\\\floor\\\\left(n^2t\\\\right),n\\\\right)-\\\\frac{n-1}{2}+a","domain":{"min":0,"max":10},"hidden":true,"color":"#F79646"},{"id":4,"latex":"y_o=\\\\frac{\\\\left(n^2t-\\\\mod\\\\left(n^2t,n\\\\right)\\\\right)}{n}-\\\\frac{n-1}{2}+b","domain":{"min":0,"max":10},"hidden":true,"color":"#000000"},{"id":17,"latex":"x_s=\\\\frac{f_x\\\\left(x_o,y_o\\\\right)}{\\\\sqrt{\\\\left(f_x\\\\left(x_o,y_o\\\\right)\\\\right)^2+\\\\left(f_y\\\\left(x_o,y_o\\\\right)\\\\right)^2}}","domain":{"min":0,"max":10},"hidden":true,"color":"#000000"},{"id":18,"latex":"y_s=\\\\frac{f_y\\\\left(x_o,y_o\\\\right)}{\\\\sqrt{\\\\left(f_x\\\\left(x_o,y_o\\\\right)\\\\right)^2+\\\\left(f_y\\\\left(x_o,y_o\\\\right)\\\\right)^2}}","domain":{"min":0,"max":10},"hidden":true,"color":"#4F81BD"},{"id":19,"latex":"t_m=\\\\mod\\\\left(n^2t,1\\\\right)","domain":{"min":0,"max":10},"hidden":true,"color":"#9BBB59"},{"id":23,"latex":"o=2.5","domain":{"min":0,"max":10},"hidden":false,"color":"#000000","sliderMin":0,"sliderMax":3.14},{"id":21,"latex":"x_p=\\\\left\\\\{0<t_m<.6:x_st_m,\\\\space.6<t_m<.8:.6x_s+\\\\cos\\\\left(o\\\\right)x_s\\\\left(t_m-.6\\\\right)-\\\\sin\\\\left(o\\\\right)y_s\\\\left(t_m-.6\\\\right),\\\\space.8<t_m<1:.6x_s+\\\\sin\\\\left(o\\\\right)y_s\\\\left(t_m-.8\\\\right)+\\\\cos\\\\left(o\\\\right)x_s\\\\left(t_m-.8\\\\right)\\\\right\\\\}","domain":{"min":0,"max":10},"hidden":true,"color":"#8064A2"},{"id":22,"latex":"y_p=\\\\left\\\\{0<t_m<.6:y_st_m,\\\\space.6<t_m<.8:.6y_s+\\\\sin\\\\left(o\\\\right)x_s\\\\left(t_m-.6\\\\right)+\\\\cos\\\\left(o\\\\right)y_s\\\\left(t_m-.6\\\\right),\\\\space.8<t_m<1:.6y_s-\\\\sin\\\\left(o\\\\right)x_s\\\\left(t_m-.8\\\\right)+\\\\cos\\\\left(o\\\\right)y_s\\\\left(t_m-.8\\\\right)\\\\right\\\\}","domain":{"min":0,"max":10},"hidden":true,"color":"#F79646"},{"id":107,"text":"Finally: we draw the field lines"},{"id":20,"latex":"\\\\left[x_o+mx_p-.3mx_s,y_o-.3my_s+my_p\\\\right]","domain":{"min":0,"max":1},"hidden": false,"color":"#4F81BD"}]}}\n},\n{\n  "title": "Pac-man",\n  "graphHash": "kmnnpjxs9s",\n  "state": {"graph":{"viewport":{"xmin":-4.292,"ymin":-5.249,"xmax":9.755,"ymax":5.865},"showLabels":false,"degreeMode":false,"showGrid":false,"polarMode":false,"showAxes":false,"squareAxes":true,"labelXMode":"","labelYMode":""},"expressions":{"list":[{"id":2,"latex":"a=8.2","domain":{"min":0,"max":10},"hidden":false,"color":"#8064A2","sliderMin":0,"sliderMax":19.978000000000065},{"id":1,"latex":"r\\\\le\\\\left\\\\{\\\\cos\\\\left(\\\\theta-h\\\\left(a\\\\right)\\\\right)<.8+.2\\\\sin2\\\\pi a\\\\right\\\\}","domain":{"min":0,"max":10},"hidden":false,"color":"#F79646"},{"id":3,"latex":"\\\\left[f\\\\left(n\\\\right)-f\\\\left(a\\\\right)+x_c,g\\\\left(n\\\\right)-g\\\\left(a\\\\right)+y_c\\\\right]","domain":{"min":0,"max":20},"hidden":false,"color":"#C0504D"},{"id":4,"latex":"f_1\\\\left(x\\\\right)=\\\\left\\\\{x<3:x,x<7:3,x-3\\\\right\\\\}","domain":{"min":0,"max":10},"hidden":true,"color":"#000000"},{"id":5,"latex":"g_1\\\\left(x\\\\right)=\\\\left\\\\{x<3:0,x<7:x-3,3\\\\right\\\\}","domain":{"min":0,"max":10},"hidden":true,"color":"#4F81BD"},{"id":13,"latex":"f\\\\left(x\\\\right)=x","domain":{"min":0,"max":10},"hidden":true,"color":"#C0504D"},{"id":14,"latex":"g\\\\left(x\\\\right)=\\\\sin x","domain":{"min":0,"max":10},"hidden":true,"color":"#8064A2"},{"id":11,"latex":"h\\\\left(x\\\\right)=\\\\arctan\\\\left(\\\\frac{\\\\frac{d}{dx}g\\\\left(x\\\\right)}{\\\\frac{d}{dx}f\\\\left(x\\\\right)}\\\\right)","domain":{"min":0,"max":10},"hidden":true,"color":"#4F81BD"},{"id":8,"latex":"x_c=.1\\\\sin\\\\left(2\\\\pi\\\\mod\\\\left(t,1\\\\right)\\\\right)","domain":{"min":0,"max":10},"hidden":true,"color":"#8064A2"},{"id":10,"latex":"y_c=.1\\\\cos\\\\left(2\\\\pi\\\\mod\\\\left(t,1\\\\right)\\\\right)","domain":{"min":0,"max":10},"hidden":true,"color":"#000000"},{"id":7,"latex":"n=\\\\floor\\\\left(t\\\\right)\\\\left\\\\{\\\\floor\\\\left(t\\\\right)>a\\\\right\\\\}","domain":{"min":0,"max":10},"hidden":true,"color":"#C0504D"},{"id":6,"latex":"\\\\left[f\\\\left(t\\\\right),g\\\\left(t\\\\right)\\\\right]","domain":{"min":0,"max":10},"hidden":true,"color":"#9BBB59"}]}}\n},\n{\n  "title": "Regular Sine Wave?",\n  "graphHash": "c1u72uowae",\n  "state": {"graph":{"viewport":{"xmin":-1.463,"ymin":-4.468,"xmax":16.313,"ymax":9.597},"showLabels":true,"degreeMode":false,"showGrid":true,"polarMode":false,"showAxes":true,"squareAxes":true,"labelXMode":"","labelYMode":""},"expressions":{"list":[{"id":47,"text":"Slide (or animate) a:"},{"id":45,"latex":"a=0","domain":{"min":0,"max":10},"hidden":false,"color":"#000000","sliderMin":0,"sliderMax":1},{"id":25,"latex":"x_m\\\\left(t\\\\right)=\\\\left\\\\{0\\\\le t<\\\\frac{1}{6}:0,\\\\frac{1}{6}\\\\le t<\\\\frac{1}{3}:.85+.85\\\\cos\\\\left(\\\\pi-6\\\\pi\\\\left(t-\\\\frac{1}{6}\\\\right)\\\\right),\\\\frac{1}{3}\\\\le t<\\\\frac{2}{3}:1.7,\\\\frac{2}{3}\\\\le t<\\\\frac{5}{6}:2.55+.85\\\\cos\\\\left(\\\\pi-6\\\\pi\\\\left(t-\\\\frac{2}{3}\\\\right)\\\\right),\\\\frac{5}{6}\\\\le t\\\\le1:3.4\\\\right\\\\}","domain":{"min":0,"max":10},"hidden":true,"color":"#8064A2"},{"id":27,"latex":"y_m\\\\left(t\\\\right)=\\\\left\\\\{0\\\\le t<\\\\frac{1}{6}:11.4t,\\\\frac{1}{6}\\\\le t<\\\\frac{1}{3}:1.9+.6\\\\sin\\\\left(\\\\pi-6\\\\pi\\\\left(t-\\\\frac{1}{6}\\\\right)\\\\right),\\\\frac{1}{3}\\\\le t<\\\\frac{1}{2}:1.9-11.4\\\\left(t-\\\\frac{1}{3}\\\\right),\\\\frac{1}{2}\\\\le t<\\\\frac{2}{3}:11.4\\\\left(t-.5\\\\right),\\\\frac{2}{3}\\\\le t<\\\\frac{5}{6}:1.9+.6\\\\sin\\\\left(\\\\pi-6\\\\pi\\\\left(t-\\\\frac{2}{3}\\\\right)\\\\right),\\\\frac{5}{6}\\\\le t\\\\le1:1.9-11.4\\\\left(t-\\\\frac{5}{6}\\\\right)\\\\right\\\\}","domain":{"min":0,"max":10},"hidden":true,"color":"#000000"},{"id":38,"latex":"L_x\\\\left(t\\\\right)=\\\\left\\\\{0\\\\le t<1:x_d\\\\left(t\\\\right),\\\\space1\\\\le t<2:x_e\\\\left(t-1\\\\right)+s_2,2\\\\le t<3:x_s\\\\left(t-2\\\\right)+s_3,3\\\\le t<4:x_m\\\\left(t-3\\\\right)+s_4,4\\\\le t<5:x_0\\\\left(t-4\\\\right)+s_5,5\\\\le t\\\\le6:x_s\\\\left(t-5\\\\right)+s_6\\\\right\\\\}","domain":{"min":0,"max":10},"hidden":true,"color":"#F79646"},{"id":39,"latex":"L_y\\\\left(t\\\\right)=\\\\left\\\\{0\\\\le t<1:y_d\\\\left(t\\\\right),\\\\space1\\\\le t<2:y_e\\\\left(t-1\\\\right),2\\\\le t<3:y_s\\\\left(t-2\\\\right),3\\\\le t<4:y_m\\\\left(t-3\\\\right),4\\\\le t<5:y_0\\\\left(t-4\\\\right),5\\\\le t\\\\le6:y_s\\\\left(t-5\\\\right)\\\\right\\\\}","domain":{"min":0,"max":10},"hidden":true,"color":"#000000"},{"id":40,"latex":"\\\\left[G_x\\\\left(t\\\\right)\\\\left(1-a\\\\right)+aL_x\\\\left(t\\\\right),G_y\\\\left(t\\\\right)\\\\left(1-a\\\\right)+aL_y\\\\left(t\\\\right)\\\\right]","domain":{"min":0,"max":6},"hidden":false,"color":"#9BBB59"},{"id":43,"latex":"\\\\left[G_x\\\\left(t\\\\right),G_y\\\\left(t\\\\right)\\\\right]","domain":{"min":0,"max":6},"hidden":true,"color":"#8064A2"},{"id":41,"latex":"G_x\\\\left(t\\\\right)=2.3t","domain":{"min":0,"max":10},"hidden":true,"color":"#9BBB59"},{"id":42,"latex":"G_y\\\\left(t\\\\right)=\\\\sin\\\\left(2\\\\pi t\\\\right)+1","domain":{"min":0,"max":10},"hidden":true,"color":"#C0504D"},{"id":1,"latex":"x_d\\\\left(t\\\\right)=\\\\left\\\\{0\\\\le t\\\\le\\\\frac{2}{3}:1.1+1.1\\\\cos\\\\left(3\\\\pi t\\\\right),\\\\frac{2}{3}\\\\le t\\\\le1:2.2\\\\right\\\\}","domain":{"min":0,"max":10},"hidden":true,"color":"#C0504D"},{"id":2,"latex":"y_d\\\\left(t\\\\right)=\\\\left\\\\{0\\\\le t\\\\le\\\\frac{2}{3}:1.25+1.25\\\\sin\\\\left(3\\\\pi t\\\\right),\\\\frac{2}{3}\\\\le t\\\\le1:1.25+9.6\\\\left(t-\\\\frac{2}{3}\\\\right)\\\\right\\\\}","domain":{"min":0,"max":10},"hidden":true,"color":"#8064A2"},{"id":4,"latex":"x_e\\\\left(t\\\\right)=\\\\left\\\\{0\\\\le t<\\\\frac{1}{3}:6.9t,\\\\frac{1}{3}\\\\le t\\\\le\\\\frac{19}{21}:1.15+1.15\\\\cos\\\\left(1.5\\\\cdot1.75\\\\pi\\\\left(t-\\\\frac{1}{3}\\\\right)\\\\right),\\\\frac{19}{21}\\\\le t\\\\le1:1.15+1.45\\\\cos\\\\left(1.5\\\\cdot1.75\\\\pi\\\\left(t-\\\\frac{1}{3}\\\\right)\\\\right)\\\\right\\\\}","domain":{"min":0,"max":10},"hidden":true,"color":"#000000"},{"id":5,"latex":"y_e\\\\left(t\\\\right)=\\\\left\\\\{0\\\\le t<\\\\frac{1}{3}:1.25,\\\\frac{1}{3}\\\\le t\\\\le1:1.25+1.25\\\\sin\\\\left(1.5\\\\cdot1.75\\\\pi\\\\left(t-\\\\frac{1}{3}\\\\right)\\\\right)\\\\right\\\\}","domain":{"min":0,"max":10},"hidden":true,"color":"#4F81BD"},{"id":7,"latex":"s_{tx}\\\\left(t\\\\right)=L+.6\\\\cos\\\\left(2\\\\pi t\\\\right)","domain":{"min":0,"max":10},"hidden":true,"color":"#C0504D"},{"id":15,"latex":"s_{ty}\\\\left(t\\\\right)=2+.5\\\\sin\\\\left(2\\\\pi t\\\\right)","domain":{"min":0,"max":10},"hidden":true,"color":"#000000"},{"id":16,"latex":"s_{bx}\\\\left(t\\\\right)=.9+.9\\\\cos\\\\left(2\\\\pi t\\\\right)","domain":{"min":0,"max":10},"hidden":true,"color":"#4F81BD"},{"id":17,"latex":"s_{by}\\\\left(t\\\\right)=.6+.6\\\\sin\\\\left(2\\\\pi t\\\\right)","domain":{"min":0,"max":10},"hidden":true,"color":"#9BBB59"},{"id":19,"latex":"s_{mx}\\\\left(t\\\\right)=11.4-4L+162\\\\left(2.4-L\\\\right)\\\\left(-\\\\frac{t^3}{3}+\\\\frac{t^2}{2}-\\\\frac{2t}{9}\\\\right)","domain":{"min":0,"max":10},"hidden":true,"color":"#8064A2"},{"id":20,"latex":"s_{my}\\\\left(t\\\\right)=2-4.2\\\\left(t-\\\\frac{1}{3}\\\\right)","domain":{"min":0,"max":10},"hidden":true,"color":"#F79646"},{"id":21,"latex":"x_s\\\\left(t\\\\right)=\\\\left\\\\{0\\\\le t<\\\\frac{1}{3}:\\\\space s_{tx}\\\\left(.1+1.2t\\\\right),\\\\frac{1}{3}\\\\le t<\\\\frac{2}{3}:s_{mx}\\\\left(t\\\\right),\\\\frac{2}{3}\\\\le t\\\\le1:s_{bx}\\\\left(-1.5\\\\left(t-\\\\frac{2}{3}\\\\right)\\\\right)\\\\right\\\\}","domain":{"min":0,"max":10},"hidden":true,"color":"#000000"},{"id":22,"latex":"y_s\\\\left(t\\\\right)=\\\\left\\\\{0\\\\le t<\\\\frac{1}{3}:\\\\space s_{ty}\\\\left(.1+1.2t\\\\right),\\\\frac{1}{3}\\\\le t<\\\\frac{2}{3}:s_{my}\\\\left(t\\\\right),\\\\frac{2}{3}\\\\le t\\\\le1:s_{by}\\\\left(-1.5\\\\left(t-\\\\frac{2}{3}\\\\right)\\\\right)\\\\right\\\\}","domain":{"min":0,"max":10},"hidden":true,"color":"#4F81BD"},{"id":14,"latex":"L=1","domain":{"min":0,"max":10},"hidden":false,"color":"#F79646","sliderMin":0,"sliderMax":1},{"id":28,"latex":"x_0\\\\left(t\\\\right)=1.1+1.1\\\\cos\\\\left(2\\\\pi\\\\left(t+.25\\\\right)\\\\right)","domain":{"min":0,"max":10},"hidden":true,"color":"#4F81BD"},{"id":29,"latex":"y_0\\\\left(t\\\\right)=1.25+1.25\\\\sin\\\\left(2\\\\pi\\\\left(t+.25\\\\right)\\\\right)","domain":{"min":0,"max":10},"hidden":true,"color":"#9BBB59"},{"id":35,"latex":"s_2=2.4","domain":{"min":0,"max":10},"hidden":false,"color":"#9BBB59","sliderMin":0,"sliderMax":10},{"id":36,"latex":"s_3=4.76","domain":{"min":0,"max":10},"hidden":false,"color":"#C0504D","sliderMin":0,"sliderMax":10},{"id":34,"latex":"s_4=6.77","domain":{"min":0,"max":10},"hidden":false,"color":"#4F81BD","sliderMin":0,"sliderMax":20},{"id":31,"latex":"s_5=10.37","domain":{"min":0,"max":10},"hidden":false,"color":"#8064A2","sliderMin":0,"sliderMax":20},{"id":33,"latex":"s_6=12.65","domain":{"min":0,"max":10},"hidden":false,"color":"#000000","sliderMin":0,"sliderMax":20}]}}\n},\n{\n  "title": "3D World",\n  "graphHash": "neyobpzndu",\n  "state": {"graph":{"viewport":{"xmin":-28.11,"ymin":-25.9,"xmax":67.4,"ymax":21.54},"showLabels":false,"degreeMode":false,"showGrid":false,"polarMode":false,"showAxes":false,"squareAxes":true,"labelXMode":"","labelYMode":""},"expressions":{"list":[{"id":31,"text":"You\'re at the black dot (u_p, v_p) looking at the world..."},{"id":4,"latex":"\\\\left(u_p,v_p\\\\right)","domain":{"min":0,"max":10},"hidden": false,"color":"#000000"},{"id":1,"latex":"u_p=1.1","domain":{"min":0,"max":10},"hidden":true,"color":"#C0504D","sliderMin":-29.34,"sliderMax":11.3},{"id":2,"latex":"v_p=0.4","domain":{"min":0,"max":10},"hidden":false,"color":"#8064A2","sliderMin":-20,"sliderMax":20},{"id":33,"text":"These are the endpoints of the purple wall (you can drag those points too)"},{"id":43,"latex":"\\\\left(u_a,v_a\\\\right)","domain":{"min":0,"max":1},"hidden":false,"color":"#8064A2"},{"id":44,"latex":"\\\\left(u_b,v_b\\\\right)","domain":{"min":0,"max":1},"hidden":false,"color":"#8064A2"},{"id":5,"latex":"u_a=-2.001","domain":{"min":0,"max":10},"hidden":false,"color":"#4F81BD","sliderMin":-10.001,"sliderMax":10,"sliderInterval":0.01},{"id":6,"latex":"v_a=4.299","domain":{"min":0,"max":10},"hidden":false,"color":"#9BBB59","sliderMin":-10.001,"sliderMax":10.5,"sliderInterval":0.01},{"id":7,"latex":"u_b=6","domain":{"min":0,"max":10},"hidden":false,"color":"#C0504D","sliderMin":-10,"sliderMax":10.5},{"id":8,"latex":"v_b=2.8","domain":{"min":0,"max":10},"hidden":false,"color":"#8064A2","sliderMin":-10,"sliderMax":10.9},{"id":35,"text":"These all draws the world:"},{"id":24,"latex":"y\\\\le-y_0","domain":{"min":0,"max":10},"hidden":false,"color":"#9BBB59"},{"id":9,"latex":"\\\\left(u_a+t\\\\left(u_b-u_a\\\\right),v_a+t\\\\left(v_b-v_a\\\\right)\\\\right)","domain":{"min":0,"max":1},"hidden":false,"color":"#8064A2"},{"id":28,"latex":"r_w\\\\left(\\\\theta\\\\right)=\\\\sec\\\\left(\\\\theta+.2\\\\right)","domain":{"min":0,"max":10},"hidden":true,"color":"#C0504D"},{"id":10,"latex":"r_b\\\\left(\\\\theta\\\\right)=\\\\floor\\\\left(\\\\frac{\\\\theta}{2\\\\pi}\\\\right)\\\\sec\\\\left(\\\\theta+\\\\frac{\\\\pi}{2}\\\\floor\\\\left(\\\\frac{2\\\\theta}{\\\\pi}+.5\\\\right)\\\\right)","domain":{"min":0,"max":10},"hidden":true,"color":"#000000"},{"id":14,"latex":"\\\\left[r_b\\\\left(2\\\\pi t\\\\right)\\\\sin2\\\\pi t,r_b\\\\left(2\\\\pi t\\\\right)\\\\cos2\\\\pi t\\\\right]","domain":{"min":0,"max":10},"hidden": false,"color":"#F79646"},{"id":16,"text":"Project (u, v) to (x, y) coordinates"},{"id":17,"latex":"X\\\\left(u,\\\\space v\\\\right)=5\\\\frac{\\\\left(u-u_p\\\\right)}{\\\\left(v-v_p\\\\right)}-x_0","domain":{"min":0,"max":10},"hidden":false,"color":"#000000"},{"id":18,"latex":"Y\\\\left(u,\\\\space v,\\\\space z\\\\right)=\\\\frac{-8+z}{\\\\left(v-v_p\\\\right)}-y_0","domain":{"min":0,"max":10},"hidden":false,"color":"#4F81BD"},{"id":47,"latex":"c_{ond}\\\\space=\\\\space v_a+\\\\left(\\\\frac{u_p-u_a}{u_b-u_a}\\\\right)\\\\left(v_b-v_a\\\\right)-v_p","domain":{"min":0,"max":1},"hidden":true,"color":"#9BBB59"},{"id":36,"latex":"f\\\\left(x,z\\\\right)=\\\\frac{\\\\left(Y\\\\left(u_b,v_b,z\\\\right)-Y\\\\left(u_a,v_a,z\\\\right)\\\\right)}{X\\\\left(u_b,v_b\\\\right)-X\\\\left(u_a,v_a\\\\right)}\\\\left(x-X\\\\left(u_a,v_a\\\\right)\\\\right)+Y\\\\left(u_a,v_a,z\\\\right)","domain":{"min":0,"max":1},"hidden":false,"color":"#4F81BD"},{"id":40,"latex":"x_m=\\\\left\\\\{v_p<v_a:X\\\\left(u_a,v_a\\\\right),-1000\\\\right\\\\}","domain":{"min":0,"max":1},"hidden":false,"color":"#000000"},{"id":41,"latex":"X_m=\\\\left\\\\{v_p<v_b:X\\\\left(u_b,v_b\\\\right),\\\\space1000\\\\right\\\\}","domain":{"min":0,"max":1},"hidden":false,"color":"#C0504D"},{"id":39,"latex":"f\\\\left(x,0\\\\right)\\\\le y\\\\le f\\\\left(x,16\\\\right)\\\\left\\\\{c_{ond}>0\\\\right\\\\}\\\\left\\\\{x_m<x<X_m\\\\right\\\\}","domain":{"min":0,"max":1},"hidden": false,"color":"#8064A2"},{"id":22,"latex":"\\\\left(X\\\\left(r_b\\\\left(t\\\\right)\\\\sin t,r_b\\\\left(t\\\\right)\\\\cos t\\\\right)\\\\left\\\\{r_b\\\\left(t\\\\right)\\\\cos t-v_p>1\\\\right\\\\},Y\\\\left(r_b\\\\left(t\\\\right)\\\\sin t,r_b\\\\left(t\\\\right)\\\\cos t,0\\\\right)\\\\right)","domain":{"min":0,"max":62.831853},"hidden": false,"color":"#F79646"},{"id":11,"latex":"x_0=-31","domain":{"min":0,"max":10},"hidden":false,"color":"#4F81BD","sliderMin":-60,"sliderMax":10},{"id":13,"latex":"y_0=11","domain":{"min":0,"max":10},"hidden":false,"color":"#C0504D","sliderMin":-10,"sliderMax":20},{"id":46,"latex":"y\\\\le-8-y_0","domain":{"min":0,"max":1},"hidden":false,"color":"#000000"}]}}\n}]'; });

define('main/betchacant', ['require', 'loadcss!css/mygraphs', 'pjs', 'main/graph', 'text!data/betchacant_graphs.json'], function(require) {
    require('loadcss!css/mygraphs');

    var P = require('pjs');
    var Graph = require('main/graph');

    var betchacantString = require('text!data/betchacant_graphs.json');

    var betchaCant = P(function(proto, _super) {
        proto.init = function(Calc, graphsController) {
            this.Calc = Calc;
            this.expressionsView = Calc._calc.expressionsView;
            this.graphsController = graphsController;

            var self = this;
            this.expressionsView.__latexChangeCallbacks.push(function(latex) {
                if (latex === "betchacant") self.acceptChallenge();
            });

            this.betchacantGraphs = JSON.parse(betchacantString);
        };

        proto.acceptChallenge = function() {
            var graphData = this.betchacantGraphs[Math.floor(Math.random() * this.betchacantGraphs.length)];

            this.expressionsView.model.getSelected().setProperty('latex', '');
            var graph = Graph({
                hash: graphData.graphHash,
                title: graphData.title,
                graphData: JSON.stringify(graphData.state)
            });

            this.selectedIndex = this.expressionsView.model.getSelected().index;
            this.graphsController.loadGraph(graph);
            var self = this;

            var undoCallback = function() {
                var model = self.expressionsView.model.getItemByIndex(self.selectedIndex);
                var view = self.expressionsView.getItemView(model.id);
                setTimeout(function() {
                    view.addFocus();
                }, 100);
            };

            this.Calc._calc.toast('Challenge accepted.', { undoCallback: undoCallback });
        };
    });

    return betchaCant;
});

define('main/heartbeat', ['require', 'jquery'], function(require) {
    var pageload_timestamp = new Date();
    var $ = require('jquery');

    var wasActiveInInterval = false;

    function heartbeat() {
        //Low resolution since google analytics only allows 500 events per user-session
        var n = Math.round((new Date() - pageload_timestamp) / (60 * 1000));
        var eventName = 'Heartbeat' + (wasActiveInInterval ? '-active' : '-passive');
        wasActiveInInterval = false;
    }

    $(document).on('tap keypress', function() {
        wasActiveInInterval = true;
    });

    // Record heartbeat every minute
    setInterval(heartbeat, 60 * 1000);
});


define('main/log_errors', ['require', 'jquery'], function(require) {
    var $ = require('jquery');

    // use google analytics to log client javascript errors
    window.onerror = function(message, file, line) {
        var sFormattedMessage = '[' + file + ' (' + line + ')] ' + message;
    };

    // Also log ajax errors
    $(document).ajaxError(function(event, request, settings, thrownError) {
        // Would be nice to include settings.data, but I'm afraid of (among other things),
        // ending up with a bunch of plain text passwords in our analytics
        var sFormattedMessage = (
            settings.type + ' ' + window.location.protocol + '//' + window.location.host + settings.url +
            ' ' + request.status + ' (' + request.statusText + ')'
        );
    });
});

define('main/calc_desktop', ['require', 'jquery', 'config', 'main/load_data', 'main/graphs_controller', 'main/graph', 'main/modals_controller', 'main/header_desktop', 'main/preserved_state', 'main/graph_change_monitor', 'browser', 'main/data_helpers', 'ipad.scrollfix', 'locales/all', 'i18n', 'api/calculator', 'main/betchacant', 'main/heartbeat', 'main/log_errors'], function(require) {

    var $ = require('jquery');
    var Config = require('config');
    var LOAD_DATA = require('main/load_data');

    //these manage the user and the loaded graph (graph hash, etc)
    var GraphsController = require('main/graphs_controller');
    var Graph = require('main/graph');

    var ModalsController = require('main/modals_controller');
    var HeaderView = require('main/header_desktop');

    //for page reloads when, for example, you switch language
    var preservedState = require('main/preserved_state');
    var GraphChangeMonitor = require('main/graph_change_monitor');

    //TODO: move browser detection into the API
    var Browser = require('browser');

    var DataHelpers = require('main/data_helpers');

    // prevent scrolling of entire page (includes the UI around embedded API)
    var ScrollFix = require('ipad.scrollfix');
    ScrollFix.limitScrollOnDocument();

    // set the dictionary for translations
    // TODO: move some of this logic into calc_embed (probably setLanguage)
    var i18n_dict = require('locales/all');
    var i18n = require('i18n');
    var lang = i18n.detectLanguage();
    i18n.init(lang, i18n_dict);

    //load up and insert the calculator!
    var CalcAPI = require('api/calculator');

    var options = Config.all();
    options.globalKeyboardUndo = true;
    options.redrawSlowly = !Browser.IS_MOBILE;
    options.border = false;
    var elt = document.getElementById('graph-container');
    var Calc = CalcAPI(elt, options);

    //we need this for tests
    var Betchacant = require('main/betchacant');

    // Send a heartbeat to google analytics once per minute
    require('main/heartbeat');
    // Send js and ajax errors to google analytics
    require('main/log_errors');

    //hook up graphsController

    var graphsController = GraphsController(Calc, LOAD_DATA ? LOAD_DATA.seed : "e3636b05148b4955b9a12f202a3512f1");
    graphsController.driveAccessErrorCallbacks.push(function() {
        Calc._calc.toast(
            'Error saving. Google login expired. Please log in again.', {
                style: 'error',
                hideAfter: 0
            }
        );
    });

    // some versions of webkit fire a ghost 'popstate ' event after and in the same event-loop as
    // the 'load' event. So, we disable 'popstate' events for the rest of the 'load' event-loop.
    var isGhostPopStateEvent = false;
    $(window).on('load', function() {
        isGhostPopStateEvent = true;
        setTimeout(function() { isGhostPopStateEvent = false; }, 0);
    });

    // back button support
    $(window).on('popstate', function(evt) {
        if (isGhostPopStateEvent) return;

        var state = evt.originalEvent.state;

        //If you have unsaved work, back will take you *not* to your last on this graph
        //But to the save (or load) before that. This warns you in the same way
        //That reload or a hard back does.
        if (Calc.hasUnsavedChanges()) {
            if (!confirm(i18n.t("Are you sure you want to leave this graph? Your unsaved work will be lost."))) {
                history.forward();
                return;
            }
        }

        if (state === null) {
            // If there is null state then we came from the calculator, but from a blank (or unsaved one) graph.
            graphsController.loadGraph(Graph());
            return;
        } else if (graphsController.currentGraph.hash === state.hash) {
            //If we read a popstate but the user wants to cancel it,
            //We execute a ".forward()". This triggers another popstate,
            //but right back to the graph we started with. We don't need to do
            //anything in this case.
            return;
        } else {
            graphsController.loadGraph(Graph(state));
        }

        //Toast when you navigate between graphs
        var graphTitle;
        if (!state.title) {
            graphTitle = i18n.t('Untitled Graph');
        } else {
            if (state.title.length > 15) {
                graphTitle = state.title.substr(0, 15) + '...';
            } else {
                graphTitle = state.title;
            }
        }

        var str = i18n.t("Opened '__graphTitle__'", { graphTitle: graphTitle });
        //include a blank undo function so that the "undo" option still shows up
        Calc._calc.toast(str, { undoCallback: function() {} });
    });

    var modalsController = ModalsController(graphsController);
    var modals = modalsController.modals;

    var headerView = HeaderView(
        graphsController,
        Calc,
        modals
    );

    if (Config.get('expressions') !== false) Betchacant(
        Calc,
        graphsController
    );

    //make sure the user doesn't accidentally leave the page!
    if (!Config.get('no_navigation_warning')) {
        $(window).bind('beforeunload', function() {
            if (Calc.hasUnsavedChanges() && !preservedState.hasState()) {
                return i18n.t('Are you sure you want to leave this graph? Your unsaved work will be lost.');
            }
            return null;
        });
    }

    var graphChangeMonitor = GraphChangeMonitor(Calc, graphsController);
    Calc.graphChangeMonitor = graphChangeMonitor;

    graphChangeMonitor.observe('graphChanged', function() {
        headerView.setProperty('graphChanged', Calc.hasUnsavedChanges());
    });

    Calc.hasUnsavedChanges = function() {
        return graphChangeMonitor.graphChanged;
    };

    $(window).on('paste', function(e) {
        var pastedText;
        if (window.clipboardData && window.clipboardData.getData) { // IE
            pastedText = window.clipboardData.getData('Text');
        } else if (e.originalEvent.clipboardData && e.originalEvent.clipboardData.getData) {
            pastedText = e.originalEvent.clipboardData.getData('text/plain');
        }

        var parsedData = DataHelpers.parse(pastedText);
        if (parsedData) {
            e.stopPropagation();
            e.preventDefault();

            if (parsedData.error) {
                return Calc._calc.toast(parsedData.error, { style: 'error', hideAfter: 12000 });
            }
            //undocumented method inside of calc_embed.js
            Calc._calc.createAndPopulateTable(parsedData.data);
        }
    });

    //This top-level location should becomes the place where all nontrivial document.ready() activities happen
    $(document).ready(function() {
        /* jshint maxcomplexity: 11 */

        //Setup save shortcut listener
        $(document).bind('keydown', headerView.handleKeydown.bind(headerView));

        modalsController.ready();
        //Show warning modal for unsupported browsers (because of screensize, for example)
        if (Browser.IS_ANDROID && !Browser.IS_CHROME) {
            modals.unsupportedBrowserDialog.show();
        }

        // headerView.appendTo('.dcg-header');

        $('.dcg-loading-div').fadeOut();

        if (LOAD_DATA.flash) {
            switch (LOAD_DATA.flash) {
                case 'clever_welcome':
                    Calc._calc.toast(i18n.t('Logged in with Clever!'));
                    break;
                case 'clever_no_email':
                    Calc._calc.toast(i18n.t('Visiting anonymously from Clever.'), {
                        hideAfter: 12000,
                        learnMoreLink: 'http://support.desmos.com/entries/47595905-Signed-in-Anonymously-with-Clever'
                    });
                    break;
                case 'clever_communication_error':
                    Calc._calc.toast(i18n.t('Error signing in with Clever.'), {
                        hideAfter: 0,
                        style: 'error',
                        learnMoreLink: 'http://support.desmos.com/entries/47595625-Error-Signing-in-with-Clever'
                    });
                    break;
                default:
                    Calc._calc.toast(LOAD_DATA.flash);
                    break;
            }
        }

        if (LOAD_DATA.graph) {
            graphsController.loadGraph(Graph.fromAjax(LOAD_DATA.graph));
        } else {
            // The graph state either needs to be set or cleared to get the
            // calculator into a consistent state.
            graphsController.clearGraph();
        }

        if (preservedState.hasState()) {
            var stateInfo = preservedState.popState();
            graphChangeMonitor.setSavedState(stateInfo.savedState);
            Calc.setState(stateInfo.unsavedState);
        }


        if (Config.get('expressions') !== false) Calc._calc.expressionsView.triggerClearGraph = function() {
            graphsController.clearGraph();
        };
    });

    return Calc;
});


requirejs(['main/calc_desktop'], function(Calc) {
    // Calc global has singletons like expressions that are useful for debugging and testing.
    window.Calc = Calc;
});

define("toplevel/calculator_desktop", function() {});